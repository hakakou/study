
===== Agents\README.md =====

# Notice

The experimental agents project/package has reached end-of-life and has been removed.

While the nuget packages continue to be available, they are not recommended for use.

In place of this experimental framework, we recommend targeting the _Semantic Kernel Agent Framework_.

**Source:**
- https://github.com/microsoft/semantic-kernel/tree/main/dotnet/src/Agents

**Samples:**
- https://github.com/microsoft/semantic-kernel/tree/main/dotnet/samples/GettingStartedWithAgents
- https://github.com/microsoft/semantic-kernel/tree/main/dotnet/samples/Concepts/Agents

**Packages:**
- https://www.nuget.org/packages/Microsoft.SemanticKernel.Agents.Abstractions
- https://www.nuget.org/packages/Microsoft.SemanticKernel.Agents.Core
- https://www.nuget.org/packages/Microsoft.SemanticKernel.Agents.OpenAI


===== Orchestration.Flow.IntegrationTests\CollectEmailPlugin.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.ComponentModel;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.ChatCompletion;
using Microsoft.SemanticKernel.Connectors.OpenAI;
using Microsoft.SemanticKernel.Experimental.Orchestration;

namespace SemanticKernel.Experimental.Orchestration.Flow.IntegrationTests;

public sealed partial class CollectEmailPlugin
{
    private const string Goal = "Collect email from user";

    private const string EmailPattern = /*lang=regex*/ @"^([\w\.\-]+)@([\w\-]+)((\.(\w){2,3})+)$";

    private const string SystemPrompt =
        $"""
        I am AI assistant and will only answer questions related to collect email.
        The email should conform to the regex: {EmailPattern}

        If I cannot answer, say that I don't know.
        Do not expose the regex unless asked.
        """;

    private readonly IChatCompletionService _chat;

    private int MaxTokens { get; set; } = 256;

    private readonly PromptExecutionSettings _chatRequestSettings;

    public CollectEmailPlugin(Kernel kernel)
    {
        this._chat = kernel.GetRequiredService<IChatCompletionService>();
        this._chatRequestSettings = new OpenAIPromptExecutionSettings
        {
            MaxTokens = this.MaxTokens,
            StopSequences = ["Observation:"],
            Temperature = 0
        };
    }

    [KernelFunction("ConfigureEmailAddress")]
    [Description("Useful to assist in configuration of email address, must be called after email provided")]
    public async Task<string> CollectEmailAsync(
        [Description("The email address provided by the user, pass no matter what the value is")]
        // ReSharper disable once InconsistentNaming
#pragma warning disable CA1707 // Identifiers should not contain underscores
        string email_address,
#pragma warning restore CA1707 // Identifiers should not contain underscores
        KernelArguments arguments)
    {
        var chat = new ChatHistory(SystemPrompt);
        chat.AddUserMessage(Goal);

        ChatHistory? chatHistory = arguments.GetChatHistory();
        if (chatHistory?.Count > 0)
        {
            chat.AddRange(chatHistory);
        }

        if (!string.IsNullOrEmpty(email_address) && EmailRegex().IsMatch(email_address))
        {
            return "Thanks for providing the info, the following email would be used in subsequent steps: " + email_address;
        }

        // invalid email, prompt user to provide a valid email
        arguments["email_address"] = string.Empty;
        arguments.PromptInput();

        var response = await this._chat.GetChatMessageContentAsync(chat).ConfigureAwait(false);

        return response.Content ?? string.Empty;
    }

#if NET
    [GeneratedRegex(EmailPattern)]
    private static partial Regex EmailRegex();
#else
    private static Regex EmailRegex() => s_emailRegex;
    private static readonly Regex s_emailRegex = new(EmailPattern, RegexOptions.Compiled);
#endif
}


===== Orchestration.Flow.IntegrationTests\FlowOrchestratorTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.Extensions.Configuration;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Experimental.Orchestration;
using Microsoft.SemanticKernel.Memory;
using Microsoft.SemanticKernel.Plugins.Web;
using Microsoft.SemanticKernel.Plugins.Web.Bing;
using SemanticKernel.Experimental.Orchestration.Flow.IntegrationTests.TestSettings;
using xRetry;
using Xunit;

namespace SemanticKernel.Experimental.Orchestration.Flow.IntegrationTests;

public sealed class FlowOrchestratorTests
{
    private readonly string _bingApiKey;

    public FlowOrchestratorTests()
    {
        // Load configuration
        this._configuration = new ConfigurationBuilder()
            .AddJsonFile(path: "testsettings.json", optional: false, reloadOnChange: true)
            .AddJsonFile(path: "testsettings.development.json", optional: true, reloadOnChange: true)
            .AddEnvironmentVariables()
            .AddUserSecrets<FlowOrchestratorTests>()
            .Build();

        string? bingApiKeyCandidate = this._configuration["Bing:ApiKey"];
        Assert.NotNull(bingApiKeyCandidate);
        this._bingApiKey = bingApiKeyCandidate;
    }

    [RetryFact(maxRetries: 3)]
    public async Task CanExecuteFlowAsync()
    {
        // Arrange
        IKernelBuilder builder = this.InitializeKernelBuilder();
        var bingConnector = new BingConnector(this._bingApiKey);
        var webSearchEnginePlugin = new WebSearchEnginePlugin(bingConnector);
        var sessionId = Guid.NewGuid().ToString();
        string dummyAddress = "abc@xyz.com";

        Dictionary<object, string?> plugins = new()
        {
            { webSearchEnginePlugin, "WebSearch" }
        };

        Microsoft.SemanticKernel.Experimental.Orchestration.Flow flow = FlowSerializer.DeserializeFromYaml(@"
goal: answer question and sent email
steps:
  - goal: What is the tallest mountain in Asia? How tall is it divided by 2?
    plugins:
      - WebSearchEnginePlugin
    provides:
      - answer
  - goal: Collect email address
    plugins:
      - CollectEmailPlugin
    provides:
      - email_address
  - goal: Send email
    plugins:
      - SendEmailPlugin
    requires:
      - email_address
      - answer
    provides:
      - email
");

        var flowOrchestrator = new FlowOrchestrator(
            builder,
            await FlowStatusProvider.ConnectAsync(new VolatileMemoryStore()),
            plugins,
            config: new FlowOrchestratorConfig() { MaxStepIterations = 20 });

        // Act
        var result = await flowOrchestrator.ExecuteFlowAsync(flow, sessionId, "What is the tallest mountain in Asia? How tall is it divided by 2?");

        // Assert
        // Loose assertion -- make sure that the plan was executed and pause when it needs interact with user to get more input
        var response = result.GetValue<List<string>>()!.First();
        Assert.Contains("email", response, StringComparison.InvariantCultureIgnoreCase);

        // Act
        result = await flowOrchestrator.ExecuteFlowAsync(flow, sessionId, $"my email is {dummyAddress}");

        // Assert
        var emailPayload = result.Metadata!["email"] as string;
        Assert.Contains(dummyAddress, emailPayload, StringComparison.InvariantCultureIgnoreCase);
        Assert.Contains("Everest", emailPayload, StringComparison.InvariantCultureIgnoreCase);
    }

    private IKernelBuilder InitializeKernelBuilder()
    {
        AzureOpenAIConfiguration? azureOpenAIConfiguration = this._configuration.GetSection("AzureOpenAI").Get<AzureOpenAIConfiguration>();
        Assert.NotNull(azureOpenAIConfiguration);

        return Kernel.CreateBuilder()
            .AddAzureOpenAIChatCompletion(
                deploymentName: azureOpenAIConfiguration.ChatDeploymentName!,
                endpoint: azureOpenAIConfiguration.Endpoint,
                apiKey: azureOpenAIConfiguration.ApiKey);
    }

    private readonly IConfigurationRoot _configuration;
}


===== Orchestration.Flow.IntegrationTests\README.md =====

# Experimental Flow Orchestrator Integration Tests

## Requirements

1. **Azure OpenAI**: go to the [Azure OpenAI Quickstart](https://learn.microsoft.com/en-us/azure/cognitive-services/openai/quickstart)
   and deploy an instance of Azure OpenAI, deploy a model like "gpt-35-turbo-instruct" find your Endpoint and API key.
2. **OpenAI**: go to [OpenAI](https://platform.openai.com) to register and procure your API key.
3. **Azure Bing Web Search API**: go to [Bing Web Search API](https://www.microsoft.com/en-us/bing/apis/bing-web-search-api)
   and select `Try Now` to get started.

## Setup

### Option 1: Use Secret Manager

Integration tests will require secrets and credentials, to access OpenAI, Azure OpenAI,
Bing and other resources. 

We suggest using .NET [Secret Manager](https://learn.microsoft.com/en-us/aspnet/core/security/app-secrets)
to avoid the risk of leaking secrets into the repository, branches and pull requests.
You can also use environment variables if you prefer.

To set your secrets with Secret Manager:

```
cd dotnet/src/IntegrationTests

dotnet user-secrets init
dotnet user-secrets set "OpenAI:ServiceId" "gpt-3.5-turbo-instruct"
dotnet user-secrets set "OpenAI:ModelId" "gpt-3.5-turbo-instruct"
dotnet user-secrets set "OpenAI:ChatModelId" "gpt-4"
dotnet user-secrets set "OpenAI:ApiKey" "..."

dotnet user-secrets set "AzureOpenAI:ServiceId" "azure-gpt-35-turbo-instruct"
dotnet user-secrets set "AzureOpenAI:DeploymentName" "gpt-35-turbo-instruct"
dotnet user-secrets set "AzureOpenAI:ChatDeploymentName" "gpt-4"
dotnet user-secrets set "AzureOpenAI:Endpoint" "https://contoso.openai.azure.com/"
dotnet user-secrets set "AzureOpenAI:ApiKey" "..."

dotnet user-secrets set "AzureOpenAIEmbeddings:ServiceId" "azure-text-embedding-ada-002"
dotnet user-secrets set "AzureOpenAIEmbeddings:DeploymentName" "text-embedding-ada-002"
dotnet user-secrets set "AzureOpenAIEmbeddings:Endpoint" "https://contoso.openai.azure.com/"
dotnet user-secrets set "AzureOpenAIEmbeddings:ApiKey" "..."

dotnet user-secrets set "Bing:ApiKey" "..."
```

### Option 2: Use Configuration File
1. Create a `testsettings.development.json` file next to `testsettings.json`. This file will be ignored by git,
   the content will not end up in pull requests, so it's safe for personal settings. Keep the file safe.
2. Edit `testsettings.development.json` and
    1. set you Azure OpenAI and OpenAI keys and settings found in Azure portal and OpenAI website.
    2. set the `Bing:ApiKey` using the API key you can find in the Azure portal.

For example:

```json
{
  "OpenAI": {
    "ServiceId": "gpt-3.5-turbo-instruct",
    "ModelId": "gpt-3.5-turbo-instruct",
    "ChatModelId": "gpt-4",
    "ApiKey": "sk-...."
  },
  "AzureOpenAI": {
    "ServiceId": "gpt-35-turbo-instruct",
    "DeploymentName": "gpt-35-turbo-instruct",
    "ChatDeploymentName": "gpt-4",
    "Endpoint": "https://contoso.openai.azure.com/",
    "ApiKey": "...."
  },
  "OpenAIEmbeddings": {
    "ServiceId": "text-embedding-ada-002",
    "ModelId": "text-embedding-ada-002",
    "ApiKey": "sk-...."
  },
  "AzureOpenAIEmbeddings": {
    "ServiceId": "azure-text-embedding-ada-002",
    "DeploymentName": "text-embedding-ada-002",
    "Endpoint": "https://contoso.openai.azure.com/",
    "ApiKey": "...."
  },
  "Bing": {
    "ApiKey": "...."
  }
}
```

### Option 3: Use Environment Variables
You may also set the test settings in your environment variables. The environment variables will override the settings in the `testsettings.development.json` file.

When setting environment variables, use a double underscore (i.e. "\_\_") to delineate between parent and child properties. For example:

- bash:

  ```bash
  export OpenAI__ApiKey="sk-...."
  export AzureOpenAI__ApiKey="...."
  export AzureOpenAI__DeploymentName="gpt-35-turbo-instruct"
  export AzureOpenAI__ChatDeploymentName="gpt-4"
  export AzureOpenAIEmbeddings__DeploymentName="azure-text-embedding-ada-002"
  export AzureOpenAI__Endpoint="https://contoso.openai.azure.com/"
  export Bing__ApiKey="...."
  ```

- PowerShell:

  ```ps
  $env:OpenAI__ApiKey = "sk-...."
  $env:AzureOpenAI__ApiKey = "...."
  $env:AzureOpenAI__DeploymentName = "gpt-35-turbo-instruct"
  $env:AzureOpenAI__ChatDeploymentName = "gpt-4"
  $env:AzureOpenAIEmbeddings__DeploymentName = "azure-text-embedding-ada-002"
  $env:AzureOpenAI__Endpoint = "https://contoso.openai.azure.com/"
  $env:Bing__ApiKey = "...."
  ```


===== Orchestration.Flow.IntegrationTests\RedirectOutput.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.IO;
using System.Text;
using Microsoft.Extensions.Logging;
using Xunit.Abstractions;

namespace SemanticKernel.Experimental.Orchestration.Flow.IntegrationTests;

public sealed class RedirectOutput(ITestOutputHelper output) : TextWriter, ILogger, ILoggerFactory
{
    private readonly ITestOutputHelper _output = output;
    private readonly StringBuilder _logs = new();

    public override Encoding Encoding { get; } = Encoding.UTF8;

    public override void WriteLine(string? value)
    {
        this._output.WriteLine(value);
        this._logs.AppendLine(value);
    }

    IDisposable ILogger.BeginScope<TState>(TState state)
    {
        return null!;
    }

    bool ILogger.IsEnabled(LogLevel logLevel)
    {
        return true;
    }

    public string GetLogs()
    {
        return this._logs.ToString();
    }

    void ILogger.Log<TState>(LogLevel logLevel, EventId eventId, TState state, Exception? exception, Func<TState, Exception?, string> formatter)
    {
        var message = formatter(state, exception);
        this._output?.WriteLine(message);
        this._logs.AppendLine(message);
    }

    ILogger ILoggerFactory.CreateLogger(string categoryName) => this;

    void ILoggerFactory.AddProvider(ILoggerProvider provider) => throw new NotSupportedException();
}


===== Orchestration.Flow.IntegrationTests\SendEmailPlugin.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.ComponentModel;
using System.Text.Json;
using Microsoft.SemanticKernel;

namespace SemanticKernel.Experimental.Orchestration.Flow.IntegrationTests;

public sealed class SendEmailPlugin
{
    private static readonly JsonSerializerOptions s_writeIndented = new() { WriteIndented = true };

    [KernelFunction]
    [Description("Send email")]
    public string SendEmail(
        // ReSharper disable once InconsistentNaming
#pragma warning disable CA1707 // Identifiers should not contain underscores
        string email_address,
#pragma warning restore CA1707 // Identifiers should not contain underscores
        string answer,
        KernelArguments variables)
    {
        var contract = new Email()
        {
            Address = email_address,
            Content = answer,
        };

        // for demo purpose only
        string emailPayload = JsonSerializer.Serialize(contract, s_writeIndented);
        variables["email"] = emailPayload;

        return "Here's the API contract I will post to mail server: " + emailPayload;
    }

    private sealed class Email
    {
        public string? Address { get; set; }

        public string? Content { get; set; }
    }
}


===== Orchestration.Flow.IntegrationTests\TestSettings\AzureOpenAIConfiguration.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Diagnostics.CodeAnalysis;

namespace SemanticKernel.Experimental.Orchestration.Flow.IntegrationTests.TestSettings;

[SuppressMessage("Performance", "CA1812:Internal class that is apparently never instantiated",
    Justification = "Configuration classes are instantiated through IConfiguration.")]
internal sealed class AzureOpenAIConfiguration(string serviceId, string deploymentName, string endpoint, string apiKey, string? chatDeploymentName = null)
{
    public string ServiceId { get; set; } = serviceId;

    public string DeploymentName { get; set; } = deploymentName;

    public string? ChatDeploymentName { get; set; } = chatDeploymentName;

    public string Endpoint { get; set; } = endpoint;

    public string ApiKey { get; set; } = apiKey;
}


===== Orchestration.Flow.IntegrationTests\TestSettings\OpenAIConfiguration.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Diagnostics.CodeAnalysis;

namespace SemanticKernel.Experimental.Orchestration.Flow.IntegrationTests.TestSettings;

[SuppressMessage("Performance", "CA1812:Internal class that is apparently never instantiated",
    Justification = "Configuration classes are instantiated through IConfiguration.")]
internal sealed class OpenAIConfiguration(string serviceId, string modelId, string apiKey, string? chatModelId = null)
{
    public string ServiceId { get; set; } = serviceId;
    public string ModelId { get; set; } = modelId;
    public string? ChatModelId { get; set; } = chatModelId;
    public string ApiKey { get; set; } = apiKey;
}


===== Orchestration.Flow.UnitTests\ChatHistorySerializerTest.cs =====

// Copyright (c) Microsoft. All rights reserved.

using Microsoft.SemanticKernel.ChatCompletion;
using Microsoft.SemanticKernel.Experimental.Orchestration.Execution;
using Xunit;

namespace SemanticKernel.Experimental.Orchestration.Flow.UnitTests;

public class ChatHistorySerializerTest
{
    [Fact]
    public void CanDeserializeChatHistory()
    {
        string input = "[{\"Role\":\"assistant\",\"Content\":\"To configure the email notification, please provide the following information:\\n\\n1. Email address: (Enter the valid email address)\\n2. Notification time: (Enter the schedule of notification)\\n3. Email Content: (Enter the content expected from email notification)\\n\\nOnce you have provided this information, please type \\u0022confirmed\\u0022 to confirm the details.\"}]\r\n";
        var history = ChatHistorySerializer.Deserialize(input);

        Assert.NotNull(history);
        Assert.Single(history);
        Assert.Equal(AuthorRole.Assistant.Label, history[0].Role.Label);
    }

    [Fact]
    public void CanSerializeChatHistory()
    {
        var history = new ChatHistory();
        var systemMessage = "system";
        var userMessage = "user";
        var assistantMessage = "assistant";

        history.AddSystemMessage(systemMessage);
        history.AddUserMessage(userMessage);
        history.AddAssistantMessage(assistantMessage);

        var serialized = ChatHistorySerializer.Serialize(history);
        var deserialized = ChatHistorySerializer.Deserialize(serialized);

        Assert.NotNull(deserialized);

        Assert.Equal(deserialized[0].Role, AuthorRole.System);
        Assert.Equal(deserialized[0].Content, systemMessage);

        Assert.Equal(deserialized[1].Role, AuthorRole.User);
        Assert.Equal(deserialized[1].Content, userMessage);

        Assert.Equal(deserialized[2].Role, AuthorRole.Assistant);
        Assert.Equal(deserialized[2].Content, assistantMessage);
    }
}


===== Orchestration.Flow.UnitTests\FlowExtensionsTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.SemanticKernel.Experimental.Orchestration;
using Microsoft.SemanticKernel.Experimental.Orchestration.Abstractions;
using Xunit;

namespace SemanticKernel.Experimental.Orchestration.Flow.UnitTests;

public class FlowExtensionsTests
{
    [Fact]
    public async Task TestBuildReferenceStepAsync()
    {
        // Arrange
        var flow1 = CreateFlowWithReferenceStep("flow2");

        var flow2 = new Microsoft.SemanticKernel.Experimental.Orchestration.Flow("flow2", "test flow goal 2")
        {
            CompletionType = CompletionType.Optional
        };
        var step5 = new FlowStep("step1");
        step5.AddRequires("a");
        step5.AddProvides("b");
        flow2.AddProvides("b");
        flow2.AddStep(step5);

        // Act
        var catalog = new InMemoryFlowCatalog([flow1, flow2]);
        var flow1InCatalog = await catalog.GetFlowAsync("flow1");
        Assert.NotNull(flow1InCatalog);

        // Assert
        Assert.DoesNotContain(flow1InCatalog.Steps, step => step is ReferenceFlowStep);
        var flow2Step = flow1InCatalog.Steps.OfType<Microsoft.SemanticKernel.Experimental.Orchestration.Flow>().SingleOrDefault();
        Assert.NotNull(flow2Step);
        Assert.Equal("flow2", flow2Step.Name);
        Assert.Equal(CompletionType.Optional, flow2Step.CompletionType);
        Assert.Equal("a", flow2Step.Requires.SingleOrDefault());
        Assert.Equal("b", flow2Step.Provides.SingleOrDefault());
    }

    [Fact]
    public void TestBuildNonExistReferenceStep()
    {
        // Arrange
        var flow1 = CreateFlowWithReferenceStep("flow2");

        var flow2 = new Microsoft.SemanticKernel.Experimental.Orchestration.Flow("flow3", "test flow goal 2");
        var step5 = new FlowStep("step1");
        step5.AddProvides("a");
        flow2.AddProvides("a");
        flow2.AddStep(step5);

        // Act and assert
        Assert.Throws<AggregateException>(() => new InMemoryFlowCatalog([flow1, flow2]));
    }

    private static Microsoft.SemanticKernel.Experimental.Orchestration.Flow CreateFlowWithReferenceStep(string referenceFlowName)
    {
        var flow = new Microsoft.SemanticKernel.Experimental.Orchestration.Flow("flow1", "test flow goal");
        var step1 = new FlowStep("step1");
        step1.AddProvides("a");
        var step2 = new FlowStep("step2");
        step2.AddRequires("a");
        step2.AddProvides("b");
        var step3 = new FlowStep("step3");
        step3.AddRequires("a", "b");
        step3.AddProvides("c");
        var step4 = new ReferenceFlowStep(referenceFlowName)
        {
            CompletionType = CompletionType.Optional
        };
        flow.AddStep(step1);
        flow.AddStep(step2);
        flow.AddStep(step3);
        flow.AddStep(step4);

        return flow;
    }

    private sealed class InMemoryFlowCatalog : IFlowCatalog
    {
        private readonly Dictionary<string, Microsoft.SemanticKernel.Experimental.Orchestration.Flow> _flows = [];

        internal InMemoryFlowCatalog()
        {
        }

        internal InMemoryFlowCatalog(IReadOnlyList<Microsoft.SemanticKernel.Experimental.Orchestration.Flow> flows)
        {
            // phase 1: register original flows
            foreach (var flow in flows)
            {
                this._flows.Add(flow.Name, flow);
            }

            // phase 2: build references
            foreach (var flow in flows)
            {
#pragma warning disable VSTHRD002 // Avoid problematic synchronous waits
                flow.BuildReferenceAsync(this).Wait();
#pragma warning restore VSTHRD002 // Avoid problematic synchronous waits
            }
        }

        public Task<IEnumerable<Microsoft.SemanticKernel.Experimental.Orchestration.Flow>> GetFlowsAsync()
        {
            return Task.FromResult(this._flows.Select(_ => _.Value));
        }

        public Task<Microsoft.SemanticKernel.Experimental.Orchestration.Flow?> GetFlowAsync(string flowName)
        {
            return Task.FromResult(this._flows.TryGetValue(flowName, out var flow) ? flow : null);
        }

        public Task<bool> RegisterFlowAsync(Microsoft.SemanticKernel.Experimental.Orchestration.Flow flow)
        {
            this._flows.Add(flow.Name, flow);

            return Task.FromResult(true);
        }
    }
}


===== Orchestration.Flow.UnitTests\FlowSerializerTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.IO;
using System.Linq;
using Microsoft.SemanticKernel.Experimental.Orchestration;
using Xunit;

namespace SemanticKernel.Experimental.Orchestration.Flow.UnitTests;

public class FlowSerializerTests
{
    [Fact]
    public void CanDeserializeFromYaml()
    {
        // Arrange
        var yamlFile = "./TestData/Flow/flow.yml";
        var content = File.ReadAllText(yamlFile);

        // Act
        var flow = FlowSerializer.DeserializeFromYaml(content);

        // Assert
        this.ValidateFlow(flow);
    }

    [Fact]
    public void CanDeserializeFromJson()
    {
        // Arrange
        var jsonFile = "./TestData/Flow/flow.json";
        var content = File.ReadAllText(jsonFile);

        // Act
        var flow = FlowSerializer.DeserializeFromJson(content);

        // Assert
        this.ValidateFlow(flow);
    }

    private void ValidateFlow(Microsoft.SemanticKernel.Experimental.Orchestration.Flow? flow)
    {
        Assert.NotNull(flow);
        Assert.NotEmpty(flow.Steps);
        Assert.False(string.IsNullOrEmpty(flow.Goal));
        Assert.Contains("breakfast", flow.Provides);
        Assert.Equal(5, flow.Steps.Count);

        var makeCoffeeStep = flow.Steps.First(step => step.Goal == "Make coffee");
        Assert.Equal("coffee_bean", makeCoffeeStep.Requires.Single());
        Assert.Equal("coffee", makeCoffeeStep.Provides.Single());
        Assert.NotNull(makeCoffeeStep.Plugins);
        Assert.Single(makeCoffeeStep.Plugins);
        Assert.Equal(CompletionType.Once, makeCoffeeStep.CompletionType);

        var recipeStep = flow.Steps.First(step => step.Goal == "Recipe");
        Assert.Equal("ingredients", recipeStep.Provides.Single());
        Assert.Equal(CompletionType.AtLeastOnce, recipeStep.CompletionType);

        var lunchStep = flow.Steps.First(step => step is ReferenceFlowStep) as ReferenceFlowStep;
        Assert.NotNull(lunchStep);
        Assert.Equal(CompletionType.Optional, lunchStep.CompletionType);
        Assert.Equal("lunch_flow", lunchStep.FlowName);
    }
}


===== Orchestration.Flow.UnitTests\FlowValidatorTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using Microsoft.SemanticKernel.Experimental.Orchestration;
using Xunit;

namespace SemanticKernel.Experimental.Orchestration.Flow.UnitTests;

public class FlowValidatorTests
{
    [Fact]
    public void TestValidateFlowReturnsTrueForValidFlow()
    {
        // Arrange
        var validator = new FlowValidator();
        var flow = new Microsoft.SemanticKernel.Experimental.Orchestration.Flow("test_flow", "test flow goal");
        var step1 = new FlowStep("step1");
        step1.AddProvides("a");
        var step2 = new FlowStep("step2");
        step2.AddRequires("a");
        step2.AddProvides("b");
        var step3 = new FlowStep("step3");
        step3.AddRequires("a", "b");
        step3.AddProvides("c");
        var step4 = new ReferenceFlowStep("another flow")
        {
            CompletionType = CompletionType.Optional,
            StartingMessage = "Would you like to start another flow?"
        };
        flow.AddStep(step1);
        flow.AddStep(step2);
        flow.AddStep(step3);
        flow.AddStep(step4);

        // Act and assert
        validator.Validate(flow);
    }

    [Fact]
    public void TestValidateFlowThrowForEmptyFlow()
    {
        // Arrange
        var validator = new FlowValidator();
        var flow = new Microsoft.SemanticKernel.Experimental.Orchestration.Flow("empty flow", "empty flow");

        // Act and assert
        Assert.Throws<ArgumentException>(() => validator.Validate(flow));
    }

    [Fact]
    public void TestValidateFlowThrowForFlowWithDependencyLoops()
    {
        // Arrange
        var validator = new FlowValidator();
        var flow = new Microsoft.SemanticKernel.Experimental.Orchestration.Flow("test_flow", "test flow goal");
        var step1 = new FlowStep("step1");
        step1.AddRequires("a");
        step1.AddProvides("b");
        var step2 = new FlowStep("step2");
        step2.AddRequires("b");
        step2.AddProvides("a");
        flow.AddStep(step1);
        flow.AddStep(step2);

        // Act and assert
        Assert.Throws<ArgumentException>(() => validator.Validate(flow));
    }

    [Fact]
    public void TestValidateFlowThrowForReferenceStepWithRequires()
    {
        // Arrange
        var validator = new FlowValidator();
        var flow = new Microsoft.SemanticKernel.Experimental.Orchestration.Flow("test_flow", "test flow goal");
        var step1 = new ReferenceFlowStep("another flow");
        step1.AddRequires("a");

        // Act and assert
        Assert.Throws<ArgumentException>(() => validator.Validate(flow));
    }

    [Fact]
    public void TestValidateFlowThrowForReferenceStepWithProvides()
    {
        // Arrange
        var validator = new FlowValidator();
        var flow = new Microsoft.SemanticKernel.Experimental.Orchestration.Flow("test_flow", "test flow goal");
        var step1 = new ReferenceFlowStep("another flow");
        step1.AddProvides("a");

        // Act and assert
        Assert.Throws<ArgumentException>(() => validator.Validate(flow));
    }

    [Fact]
    public void TestValidateFlowThrowForOptionalStepWithoutStartingMessage()
    {
        // Arrange
        var validator = new FlowValidator();
        var flow = new Microsoft.SemanticKernel.Experimental.Orchestration.Flow("test_flow", "test flow goal");
        var step1 = new FlowStep("step1");
        step1.AddProvides("a");
        var step2 = new ReferenceFlowStep("another flow")
        {
            CompletionType = CompletionType.Optional
        };
        flow.AddStep(step1);
        flow.AddStep(step2);

        // Act and assert
        Assert.Throws<ArgumentException>(() => validator.Validate(flow));
    }
}


===== Orchestration.Flow.UnitTests\XunitHelpers\TestConsoleLogger.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using Microsoft.Extensions.Logging;

namespace SemanticKernel.Experimental.Orchestration.Flow.UnitTests.XunitHelpers;

/// <summary>
/// Basic logger printing to console
/// </summary>
internal static class TestConsoleLogger
{
    internal static ILogger Log => LoggerFactory.CreateLogger<object>();

    internal static ILoggerFactory LoggerFactory => s_loggerFactory.Value;
    private static readonly Lazy<ILoggerFactory> s_loggerFactory = new(LogBuilder);

    private static ILoggerFactory LogBuilder()
    {
        return Microsoft.Extensions.Logging.LoggerFactory.Create(builder =>
        {
            builder.SetMinimumLevel(LogLevel.Trace);
            // builder.AddFilter("Microsoft", LogLevel.Trace);
            // builder.AddFilter("Microsoft", LogLevel.Debug);
            // builder.AddFilter("Microsoft", LogLevel.Information);
            // builder.AddFilter("Microsoft", LogLevel.Warning);
            // builder.AddFilter("Microsoft", LogLevel.Error);
            builder.AddConsole();
        });
    }
}


===== Orchestration.Flow\Abstractions\IFlowCatalog.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Threading.Tasks;

namespace Microsoft.SemanticKernel.Experimental.Orchestration.Abstractions;

/// <summary>
/// Interface for flow catalog, which provides functionality of flow registration, enumeration and search.
/// </summary>
public interface IFlowCatalog
{
    /// <summary>
    /// Get all <see cref="Flow"/> instances from the repository
    /// </summary>
    /// <returns>flows</returns>
    Task<IEnumerable<Flow>> GetFlowsAsync();

    /// <summary>
    /// Get <see cref="Flow"/> by name
    /// </summary>
    /// <param name="flowName">the flow name</param>
    /// <returns>flow given the name</returns>
    Task<Flow?> GetFlowAsync(string flowName);

    /// <summary>
    /// Register flow in the catalog
    /// </summary>
    /// <param name="flow">flow</param>
    /// <returns></returns>
    Task<bool> RegisterFlowAsync(Flow flow);
}


===== Orchestration.Flow\Abstractions\IFlowExecutor.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Threading.Tasks;

namespace Microsoft.SemanticKernel.Experimental.Orchestration.Abstractions;

/// <summary>
/// Flow executor interface
/// </summary>
public interface IFlowExecutor
{
    /// <summary>
    /// Execute the <see cref="Flow"/>
    /// </summary>
    /// <param name="flow">Flow</param>
    /// <param name="sessionId">Session id, which is used to track the execution status.</param>
    /// <param name="input">The input from client to continue the execution.</param>
    /// <param name="kernelArguments">The request kernel arguments </param>
    /// <returns>The execution context</returns>
    Task<FunctionResult> ExecuteFlowAsync(Flow flow, string sessionId, string input, KernelArguments kernelArguments);
}


===== Orchestration.Flow\Abstractions\IFlowStatusProvider.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Threading.Tasks;
using Microsoft.SemanticKernel.ChatCompletion;
using Microsoft.SemanticKernel.Experimental.Orchestration.Execution;

namespace Microsoft.SemanticKernel.Experimental.Orchestration.Abstractions;

/// <summary>
/// The flow status provider interface.
/// </summary>
public interface IFlowStatusProvider
{
    /// <summary>
    /// Get the state of current execution session.
    /// </summary>
    /// <param name="sessionId">The session id</param>
    /// <returns>The variables</returns>
    Task<ExecutionState> GetExecutionStateAsync(string sessionId);

    /// <summary>
    /// Save the state for current execution session.
    /// </summary>
    /// <param name="sessionId">The session id</param>
    /// <param name="state">The execution state</param>
    /// <returns>Task</returns>
    Task SaveExecutionStateAsync(string sessionId, ExecutionState state);

    /// <summary>
    /// Get the chat history for current execution session.
    /// </summary>
    /// <param name="sessionId">The session id</param>
    /// <param name="stepId">The step id</param>
    /// <returns></returns>
    Task<ChatHistory?> GetChatHistoryAsync(string sessionId, string stepId);

    /// <summary>
    /// Save the chat history for current execution session.
    /// </summary>
    /// <param name="sessionId">The session id</param>
    /// <param name="stepId">The step id</param>
    /// <param name="history">The chat history</param>
    /// <returns></returns>
    Task SaveChatHistoryAsync(string sessionId, string stepId, ChatHistory history);

    /// <summary>
    /// Get the ReAct history for current execution <see cref="FlowStep"/>.
    /// </summary>
    /// <param name="sessionId">The session id</param>
    /// <param name="stepId">The step id</param>
    /// <returns>The list of ReAct steps for current flow step.</returns>
    Task<List<ReActStep>> GetReActStepsAsync(string sessionId, string stepId);

    /// <summary>
    /// Save the ReAct history for current execution step to <see cref="Memory"/>.
    /// </summary>
    /// <param name="sessionId">The session id</param>
    /// <param name="stepId">The step id</param>
    /// <param name="steps">The executed steps</param>
    /// <returns>Task</returns>
    Task SaveReActStepsAsync(string sessionId, string stepId, List<ReActStep> steps);
}


===== Orchestration.Flow\Abstractions\IFlowValidator.cs =====

// Copyright (c) Microsoft. All rights reserved.

namespace Microsoft.SemanticKernel.Experimental.Orchestration.Abstractions;

/// <summary>
/// Flow validator interface
/// </summary>
public interface IFlowValidator
{
    /// <summary>
    /// Validate if the <see cref="Flow"/> is valid.
    /// </summary>
    /// <param name="flow"></param>
    void Validate(Flow flow);
}


===== Orchestration.Flow\AssemblyInfo.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Diagnostics.CodeAnalysis;

// This assembly is currently experimental.
[assembly: Experimental("SKEXP0101")]


===== Orchestration.Flow\EmbeddedResource.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.IO;
using System.Reflection;

namespace Microsoft.SemanticKernel.Experimental.Orchestration;

internal static class EmbeddedResource
{
    private static readonly string? s_namespace = typeof(EmbeddedResource).Namespace;

    internal static string? Read(string name, bool throwIfNotFound = true)
    {
        var assembly = typeof(EmbeddedResource).GetTypeInfo().Assembly ??
            throw new KernelException($"[{s_namespace}] {name} assembly not found");

        using Stream? resource = assembly.GetManifestResourceStream($"{s_namespace}." + name);
        if (resource is null)
        {
            if (!throwIfNotFound)
            {
                return null;
            }

            throw new KernelException($"[{s_namespace}] {name} resource not found");
        }

        using var reader = new StreamReader(resource);
        return reader.ReadToEnd();
    }
}


===== Orchestration.Flow\Execution\ChatHistorySerializer.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Linq;
using System.Text.Json;
using Microsoft.SemanticKernel.ChatCompletion;

namespace Microsoft.SemanticKernel.Experimental.Orchestration.Execution;

internal static class ChatHistorySerializer
{
    internal static ChatHistory? Deserialize(string input)
    {
        if (string.IsNullOrEmpty(input))
        {
            return null;
        }

        var messages = JsonSerializer.Deserialize<SerializableChatMessage[]>(input) ?? [];
        ChatHistory history = [];
        foreach (var message in messages)
        {
            history.AddMessage(new AuthorRole(message.Role!), message.Content!);
        }

        return history;
    }

    internal static string Serialize(ChatHistory? history)
    {
        if (history is null)
        {
            return string.Empty;
        }

        var messages = history.Select(m => new SerializableChatMessage()
        {
            Role = m.Role.Label,
            Content = m.Content,
        });

        return JsonSerializer.Serialize(messages);
    }

    private sealed class SerializableChatMessage
    {
        public string? Role { get; set; }

        public string? Content { get; set; }
    }
}


===== Orchestration.Flow\Execution\Constants.cs =====

// Copyright (c) Microsoft. All rights reserved.

namespace Microsoft.SemanticKernel.Experimental.Orchestration.Execution;

internal static class Constants
{
    /// <summary>
    /// The function name to indicate stop execution and prompt user
    /// </summary>
    public const string StopAndPromptFunctionName = "StopAndPrompt";

    /// <summary>
    /// The parameter name of StopAndPrompt function
    /// </summary>
    public const string StopAndPromptParameterName = "prompt";

    internal static class ActionVariableNames
    {
        /// <summary>
        /// Variable name for the chat history
        /// </summary>
        public const string ChatHistory = "_chatHistory";

        /// <summary>
        /// Variable name for the chat input
        /// </summary>
        public const string ChatInput = "_chatInput";

        /// <summary>
        /// All reserved variable names
        /// </summary>
        public static readonly string[] All = [ChatHistory, ChatInput];
    }

    internal static class ChatPluginVariables
    {
        /// <summary>
        /// Variable name to prompt input
        /// </summary>
        public const string PromptInputName = "PromptInput";

        /// <summary>
        /// Variable name to exit out the of AtLeastOnce or ZeroOrMore loop
        /// </summary>
        public const string ExitLoopName = "ExitLoop";

        /// <summary>
        /// Variable name to force the next iteration of the of AtLeastOnce or ZeroOrMore loop
        /// </summary>
        public const string ContinueLoopName = "ContinueLoop";

        /// <summary>
        /// Variable name to terminate the flow
        /// </summary>
        public const string StopFlowName = "StopFlow";

        /// <summary>
        /// Default variable value
        /// </summary>
        public const string DefaultValue = "True";

        /// <summary>
        /// The variables that change the default flow
        /// </summary>
        public static readonly string[] ControlVariables = [PromptInputName, ExitLoopName, ContinueLoopName, StopFlowName];
    }
}


===== Orchestration.Flow\Execution\ExecutionState.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;

namespace Microsoft.SemanticKernel.Experimental.Orchestration.Execution;

/// <summary>
/// Execution state
/// </summary>
public sealed class ExecutionState
{
    /// <summary>
    /// Index of current step
    /// </summary>
    public int CurrentStepIndex { get; set; } = 0;

    /// <summary>
    /// Execution state described by variables.
    /// </summary>
    public Dictionary<string, string> Variables { get; set; } = [];

    /// <summary>
    /// Execution state of each step
    /// </summary>
    public Dictionary<string, StepExecutionState> StepStates { get; set; } = [];

    /// <summary>
    /// Step execution state
    /// </summary>
    public class StepExecutionState
    {
        /// <summary>
        /// The status of step execution
        /// </summary>
        public Status Status { get; set; } = Status.NotStarted;

        /// <summary>
        /// The execution count of step. The value could be larger than one if the step allows repeatable execution.
        /// </summary>
        public int ExecutionCount { get; set; }

        /// <summary>
        /// The output variables provided by the step
        /// </summary>
        public Dictionary<string, List<string>> Output { get; set; } = [];

        /// <summary>
        /// Add or update variable for the step
        /// </summary>
        /// <param name="executionIndex">The execution index</param>
        /// <param name="key">The key of variable.</param>
        /// <param name="value">The value of variable.</param>
        public void AddOrUpdateVariable(int executionIndex, string key, string value)
        {
            if (!this.Output.TryGetValue(key, out List<string>? output))
            {
                this.Output[key] = output = [];
            }

            if (output!.Count <= executionIndex)
            {
                output.Add(value);
            }
            else
            {
                output[executionIndex] = value;
            }
        }
    }

    /// <summary>
    /// The execution status enum
    /// </summary>
    public enum Status
    {
        /// <summary>
        /// Not started
        /// </summary>
        NotStarted,

        /// <summary>
        /// In progress
        /// </summary>
        InProgress,

        /// <summary>
        /// Completed
        /// </summary>
        Completed
    }
}


===== Orchestration.Flow\Execution\FlowExecutor.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.Json;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.SemanticKernel.ChatCompletion;
using Microsoft.SemanticKernel.Experimental.Orchestration.Abstractions;
using Microsoft.SemanticKernel.Experimental.Orchestration.Extensions;

namespace Microsoft.SemanticKernel.Experimental.Orchestration.Execution;

/// <summary>
/// This is a flow executor which iterates over the flow steps and executes them one by one.
/// </summary>
/// <remarks>
/// For each step, it is executed in the ReAct (Reasoning-Act-Observe) style, which is similar as StepwisePlanner, with the following differences:
/// 1. It is implemented in a way so that the chat could be streamed for more effective reasoning, action and feedback loop.
/// 2. The user input would be part of observation for the engine to reason and determine next action.
/// 3. For each step, it is considered as complete by verifying all the outputs are provided in programmatic way, instead of LLM evaluation.
///
/// Further consolidation can happen in the future so that flow executor becomes a generalization of StepwisePlanner.
/// And both chatMode and completionMode could be supported.
/// </remarks>
internal partial class FlowExecutor : IFlowExecutor
{
    /// <summary>
    /// The kernel builder
    /// </summary>
    private readonly IKernelBuilder _kernelBuilder;

    /// <summary>
    /// The logger
    /// </summary>
    private readonly ILogger _logger;

    /// <summary>
    /// The global plugin collection
    /// </summary>
    private readonly Dictionary<object, string?> _globalPluginCollection;

    /// <summary>
    /// The flow planner config
    /// </summary>
    private readonly FlowOrchestratorConfig _config;

    /// <summary>
    /// The flow status provider
    /// </summary>
    private readonly IFlowStatusProvider _flowStatusProvider;

    /// <summary>
    /// System kernel for flow execution
    /// </summary>
    private readonly Kernel _systemKernel;

    /// <summary>
    /// Re-Act engine for flow execution
    /// </summary>
    private readonly ReActEngine _reActEngine;

    /// <summary>
    /// Restricted plugin name
    /// </summary>
    private const string RestrictedPluginName = "FlowExecutor_Excluded";

    /// <summary>
    /// The regex for parsing the final answer response
    /// </summary>
#if NET
    [GeneratedRegex(@"\[FINAL.+\](?<final_answer>.+)", RegexOptions.Singleline)]
    private static partial Regex FinalAnswerRegex();
#else
    private static Regex FinalAnswerRegex() => s_finalAnswerRegex;
    private static readonly Regex s_finalAnswerRegex = new(@"\[FINAL.+\](?<final_answer>.+)", RegexOptions.Singleline | RegexOptions.Compiled);
#endif

    /// <summary>
    /// The regex for parsing the question
    /// </summary>
#if NET
    [GeneratedRegex(@"\[QUESTION\](?<question>.+)", RegexOptions.Singleline)]
    private static partial Regex QuestionRegex();
#else
    private static Regex QuestionRegex() => s_questionRegex;
    private static readonly Regex s_questionRegex = new(@"\[QUESTION\](?<question>.+)", RegexOptions.Singleline | RegexOptions.Compiled);
#endif

    /// <summary>
    /// The regex for parsing the thought response
    /// </summary>
#if NET
    [GeneratedRegex(@"\[THOUGHT\](?<thought>.+)", RegexOptions.Singleline)]
    private static partial Regex ThoughtRegex();
#else
    private static Regex ThoughtRegex() => s_thoughtRegex;
    private static readonly Regex s_thoughtRegex = new(@"\[THOUGHT\](?<thought>.+)", RegexOptions.Singleline | RegexOptions.Compiled);
#endif

    /// <summary>
    /// Check repeat step function
    /// </summary>
    private readonly KernelFunction _checkRepeatStepFunction;

    /// <summary>
    /// Check start step function
    /// </summary>
    private readonly KernelFunction _checkStartStepFunction;

    /// <summary>
    /// ExecuteFlow function
    /// </summary>
    private readonly KernelFunction _executeFlowFunction;

    /// <summary>
    /// ExecuteStep function
    /// </summary>
    private readonly KernelFunction _executeStepFunction;

    internal FlowExecutor(IKernelBuilder kernelBuilder, IFlowStatusProvider statusProvider, Dictionary<object, string?> globalPluginCollection, FlowOrchestratorConfig? config = null)
    {
        this._kernelBuilder = kernelBuilder;
        this._systemKernel = kernelBuilder.Build();

        this._logger = this._systemKernel.LoggerFactory.CreateLogger(typeof(FlowExecutor)) ?? NullLogger.Instance;
        this._config = config ?? new FlowOrchestratorConfig();

        this._flowStatusProvider = statusProvider;
        this._globalPluginCollection = globalPluginCollection;

        var checkRepeatStepConfig = this.ImportPromptTemplateConfig("CheckRepeatStep");
        this._checkRepeatStepFunction = KernelFunctionFactory.CreateFromPrompt(checkRepeatStepConfig);

        var checkStartStepConfig = this.ImportPromptTemplateConfig("CheckStartStep");
        this._checkStartStepFunction = KernelFunctionFactory.CreateFromPrompt(checkStartStepConfig);

        this._config.ExcludedPlugins.Add(RestrictedPluginName);
        this._reActEngine = new ReActEngine(this._systemKernel, this._logger, this._config);

        this._executeFlowFunction = KernelFunctionFactory.CreateFromMethod(this.ExecuteFlowAsync, "ExecuteFlow", "Execute a flow");
        this._executeStepFunction = KernelFunctionFactory.CreateFromMethod(this.ExecuteStepAsync, "ExecuteStep", "Execute a flow step");
    }

    private PromptTemplateConfig ImportPromptTemplateConfig(string functionName)
    {
        var config = KernelFunctionYaml.ToPromptTemplateConfig(EmbeddedResource.Read($"Plugins.{functionName}.yaml")!);

        // if AIServiceIds is specified, only include the relevant execution settings
        if (this._config.AIServiceIds.Count > 0)
        {
            var serviceIdsToRemove = config.ExecutionSettings.Keys.Except(this._config.AIServiceIds);
            foreach (var serviceId in serviceIdsToRemove)
            {
                config.ExecutionSettings.Remove(serviceId);
            }
        }

        return config;
    }

    public async Task<FunctionResult> ExecuteFlowAsync(Flow flow, string sessionId, string input, KernelArguments kernelArguments)
    {
        Verify.NotNull(flow, nameof(flow));

        if (this._logger.IsEnabled(LogLevel.Information))
        {
            this._logger.LogInformation("Executing flow {FlowName} with sessionId={SessionId}.", flow.Name, sessionId);
        }

        var sortedSteps = flow.SortSteps();

        var rootContext = new KernelArguments(kernelArguments);

        // populate persisted state arguments
        ExecutionState executionState = await this._flowStatusProvider.GetExecutionStateAsync(sessionId).ConfigureAwait(false);
        List<string> outputs = [];

        while (executionState.CurrentStepIndex < sortedSteps.Count)
        {
            int stepIndex = executionState.CurrentStepIndex;
            FlowStep step = sortedSteps[stepIndex];

            foreach (var kv in executionState.Variables)
            {
                rootContext[kv.Key] = kv.Value;
            }

            this.ValidateStep(step, rootContext);

            // init step execution state
            string stepKey = $"{stepIndex}_{step.Goal}";
            if (!executionState.StepStates.TryGetValue(stepKey, out ExecutionState.StepExecutionState? stepState))
            {
                stepState = new ExecutionState.StepExecutionState();
                executionState.StepStates.Add(stepKey, stepState);
            }

            var stepId = $"{stepKey}_{stepState.ExecutionCount}";

            var continueLoop = false;
            var completed = step.Provides.All(executionState.Variables.ContainsKey);
            if (!completed)
            {
                // On the first iteration of an Optional or ZeroOrMore step, we need to check whether the user wants to start the step
                if (step.CompletionType is CompletionType.Optional or CompletionType.ZeroOrMore && stepState.Status == ExecutionState.Status.NotStarted)
                {
                    RepeatOrStartStepResult? startStep = await this.CheckStartStepAsync(rootContext, step, sessionId, stepId, input).ConfigureAwait(false);
                    if (startStep is null)
                    {
                        // Unknown error, try again
                        this._logger?.LogWarning("Unexpected error when checking whether to start the step, try again");
                        continue;
                    }
                    else if (startStep.Execute is null)
                    {
                        // Unconfirmed, prompt user
                        outputs.Add(startStep.Prompt!);
                        await this._flowStatusProvider.SaveExecutionStateAsync(sessionId, executionState).ConfigureAwait(false);
                        break;
                    }
                    else if (startStep.Execute.Value)
                    {
                        stepState.Status = ExecutionState.Status.InProgress;
                        await this._flowStatusProvider.SaveExecutionStateAsync(sessionId, executionState).ConfigureAwait(false);

                        if (this._logger?.IsEnabled(LogLevel.Information) ?? false)
                        {
                            this._logger.LogInformation("Need to start step {StepIndex} for iteration={Iteration}, goal={StepGoal}.", stepIndex, stepState.ExecutionCount, step.Goal);
                        }
                    }
                    else
                    {
                        // User doesn't want to run the step
                        foreach (var variable in step.Provides)
                        {
                            executionState.Variables[variable] = "[]";
                        }

                        await this.CompleteStepAsync(rootContext, sessionId, executionState, step, stepState).ConfigureAwait(false);

                        if (this._logger?.IsEnabled(LogLevel.Information) ?? false)
                        {
                            this._logger.LogInformation("Completed step {StepIndex} with iteration={Iteration}, goal={StepGoal}.", stepIndex, stepState.ExecutionCount, step.Goal);
                        }

                        continue;
                    }
                }

                // execute step
                if (this._logger?.IsEnabled(LogLevel.Information) ?? false)
                {
                    this._logger.LogInformation(
                        "Executing step {StepIndex} for iteration={Iteration}, goal={StepGoal}, input={Input}.", stepIndex,
                        stepState.ExecutionCount, step.Goal, input);
                }

                Kernel stepKernel = this._kernelBuilder.Build();
                var stepArguments = new KernelArguments();
                foreach (var key in step.Requires)
                {
                    stepArguments[key] = rootContext[key];
                }

                foreach (var key in step.Passthrough)
                {
                    if (rootContext.TryGetValue(key, out var val))
                    {
                        stepArguments[key] = val;
                    }
                }

                FunctionResult? stepResult;
                if (step is Flow flowStep)
                {
                    stepResult = await this.ExecuteFlowAsync(flowStep, $"{sessionId}_{stepId}", input, stepArguments).ConfigureAwait(false);
                }
                else
                {
                    var stepPlugins = step.LoadPlugins(stepKernel, this._globalPluginCollection);
                    foreach (var plugin in stepPlugins)
                    {
                        stepKernel.ImportPluginFromObject(plugin, plugin.GetType().Name);
                    }

                    stepResult = await this.ExecuteStepAsync(step, sessionId, stepId, input, stepKernel, stepArguments).ConfigureAwait(false);
                }

                if (!string.IsNullOrEmpty(stepResult.ToString()) && (stepResult.IsPromptInput() || stepResult.IsTerminateFlow()))
                {
                    if (stepResult.ValueType == typeof(List<string>))
                    {
                        outputs.AddRange(stepResult.GetValue<List<string>>()!);
                    }
                    else
                    {
                        outputs.Add(stepResult.ToString());
                    }
                }
                else if (stepResult.TryGetExitLoopResponse(out string? exitResponse))
                {
                    stepState.Status = ExecutionState.Status.Completed;

                    var metadata = stepResult.Metadata!.ToDictionary(kvp => kvp.Key, kvp => kvp.Value);
                    foreach (var variable in step.Provides)
                    {
                        if (!metadata.ContainsKey(variable))
                        {
                            metadata[variable] = string.Empty;
                        }
                    }

                    stepResult = new FunctionResult(stepResult.Function, stepResult.GetValue<object>(), metadata: metadata);

                    if (!string.IsNullOrWhiteSpace(exitResponse))
                    {
                        outputs.Add(exitResponse!);
                    }

                    if (this._logger?.IsEnabled(LogLevel.Information) ?? false)
                    {
                        this._logger.LogInformation("Exiting loop for step {StepIndex} with iteration={Iteration}, goal={StepGoal}.", stepIndex, stepState.ExecutionCount, step.Goal);
                    }
                }
                else if (stepResult.IsContinueLoop())
                {
                    continueLoop = true;

                    if (this._logger?.IsEnabled(LogLevel.Information) ?? false)
                    {
                        this._logger.LogInformation("Continuing to the next loop iteration for step {StepIndex} with iteration={Iteration}, goal={StepGoal}.", stepIndex, stepState.ExecutionCount, step.Goal);
                    }
                }

                // check if current execution is complete by checking whether all arguments are already provided
                completed = true;
                foreach (var variable in step.Provides)
                {
                    if (!stepResult.Metadata!.ContainsKey(variable))
                    {
                        completed = false;
                    }
                    else
                    {
                        executionState.Variables[variable] = (string)stepResult.Metadata[variable]!;
                        stepState.AddOrUpdateVariable(stepState.ExecutionCount, variable, (string)stepResult.Metadata[variable]!);
                    }
                }

                foreach (var variable in step.Passthrough)
                {
                    if (stepResult.Metadata!.TryGetValue(variable, out object? variableValue))
                    {
                        executionState.Variables[variable] = (string)variableValue!;
                        stepState.AddOrUpdateVariable(stepState.ExecutionCount, variable, (string)variableValue!);

                        // propagate arguments to root context, needed if Flow itself is a step
                        this.PropagateVariable(rootContext, stepResult, variable);
                    }
                }

                // propagate arguments to root context, needed if Flow itself is a step
                foreach (var variable in Constants.ChatPluginVariables.ControlVariables)
                {
                    this.PropagateVariable(rootContext, stepResult, variable);
                }
            }

            if (completed)
            {
                if (this._logger?.IsEnabled(LogLevel.Information) ?? false)
                {
                    this._logger.LogInformation("Completed step {StepIndex} for iteration={Iteration}, goal={StepGoal}.", stepIndex, stepState.ExecutionCount, step.Goal);
                }

                if (step.CompletionType is CompletionType.AtLeastOnce or CompletionType.ZeroOrMore && stepState.Status != ExecutionState.Status.Completed)
                {
                    var nextStepId = $"{stepKey}_{stepState.ExecutionCount + 1}";
                    var repeatStep = continueLoop
                        ? new RepeatOrStartStepResult(true, null)
                        : await this.CheckRepeatStepAsync(rootContext, step, sessionId, nextStepId, input).ConfigureAwait(false);

                    if (repeatStep is null)
                    {
                        // unknown error, try again
                        this._logger?.LogWarning("Unexpected error when checking whether to repeat the step, try again");
                    }
                    else if (repeatStep.Execute is null)
                    {
                        // unconfirmed, prompt user
                        outputs.Add(repeatStep.Prompt!);

                        if (this._logger?.IsEnabled(LogLevel.Information) ?? false)
                        {
                            this._logger.LogInformation("Unclear intention, need follow up to check whether to repeat the step");
                        }

                        await this._flowStatusProvider.SaveExecutionStateAsync(sessionId, executionState).ConfigureAwait(false);
                        break;
                    }
                    else if (repeatStep.Execute.Value)
                    {
                        // need repeat the step again
                        foreach (var variable in step.Provides)
                        {
                            executionState.Variables.Remove(variable);
                        }

                        stepState.ExecutionCount++;
                        await this._flowStatusProvider.SaveExecutionStateAsync(sessionId, executionState).ConfigureAwait(false);

                        if (this._logger?.IsEnabled(LogLevel.Information) ?? false)
                        {
                            this._logger.LogInformation("Need repeat step {StepIndex} for iteration={Iteration}, goal={StepGoal}.", stepIndex, stepState.ExecutionCount, step.Goal);
                        }
                    }
                    else
                    {
                        // completed
                        await this.CompleteStepAsync(rootContext, sessionId, executionState, step, stepState).ConfigureAwait(false);

                        if (this._logger?.IsEnabled(LogLevel.Information) ?? false)
                        {
                            this._logger.LogInformation("Completed step {StepIndex} with iteration={Iteration}, goal={StepGoal}.", stepIndex, stepState.ExecutionCount, step.Goal);
                        }
                    }
                }
                else
                {
                    await this.CompleteStepAsync(rootContext, sessionId, executionState, step, stepState).ConfigureAwait(false);
                }
            }
            else
            {
                await this._flowStatusProvider.SaveExecutionStateAsync(sessionId, executionState).ConfigureAwait(false);
                break;
            }
        }

        if (this._logger?.IsEnabled(LogLevel.Information) ?? false)
        {
            foreach (var output in outputs)
            {
                this._logger?.LogInformation("[Output] {Output}", output);
            }
        }

        return new FunctionResult(this._executeFlowFunction, outputs, metadata: rootContext);
    }

    private void PropagateVariable(KernelArguments rootContext, FunctionResult stepResult, string variableName)
    {
        if (stepResult.Metadata!.ContainsKey(variableName))
        {
            rootContext[variableName] = stepResult.Metadata[variableName];
        }
    }

    private async Task CompleteStepAsync(KernelArguments context, string sessionId, ExecutionState state, FlowStep step, ExecutionState.StepExecutionState stepState)
    {
        stepState.Status = ExecutionState.Status.Completed;
        state.CurrentStepIndex++;

        foreach (var kvp in stepState.Output)
        {
            if (step.CompletionType == CompletionType.Once)
            {
                state.Variables[kvp.Key] = kvp.Value.Single();
            }
            else
            {
                // kvp.Value may contain empty strings when the loop was exited and the arguments the step provides weren't set
                state.Variables[kvp.Key] = JsonSerializer.Serialize(kvp.Value.Where(x => !string.IsNullOrWhiteSpace(x)).ToList());
            }
        }

        foreach (var variable in step.Provides)
        {
            context[variable] = state.Variables[variable];
        }

        await this._flowStatusProvider.SaveExecutionStateAsync(sessionId, state).ConfigureAwait(false);
    }

    private void ValidateStep(FlowStep step, KernelArguments context)
    {
        if (step.Requires.Any(p => !context.ContainsName(p)))
        {
            throw new KernelException($"Step {step.Goal} requires arguments {string.Join(",", step.Requires.Where(p => !context.ContainsName(p)))} that are not provided. ");
        }
    }

    private async Task<RepeatOrStartStepResult?> CheckStartStepAsync(KernelArguments context, FlowStep step, string sessionId, string stepId, string input)
    {
        context = new KernelArguments(context)
        {
            ["goal"] = step.Goal,
            ["message"] = step.StartingMessage
        };
        return await this.CheckRepeatOrStartStepAsync(context, this._checkStartStepFunction, sessionId, $"{stepId}_CheckStartStep", input).ConfigureAwait(false);
    }

    private async Task<RepeatOrStartStepResult?> CheckRepeatStepAsync(KernelArguments context, FlowStep step, string sessionId, string nextStepId, string input)
    {
        context = new KernelArguments(context)
        {
            ["goal"] = step.Goal,
            ["transitionMessage"] = step.TransitionMessage
        };
        return await this.CheckRepeatOrStartStepAsync(context, this._checkRepeatStepFunction, sessionId, $"{nextStepId}_CheckRepeatStep", input).ConfigureAwait(false);
    }

    private async Task<RepeatOrStartStepResult?> CheckRepeatOrStartStepAsync(KernelArguments context, KernelFunction function, string sessionId, string checkRepeatOrStartStepId, string input)
    {
        var chatHistory = await this._flowStatusProvider.GetChatHistoryAsync(sessionId, checkRepeatOrStartStepId).ConfigureAwait(false);
        if (chatHistory is not null)
        {
            chatHistory.AddUserMessage(input);
        }
        else
        {
            chatHistory = [];
        }

        var scratchPad = this.CreateRepeatOrStartStepScratchPad(chatHistory);
        context["agentScratchPad"] = scratchPad;

        if (this._logger.IsEnabled(LogLevel.Information))
        {
            this._logger.LogInformation("Scratchpad: {ScratchPad}", scratchPad);
        }

        var llmResponse = await this._systemKernel.InvokeAsync(function, context).ConfigureAwait(false);

        string llmResponseText = llmResponse.GetValue<string>()?.Trim() ?? string.Empty;

        if (this._logger.IsEnabled(LogLevel.Information))
        {
            this._logger.LogInformation("Response from {Function} : {ActionText}", "CheckRepeatOrStartStep", llmResponseText);
        }

        Match finalAnswerMatch = FinalAnswerRegex().Match(llmResponseText);
        if (finalAnswerMatch.Success)
        {
            string resultString = finalAnswerMatch.Groups[1].Value.Trim();
            if (bool.TryParse(resultString, out bool result))
            {
                await this._flowStatusProvider.SaveChatHistoryAsync(sessionId, checkRepeatOrStartStepId, chatHistory).ConfigureAwait(false);
                return new RepeatOrStartStepResult(result);
            }
        }

        // Extract thought
        Match thoughtMatch = ThoughtRegex().Match(llmResponseText);
        if (thoughtMatch.Success)
        {
            string thoughtString = thoughtMatch.Groups[1].Value.Trim();
            chatHistory.AddSystemMessage(thoughtString);
        }

        Match questionMatch = QuestionRegex().Match(llmResponseText);
        if (questionMatch.Success)
        {
            string prompt = questionMatch.Groups[1].Value.Trim();
            chatHistory.AddAssistantMessage(prompt);
            await this._flowStatusProvider.SaveChatHistoryAsync(sessionId, checkRepeatOrStartStepId, chatHistory).ConfigureAwait(false);

            return new RepeatOrStartStepResult(null, prompt);
        }

        this._logger.LogWarning("Missing result tag from {Function} : {ActionText}", "CheckRepeatOrStartStep", llmResponseText);
        chatHistory.AddSystemMessage(llmResponseText + "\nI should provide either [QUESTION] or [FINAL_ANSWER].");
        await this._flowStatusProvider.SaveChatHistoryAsync(sessionId, checkRepeatOrStartStepId, chatHistory).ConfigureAwait(false);
        return null;
    }

    private string CreateRepeatOrStartStepScratchPad(ChatHistory chatHistory)
    {
        var scratchPadLines = new List<string>();
        foreach (var message in chatHistory)
        {
            if (message.Role == AuthorRole.Assistant)
            {
                scratchPadLines.Add("[QUESTION]");
            }
            else if (message.Role == AuthorRole.User)
            {
                scratchPadLines.Add("[RESPONSE]");
            }
            else if (message.Role == AuthorRole.System)
            {
                scratchPadLines.Add("[THOUGHT]");
            }

            scratchPadLines.Add(message.Content!);
        }

        return string.Join("\n", scratchPadLines).Trim();
    }

    private async Task<FunctionResult> ExecuteStepAsync(FlowStep step, string sessionId, string stepId, string input, Kernel kernel, KernelArguments arguments)
    {
        var stepsTaken = await this._flowStatusProvider.GetReActStepsAsync(sessionId, stepId).ConfigureAwait(false);
        var lastStep = stepsTaken.LastOrDefault();
        if (lastStep is not null)
        {
            lastStep.Observation += $"{AuthorRole.User.Label}: {input}\n";
            await this._flowStatusProvider.SaveReActStepsAsync(sessionId, stepId, stepsTaken).ConfigureAwait(false);
        }

        var question = step.Goal;
        foreach (var variable in step.Requires)
        {
            if (!variable.StartsWith("_", StringComparison.InvariantCulture) && ((string)arguments[variable]!).Length <= this._config.MaxVariableLength)
            {
                question += $"\n - {variable}: {JsonSerializer.Serialize(arguments[variable])}";
            }
        }

        for (int i = stepsTaken.Count; i < this._config.MaxStepIterations; i++)
        {
            var actionStep = await this._reActEngine.GetNextStepAsync(kernel, arguments, question, stepsTaken).ConfigureAwait(false);

            if (actionStep is null)
            {
                this._logger?.LogWarning("Failed to get action step given input=\"{Input}\"", input);
                continue;
            }

            stepsTaken.Add(actionStep);

            if (this._logger?.IsEnabled(LogLevel.Information) ?? false)
            {
                this._logger.LogInformation("Thought: {Thought}", actionStep.Thought);
            }

            if (!string.IsNullOrEmpty(actionStep.FinalAnswer))
            {
                if (step.Provides.Count() == 1)
                {
                    arguments[step.Provides.Single()] = actionStep.FinalAnswer;
                    return new FunctionResult(this._executeStepFunction, actionStep.FinalAnswer, metadata: arguments);
                }
            }
            else if (!string.IsNullOrEmpty(actionStep.Action!))
            {
                if (actionStep.Action!.Contains(Constants.StopAndPromptFunctionName))
                {
                    string prompt = actionStep.ActionVariables![Constants.StopAndPromptParameterName];
                    arguments.TerminateFlow();

                    return new FunctionResult(this._executeStepFunction, prompt, metadata: arguments);
                }

                var actionContextVariables = new KernelArguments();
                foreach (var kvp in arguments)
                {
                    if (step.Requires.Contains(kvp.Key) || step.Passthrough.Contains(kvp.Key))
                    {
                        actionContextVariables[kvp.Key] = kvp.Value;
                    }
                }

                // get chat history
                var chatHistory = await this._flowStatusProvider.GetChatHistoryAsync(sessionId, stepId).ConfigureAwait(false);
                if (chatHistory is null)
                {
                    chatHistory = [];
                }
                else
                {
                    chatHistory.AddUserMessage(input);
                }

                string? actionResult;
                try
                {
                    if (this._config.MinIterationTimeMs > 0)
                    {
                        await Task.Delay(this._config.MinIterationTimeMs).ConfigureAwait(false);
                    }
                    actionResult = await this._reActEngine.InvokeActionAsync(actionStep, input, chatHistory, kernel, actionContextVariables).ConfigureAwait(false);

                    if (string.IsNullOrEmpty(actionResult))
                    {
                        actionStep.Observation = "Got no result from action";
                    }
                    else
                    {
                        actionStep.Observation = $"{AuthorRole.Assistant.Label}: {actionResult}\n";
                        chatHistory.AddAssistantMessage(actionResult);
                        await this._flowStatusProvider.SaveChatHistoryAsync(sessionId, stepId, chatHistory).ConfigureAwait(false);

                        foreach (var passthroughParam in step.Passthrough)
                        {
                            if (actionContextVariables.TryGetValue(passthroughParam, out object? paramValue) && paramValue is string paramStringValue && !string.IsNullOrEmpty(paramStringValue))
                            {
                                arguments[passthroughParam] = actionContextVariables[passthroughParam];
                            }
                        }

                        foreach (var providedParam in step.Provides)
                        {
                            if (actionContextVariables.TryGetValue(providedParam, out object? paramValue) && paramValue is string paramStringValue && !string.IsNullOrEmpty(paramStringValue))
                            {
                                arguments[providedParam] = actionContextVariables[providedParam];
                            }
                        }

                        foreach (var variable in Constants.ChatPluginVariables.ControlVariables)
                        {
                            if (actionContextVariables.TryGetValue(variable, out object? variableValue))
                            {
                                arguments[variable] = variableValue;
                            }
                        }
                    }
                }
                catch (MissingMethodException ex)
                {
                    actionStep.Observation = $"Error invoking action {actionStep.Action} : {ex.Message}. " +
                                             "Use only the available functions listed in the [AVAILABLE FUNCTIONS] section. " +
                                             "Do not attempt to use any other functions that are not specified.\n";

                    continue;
                }
                catch (Exception ex) when (!ex.IsNonRetryable())
                {
                    actionStep.Observation = $"Error invoking action {actionStep.Action} : {ex.Message}";
                    this._logger?.LogWarning(ex, "Error invoking action {Action}", actionStep.Action);

                    continue;
                }

                if (this._logger?.IsEnabled(LogLevel.Information) ?? false)
                {
                    this._logger.LogInformation("Observation: {Observation}", actionStep.Observation);
                }

                await this._flowStatusProvider.SaveReActStepsAsync(sessionId, stepId, stepsTaken).ConfigureAwait(false);

                if (!string.IsNullOrEmpty(actionResult))
                {
                    if (arguments.IsTerminateFlow())
                    {
                        // Terminate the flow without another round of reasoning, to save the LLM reasoning calls.
                        // This is not suggested unless plugin has performance requirement and has explicitly set the control variable.
                        return new FunctionResult(this._executeStepFunction, actionResult, metadata: arguments);
                    }

                    foreach (var variable in Constants.ChatPluginVariables.ControlVariables)
                    {
                        if (arguments.ContainsName(variable))
                        {
                            // redirect control to client
                            return new FunctionResult(this._executeStepFunction, actionResult, metadata: arguments);
                        }
                    }

                    if (!step.Provides.Except(arguments.Where(v => !string.IsNullOrEmpty((string)v.Value!)).Select(_ => _.Key)).Any())
                    {
                        // step is complete
                        return new FunctionResult(this._executeStepFunction, actionResult, metadata: arguments);
                    }

                    // continue to next iteration
                    continue;
                }

                this._logger?.LogWarning("Action: No result from action");
            }
            else
            {
                actionStep.Observation = "ACTION $JSON_BLOB must be provided as part of thought process.";
                this._logger?.LogWarning("Action: No action to take");
            }

            if (this._config.MinIterationTimeMs > 0)
            {
                // continue to next iteration
                await Task.Delay(this._config.MinIterationTimeMs).ConfigureAwait(false);
            }
        }

        throw new KernelException($"Failed to complete step {stepId} for session {sessionId}.");
    }

    private sealed class RepeatOrStartStepResult(bool? execute, string? prompt = null)
    {
        public bool? Execute { get; } = execute;

        public string? Prompt { get; } = prompt;
    }
}


===== Orchestration.Flow\Execution\FlowStatusProvider.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.SemanticKernel.ChatCompletion;
using Microsoft.SemanticKernel.Experimental.Orchestration.Abstractions;
using Microsoft.SemanticKernel.Experimental.Orchestration.Execution;
using Microsoft.SemanticKernel.Memory;

namespace Microsoft.SemanticKernel.Experimental.Orchestration;

/// <summary>
/// Default flow status provider implemented on top of <see cref="IMemoryStore"/>
/// </summary>
public sealed class FlowStatusProvider : IFlowStatusProvider
{
    private readonly IMemoryStore _memoryStore;

    private readonly string _collectionName;

    /// <summary>
    /// Initializes a new instance of the <see cref="FlowStatusProvider"/> class.
    /// </summary>
    public static async Task<FlowStatusProvider> ConnectAsync(IMemoryStore memoryStore, string? collectionName = null)
    {
        var provider = new FlowStatusProvider(memoryStore, collectionName);
        return await InitializeProviderStoreAsync(provider).ConfigureAwait(false);
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="FlowStatusProvider"/> class.
    /// </summary>
    /// <param name="memoryStore"><see cref="IMemoryStore"/> instance</param>
    /// <param name="collectionName">Collection name in <see cref="IMemoryStore"/> instance</param>
    private FlowStatusProvider(IMemoryStore memoryStore, string? collectionName = null)
    {
        this._memoryStore = memoryStore;
        this._collectionName = collectionName ?? nameof(FlowStatusProvider);
    }

    /// <inheritdoc/>
    public async Task<ExecutionState> GetExecutionStateAsync(string sessionId)
    {
        var result = await (this._memoryStore.GetAsync(this._collectionName, this.GetExecutionStateStorageKey(sessionId))).ConfigureAwait(false);
        var text = result?.Metadata.Text ?? string.Empty;

        if (!string.IsNullOrEmpty(text))
        {
            try
            {
                return JsonSerializer.Deserialize<ExecutionState>(text) ?? new ExecutionState();
            }
            catch
            {
                throw new InvalidOperationException(
                    $"Failed to deserialize execution state for sessionId={sessionId}, data={text}");
            }
        }
        else
        {
            return new ExecutionState();
        }
    }

    /// <inheritdoc/>
    public async Task SaveExecutionStateAsync(string sessionId, ExecutionState state)
    {
        var json = JsonSerializer.Serialize(state);
        await this._memoryStore.UpsertAsync(this._collectionName, this.CreateMemoryRecord(this.GetExecutionStateStorageKey(sessionId), json))
            .ConfigureAwait(false);
    }

    private string GetExecutionStateStorageKey(string sessionId)
    {
        return $"FlowStatus_{sessionId}";
    }

    /// <inheritdoc/>
    public async Task<ChatHistory?> GetChatHistoryAsync(string sessionId, string stepId)
    {
        var result = await this._memoryStore.GetAsync(this._collectionName, this.GetChatHistoryStorageKey(sessionId, stepId)).ConfigureAwait(false);
        var text = result?.Metadata.Text ?? string.Empty;

        if (!string.IsNullOrEmpty(text))
        {
            try
            {
                return ChatHistorySerializer.Deserialize(text);
            }
            catch
            {
                throw new InvalidOperationException(
                    $"Failed to deserialize chat history for session {sessionId}, data={text}");
            }
        }
        else
        {
            return null;
        }
    }

    /// <inheritdoc/>
    public async Task SaveChatHistoryAsync(string sessionId, string stepId, ChatHistory history)
    {
        var json = ChatHistorySerializer.Serialize(history);
        await this._memoryStore.UpsertAsync(this._collectionName, this.CreateMemoryRecord(this.GetChatHistoryStorageKey(sessionId, stepId), json))
            .ConfigureAwait(false);
    }

    private string GetChatHistoryStorageKey(string sessionId, string stepId)
    {
        return $"ChatHistory_{sessionId}_{stepId}";
    }

    /// <inheritdoc/>
    public async Task<List<ReActStep>> GetReActStepsAsync(string sessionId, string stepId)
    {
        var result = await this._memoryStore.GetAsync(this._collectionName, this.GetStepsStorageKey(sessionId, stepId)).ConfigureAwait(false);
        var text = result?.Metadata.Text ?? string.Empty;

        if (!string.IsNullOrEmpty(text))
        {
            try
            {
                return JsonSerializer.Deserialize<List<ReActStep>>(text) ?? [];
            }
            catch
            {
                throw new InvalidOperationException(
                    $"Failed to deserialize steps for session {sessionId}, data={text}");
            }
        }

        return [];
    }

    /// <inheritdoc/>
    public async Task SaveReActStepsAsync(string sessionId, string stepId, List<ReActStep> steps)
    {
        var json = JsonSerializer.Serialize(steps);
        await this._memoryStore.UpsertAsync(this._collectionName, this.CreateMemoryRecord(this.GetStepsStorageKey(sessionId, stepId), json))
            .ConfigureAwait(false);
    }

    private static async Task<FlowStatusProvider> InitializeProviderStoreAsync(FlowStatusProvider flowProvider, CancellationToken cancellationToken = default)
    {
        if (!await flowProvider._memoryStore.DoesCollectionExistAsync(flowProvider._collectionName, cancellationToken).ConfigureAwait(false))
        {
            await flowProvider._memoryStore.CreateCollectionAsync(flowProvider._collectionName, cancellationToken).ConfigureAwait(false);
        }

        return flowProvider;
    }

    private string GetStepsStorageKey(string sessionId, string stepId)
    {
        return $"Steps_{sessionId}_{stepId}";
    }

    private MemoryRecord CreateMemoryRecord(string key, string text)
    {
        return MemoryRecord.LocalRecord(key, text, null, ReadOnlyMemory<float>.Empty);
    }
}


===== Orchestration.Flow\Execution\ReActEngine.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.Json;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.SemanticKernel.ChatCompletion;
using Microsoft.SemanticKernel.Experimental.Orchestration.Extensions;

namespace Microsoft.SemanticKernel.Experimental.Orchestration.Execution;

/// <summary>
/// Chat ReAct Engine
/// </summary>
internal sealed class ReActEngine
{
    /// <summary>
    /// The logger
    /// </summary>
    private readonly ILogger _logger;

    /// <summary>
    /// Re-Act function for flow execution
    /// </summary>
    private readonly KernelFunction _reActFunction;

    /// <summary>
    /// The flow planner config
    /// </summary>
    private readonly FlowOrchestratorConfig _config;

    /// <summary>
    /// The goal to use when creating semantic functions that are restricted from flow creation
    /// </summary>
    private const string RestrictedPluginName = "ReActEngine_Excluded";

    /// <summary>
    /// The Action tag
    /// </summary>
    private const string Action = "[ACTION]";

    /// <summary>
    /// The Thought tag
    /// </summary>
    private const string Thought = "[THOUGHT]";

    /// <summary>
    /// The Observation tag
    /// </summary>
    private const string Observation = "[OBSERVATION]";

    /// <summary>
    /// The prefix used for the scratch pad
    /// </summary>
    private const string ScratchPadPrefix =
        "This was my previous work (but they haven't seen any of it! They only see what I return as final answer):";

    /// <summary>
    /// The regex for parsing the action response
    /// </summary>
    private static readonly Regex s_actionRegex =
        new(@"(?<=\[ACTION\])[^{}]*(\{.*?\})(?=\n\[)", RegexOptions.Singleline);

    /// <summary>
    /// The regex for parsing the final action response
    /// </summary>
    private static readonly Regex s_finalActionRegex =
        new(@"\[FINAL.+\][^{}]*({(?:[^{}]*{[^{}]*})*[^{}]*})", RegexOptions.Singleline);

    /// <summary>
    /// The regex for parsing the thought response
    /// </summary>
    private static readonly Regex s_thoughtRegex =
        new(@"(\[THOUGHT\])?(?<thought>.+?)(?=\[ACTION\]|$)", RegexOptions.Singleline);

    /// <summary>
    /// The regex for parsing the final answer response
    /// </summary>
    private static readonly Regex s_finalAnswerRegex =
        new(@"\[FINAL.+\](?<final_answer>.+)", RegexOptions.Singleline);

    internal ReActEngine(Kernel systemKernel, ILogger logger, FlowOrchestratorConfig config)
    {
        this._logger = logger;

        this._config = config;
        this._config.ExcludedPlugins.Add(RestrictedPluginName);

        var modelId = config.AIRequestSettings?.ModelId;
        var promptConfig = config.ReActPromptTemplateConfig;
        if (promptConfig is null)
        {
            string promptConfigString = EmbeddedResource.Read("Plugins.ReActEngine.yaml")!;
            if (!string.IsNullOrEmpty(modelId))
            {
                var modelConfigString = EmbeddedResource.Read($"Plugins.ReActEngine.{modelId}.yaml", false);
                promptConfigString = string.IsNullOrEmpty(modelConfigString) ? promptConfigString : modelConfigString!;
            }

            promptConfig = KernelFunctionYaml.ToPromptTemplateConfig(promptConfigString);

            if (!string.IsNullOrEmpty(modelId))
            {
                var modelConfigString = EmbeddedResource.Read($"Plugins.ReActEngine.{modelId}.yaml", false);
                promptConfigString = string.IsNullOrEmpty(modelConfigString) ? promptConfigString : modelConfigString!;
            }
        }

        this._reActFunction = systemKernel.CreateFunctionFromPrompt(promptConfig);
    }

    internal async Task<ReActStep?> GetNextStepAsync(Kernel kernel, KernelArguments arguments, string question, List<ReActStep> previousSteps)
    {
        arguments["question"] = question;
        var scratchPad = this.CreateScratchPad(previousSteps);
        arguments["agentScratchPad"] = scratchPad;

        var availableFunctions = this.GetAvailableFunctions(kernel).ToArray();
        if (availableFunctions.Length == 1)
        {
            var firstActionFunction = availableFunctions.First();
            if (firstActionFunction.Parameters.Count == 0)
            {
                var action = $"{firstActionFunction.PluginName}.{firstActionFunction.Name}";

                if (this._logger.IsEnabled(LogLevel.Debug))
                {
                    this._logger?.LogDebug("Auto selecting {Action} as it is the only function available and it has no parameters.", action);
                }

                return new ReActStep
                {
                    Action = action
                };
            }
        }

        var functionDesc = this.GetFunctionDescriptions(availableFunctions);
        arguments["functionDescriptions"] = functionDesc;

        if (this._logger.IsEnabled(LogLevel.Information))
        {
            this._logger?.LogInformation("question: {Question}", question);
            this._logger?.LogInformation("functionDescriptions: {FunctionDescriptions}", functionDesc);
            this._logger?.LogInformation("Scratchpad: {ScratchPad}", scratchPad);
        }

        var llmResponse = await this._reActFunction.InvokeAsync(kernel, arguments).ConfigureAwait(false);

        string llmResponseText = llmResponse.GetValue<string>()!.Trim();

        if (this._logger?.IsEnabled(LogLevel.Debug) ?? false)
        {
            this._logger?.LogDebug("Response : {ActionText}", llmResponseText);
        }

        var actionStep = this.ParseResult(llmResponseText);

        if (!string.IsNullOrEmpty(actionStep.Action) || previousSteps.Count == 0 || !string.IsNullOrEmpty(actionStep.FinalAnswer))
        {
            return actionStep;
        }

        actionStep.Thought = llmResponseText;
        actionStep.Observation = "Failed to parse valid action step, missing action or final answer.";
        this._logger?.LogWarning("Failed to parse valid action step from llm response={LLMResponseText}", llmResponseText);
        this._logger?.LogWarning("Scratchpad={ScratchPad}", scratchPad);
        return actionStep;
    }

    internal async Task<string> InvokeActionAsync(ReActStep actionStep, string chatInput, ChatHistory chatHistory, Kernel kernel, KernelArguments contextVariables)
    {
        var variables = actionStep.ActionVariables ?? [];

        variables[Constants.ActionVariableNames.ChatInput] = chatInput;
        variables[Constants.ActionVariableNames.ChatHistory] = ChatHistorySerializer.Serialize(chatHistory);

        if (this._logger.IsEnabled(LogLevel.Information))
        {
            this._logger?.LogInformation("Action: {Action}({ActionVariables})", actionStep.Action, JsonSerializer.Serialize(variables));
        }

        var availableFunctions = this.GetAvailableFunctions(kernel);
        var targetFunction = availableFunctions.FirstOrDefault(f => ToFullyQualifiedName(f) == actionStep.Action) ?? throw new MissingMethodException($"The function '{actionStep.Action}' was not found.");
        var function = kernel.Plugins.GetFunction(targetFunction.PluginName, targetFunction.Name);
        var functionView = function.Metadata;

        var actionContextVariables = this.CreateActionKernelArguments(variables, contextVariables);

        foreach (var parameter in functionView.Parameters)
        {
            if (!actionContextVariables.ContainsName(parameter.Name))
            {
                actionContextVariables[parameter.Name] = parameter.DefaultValue ?? string.Empty;
            }
        }

        try
        {
            var result = await function.InvokeAsync(kernel, actionContextVariables).ConfigureAwait(false);

            foreach (var variable in actionContextVariables)
            {
                contextVariables[variable.Key] = variable.Value;
            }

            if (this._logger?.IsEnabled(LogLevel.Debug) ?? false)
            {
                this._logger?.LogDebug("Invoked {FunctionName}. Result: {Result}", targetFunction.Name, result.GetValue<string>());
            }

            return result.GetValue<string>() ?? string.Empty;
        }
        catch (Exception e) when (!e.IsNonRetryable())
        {
            this._logger?.LogError(e, "Something went wrong in action step: {0}.{1}. Error: {2}", targetFunction.PluginName, targetFunction.Name, e.Message);
            return $"Something went wrong in action step: {targetFunction.PluginName}.{targetFunction.Name}. Error: {e.Message} {e.InnerException?.Message}";
        }
    }

    private KernelArguments CreateActionKernelArguments(Dictionary<string, string> actionVariables, KernelArguments context)
    {
        var actionContext = new KernelArguments(context);

        foreach (var kvp in actionVariables)
        {
            actionContext[kvp.Key] = kvp.Value;
        }

        return actionContext;
    }

    private string CreateScratchPad(List<ReActStep> stepsTaken)
    {
        if (stepsTaken.Count == 0)
        {
            return string.Empty;
        }

        var scratchPadLines = new List<string>
        {
            // Add the original first thought
            ScratchPadPrefix,
            $"{Thought} {stepsTaken[0].Thought}"
        };

        // Keep track of where to insert the next step
        var insertPoint = scratchPadLines.Count;

        // Keep the most recent steps in the scratch pad.
        for (var i = stepsTaken.Count - 1; i >= 0; i--)
        {
            if (scratchPadLines.Count / 4.0 > (this._config.MaxTokens * 0.75))
            {
                if (this._logger.IsEnabled(LogLevel.Debug))
                {
                    this._logger.LogDebug("Scratchpad is too long, truncating. Skipping {CountSkipped} steps.", i + 1);
                }

                break;
            }

            var s = stepsTaken[i];

            if (!string.IsNullOrEmpty(s.Observation))
            {
                scratchPadLines.Insert(insertPoint, $"{Observation} \n{s.Observation}");
            }

            if (!string.IsNullOrEmpty(s.Action))
            {
                // ignore the built-in context variables
                var variablesToPrint = s.ActionVariables?.Where(v => !Constants.ActionVariableNames.All.Contains(v.Key)).ToDictionary(_ => _.Key, _ => _.Value);
                scratchPadLines.Insert(insertPoint, $$"""{{Action}} {"action": "{{s.Action}}","action_variables": {{JsonSerializer.Serialize(variablesToPrint)}}}""");
            }

            if (i != 0)
            {
                scratchPadLines.Insert(insertPoint, $"{Thought} {s.Thought}");
            }
        }

        return string.Join("\n", scratchPadLines).Trim();
    }

    private ReActStep ParseResult(string input)
    {
        var result = new ReActStep
        {
            OriginalResponse = input
        };

        // Extract final answer
        Match finalAnswerMatch = s_finalAnswerRegex.Match(input);

        if (finalAnswerMatch.Success)
        {
            result.FinalAnswer = finalAnswerMatch.Groups[1].Value.Trim();
        }

        // Extract thought
        Match thoughtMatch = s_thoughtRegex.Match(input);

        if (thoughtMatch.Success)
        {
            result.Thought = thoughtMatch.Value.Trim();
        }
        else if (!input.Contains(Action))
        {
            result.Thought = input;
        }
        else
        {
            throw new InvalidOperationException("Unexpected input format");
        }

        result.Thought = result.Thought.Replace(Thought, string.Empty).Trim();

        // Extract action
        string actionStepJson = input;
        Match actionMatch = s_actionRegex.Match(input + "\n[");
        if (actionMatch.Success)
        {
            actionStepJson = actionMatch.Groups[1].Value.Trim();
        }
        else
        {
            Match finalActionMatch = s_finalActionRegex.Match(input);
            if (finalActionMatch.Success)
            {
                actionStepJson = finalActionMatch.Groups[1].Value.Trim();
            }
        }

        try
        {
            var reActStep = JsonSerializer.Deserialize<ReActStep>(actionStepJson);
            if (reActStep is null)
            {
                result.Observation = $"Action step parsing error, empty JSON: {actionStepJson}";
            }
            else
            {
                result.Action = reActStep.Action;
                result.ActionVariables = reActStep.ActionVariables;
            }
        }
        catch (JsonException)
        {
            result.Observation = $"Action step parsing error, invalid JSON: {actionStepJson}";
        }

        if (string.IsNullOrEmpty(result.Thought) && string.IsNullOrEmpty(result.Action))
        {
            result.Observation = "Action step error, no thought or action found. Please give a valid thought and/or action.";
        }

        return result;
    }

    private string GetFunctionDescriptions(KernelFunctionMetadata[] functions)
    {
        return string.Join("\n", functions.Select(ToManualString));
    }

    private IEnumerable<KernelFunctionMetadata> GetAvailableFunctions(Kernel kernel)
    {
        var functionViews = kernel.Plugins.GetFunctionsMetadata();

        var excludedPlugins = this._config.ExcludedPlugins ?? [];
        var excludedFunctions = this._config.ExcludedFunctions ?? [];

        var availableFunctions =
            functionViews
                .Where(s => !excludedPlugins.Contains(s.PluginName!) && !excludedFunctions.Contains(s.Name))
                .OrderBy(x => x.PluginName)
                .ThenBy(x => x.Name);

        return this._config.EnableAutoTermination
            ? availableFunctions.Append(GetStopAndPromptUserFunction())
            : availableFunctions;
    }

    private static KernelFunctionMetadata GetStopAndPromptUserFunction()
    {
        KernelParameterMetadata promptParameter = new(Constants.StopAndPromptParameterName)
        {
            Description = "The message to be shown to the user.",
            ParameterType = typeof(string),
            Schema = KernelJsonSchema.Parse("""{"type":"string"}"""),
        };

        return new KernelFunctionMetadata(Constants.StopAndPromptFunctionName)
        {
            PluginName = "_REACT_ENGINE_",
            Description = "Terminate the session, only used when previous attempts failed with FATAL error and need notify user",
            Parameters = [promptParameter]
        };
    }

    private static string ToManualString(KernelFunctionMetadata function)
    {
        var inputs = string.Join("\n", function.Parameters.Select(parameter =>
        {
            var defaultValueString = parameter.DefaultValue is not string value || string.IsNullOrEmpty(value) ? string.Empty : $"(default='{parameter.DefaultValue}')";
            return $"  - {parameter.Name}: {parameter.Description} {defaultValueString}";
        }));

        var functionDescription = function.Description.Trim();

        if (string.IsNullOrEmpty(inputs))
        {
            return $"{ToFullyQualifiedName(function)}: {functionDescription}\n";
        }

        return $"{ToFullyQualifiedName(function)}: {functionDescription}\n{inputs}\n";
    }

    private static string ToFullyQualifiedName(KernelFunctionMetadata function)
    {
        return $"{function.PluginName}.{function.Name}";
    }
}


===== Orchestration.Flow\Execution\ReActStep.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Text.Json.Serialization;

namespace Microsoft.SemanticKernel.Experimental.Orchestration.Execution;

/// <summary>
/// An ReAct (Reasoning-Action-Observation) step in flow execution.
/// </summary>
/// <remarks>
/// https://arxiv.org/pdf/2210.03629.pdf
/// </remarks>
public class ReActStep
{
    /// <summary>
    /// Gets or sets the step number.
    /// </summary>
    [JsonPropertyName("thought")]
    public string? Thought { get; set; }

    /// <summary>
    /// Gets or sets the action of the step
    /// </summary>
    [JsonPropertyName("action")]
    public string? Action { get; set; }

    /// <summary>
    /// Gets or sets the variables for the action
    /// </summary>
    [JsonPropertyName("action_variables")]
    public Dictionary<string, string>? ActionVariables { get; set; }

    /// <summary>
    /// Gets or sets the output of the action
    /// </summary>
    [JsonPropertyName("observation")]
    public string? Observation { get; set; }

    /// <summary>
    /// Gets or sets the output of the system
    /// </summary>
    [JsonPropertyName("final_answer")]
    public string? FinalAnswer { get; set; }

    /// <summary>
    /// The raw response from the action
    /// </summary>
    [JsonPropertyName("original_response")]
    public string? OriginalResponse { get; set; }
}


===== Orchestration.Flow\Extensions\ExceptionExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Net;

namespace Microsoft.SemanticKernel.Experimental.Orchestration.Extensions;

internal static class ExceptionExtensions
{
    internal static bool IsNonRetryable(this Exception ex)
    {
        bool isContentFilterException = ex is HttpOperationException
        {
            StatusCode: HttpStatusCode.BadRequest, InnerException: { }
        } hoe && hoe.InnerException?.Message.Contains("content_filter") is true;

        return isContentFilterException || ex.IsCriticalException();
    }
}


===== Orchestration.Flow\Extensions\FlowExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.SemanticKernel.Experimental.Orchestration.Abstractions;

namespace Microsoft.SemanticKernel.Experimental.Orchestration;

/// <summary>
/// Extension methods for <see cref="Flow"/>.
/// </summary>
public static class FlowExtensions
{
    internal static List<FlowStep> SortSteps(this Flow flow)
    {
        var sortedSteps = new List<FlowStep>();
        var remainingSteps = new List<FlowStep>(flow.Steps);

        while (remainingSteps.Count > 0)
        {
            var independentStep = remainingSteps.FirstOrDefault(step => !remainingSteps.Any(step.DependsOn)) ??
                throw new KernelException("The plan contains circular dependencies.");

            sortedSteps.Add(independentStep);
            remainingSteps.Remove(independentStep);
        }

        return sortedSteps;
    }

    /// <summary>
    /// Hydrate the reference steps in the flow.
    /// </summary>
    /// <param name="flow">the flow</param>
    /// <param name="flowRepository">the flow repository</param>
    /// <returns>The flow with hydrated steps</returns>
    /// <exception cref="ArgumentException">if referenced flow cannot be found in the repository</exception>
    public static async Task<Flow> BuildReferenceAsync(this Flow flow, IFlowCatalog flowRepository)
    {
        var referenceSteps = flow.Steps.OfType<ReferenceFlowStep>().ToList();

        foreach (var step in referenceSteps)
        {
            flow.Steps.Remove(step);
            var referencedFlow = await flowRepository.GetFlowAsync(step.FlowName).ConfigureAwait(false) ??
                throw new ArgumentException($"Referenced flow {step.FlowName} is not found");

            referencedFlow.CompletionType = step.CompletionType;
            referencedFlow.AddPassthrough(step.Passthrough.ToArray());
            referencedFlow.StartingMessage = step.StartingMessage;
            referencedFlow.TransitionMessage = step.TransitionMessage;

            foreach (var referencedFlowStep in referencedFlow.Steps)
            {
                referencedFlowStep.AddPassthrough(step.Passthrough.ToArray(), isReferencedFlow: true);
            }

            flow.Steps.Add(referencedFlow);
        }

        return flow;
    }
}


===== Orchestration.Flow\Extensions\FunctionResultExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Linq;
using Microsoft.SemanticKernel.ChatCompletion;
using Microsoft.SemanticKernel.Experimental.Orchestration.Execution;

namespace Microsoft.SemanticKernel.Experimental.Orchestration;

/// <summary>
/// Extension methods for <see cref="FunctionResult"/>
/// </summary>
// ReSharper disable once InconsistentNaming
public static class FunctionResultExtensions
{
    /// <summary>
    /// Check if we should prompt user for input based on function result.
    /// </summary>
    /// <param name="result">Function result.</param>
    internal static bool IsPromptInput(this FunctionResult result)
    {
        return result.Metadata!.TryGetValue(Constants.ChatPluginVariables.PromptInputName, out object? promptInput)
               && promptInput is Constants.ChatPluginVariables.DefaultValue;
    }

    /// <summary>
    /// Check if we should force the next iteration loop based on function result.
    /// </summary>
    /// <param name="result">Function result.</param>
    internal static bool IsContinueLoop(this FunctionResult result)
    {
        return result.Metadata!.TryGetValue(Constants.ChatPluginVariables.ContinueLoopName, out object? continueLoop)
               && continueLoop is Constants.ChatPluginVariables.DefaultValue;
    }

    /// <summary>
    /// Check if we should exit the loop based on function result.
    /// </summary>
    /// <param name="result">Function result.</param>
    /// <param name="response">The response to exit loop</param>
    internal static bool TryGetExitLoopResponse(this FunctionResult result, out string? response)
    {
        if (result.Metadata!.TryGetValue(Constants.ChatPluginVariables.ExitLoopName, out object? exitLoop)
            && exitLoop is string exitLoopResponse)
        {
            response = exitLoopResponse;
            return true;
        }

        response = null;
        return false;
    }

    /// <summary>
    /// Check if we should terminate flow based on function result.
    /// </summary>
    /// <param name="result">Function result.</param>
    public static bool IsTerminateFlow(this FunctionResult result)
    {
        return result.Metadata!.TryGetValue(Constants.ChatPluginVariables.StopFlowName, out object? stopFlow)
               && stopFlow is Constants.ChatPluginVariables.DefaultValue;
    }

    /// <summary>
    /// Check if all arguments to be provided with the flow is available in the context
    /// </summary>
    /// <param name="result">Function result.</param>
    /// <param name="flow">flow</param>
    /// <returns></returns>
    public static bool IsComplete(this FunctionResult result, Flow flow)
    {
        return flow.Provides.All(result.Metadata!.ContainsKey);
    }

    /// <summary>
    /// Get <see cref="ChatHistory"/> from context.
    /// </summary>
    /// <param name="result">Function result.</param>
    /// <returns>The chat history</returns>
    public static ChatHistory? GetChatHistory(this FunctionResult result)
    {
        if (result.Metadata!.TryGetValue(Constants.ActionVariableNames.ChatHistory, out object? chatHistory)
            && chatHistory is string chatHistoryText
            && !string.IsNullOrEmpty(chatHistoryText))
        {
            return ChatHistorySerializer.Deserialize(chatHistoryText!);
        }

        return null;
    }

    /// <summary>
    /// Get latest chat input from context.
    /// </summary>
    /// <param name="result">Function result.</param>
    /// <returns>The latest chat input.</returns>
    public static string GetChatInput(this FunctionResult result)
    {
        if (result.Metadata!.TryGetValue(Constants.ActionVariableNames.ChatInput, out object? chatInput)
            && chatInput is string chatInputString)
        {
            return chatInputString;
        }

        return string.Empty;
    }
}


===== Orchestration.Flow\Extensions\KernelArgumentsExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Linq;
using Microsoft.SemanticKernel.ChatCompletion;
using Microsoft.SemanticKernel.Experimental.Orchestration.Execution;

namespace Microsoft.SemanticKernel.Experimental.Orchestration;

/// <summary>
/// Extension methods for <see cref="KernelArguments"/>
/// </summary>
// ReSharper disable once InconsistentNaming
public static class KernelArgumentsExtensions
{
    /// <summary>
    /// Check if we should prompt user for input based on current context.
    /// </summary>
    /// <param name="variables">Context arguments.</param>
    internal static bool IsPromptInput(this KernelArguments variables)
    {
        return variables.TryGetValue(Constants.ChatPluginVariables.PromptInputName, out object? promptInput)
               && promptInput is Constants.ChatPluginVariables.DefaultValue;
    }

    /// <summary>
    /// Check if we should force the next iteration loop based on current context.
    /// </summary>
    /// <param name="arguments">Context arguments.</param>
    internal static bool IsContinueLoop(this KernelArguments arguments)
    {
        return arguments.TryGetValue(Constants.ChatPluginVariables.ContinueLoopName, out object? continueLoop)
               && continueLoop is Constants.ChatPluginVariables.DefaultValue;
    }

    /// <summary>
    /// Check if we should terminate flow based on current context.
    /// </summary>
    /// <param name="arguments">Context arguments.</param>
    public static bool IsTerminateFlow(this KernelArguments arguments)
    {
        return arguments.TryGetValue(Constants.ChatPluginVariables.StopFlowName, out object? stopFlow)
               && stopFlow is Constants.ChatPluginVariables.DefaultValue;
    }

    /// <summary>
    /// Check if all arguments to be provided with the flow is available in the context
    /// </summary>
    /// <param name="arguments">Context arguments.</param>
    /// <param name="flow">flow</param>
    /// <returns></returns>
    public static bool IsComplete(this KernelArguments arguments, Flow flow)
    {
        return flow.Provides.All(arguments.ContainsName);
    }

    /// <summary>
    /// Get <see cref="ChatHistory"/> from context.
    /// </summary>
    /// <param name="arguments">Context arguments.</param>
    /// <returns>The chat history</returns>
    public static ChatHistory? GetChatHistory(this KernelArguments arguments)
    {
        if (arguments.TryGetValue(Constants.ActionVariableNames.ChatHistory, out object? chatHistory)
            && chatHistory is string chatHistoryText
            && !string.IsNullOrEmpty(chatHistoryText))
        {
            return ChatHistorySerializer.Deserialize(chatHistoryText!);
        }

        return null;
    }

    /// <summary>
    /// Get latest chat input from context.
    /// </summary>
    /// <param name="arguments">Context arguments.</param>
    /// <returns>The latest chat input.</returns>
    public static string GetChatInput(this KernelArguments arguments)
    {
        if (arguments.TryGetValue(Constants.ActionVariableNames.ChatInput, out object? chatInput)
            && chatInput is string chatInputString)
        {
            return chatInputString;
        }

        return string.Empty;
    }

    /// <summary>
    /// Signal the orchestrator to prompt user for input with current function response.
    /// </summary>
    /// <param name="arguments">Context arguments.</param>
    public static void PromptInput(this KernelArguments arguments)
    {
        // Cant prompt the user for input and exit the execution at the same time
        if (!arguments.ContainsName(Constants.ChatPluginVariables.ExitLoopName))
        {
            arguments[Constants.ChatPluginVariables.PromptInputName] = Constants.ChatPluginVariables.DefaultValue;
        }
    }

    /// <summary>
    /// Signal the orchestrator to exit out of the AtLeastOnce or ZeroOrMore loop. If response is non-null, that value will be outputted to the user.
    /// </summary>
    /// <param name="arguments">Context arguments.</param>
    /// <param name="response">context</param>
    public static void ExitLoop(this KernelArguments arguments, string? response = null)
    {
        // Cant prompt the user for input and exit the execution at the same time
        if (!arguments.ContainsName(Constants.ChatPluginVariables.PromptInputName))
        {
            arguments[Constants.ChatPluginVariables.ExitLoopName] = response ?? string.Empty;
        }
    }

    /// <summary>
    /// Signal the orchestrator to go to the next iteration of the loop in the AtLeastOnce or ZeroOrMore step.
    /// </summary>
    /// <param name="arguments">Context arguments.</param>
    public static void ContinueLoop(this KernelArguments arguments)
    {
        arguments[Constants.ChatPluginVariables.ContinueLoopName] = Constants.ChatPluginVariables.DefaultValue;
    }

    /// <summary>
    /// Signal the orchestrator to terminate the flow.
    /// </summary>
    /// <param name="arguments">context</param>
    public static void TerminateFlow(this KernelArguments arguments)
    {
        arguments[Constants.ChatPluginVariables.StopFlowName] = Constants.ChatPluginVariables.DefaultValue;
    }
}


===== Orchestration.Flow\Extensions\PromptTemplateConfigExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

namespace Microsoft.SemanticKernel.Experimental.Orchestration;

/// <summary>
/// Extension methods for PromptTemplateConfig
/// </summary>
internal static class PromptTemplateConfigExtensions
{
    /// <summary>
    /// Set the max_tokens request setting to be used by OpenAI models
    /// </summary>
    /// <param name="config">PromptTemplateConfig instance</param>
    /// <param name="maxTokens">Value of max tokens to set</param>
    internal static void SetMaxTokens(this PromptTemplateConfig config, int maxTokens)
    {
        var executionSettings = config.ExecutionSettings;
        foreach (var setting in executionSettings)
        {
            if (setting.Value.ExtensionData is not null)
            {
                setting.Value.ExtensionData["max_tokens"] = maxTokens;
            }
        }
    }
}


===== Orchestration.Flow\FlowOrchestrator.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Threading.Tasks;
using Microsoft.SemanticKernel.Experimental.Orchestration.Abstractions;
using Microsoft.SemanticKernel.Experimental.Orchestration.Execution;

namespace Microsoft.SemanticKernel.Experimental.Orchestration;

/// <summary>
/// A flow orchestrator that using semantic kernel for execution.
/// </summary>
public class FlowOrchestrator
{
    private readonly IKernelBuilder _kernelBuilder;

    private readonly IFlowStatusProvider _flowStatusProvider;

    private readonly Dictionary<object, string?> _globalPluginCollection;

    private readonly IFlowValidator _flowValidator;

    private readonly FlowOrchestratorConfig? _config;

    /// <summary>
    /// Initialize a new instance of the <see cref="FlowOrchestrator"/> class.
    /// </summary>
    /// <param name="kernelBuilder">The semantic kernel builder.</param>
    /// <param name="flowStatusProvider">The flow status provider.</param>
    /// <param name="globalPluginCollection">The global plugin collection</param>
    /// <param name="validator">The flow validator.</param>
    /// <param name="config">Optional configuration object</param>
    public FlowOrchestrator(
        IKernelBuilder kernelBuilder,
        IFlowStatusProvider flowStatusProvider,
        Dictionary<object, string?>? globalPluginCollection = null,
        IFlowValidator? validator = null,
        FlowOrchestratorConfig? config = null)
    {
        Verify.NotNull(kernelBuilder);

        this._kernelBuilder = kernelBuilder;
        this._flowStatusProvider = flowStatusProvider;
        this._globalPluginCollection = globalPluginCollection ?? [];
        this._flowValidator = validator ?? new FlowValidator();
        this._config = config;
    }

    /// <summary>
    /// Execute a given flow.
    /// </summary>
    /// <param name="flow">goal to achieve</param>
    /// <param name="sessionId">execution session id</param>
    /// <param name="input">current input</param>
    /// <param name="kernelArguments">execution kernel arguments</param>
    /// <returns>KernelArguments, which includes a json array of strings as output. The flow result is also exposed through the context when completes.</returns>
    public async Task<FunctionResult> ExecuteFlowAsync(
        [Description("The flow to execute")] Flow flow,
        [Description("Execution session id")] string sessionId,
        [Description("Current input")] string input,
        [Description("Execution arguments")]
        KernelArguments? kernelArguments = null)
    {
        try
        {
            this._flowValidator.Validate(flow);
        }
        catch (Exception ex)
        {
            throw new KernelException("Invalid flow", ex);
        }

        var executor = new FlowExecutor(this._kernelBuilder, this._flowStatusProvider, this._globalPluginCollection, this._config);
        return await executor.ExecuteFlowAsync(flow, sessionId, input, kernelArguments ?? new KernelArguments()).ConfigureAwait(false);
    }
}


===== Orchestration.Flow\FlowOrchestratorConfig.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using Microsoft.SemanticKernel.Experimental.Orchestration.Execution;

namespace Microsoft.SemanticKernel.Experimental.Orchestration;

/// <summary>
/// Configuration for flow planner instances.
/// </summary>
public sealed class FlowOrchestratorConfig
{
    /// <summary>
    /// A list of plugins to exclude from the plan creation request.
    /// </summary>
    public HashSet<string> ExcludedPlugins { get; } = [];

    /// <summary>
    /// A list of functions to exclude from the plan creation request.
    /// </summary>
    public HashSet<string> ExcludedFunctions { get; } = [];

    /// <summary>
    /// The maximum number of tokens to allow in a plan.
    /// </summary>
    public int MaxTokens { get; set; } = 1024;

    /// <summary>
    /// The maximum length of a string variable.
    /// </summary>
    /// <remarks>
    /// In most cases, the required variables are passed to ReAct engine to infer the next plugin and parameters to execute.
    /// However when the variable is too long, it will either be truncated or decrease the robustness of value passing.
    /// To mitigate that, the <see cref="ReActEngine"/> will avoid rendering the variables exceeding MaxVariableLength in the prompt.
    /// And the variables should be accessed implicitly from ContextVariables instead of function parameters by the plugins.
    /// </remarks>
    public int MaxVariableLength { get; set; } = 400;

    /// <summary>
    /// The maximum number of iterations to allow for a step.
    /// </summary>
    public int MaxStepIterations { get; set; } = 10;

    /// <summary>
    /// The minimum time to wait between iterations in milliseconds.
    /// </summary>
    public int MinIterationTimeMs { get; set; } = 0;

    /// <summary>
    /// Optional. The prompt template configuration override for the ReAct engine.
    /// </summary>
    public PromptTemplateConfig? ReActPromptTemplateConfig { get; set; } = null;

    /// <summary>
    /// When this is enabled, the flow will be terminated automatically if ReAct engine has exhausted available plugins.
    /// </summary>
    public bool EnableAutoTermination { get; set; } = false;

    /// <summary>
    /// Optional. The allowed AI service id for the React engine.
    /// </summary>
    public HashSet<string> AIServiceIds { get; set; } = [];

    /// <summary>
    /// Optional. The AI request settings for the ReAct engine.
    /// </summary>
    /// <remarks>
    /// Prompt used for reasoning may be different for different models, the prompt selection would be based on the PromptExecutionSettings.
    /// if the built in prompt template does not work for your model, suggest to override it with <see cref="ReActPromptTemplateConfig"/>.
    /// </remarks>
    public PromptExecutionSettings? AIRequestSettings { get; set; } = null;
}


===== Orchestration.Flow\FlowSerializer.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.IO;
using System.Text.Json;
using System.Text.Json.Serialization;
using YamlDotNet.Serialization;
using YamlDotNet.Serialization.NamingConventions;

namespace Microsoft.SemanticKernel.Experimental.Orchestration;

/// <summary>
/// Serializer for <see cref="Flow"/>
/// </summary>
public static class FlowSerializer
{
    /// <summary>Options for <see cref="DeserializeFromJson"/>.</summary>
    private static readonly JsonSerializerOptions s_deserializeOptions = new()
    {
        PropertyNameCaseInsensitive = true,
        Converters = { new JsonStringEnumConverter(JsonNamingPolicy.CamelCase) }
    };

    /// <summary>
    /// Deserialize flow from yaml
    /// </summary>
    /// <param name="yaml">the yaml string</param>
    /// <returns>the <see cref="Flow"/> instance</returns>
    public static Flow DeserializeFromYaml(string yaml)
    {
        var deserializer = new DeserializerBuilder()
            .WithNamingConvention(CamelCaseNamingConvention.Instance)
            .Build();

        var flow = deserializer.Deserialize<FlowModel>(new StringReader(yaml));

        return UpCast(flow);
    }

    /// <summary>
    /// Deserialize flow from json
    /// </summary>
    /// <param name="json">the json string</param>
    /// <returns>the <see cref="Flow"/> instance</returns>
    public static Flow? DeserializeFromJson(string json)
    {
        var flow = JsonSerializer.Deserialize<FlowModel>(json, s_deserializeOptions) ??
            throw new JsonException("Failed to deserialize flow");

        return UpCast(flow);
    }

    private static Flow UpCast(FlowModel flow)
    {
        Flow result = new(flow.Name, flow.Goal);

        foreach (var step in flow.Steps)
        {
            result.AddStep(UpCast(step));
        }

        PopulateVariables(result, flow);

        return result;
    }

    private static FlowStep UpCast(FlowStepModel step)
    {
        FlowStep result = string.IsNullOrEmpty(step.FlowName) ? new FlowStep(step.Goal) : new ReferenceFlowStep(step.FlowName!);

        result.CompletionType = step.CompletionType;
        result.StartingMessage = step.StartingMessage;
        result.TransitionMessage = step.TransitionMessage;
        result.Plugins = step.Plugins;

        PopulateVariables(result, step);

        return result;
    }

    private static void PopulateVariables(FlowStep step, FlowStepModel model)
    {
        step.AddProvides(model.Provides.ToArray());
        step.AddRequires(model.Requires.ToArray());
        step.AddPassthrough(model.Passthrough.ToArray());
    }

    private class FlowStepModel
    {
        public string Goal { get; set; } = string.Empty;

        public List<string> Requires { get; set; } = [];

        public List<string> Provides { get; set; } = [];

        public List<string> Passthrough { get; set; } = [];

        public CompletionType CompletionType { get; set; } = CompletionType.Once;

        public string? StartingMessage { get; set; }

        public string? TransitionMessage { get; set; }

        public List<string> Plugins { get; set; } = [];

        public string? FlowName { get; set; }
    }

    private sealed class FlowModel : FlowStepModel
    {
        public string Name { get; set; } = string.Empty;

        public List<FlowStepModel> Steps { get; set; } = [];
    }
}


===== Orchestration.Flow\FlowValidator.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Linq;
using Microsoft.SemanticKernel.Experimental.Orchestration.Abstractions;

namespace Microsoft.SemanticKernel.Experimental.Orchestration;

/// <summary>
/// The flow validator
/// </summary>
public class FlowValidator : IFlowValidator
{
    /// <inheritdoc/>
    public void Validate(Flow flow)
    {
        Verify.NotNullOrWhiteSpace(flow.Goal, nameof(flow.Goal));

        this.ValidateNonEmpty(flow);
        this.ValidatePartialOrder(flow);
        this.ValidateReferenceStep(flow);
        this.ValidateStartingMessage(flow);
        this.ValidatePassthroughVariables(flow);
    }

    private void ValidateStartingMessage(Flow flow)
    {
        foreach (var step in flow.Steps)
        {
            if (step.CompletionType is CompletionType.Optional or CompletionType.ZeroOrMore
                && string.IsNullOrEmpty(step.StartingMessage))
            {
                throw new ArgumentException(
                    $"Missing starting message for step={step.Goal} with completion type={step.CompletionType}");
            }
        }
    }

    private void ValidateNonEmpty(Flow flow)
    {
        if (flow.Steps.Count == 0)
        {
            throw new ArgumentException("Flow must contain at least one flow step.");
        }
    }

    private void ValidatePartialOrder(Flow flow)
    {
        try
        {
            var sorted = flow.SortSteps();
        }
        catch (Exception ex)
        {
            throw new ArgumentException("Flow steps must be a partial order set.", ex);
        }
    }

    private void ValidateReferenceStep(Flow flow)
    {
        var steps = flow.Steps
            .Select(step => step as ReferenceFlowStep)
            .Where(step => step is not null);

        foreach (var step in steps)
        {
            Verify.NotNullOrWhiteSpace(step!.FlowName);

            if (step.Requires.Any())
            {
                throw new ArgumentException("Reference flow step cannot have any direct requirements.");
            }

            if (step.Provides.Any())
            {
                throw new ArgumentException("Reference flow step cannot have any direct provides.");
            }

            if (step.Plugins?.Count != 0)
            {
                throw new ArgumentException("Reference flow step cannot have any direct plugins.");
            }
        }
    }

    private void ValidatePassthroughVariables(Flow flow)
    {
        foreach (var step in flow.Steps)
        {
            if (step.CompletionType != CompletionType.AtLeastOnce
                && step.CompletionType != CompletionType.ZeroOrMore
                && step.Passthrough.Any())
            {
                throw new ArgumentException(
                    $"step={step.Goal} with completion type={step.CompletionType} cannot have passthrough variables as that is only applicable for the AtLeastOnce or ZeroOrMore completion types");
            }
        }
    }
}


===== Orchestration.Flow\Model\CompletionType.cs =====

// Copyright (c) Microsoft. All rights reserved.

namespace Microsoft.SemanticKernel.Experimental.Orchestration;

/// <summary>
/// The completion type of step
/// </summary>
public enum CompletionType
{
    /// <summary>
    /// Once
    /// </summary>
    Once,

    /// <summary>
    /// Optional
    /// </summary>
    Optional,

    /// <summary>
    /// At least once
    /// </summary>
    AtLeastOnce,

    /// <summary>
    /// Optional or multiple times
    /// </summary>
    ZeroOrMore,
}


===== Orchestration.Flow\Model\Flow.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Linq;

namespace Microsoft.SemanticKernel.Experimental.Orchestration;

/// <summary>
/// Flow data model
/// </summary>
/// <remarks>
/// Principles:
/// 1. The model should be decoupled from execution status
/// 2. The model is mutable to allow dynamic changes
/// 3. The model doesn't enforce any execution order as long as the dependencies are satisfied
/// </remarks>
public sealed class Flow : FlowStep
{
    /// <summary>
    /// Initializes a new instance of the <see cref="Flow"/> class.
    /// </summary>
    /// <param name="name">The name of flow</param>
    /// <param name="goal">The goal of flow</param>
    public Flow(string name, string goal) : base(goal, null)
    {
        this.Name = name;
        this.Steps = [];
    }

    /// <summary>
    /// Steps of the flow
    /// </summary>
    public List<FlowStep> Steps { get; set; }

    /// <summary>
    /// Friendly name and identifier of the flow
    /// </summary>
    public string Name { get; set; }

    /// <summary>
    /// Adds a step to the flow
    /// </summary>
    /// <param name="step">the <see cref="FlowStep"/> instance</param>
    public void AddStep(FlowStep step)
    {
        this.Steps.Add(step);
    }

    /// <summary>
    /// Adds steps to the flow
    /// </summary>
    /// <param name="steps">the array of <see cref="FlowStep"/> instance to be add</param>
    public void AddSteps(params FlowStep[] steps)
    {
        this.Steps.AddRange(steps);
    }

    /// <inheritdoc/>
    public override IEnumerable<string> Requires
    {
        get
        {
            var requires = new List<string>();
            foreach (var step in this.Steps)
            {
                requires.AddRange(step.Requires);
            }

            foreach (var step in this.Steps)
            {
                requires.RemoveAll(r => step.Provides.Contains(r));
            }

            return requires;
        }
    }
}


===== Orchestration.Flow\Model\FlowStep.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using Microsoft.SemanticKernel.Experimental.Orchestration.Execution;

namespace Microsoft.SemanticKernel.Experimental.Orchestration;

/// <summary>
/// Step within a <see cref="Flow"/> which defines the step goal, available plugins, required and provided variables.
/// </summary>
public class FlowStep
{
    private readonly List<string> _requires = [];

    private readonly List<string> _provides = [];

    private readonly List<string> _passthrough = [];

    private Dictionary<string, Type?> _pluginTypes = [];

    private Func<Kernel, Dictionary<object, string?>, IEnumerable<object>>? _pluginsFactory;

    /// <summary>
    /// Initializes a new instance of the <see cref="FlowStep"/> class.
    /// </summary>
    /// <param name="goal">The goal of step</param>
    /// <param name="pluginsFactory">The factory to get plugins</param>
    public FlowStep(string goal, Func<Kernel, Dictionary<object, string?>, IEnumerable<object>>? pluginsFactory = null)
    {
        this.Goal = goal;
        this._pluginsFactory = pluginsFactory;
    }

    /// <summary>
    /// Goal of the step
    /// </summary>
    public string Goal { get; set; }

    /// <summary>
    /// <see cref="CompletionType"/> of the step
    /// </summary>
    public CompletionType CompletionType { get; set; } = CompletionType.Once;

    /// <summary>
    /// If the CompletionType is CompletionType.ZeroOrMore, this message will be used to ask the user if they want to execute the current step or skip it.
    /// </summary>
    public string? StartingMessage { get; set; }

    /// <summary>
    /// If the CompletionType is CompletionType.AtLeastOnce or CompletionType.ZeroOrMore, this message will be used to ask the user if they want to try the step again.
    /// </summary>
    public string? TransitionMessage { get; set; } = "Did you want to try the previous step again?";

    /// <summary>
    /// Parameters required for executing the step
    /// </summary>
    public virtual IEnumerable<string> Requires => this._requires;

    /// <summary>
    /// Variables to be provided by the step
    /// </summary>
    public IEnumerable<string> Provides => this._provides;

    /// <summary>
    /// Variables to be passed through on iterations of the step
    /// </summary>
    public IEnumerable<string> Passthrough => this._passthrough;

    /// <summary>
    /// Gets or sets the plugin available for the current step
    /// </summary>
    public List<string>? Plugins
    {
        get => this._pluginTypes.Keys.ToList();
        set
        {
            Dictionary<string, Type?> plugins = GetPluginTypes(value);

            this._pluginTypes = plugins;
            this._pluginsFactory = (kernel, globalPlugins) => this.GetPlugins(globalPlugins, kernel);
        }
    }

    private List<object> GetPlugins(Dictionary<object, string?> globalPlugins, Kernel kernel)
    {
        return this._pluginTypes.Select(kvp =>
        {
            var pluginName = kvp.Key;
            var globalPlugin = globalPlugins.FirstOrDefault(_ => _.Key.GetType().Name.Contains(pluginName)).Key;
            if (globalPlugin is not null)
            {
                return globalPlugin;
            }

            var type = kvp.Value;
            if (type is not null)
            {
                try
                {
                    return Activator.CreateInstance(type, BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance, null, [kernel], null);
                }
                catch (MissingMethodException)
                {
                    try
                    {
                        return Activator.CreateInstance(type, true);
                    }
                    catch (MissingMethodException)
                    {
                    }
                }
            }

            return null;
        }).Where(plugin => plugin is not null).ToList()!;
    }

    private static Dictionary<string, Type?> GetPluginTypes(List<string>? value)
    {
        Dictionary<string, Type?> plugins = [];

        if (value is not null)
        {
            var types = AppDomain.CurrentDomain.GetAssemblies()
                .Where(a => !a.IsDynamic)
                .SelectMany(a => a.GetTypes())
                .ToList();

            foreach (var pluginName in value)
            {
                if (pluginName is null)
                {
                    continue;
                }

                var type = types.FirstOrDefault(predicate: t => t.FullName?.Equals(pluginName, StringComparison.OrdinalIgnoreCase) ?? false);
                if (type is null)
                {
                    type = types.FirstOrDefault(t => t.FullName?.Contains(pluginName) ?? false);

                    if (type is null)
                    {
                        // If not found, assume the plugin would be loaded separately.
                        plugins.Add(pluginName, null);
                        continue;
                    }
                }

                plugins.Add(pluginName, type);
            }
        }

        return plugins;
    }

    /// <summary>
    /// Register the required arguments for the step
    /// </summary>
    /// <param name="requiredArguments">Array of required arguments</param>
    public void AddRequires(params string[] requiredArguments)
    {
        this.ValidateArguments(requiredArguments);
        this._requires.AddRange(requiredArguments);
    }

    /// <summary>
    /// Register the arguments provided by the step
    /// </summary>
    /// <param name="providedArguments">Array of provided arguments</param>
    public void AddProvides(params string[] providedArguments)
    {
        this.ValidateArguments(providedArguments);
        this._provides.AddRange(providedArguments);
    }

    /// <summary>
    /// Register the arguments passed through by the step
    /// </summary>
    /// <param name="passthroughArguments">Array of passthrough arguments</param>
    /// <param name="isReferencedFlow">Is referenced flow</param>
    public void AddPassthrough(string[] passthroughArguments, bool isReferencedFlow = false)
    {
        // A referenced flow is allowed to have steps that have passthrough arguments even if the completion type is not AtLeastOnce or ZeroOrMore. This is so the step can pass arguments to the outer flow.
        if (!isReferencedFlow
            && passthroughArguments.Length != 0
            && this.CompletionType != CompletionType.AtLeastOnce
            && this.CompletionType != CompletionType.ZeroOrMore)
        {
            throw new ArgumentException("Passthrough arguments can only be set for the AtLeastOnce or ZeroOrMore completion type");
        }

        this.ValidateArguments(passthroughArguments);
        this._passthrough.AddRange(passthroughArguments);
    }

    /// <summary>
    /// Get the plugin instances registered with the step
    /// </summary>
    /// <param name="kernel">The semantic kernel</param>
    /// <param name="globalPlugins">The global plugins available</param>
    /// <returns></returns>
    public IEnumerable<object> LoadPlugins(Kernel kernel, Dictionary<object, string?> globalPlugins)
    {
        if (this._pluginsFactory is not null)
        {
            return this._pluginsFactory(kernel, globalPlugins);
        }

        return [];
    }

    /// <summary>
    /// Check if the step depends on another step
    /// </summary>
    /// <param name="otherStep">The other step</param>
    /// <returns>true if the step depends on the other step, false otherwise</returns>
    public bool DependsOn(FlowStep otherStep)
    {
        return this.Requires.Intersect(otherStep.Provides).Any();
    }

    private void ValidateArguments(string[] arguments)
    {
        var invalidArguments = arguments.Intersect(Constants.ActionVariableNames.All).ToArray();

        if (invalidArguments.Length != 0)
        {
            throw new ArgumentException($"Invalid arguments: {string.Join(",", invalidArguments)}");
        }
    }
}


===== Orchestration.Flow\Model\ReferenceFlowStep.cs =====

// Copyright (c) Microsoft. All rights reserved.

namespace Microsoft.SemanticKernel.Experimental.Orchestration;

/// <summary>
/// The flow step which references another flow.
/// </summary>
public sealed class ReferenceFlowStep : FlowStep
{
    /// <summary>
    /// Initializes a new instance of the <see cref="Flow"/> class.
    /// </summary>
    /// <param name="flowName">The name of referenced flow</param>
    public ReferenceFlowStep(string flowName) : base(string.Empty)
    {
        this.FlowName = flowName;
    }

    /// <summary>
    /// Only for deserialization.
    /// </summary>
    public ReferenceFlowStep() : this(string.Empty)
    {
    }

    /// <summary>
    /// Name of reference <see cref="Flow"/>.
    /// </summary>
    public string FlowName { get; set; }
}


===== Process.Abstractions\AssemblyInfo.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Diagnostics.CodeAnalysis;

// This assembly is currently experimental.
[assembly: Experimental("SKEXP0080")]


===== Process.Abstractions\IKernelExternalProcessMessageChannel.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Threading.Tasks;

namespace Microsoft.SemanticKernel;

/// <summary>
/// An interface that provides a channel for emitting external messages from a step.
/// In addition provide common methods like initialization and Uninitialization
/// </summary>
public interface IExternalKernelProcessMessageChannel
{
    /// <summary>
    /// Initialization of the external messaging channel used
    /// </summary>
    /// <returns>A <see cref="ValueTask"/></returns>
    abstract ValueTask Initialize();

    /// <summary>
    /// Uninitialization of the external messaging channel used
    /// </summary>
    /// <returns>A <see cref="ValueTask"/></returns>
    abstract ValueTask Uninitialize();

    /// <summary>
    /// Emits the specified event from the step outside the SK process
    /// </summary>
    /// <param name="externalTopicEvent">name of the topic to be used externally as the event name</param>
    /// <param name="message">data to be transmitted externally</param>
    /// <returns></returns>
    abstract Task EmitExternalEventAsync(string externalTopicEvent, KernelProcessProxyMessage message);
}


===== Process.Abstractions\IKernelProcessMessageChannel.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Threading.Tasks;

namespace Microsoft.SemanticKernel;

/// <summary>
/// An interface that provides a channel for emitting messages from a step.
/// </summary>
public interface IKernelProcessMessageChannel
{
    /// <summary>
    /// Emits the specified event from the step.
    /// </summary>
    /// <param name="processEvent">The event to emit.</param>
    /// <returns>A <see cref="ValueTask"/></returns>
    abstract ValueTask EmitEventAsync(KernelProcessEvent processEvent);
}


===== Process.Abstractions\Internal\KernelProcessStepMetadataFactory.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Linq;
using System.Reflection;

namespace Microsoft.SemanticKernel.Process.Internal;
/// <summary>
/// Factory that help extract <see cref="KernelProcessStepMetadataAttribute"/>
/// </summary>
public static class KernelProcessStepMetadataFactory
{
    /// <summary>
    /// Extracts <see cref="KernelProcessStepMetadataAttribute"/> from annotations on a <see cref="KernelProcessStep"/> based class.
    /// </summary>
    /// <param name="stepType">specific step type</param>
    /// <returns><see cref="KernelProcessStepMetadataAttribute"/></returns>
    public static KernelProcessStepMetadataAttribute ExtractProcessStepMetadataFromType(Type stepType)
    {
        var attributes = stepType.GetCustomAttributes<KernelProcessStepMetadataAttribute>();
        return attributes?.FirstOrDefault() ?? new KernelProcessStepMetadataAttribute();
    }
}


===== Process.Abstractions\KernelProcess.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using Microsoft.SemanticKernel.Process.Internal;
using Microsoft.SemanticKernel.Process.Models;

namespace Microsoft.SemanticKernel;

/// <summary>
/// A serializable representation of a Process.
/// </summary>
public sealed record KernelProcess : KernelProcessStepInfo
{
    /// <summary>
    /// The collection of Steps in the Process.
    /// </summary>
    public IList<KernelProcessStepInfo> Steps { get; }

    /// <summary>
    /// The collection of Threads in the Process.
    /// </summary>
    public IReadOnlyDictionary<string, KernelProcessAgentThread> Threads { get; init; } = new Dictionary<string, KernelProcessAgentThread>();

    /// <summary>
    /// The type of the user state. This is used to identify the underlying state type.
    /// </summary>
    public Type? UserStateType { get; init; } = null;

    /// <summary>
    /// Captures Kernel Process State into <see cref="KernelProcessStateMetadata"/> after process has run
    /// </summary>
    /// <returns><see cref="KernelProcessStateMetadata"/></returns>
    public KernelProcessStateMetadata ToProcessStateMetadata()
    {
        return ProcessStateMetadataFactory.KernelProcessToProcessStateMetadata(this);
    }

    /// <summary>
    /// Creates a new instance of the <see cref="KernelProcess"/> class.
    /// </summary>
    /// <param name="state">The process state.</param>
    /// <param name="steps">The steps of the process.</param>
    /// <param name="edges">The edges of the process.</param>
    /// <param name="threads">The threads associated with the process.</param>
    public KernelProcess(KernelProcessState state, IList<KernelProcessStepInfo> steps, Dictionary<string, List<KernelProcessEdge>>? edges = null, IReadOnlyDictionary<string, KernelProcessAgentThread>? threads = null)
        : base(typeof(KernelProcess), state, edges ?? [])
    {
        Verify.NotNull(steps);
        Verify.NotNullOrWhiteSpace(state.Name);

        this.Steps = [.. steps];
    }
}


===== Process.Abstractions\KernelProcessAgentExecutor.cs =====

// Copyright (c) Microsoft. All rights reserved.

namespace Microsoft.SemanticKernel;

/// <summary>
/// Represents a step in a process that executes an agent.
/// </summary>
public class KernelProcessAgentExecutor : KernelProcessStep
{
    /// <summary>
    /// SK Function names in this SK Step as entry points
    /// </summary>
    public static class ProcessFunctions
    {
        /// <summary>
        /// Function name used to emit events externally
        /// </summary>
        public const string Invoke = nameof(Invoke);
    }

    /// <summary>
    /// Invokes the agent with the provided definition.
    /// </summary>
    [KernelFunction]
    public void Invoke()
    {
    }
}


===== Process.Abstractions\KernelProcessAgentStep.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Microsoft.SemanticKernel.Agents;

namespace Microsoft.SemanticKernel;

/// <summary>
/// Delegate that represents a condition that must be met for a <see cref="KernelProcessEdge"/> to be activated.
/// </summary>
/// <param name="processState">The readonly process state.</param>
/// <returns></returns>
public delegate Task<T> KernelProcessStateResolver<T>(object? processState);

/// <summary>
/// Represents a step in a process that is an agent.
/// </summary>
public record KernelProcessAgentStep : KernelProcessStepInfo
{
    /// <summary>
    /// Initializes a new instance of the <see cref="KernelProcessAgentStep"/> class.
    /// </summary>
    /// <param name="agentDefinition"></param>
    /// <param name="agentActions"></param>
    /// <param name="state"></param>
    /// <param name="edges"></param>
    /// <param name="threadName"></param>
    /// <param name="inputs"></param>
    /// <param name="incomingEdgeGroups"></param>
    public KernelProcessAgentStep(AgentDefinition agentDefinition, ProcessAgentActions agentActions, KernelProcessStepState state, Dictionary<string, List<KernelProcessEdge>> edges, string threadName, Dictionary<string, Type> inputs, Dictionary<string, KernelProcessEdgeGroup>? incomingEdgeGroups = null) : base(typeof(KernelProcessAgentExecutor), state, edges, incomingEdgeGroups)
    {
        Verify.NotNull(agentDefinition);
        Verify.NotNull(agentActions);

        this.AgentDefinition = agentDefinition;
        this.Actions = agentActions;
        this.ThreadName = threadName;
        this.Inputs = inputs;
    }

    /// <summary>
    /// The optional resolver for the agent ID. This is used to determine the ID of the agent at runtime.
    /// </summary>
    public KernelProcessStateResolver<string?>? AgentIdResolver { get; init; } = null;

    /// <summary>
    /// The name of the thread this agent is associated with. Will be null if not associated with a specific thread instance.
    /// </summary>
    public string ThreadName { get; init; }

    /// <summary>
    /// The agent definition associated with this step.
    /// </summary>
    public AgentDefinition AgentDefinition { get; init; }

    /// <summary>
    /// The inputs for this agent.
    /// </summary>
    public Dictionary<string, Type> Inputs { get; init; }

    /// <summary>
    /// The handler group for code-based actions.
    /// </summary>
    public ProcessAgentActions Actions { get; init; }

    /// <summary>
    /// The human-in-the-loop mode for this agent. This determines whether the agent will wait for human input before proceeding.
    /// </summary>
    public HITLMode HumanInLoopMode { get; init; } = HITLMode.Never;
}


===== Process.Abstractions\KernelProcessAgentThread.cs =====

// Copyright (c) Microsoft. All rights reserved.

namespace Microsoft.SemanticKernel;

/// <summary>
/// Represents a thread in the process.
/// </summary>
public record KernelProcessAgentThread
{
    /// <summary>
    /// The policy describing how the thread is created and managed in the process.
    /// </summary>
    public KernelProcessThreadLifetime ThreadPolicy { get; init; } = KernelProcessThreadLifetime.Scoped;

    /// <summary>
    /// The type of the thread. This is used to identify the underlying thread type.
    /// </summary>
    public KernelProcessThreadType ThreadType { get; init; } = KernelProcessThreadType.ChatCompletion;

    /// <summary>
    /// The id of the thread. This may be null if the thread is not existing when the Process is created.
    /// </summary>
    public string? ThreadId { get; init; }

    /// <summary>
    /// The name of the thread. This is used to identify the thread in the process.
    /// </summary>
    public string ThreadName { get; init; } = string.Empty;
}


===== Process.Abstractions\KernelProcessContext.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Threading.Tasks;

namespace Microsoft.SemanticKernel.Process;

/// <summary>
/// Represents the context of a running process.
/// </summary>
public abstract class KernelProcessContext
{
    /// <summary>
    /// Sends a message to the process.
    /// </summary>
    /// <param name="processEvent">The event to sent to the process.</param>
    /// <returns>A <see cref="Task"/></returns>
    public abstract Task SendEventAsync(KernelProcessEvent processEvent);

    /// <summary>
    /// Stops the process.
    /// </summary>
    /// <returns>A <see cref="Task"/></returns>
    public abstract Task StopAsync();

    /// <summary>
    /// Gets a snapshot of the current state of the process.
    /// </summary>
    /// <returns>A <see cref="Task{T}"/> where T is <see cref="KernelProcess"/></returns>
    public abstract Task<KernelProcess> GetStateAsync();

    /// <summary>
    /// Gets the instance of <see cref="IExternalKernelProcessMessageChannel"/> used for external messages
    /// </summary>
    /// <returns></returns>
    public abstract Task<IExternalKernelProcessMessageChannel?> GetExternalMessageChannelAsync();

    /// <summary>
    /// Gets the id of the running process instance
    /// </summary>
    /// <returns></returns>
    public abstract Task<string> GetProcessIdAsync();
}


===== Process.Abstractions\KernelProcessDeclarativeConditionHandler.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;

namespace Microsoft.SemanticKernel;

/// <summary>
/// Represents a declarative event handler for a process.
/// </summary>
public class KernelProcessDeclarativeConditionHandler
{
    /// <summary>
    /// An optional handler that will always be executed.
    /// </summary>
    public DeclarativeProcessCondition? AlwaysCondition { get; init; }

    /// <summary>
    /// An optional handler that will be executed if no other condition is met.
    /// </summary>
    public DeclarativeProcessCondition? DefaultCondition { get; init; }

    /// <summary>
    /// The list of eval-based handlers.
    /// </summary>
    public List<DeclarativeProcessCondition>? EvalConditions { get; init; } = [];
}


===== Process.Abstractions\KernelProcessEdge.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Runtime.Serialization;
using System.Threading.Tasks;

namespace Microsoft.SemanticKernel;

/// <summary>
/// A serializable representation of an edge between a source <see cref="KernelProcessStep"/> and a <see cref="KernelProcessFunctionTarget"/>.
/// </summary>
[DataContract]
[KnownType(typeof(KernelProcessFunctionTarget))]
public sealed class KernelProcessEdge
{
    /// <summary>
    /// The unique identifier of the source Step.
    /// </summary>
    [DataMember]
    public string SourceStepId { get; init; }

    /// <summary>
    /// The collection of <see cref="KernelProcessFunctionTarget"/>s that are the output of the source Step.
    /// </summary>
    [DataMember]
    public KernelProcessTarget OutputTarget { get; init; }

    /// <summary>
    /// The unique identifier for the group of edges. This may be null if the edge is not part of a group.
    /// </summary>
    [DataMember]
    public string? GroupId { get; init; }

    /// <summary>
    /// The condition that must be met for the edge to be activated.
    /// </summary>
    public KernelProcessEdgeCondition Condition { get; init; }

    /// <summary>
    /// The list of variable updates to be performed when the edge fires.
    /// </summary>
    public VariableUpdate? Update { get; init; }

    /// <summary>
    /// Creates a new instance of the <see cref="KernelProcessEdge"/> class.
    /// </summary>
    public KernelProcessEdge(string sourceStepId, KernelProcessTarget outputTarget, string? groupId = null, KernelProcessEdgeCondition? condition = null, /*Dictionary<string, object?>? metadata = null,*/ VariableUpdate? update = null)
    {
        Verify.NotNullOrWhiteSpace(sourceStepId);
        Verify.NotNull(outputTarget);

        this.SourceStepId = sourceStepId;
        this.OutputTarget = outputTarget;
        this.GroupId = groupId;
        this.Condition = condition ?? new KernelProcessEdgeCondition(callback: (_, _) => Task.FromResult(true));
        //this.Metadata = metadata ?? [];
        this.Update = update;
    }
}


===== Process.Abstractions\KernelProcessEdgeCondition.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Threading.Tasks;

namespace Microsoft.SemanticKernel;

/// <summary>
/// Delegate that represents a condition that must be met for a <see cref="KernelProcessEdge"/> to be activated.
/// </summary>
/// <param name="processEvent">The event associated with the edge.</param>
/// <param name="processState">The readonly process state.</param>
/// <returns></returns>
public delegate Task<bool> KernelProcessEdgeConditionCallback(KernelProcessEvent processEvent, object? processState);

/// <summary>
/// A class representing a condition that must be met for a <see cref="KernelProcessEdge"/> to be activated.
/// </summary>
public class KernelProcessEdgeCondition
{
    /// <summary>
    /// Initializes a new instance of the <see cref="KernelProcessEdgeCondition"/> class with the specified callback and optional declarative definition.
    /// </summary>
    /// <param name="callback"></param>
    /// <param name="declarativeDefinition"></param>
    public KernelProcessEdgeCondition(
        KernelProcessEdgeConditionCallback callback,
        string? declarativeDefinition = null)
    {
        this.Callback = callback;
        this.DeclarativeDefinition = declarativeDefinition;
    }

    /// <summary>
    /// The condition that must be met for the edge to be activated.
    /// </summary>
    public KernelProcessEdgeConditionCallback Callback { get; init; }

    /// <summary>
    /// The declarative definition of the condition, if any.
    /// </summary>
    public string? DeclarativeDefinition { get; init; }
}


===== Process.Abstractions\KernelProcessEdgeGroup.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;

namespace Microsoft.SemanticKernel;

/// <summary>
/// Represents a group of edges in a kernel process.
/// </summary>
public sealed class KernelProcessEdgeGroup
{
    /// <summary>
    /// Initializes a new instance of the <see cref="KernelProcessEdgeGroup"/> class.
    /// </summary>
    /// <param name="groupId">The unique Id of the edge group.</param>
    /// <param name="messageSources">The message sources.</param>
    /// <param name="inputMapping">The input mapping.</param>
    public KernelProcessEdgeGroup(string groupId, List<KernelProcessMessageSource> messageSources, Func<Dictionary<string, object?>, IReadOnlyDictionary<string, object?>> inputMapping)
    {
        Verify.NotNullOrWhiteSpace(groupId, nameof(groupId));
        Verify.NotNullOrEmpty(messageSources, nameof(messageSources));
        Verify.NotNull(inputMapping, nameof(inputMapping));

        this.GroupId = groupId;
        this.MessageSources = messageSources;
        this.InputMapping = inputMapping;
    }

    /// <summary>
    /// Gets the unique identifier for this edge group.
    /// </summary>
    public string GroupId { get; }

    /// <summary>
    /// Gets the list of message sources that this edge group is listening to.
    /// </summary>
    public List<KernelProcessMessageSource> MessageSources { get; }

    /// <summary>
    /// Gets the input mapping function for this edge group.
    /// </summary>
    public Func<Dictionary<string, object?>, IReadOnlyDictionary<string, object?>> InputMapping { get; }
}


===== Process.Abstractions\KernelProcessError.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;

namespace Microsoft.SemanticKernel;

/// <summary>
/// Represents an failure that occurred during the execution of a process.
/// </summary>
/// <remarks>
/// Initializes a new instance of the <see cref="KernelProcessError"/> class.
/// </remarks>
public sealed record KernelProcessError
{
    /// <summary>
    ///The exception type name.
    /// </summary>
    public string Type { get; init; } = string.Empty;

    /// <summary>
    /// The exception message (<see cref="Exception.Message"/>.
    /// </summary>
    public string Message { get; init; } = string.Empty;

    /// <summary>
    /// The exception stack-trace (<see cref="Exception.StackTrace"/>.
    /// </summary>
    public string? StackTrace { get; init; }

    /// <summary>
    /// The inner failure, when exists, as <see cref="KernelProcessError"/>.
    /// </summary>
    public KernelProcessError? InnerError { get; init; }

    /// <summary>
    /// Factory method to create a <see cref="KernelProcessError"/> from a source <see cref="Exception"/> object.
    /// </summary>
    public static KernelProcessError FromException(Exception ex) =>
        new()
        {
            Type = ex.GetType().Name,
            Message = ex.Message,
            StackTrace = ex.StackTrace,
            InnerError = ex.InnerException is not null ? FromException(ex.InnerException) : null
        };
}


===== Process.Abstractions\KernelProcessEvent.cs =====

// Copyright (c) Microsoft. All rights reserved.

namespace Microsoft.SemanticKernel;

/// <summary>
/// A class representing an event that can be emitted from a <see cref="KernelProcessStep"/>. This type is convertible to and from CloudEvents.
/// </summary>
public record KernelProcessEvent
{
    /// <summary>
    /// The unique identifier for the event.
    /// </summary>
    public string Id { get; init; } = string.Empty;

    /// <summary>
    /// An optional data payload associated with the event.
    /// </summary>
    public object? Data { get; init; }

    /// <summary>
    /// The visibility of the event. Defaults to <see cref="KernelProcessEventVisibility.Internal"/>.
    /// </summary>
    public KernelProcessEventVisibility Visibility { get; set; } = KernelProcessEventVisibility.Internal;
}

/// <summary>
/// A strongly typed version of <see cref="KernelProcessEvent"/> that allows for a specific type of data payload.
/// </summary>
/// <typeparam name="TData"></typeparam>
public record KernelProcessEvent<TData> : KernelProcessEvent where TData : class
{
    /// <summary>
    /// The data payload associated with the event, strongly typed.
    /// </summary>
    public new TData? Data
    {
        get => (TData?)base.Data;
        init => base.Data = value;
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="KernelProcessEvent{TData}"/> class with default values.
    /// </summary>
    public KernelProcessEvent()
    {
        this.Visibility = KernelProcessEventVisibility.Internal;
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="KernelProcessEvent{TData}"/> class with the specified id, data, and visibility.
    /// </summary>
    /// <param name="id"></param>
    /// <param name="data"></param>
    /// <param name="visibility"></param>
    public KernelProcessEvent(string id, TData? data, KernelProcessEventVisibility visibility = KernelProcessEventVisibility.Internal)
    {
        this.Id = id;
        this.Data = data;
        this.Visibility = visibility;
    }
}


===== Process.Abstractions\KernelProcessEventData.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.Runtime.Serialization;
using System.Text.Json;
using Microsoft.SemanticKernel.Connectors.OpenAI;

namespace Microsoft.SemanticKernel;

/// <summary>
/// A serializable representation of an internal message used in a process runtime received by proxy steps.
/// </summary>
/// <remarks>
/// Initializes a new instance of the <see cref="KernelProcessEventData"/> class.
/// </remarks>
[DataContract]
public sealed record KernelProcessEventData
{
    /// <summary>
    /// The assembly qualified name of the object type
    /// </summary>
    [DataMember]
    public string ObjectType { get; set; } = string.Empty;
    /// <summary>
    /// The Json serialized object
    /// </summary>
    [DataMember]
    public string Content { get; set; } = string.Empty;

    /// <summary>
    /// Converts serialized object to original object type
    /// </summary>
    /// <returns></returns>
    public object? ToObject()
    {
        Verify.NotNullOrWhiteSpace(this.ObjectType);
        Type? type = Type.GetType(this.ObjectType);
        if (type != null)
        {
            try
            {
                if (type == typeof(OpenAIChatMessageContent))
                {
                    // Special case for OpenAIChatMessageContent, which only has constructors with parameters
                    // Instead using base class ChatMessageContent
                    return JsonSerializer.Deserialize<ChatMessageContent>(this.Content);
                }

                return JsonSerializer.Deserialize(this.Content, type);
            }
            catch (JsonException)
            {
                throw new KernelException($"Cannot deserialize object {this.Content}");
            }
            catch (NotSupportedException e)
            {
                throw new KernelException($"Cannot deserialize object {this.Content}, type {type.FullName} has no parameterless constructor", e);
            }
        }

        return null;
    }

    /// <summary>
    /// Converts from original object to serialized version of the object
    /// </summary>
    /// <param name="obj">object to be serialized</param>
    /// <returns>instance of <see cref="KernelProcessEventData"/></returns>
    public static KernelProcessEventData? FromObject(object? obj)
    {
        if (obj == null)
        {
            return null;
        }

        Verify.NotNull(obj.GetType());
        Verify.NotNull(obj.GetType().AssemblyQualifiedName);

        try
        {
            return new KernelProcessEventData()
            {
                ObjectType = obj.GetType().AssemblyQualifiedName!,
                Content = JsonSerializer.Serialize(obj)
            };
        }
        catch (NotSupportedException)
        {
            throw new KernelException($"Cannot serialize object {obj.GetType().FullName}");
        }
    }
}


===== Process.Abstractions\KernelProcessEventVisibility.cs =====

// Copyright (c) Microsoft. All rights reserved.

namespace Microsoft.SemanticKernel;

/// <summary>
/// An enumeration representing the visibility of a <see cref="KernelProcessEvent"/>. This is used to determine
/// if the event is kept within the process it's emitted in, or exposed to external processes and systems.
/// </summary>
public enum KernelProcessEventVisibility
{
    /// <summary>
    /// The event is only visible to steps within the same process.
    /// </summary>
    Internal,

    /// <summary>
    /// The event is visible inside the process as well as outside the process. This is useful
    /// when the event is intended to be consumed by other processes or external systems.
    /// </summary>
    Public
}


===== Process.Abstractions\KernelProcessFunctionTarget.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace Microsoft.SemanticKernel;

/// <summary>
/// Represents the target for an edge in a Process
/// </summary>
[DataContract]
public record KernelProcessTarget
{
    /// <summary>
    /// Creates an instance of the <see cref="KernelProcessTarget"/> class.
    /// </summary>
    /// <param name="type"></param>
    public KernelProcessTarget(ProcessTargetType type)
    {
        this.Type = type;
    }

    /// <summary>
    /// The type of target.
    /// </summary>
    public ProcessTargetType Type { get; init; } = ProcessTargetType.Invocation;
}

/// <summary>
/// Represents a state operations target for an edge in a Process
/// </summary>
[DataContract]
public record KernelProcessStateTarget : KernelProcessTarget
{
    /// <summary>
    /// Creates an instance of the <see cref="KernelProcessStateTarget"/> class.
    /// </summary>
    public KernelProcessStateTarget(VariableUpdate variableUpdate) : base(ProcessTargetType.StateUpdate)
    {
        this.VariableUpdate = variableUpdate;
    }

    /// <summary>
    /// The associated <see cref="VariableUpdate"/>.
    /// </summary>
    [DataMember]
    public VariableUpdate VariableUpdate { get; init; }
}

/// <summary>
/// Represents a state operations target for an edge in a Process
/// </summary>
[DataContract]
public record KernelProcessEmitTarget : KernelProcessTarget
{
    /// <summary>
    /// Initializes a new instance of the <see cref="KernelProcessEmitTarget"/> class.
    /// </summary>
    /// <param name="eventName"></param>
    /// <param name="payload"></param>
    public KernelProcessEmitTarget(string eventName, Dictionary<string, string>? payload = null) : base(ProcessTargetType.StateUpdate)
    {
        Verify.NotNullOrWhiteSpace(eventName, nameof(eventName));
        this.EventName = eventName;
        this.Payload = payload;
    }

    /// <summary>
    /// The name or type of the event to be emitted.
    /// </summary>
    [DataMember]
    public string EventName { get; init; }

    /// <summary>
    /// /// The payload to be sent with the event.
    /// </summary>
    [DataMember]
    public Dictionary<string, string>? Payload { get; init; }
}

/// <summary>
/// Represents an agent invocation target for an edge in a Process
/// </summary>
[DataContract]
public record KernelProcessAgentInvokeTarget : KernelProcessTarget
{
    /// <summary>
    /// Creates an instance of the <see cref="KernelProcessAgentInvokeTarget"/> class.
    /// </summary>
    /// <param name="stepId"></param>
    /// <param name="threadEval"></param>
    /// <param name="messagesInEval"></param>
    /// <param name="inputEvals"></param>
    public KernelProcessAgentInvokeTarget(string stepId, string? threadEval, List<string>? messagesInEval, Dictionary<string, string> inputEvals) : base(ProcessTargetType.Invocation)
    {
        Verify.NotNullOrWhiteSpace(stepId);
        Verify.NotNull(inputEvals);

        this.StepId = stepId;
        this.ThreadEval = threadEval;
        this.MessagesInEval = messagesInEval;
        this.InputEvals = inputEvals;
    }

    /// <summary>
    /// The unique identifier of the Step being targeted.
    /// </summary>
    [DataMember]
    public string StepId { get; init; }

    /// <summary>
    /// An evaluation string that will be evaluated to determine the thread to run on.
    /// </summary>
    [DataMember]
    public string? ThreadEval { get; init; }

    /// <summary>
    /// An evaluation string that will be evaluated to determine the messages to send to the target.
    /// </summary>
    [DataMember]
    public List<string>? MessagesInEval { get; init; }

    /// <summary>
    /// An evaluation string that will be evaluated to determine the inputs to send to the target.
    /// </summary>
    [DataMember]
    public Dictionary<string, string> InputEvals { get; init; }
}

/// <summary>
/// A serializable representation of a specific parameter of a specific function of a specific Step.
/// </summary>
[DataContract]
public record KernelProcessFunctionTarget : KernelProcessTarget
{
    /// <summary>
    /// Creates an instance of the <see cref="KernelProcessFunctionTarget"/> class.
    /// </summary>
    public KernelProcessFunctionTarget(string stepId, string functionName, string? parameterName = null, string? targetEventId = null, Func<Dictionary<string, object?>, Dictionary<string, object?>>? inputMapping = null) : base(ProcessTargetType.KernelFunction)
    {
        Verify.NotNullOrWhiteSpace(stepId);
        Verify.NotNullOrWhiteSpace(functionName);

        this.StepId = stepId;
        this.FunctionName = functionName;
        this.ParameterName = parameterName;
        this.TargetEventId = targetEventId;
        this.InputMapping = inputMapping;
    }

    /// <summary>
    /// The unique identifier of the Step being targeted.
    /// </summary>
    [DataMember]
    public string StepId { get; init; }

    /// <summary>
    /// The name if the Kernel Function to target.
    /// </summary>
    [DataMember]
    public string FunctionName { get; init; }

    /// <summary>
    /// The name of the parameter to target. This may be null if the function has no parameters.
    /// </summary>
    [DataMember]
    public string? ParameterName { get; init; }

    /// <summary>
    /// The unique identifier for the event to target. This may be null if the target is not a sub-process.
    /// </summary>
    [DataMember]
    public string? TargetEventId { get; init; }

    /// <summary>
    /// The mapping function to apply to the input data before passing it to the function.
    /// </summary>
    public Func<Dictionary<string, object?>, Dictionary<string, object?>>? InputMapping { get; init; }
}


===== Process.Abstractions\KernelProcessMap.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Collections.Generic;

namespace Microsoft.SemanticKernel;

/// <summary>
/// A serializable representation of a ProcessMap.
/// </summary>
public sealed record KernelProcessMap : KernelProcessStepInfo
{
    /// <summary>
    /// The map operation.
    /// </summary>
    public KernelProcessStepInfo Operation { get; }

    /// <summary>
    /// Creates a new instance of the <see cref="KernelProcess"/> class.
    /// </summary>
    /// <param name="state">The process state.</param>
    /// <param name="operation">The map operation.</param>
    /// <param name="edges">The edges for the map.</param>
    public KernelProcessMap(KernelProcessMapState state, KernelProcessStepInfo operation, Dictionary<string, List<KernelProcessEdge>> edges)
        : base(typeof(KernelProcessMap), state, edges)
    {
        Verify.NotNull(operation, nameof(operation));
        Verify.NotNullOrWhiteSpace(state.Name, $"{nameof(state)}.{nameof(KernelProcessMapState.Name)}");
        Verify.NotNullOrWhiteSpace(state.Id, $"{nameof(state)}.{nameof(KernelProcessMapState.Id)}");

        this.Operation = operation;
    }
}


===== Process.Abstractions\KernelProcessMapState.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Runtime.Serialization;

namespace Microsoft.SemanticKernel;

/// <summary>
/// Represents the state of a <see cref="KernelProcessMap"/>.
/// </summary>
[DataContract]
public sealed record KernelProcessMapState : KernelProcessStepState
{
    /// <summary>
    /// Initializes a new instance of the <see cref="KernelProcessMapState"/> class.
    /// </summary>
    /// <param name="name">The name of the associated <see cref="KernelProcessMap"/></param>
    /// <param name="version">version id of the process step state</param>
    /// <param name="id">The Id of the associated <see cref="KernelProcessMap"/></param>
    public KernelProcessMapState(string name, string version, string id)
        : base(name, version, id)
    {
        Verify.NotNullOrWhiteSpace(id, nameof(id));
    }
}


===== Process.Abstractions\KernelProcessMessageSource.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Runtime.Serialization;

namespace Microsoft.SemanticKernel;

/// <summary>
/// Represents a message type and source in the context of a kernel process.
/// </summary>
[DataContract]
public class KernelProcessMessageSource
{
    /// <summary>
    /// Initializes a new instance of the <see cref="KernelProcessMessageSource"/> class.
    /// </summary>
    /// <param name="messageType">The message type</param>
    /// <param name="sourceStepId">The unique Id of the source step.</param>
    public KernelProcessMessageSource(string messageType, string sourceStepId)
    {
        Verify.NotNullOrWhiteSpace(messageType, nameof(messageType));
        Verify.NotNullOrWhiteSpace(sourceStepId, nameof(sourceStepId));

        this.MessageType = messageType;
        this.SourceStepId = sourceStepId;
    }

    /// <summary>
    /// The type of message.
    /// </summary>
    [DataMember]
    public string MessageType { get; set; }

    /// <summary>
    /// The unique identifier of the step that generated this message.
    /// </summary>
    [DataMember]
    public string SourceStepId { get; set; }
}


===== Process.Abstractions\KernelProcessProxy.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Collections.Generic;
using Microsoft.SemanticKernel.Process;
using Microsoft.SemanticKernel.Process.Models;

namespace Microsoft.SemanticKernel;

/// <summary>
/// A serializable representation of a ProcessProxy.
/// </summary>
public sealed record KernelProcessProxy : KernelProcessStepInfo
{
    /// <summary>
    /// Proxy metadata used for linking specific SK events to external events and viceversa
    /// </summary>
    public KernelProcessProxyStateMetadata? ProxyMetadata { get; init; }

    /// <summary>
    /// Creates a new instance of the <see cref="KernelProcess"/> class.
    /// </summary>
    /// <param name="state">The process state.</param>
    /// <param name="edges">The edges for the map.</param>
    public KernelProcessProxy(KernelProcessStepState state, Dictionary<string, List<KernelProcessEdge>> edges)
        : base(typeof(KernelProxyStep), state, edges)
    {
        Verify.NotNullOrWhiteSpace(state.Name, $"{nameof(state)}.{nameof(KernelProcessStepState.Name)}");
        Verify.NotNullOrWhiteSpace(state.Id, $"{nameof(state)}.{nameof(KernelProcessStepState.Id)}");
    }
}


===== Process.Abstractions\KernelProcessProxyMessage.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Runtime.Serialization;
using System.Text.Json.Serialization;

namespace Microsoft.SemanticKernel;

/// <summary>
/// A serializable representation of an internal message used in a process runtime received by proxy steps.
/// </summary>
/// <remarks>
/// Initializes a new instance of the <see cref="KernelProcessProxyMessage"/> class.
/// </remarks>
[DataContract]
public sealed record KernelProcessProxyMessage
{
    /// <summary>
    /// Id of the SK process that emits the external event
    /// </summary>
    [DataMember]
    [JsonPropertyName("processId")]
    public string? ProcessId { get; init; }

    /// <summary>
    /// Name of the SK process that triggers sending the event externally
    /// </summary>
    [DataMember]
    [JsonPropertyName("triggerEventId")]
    public string? TriggerEventId { get; init; }

    /// <summary>
    /// Topic name used for publishing process event data externally
    /// </summary>
    [DataMember]
    [JsonPropertyName("externalTopicName")]
    public string ExternalTopicName { get; init; } = string.Empty;
    /// <summary>
    /// Event name used for publishing process event as another process event with a different event name
    /// </summary>
    [DataMember]
    [JsonPropertyName("proxyEventName")]
    public string? ProxyEventName { get; init; }
    /// <summary>
    /// Data to be emitted
    /// </summary>
    [DataMember]
    [JsonPropertyName("eventData")]
    public KernelProcessEventData? EventData { get; init; }
}


===== Process.Abstractions\KernelProcessState.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Runtime.Serialization;

namespace Microsoft.SemanticKernel;

/// <summary>
/// Represents the state of a <see cref="KernelProcess"/>.
/// </summary>
[DataContract]
public sealed record KernelProcessState : KernelProcessStepState
{
    /// <summary>
    /// Initializes a new instance of the <see cref="KernelProcessState"/> class.
    /// </summary>
    /// <param name="name">The name of the associated <see cref="KernelProcessStep"/></param>
    /// <param name="version">version id of the process step state</param>
    /// <param name="id">The Id of the associated <see cref="KernelProcessStep"/></param>
    public KernelProcessState(string name, string version, string? id = null)
        : base(name, version, id)
    {
    }
}


===== Process.Abstractions\KernelProcessStep.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Threading.Tasks;

namespace Microsoft.SemanticKernel;

/// <summary>
/// Process Step. Derive from this class to create a new Step for a Process.
/// </summary>
public class KernelProcessStep
{
    /// <inheritdoc/>
    public virtual ValueTask ActivateAsync(KernelProcessStepState state)
    {
        return default;
    }
}

/// <summary>
/// Process Step. Derive from this class to create a new Step with user-defined state of type TState for a Process.
/// </summary>
/// <typeparam name="TState">An instance of TState used for user-defined state.</typeparam>
public class KernelProcessStep<TState> : KernelProcessStep where TState : class, new()
{
    /// <inheritdoc/>
    public virtual ValueTask ActivateAsync(KernelProcessStepState<TState> state)
    {
        return default;
    }
}


===== Process.Abstractions\KernelProcessStepContext.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Threading.Tasks;

namespace Microsoft.SemanticKernel;

/// <summary>
/// Provides step related functionality for Kernel Functions running in a step.
/// </summary>
public sealed class KernelProcessStepContext
{
    private readonly IKernelProcessMessageChannel _stepMessageChannel;

    /// <summary>
    /// Initializes a new instance of the <see cref="KernelProcessStepContext"/> class.
    /// </summary>
    /// <param name="channel">An instance of <see cref="IKernelProcessMessageChannel"/>.</param>
    public KernelProcessStepContext(IKernelProcessMessageChannel channel)
    {
        this._stepMessageChannel = channel;
    }

    /// <summary>
    /// Emit an SK process event from the current step.
    /// </summary>
    /// <param name="processEvent">An instance of <see cref="KernelProcessEvent"/> to be emitted from the <see cref="KernelProcessStep"/></param>
    /// <returns>A <see cref="ValueTask"/></returns>
    public ValueTask EmitEventAsync(KernelProcessEvent processEvent)
    {
        return this._stepMessageChannel.EmitEventAsync(processEvent);
    }

    /// <summary>
    /// Emit an SK process event from the current step with a simplified method signature.
    /// </summary>
    /// <param name="eventId"></param>
    /// <param name="data"></param>
    /// <param name="visibility"></param>
    /// <returns></returns>
    public ValueTask EmitEventAsync(
        string eventId,
        object? data = null,
        KernelProcessEventVisibility visibility = KernelProcessEventVisibility.Internal)
    {
        Verify.NotNullOrWhiteSpace(eventId, nameof(eventId));

        return this._stepMessageChannel.EmitEventAsync(
            new KernelProcessEvent
            {
                Id = eventId,
                Data = data,
                Visibility = visibility
            });
    }
}


===== Process.Abstractions\KernelProcessStepExternalContext.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Threading.Tasks;

namespace Microsoft.SemanticKernel;

/// <summary>
/// Provides step related functionality for Kernel Functions running in a step to emit events externally.
/// </summary>
public class KernelProcessStepExternalContext
{
    private readonly IExternalKernelProcessMessageChannel? _externalMessageChannel;

    /// <summary>
    /// Initializes a new instance of the <see cref="KernelProcessStepContext"/> class.
    /// </summary>
    /// <param name="externalMessageChannel">An instance of <see cref="IExternalKernelProcessMessageChannel"/></param>
    public KernelProcessStepExternalContext(IExternalKernelProcessMessageChannel? externalMessageChannel = null)
    {
        this._externalMessageChannel = externalMessageChannel;
    }

    /// <summary>
    /// Emit an external event to through a <see cref="IExternalKernelProcessMessageChannel"/>
    /// component if connected from within the SK process
    /// </summary>
    /// <param name="processEventData">data containing event details</param>
    /// <returns></returns>
    /// <exception cref="KernelException"></exception>
    public async Task EmitExternalEventAsync(KernelProcessProxyMessage processEventData)
    {
        if (this._externalMessageChannel == null)
        {
            throw new KernelException($"External message channel not configured for step with topic {processEventData.ExternalTopicName}");
        }

        await this._externalMessageChannel.EmitExternalEventAsync(processEventData.ExternalTopicName, processEventData).ConfigureAwait(false);
    }

    /// <summary>
    /// Closes connection with external messaging channel
    /// </summary>
    /// <returns><see cref="Task"/></returns>
    /// <exception cref="KernelException"></exception>
    public async Task CloseExternalEventChannelAsync()
    {
        if (this._externalMessageChannel == null)
        {
            throw new KernelException("External message channel not configured for step");
        }

        await this._externalMessageChannel.Uninitialize().ConfigureAwait(false);
    }
}


===== Process.Abstractions\KernelProcessStepInfo.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Linq;

namespace Microsoft.SemanticKernel;

/// <summary>
/// Contains information about a Step in a Process including it's state and edges.
/// </summary>
public record KernelProcessStepInfo
{
    private KernelProcessStepState _state;

    /// <summary>
    /// The type of the inner step.
    /// </summary>
    public Type InnerStepType { get; }

    /// <summary>
    /// The state of the Step.
    /// </summary>
    public KernelProcessStepState State
    {
        get => this._state;
        init
        {
            Verify.NotNull(value);
            this._state = value;
        }
    }

    /// <summary>
    /// The semantic description of the Step. This is intended to be human and AI readable and is not required to be unique.
    /// </summary>
    public string? Description { get; init; } = null;

    /// <summary>
    /// A read-only dictionary of output edges from the Step.
    /// </summary>
    public IReadOnlyDictionary<string, IReadOnlyCollection<KernelProcessEdge>> Edges { get; }

    /// <summary>
    /// A dictionary of input mappings for the grouped edges.
    /// </summary>
    public IReadOnlyDictionary<string, KernelProcessEdgeGroup>? IncomingEdgeGroups { get; }

    /// <summary>
    /// Initializes a new instance of the <see cref="KernelProcessStepInfo"/> class.
    /// </summary>
    public KernelProcessStepInfo(Type innerStepType, KernelProcessStepState state, Dictionary<string, List<KernelProcessEdge>> edges, Dictionary<string, KernelProcessEdgeGroup>? incomingEdgeGroups = null)
    {
        Verify.NotNull(innerStepType);
        Verify.NotNull(edges);
        Verify.NotNull(state);

        this.InnerStepType = innerStepType;
        this.Edges = edges.ToDictionary(kvp => kvp.Key, kvp => (IReadOnlyCollection<KernelProcessEdge>)kvp.Value.AsReadOnly());
        this._state = state;
        this.IncomingEdgeGroups = incomingEdgeGroups;

        // Register the state as a know type for the DataContractSerialization used by Dapr.
        KernelProcessState.RegisterDerivedType(state.GetType());
    }
}


===== Process.Abstractions\KernelProcessStepMetadataAttribute.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;

namespace Microsoft.SemanticKernel.Process;

/// <summary>
/// Attribute to set Process Step State Metadata related properties
/// </summary>
[AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]
public sealed class KernelProcessStepMetadataAttribute : Attribute
{
    /// <summary>
    /// Attribute that assigns default values to Process Step Metadata
    /// </summary>
    public KernelProcessStepMetadataAttribute() { }

    /// <summary>
    /// Attribute that assigns default version to Process Step Metadata
    /// </summary>
    /// <param name="version"></param>
    public KernelProcessStepMetadataAttribute(string version)
    {
        this.Version = version;
    }

    /// <summary>
    /// Version of the step to be used to save with the step state
    /// </summary>
    public string Version { get; } = "v1";
}


===== Process.Abstractions\KernelProcessStepState.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace Microsoft.SemanticKernel;

/// <summary>
/// Represents the state of an individual step in a process.
/// </summary>
[DataContract]
[KnownType(nameof(GetKnownTypes))]
public record KernelProcessStepState
{
    /// <summary>
    /// A set of known types that may be used in serialization.
    /// </summary>
    private readonly static ConcurrentDictionary<string, Type> s_knownTypes = [];

    /// <summary>
    /// Used to dynamically provide the set of known types for serialization.
    /// </summary>
    /// <returns></returns>
    private static IEnumerable<Type> GetKnownTypes() => s_knownTypes.Values;

    /// <summary>
    /// Registers a derived type for serialization. Types registered here are used by the KnownType attribute
    /// to support DataContractSerialization of derived types as required to support Dapr.
    /// </summary>
    /// <param name="derivedType">A Type that derives from <typeref name="KernelProcessStepState"/></param>
    internal static void RegisterDerivedType(Type derivedType)
    {
        s_knownTypes.TryAdd(derivedType.Name, derivedType);
    }

    /// <summary>
    /// The identifier of the Step which is required to be unique within an instance of a Process.
    /// This may be null until a process containing this step has been invoked.
    /// </summary>
    [DataMember]
    public string? Id { get; init; }

    /// <summary>
    /// The name of the Step. This is intended to be human readable and is not required to be unique. If
    /// not provided, the name will be derived from the steps .NET type.
    /// </summary>
    [DataMember]
    public string Name { get; init; }

    /// <summary>
    /// Version of the state
    /// </summary>
    [DataMember]
    public string Version { get; init; }

    /// <summary>
    /// Initializes a new instance of the <see cref="KernelProcessStepState"/> class.
    /// </summary>
    /// <param name="name">The name of the associated <see cref="KernelProcessStep"/></param>
    /// <param name="version">version id of the process step state</param>
    /// <param name="id">The Id of the associated <see cref="KernelProcessStep"/></param>
    public KernelProcessStepState(string name, string version, string? id = null)
    {
        Verify.NotNullOrWhiteSpace(name, nameof(name));
        Verify.NotNullOrWhiteSpace(version, nameof(version));

        this.Id = id;
        this.Name = name;
        this.Version = version;
    }
}

/// <summary>
/// Represents the state of an individual step in a process that includes a user-defined state object.
/// </summary>
/// <typeparam name="TState">The type of the user-defined state.</typeparam>
[DataContract]
public sealed record KernelProcessStepState<TState> : KernelProcessStepState where TState : class, new()
{
    /// <summary>
    /// The user-defined state object associated with the Step.
    /// </summary>
    [DataMember]
    public TState? State { get; init; }

    /// <summary>
    /// Initializes a new instance of the <see cref="KernelProcessStepState"/> class.
    /// </summary>
    /// <param name="name">The name of the associated <see cref="KernelProcessStep"/></param>
    /// <param name="version">version id of the process step state</param>
    /// <param name="id">The Id of the associated <see cref="KernelProcessStep"/></param>
    public KernelProcessStepState(string name, string version, string? id = null)
        : base(name, version, id)
    {
        Verify.NotNullOrWhiteSpace(name);

        this.Id = id;
        this.Name = name;
        this.Version = version;
    }
}


===== Process.Abstractions\KernelProcessThreadLifetime.cs =====

// Copyright (c) Microsoft. All rights reserved.

namespace Microsoft.SemanticKernel;

/// <summary>
/// Defines the policy for how threads are managed in the process.
/// </summary>
public enum KernelProcessThreadLifetime
{
    /// <summary>
    /// The thread is created when the process is created. The thread id is saved in the process state and will be reused within the scope of a process instance. Scoped threads can be shared between steps.
    /// </summary>
    Scoped,

    /// <summary>
    /// A new thread is created every time a step in the process uses it. The thread id is not saved in the process state. Transient threads cannot be shared between steps.
    /// </summary>
    Transient
}


===== Process.Abstractions\KernelProcessThreadType.cs =====

// Copyright (c) Microsoft. All rights reserved.

namespace Microsoft.SemanticKernel;

/// <summary>
/// Represents the type of a thread in a kernel process.
/// </summary>
public enum KernelProcessThreadType
{
    /// <summary>
    /// A thread is a general chat completion type.
    /// </summary>
    ChatCompletion,

    /// <summary>
    /// A thread is an AzureAI or Foundry type.
    /// </summary>
    AzureAI
}


===== Process.Abstractions\KernelProxyStep.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Threading.Tasks;

namespace Microsoft.SemanticKernel.Process;

/// <summary>
/// Internal SK KernelProcessStep preconfigured to be used when emitting SK events outside of the SK Process Framework or inside with a different event name
/// </summary>
public sealed class KernelProxyStep : KernelProcessStep
{
    /// <summary>
    /// SK Function names in this SK Step as entry points
    /// </summary>
    public static class ProcessFunctions
    {
        /// <summary>
        /// Function name used to emit events externally
        /// </summary>
        public const string EmitExternalEvent = nameof(EmitExternalEvent);
    }

    /// <summary>
    /// On deactivation, external communication channel must be closed
    /// </summary>
    /// <param name="context">instance of <see cref="KernelProcessStepContext"/></param>
    /// <returns></returns>
    public async ValueTask DeactivateAsync(KernelProcessStepExternalContext context)
    {
        await context.CloseExternalEventChannelAsync().ConfigureAwait(false);
    }

    /// <summary>
    /// Step function used to emit events externally
    /// </summary>
    /// <param name="context">instance of <see cref="KernelProcessStepContext"/></param>
    /// <param name="proxyEvent">event data passed to proxy step</param>
    /// <returns></returns>
    [KernelFunction(ProcessFunctions.EmitExternalEvent)]
    public Task EmitExternalEventAsync(KernelProcessStepExternalContext context, KernelProcessProxyMessage proxyEvent)
    {
        Verify.NotNull(proxyEvent.ExternalTopicName, nameof(proxyEvent.ExternalTopicName));
        return context.EmitExternalEventAsync(proxyEvent);
    }
}


===== Process.Abstractions\Models\KernelProcessMapStateMetadata.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Runtime.Serialization;
using System.Text.Json.Serialization;

namespace Microsoft.SemanticKernel.Process.Models;

/// <summary>
/// Process state used for State Persistence serialization
/// </summary>
public sealed record class KernelProcessMapStateMetadata : KernelProcessStepStateMetadata
{
    /// <summary>
    /// Process State of Steps if provided
    /// </summary>
    [DataMember]
    [JsonPropertyName("operationState")]
    public KernelProcessStepStateMetadata? OperationState { get; set; }
}


===== Process.Abstractions\Models\KernelProcessProxyEventMetadata.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Runtime.Serialization;
using System.Text.Json.Serialization;

namespace Microsoft.SemanticKernel.Process.Models;

/// <summary>
/// Process state used for State Persistence serialization
/// </summary>
public sealed record class KernelProcessProxyEventMetadata
{
    /// <summary>
    /// Name of the topic to be emitted externally
    /// </summary>
    [DataMember]
    [JsonPropertyName("topicName")]
    public string TopicName { get; set; } = string.Empty;

    /// <summary>
    /// Internal id used to identify the SK event
    /// </summary>
    [DataMember]
    [JsonPropertyName("eventId")]
    public string EventId { get; set; } = string.Empty;
}


===== Process.Abstractions\Models\KernelProcessProxyStateMetadata.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Collections.Generic;
using System.Runtime.Serialization;
using System.Text.Json.Serialization;

namespace Microsoft.SemanticKernel.Process.Models;

/// <summary>
/// Process state used for State Persistence serialization
/// </summary>
public sealed record class KernelProcessProxyStateMetadata : KernelProcessStepStateMetadata
{
    /// <summary>
    /// List of publish topics that can be used by the SK process
    /// </summary>
    [DataMember]
    [JsonPropertyName("publishTopics")]
    public List<string> PublishTopics { get; set; } = [];

    /// <summary>
    /// Map that stores which process events trigger external topic to be published and internal metadata information
    /// </summary>
    [DataMember]
    [JsonPropertyName("eventMetadata")]
    public Dictionary<string, KernelProcessProxyEventMetadata> EventMetadata { get; set; } = [];
}


===== Process.Abstractions\Models\KernelProcessStateMetadata.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Runtime.Serialization;
using System.Text.Json.Serialization;

namespace Microsoft.SemanticKernel.Process.Models;

/// <summary>
/// Process state used for State Persistence serialization
/// </summary>
public sealed record class KernelProcessStateMetadata : KernelProcessStepStateMetadata
{
    /// <summary>
    /// Process State of Steps if provided
    /// </summary>
    [DataMember]
    [JsonPropertyName("stepsState")]
    public Dictionary<string, KernelProcessStepStateMetadata>? StepsState { get; set; } = null;
}


===== Process.Abstractions\Models\KernelProcessStepStateMetadata.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Runtime.Serialization;
using System.Text.Json.Serialization;
using Microsoft.SemanticKernel.Process.Internal;

namespace Microsoft.SemanticKernel.Process.Models;

/// <summary>
/// Step state used for State Persistence serialization
/// </summary>
[JsonPolymorphic(TypeDiscriminatorPropertyName = "$type", UnknownDerivedTypeHandling = JsonUnknownDerivedTypeHandling.FallBackToNearestAncestor)]
[JsonDerivedType(typeof(KernelProcessStepStateMetadata), typeDiscriminator: nameof(ProcessConstants.SupportedComponents.Step))]
[JsonDerivedType(typeof(KernelProcessMapStateMetadata), typeDiscriminator: nameof(ProcessConstants.SupportedComponents.Map))]
[JsonDerivedType(typeof(KernelProcessProxyStateMetadata), typeDiscriminator: nameof(ProcessConstants.SupportedComponents.Proxy))]
[JsonDerivedType(typeof(KernelProcessStateMetadata), typeDiscriminator: nameof(ProcessConstants.SupportedComponents.Process))]
public record class KernelProcessStepStateMetadata
{
    /// <summary>
    /// The identifier of the Step which is required to be unique within an instance of a Process.
    /// This may be null until a process containing this step has been invoked.
    /// </summary>
    [DataMember]
    [JsonPropertyName("id")]
    public string? Id { get; init; }

    /// <summary>
    /// The name of the Step. This is intended to be human readable and is not required to be unique. If
    /// not provided, the name will be derived from the steps .NET type.
    /// </summary>
    [DataMember]
    [JsonPropertyName("name")]
    public string? Name { get; set; }

    /// <summary>
    /// Version of the state that is stored. Used for validation and versioning
    /// purposes when reading a state and applying it to a ProcessStepBuilder/ProcessBuilder
    /// </summary>
    [DataMember]
    [JsonPropertyName("versionInfo")]
    public string? VersionInfo { get; init; } = null;

    /// <summary>
    /// The user-defined state object associated with the Step (if the step is stateful)
    /// </summary>
    [DataMember]
    [JsonPropertyName("state")]
    public object? State { get; set; } = null;
}


===== Process.Abstractions\ProcessAgentActions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Runtime.Serialization;

namespace Microsoft.SemanticKernel;

/// <summary>
/// Represents the actions that can be performed by a process agent.
/// </summary>
[DataContract]
public sealed class ProcessAgentActions
{
    /// <summary>
    /// Creates a new instance of the <see cref="ProcessAgentActions"/> class.
    /// </summary>
    /// <param name="codeActions">The code based actions. These are not serializable to a declarative format.</param>
    /// <param name="declarativeActions">The declarative action. These are required when building an exportable process.</param>
    /// <exception cref="ArgumentException"></exception>
    public ProcessAgentActions(
        ProcessAgentCodeActions? codeActions = null,
        ProcessAgentDeclarativeActions? declarativeActions = null)
    {
        this.CodeActions = codeActions;
        this.DeclarativeActions = declarativeActions;

        if (codeActions == null && declarativeActions == null)
        {
            throw new ArgumentException("At least one action must be provided.");
        }
    }

    /// <summary>
    /// The optional handler group for code-based actions.
    /// </summary>
    public ProcessAgentCodeActions? CodeActions { get; init; }

    /// <summary>
    /// The optional handler group for declarative actions.
    /// </summary>
    public ProcessAgentDeclarativeActions? DeclarativeActions { get; init; }
}

/// <summary>
/// Represents the code-based actions that can be performed by a process agent.
/// </summary>
public sealed class ProcessAgentCodeActions
{
    /// <summary>
    /// The optional handler group for OnComplete events.
    /// </summary>
    public Action<object?, KernelProcessStepContext>? OnComplete { get; init; }
    /// <summary>
    /// The optional handler group for OnError events.
    /// </summary>
    public Action<object?, KernelProcessStepContext>? OnError { get; init; }
}

/// <summary>
/// Represents the declarative actions that can be performed by a process agent.
/// </summary>
public class ProcessAgentDeclarativeActions
{
    /// <summary>
    /// The optional handler group for OnComplete events.
    /// </summary>
    public KernelProcessDeclarativeConditionHandler? OnComplete { get; init; }
    /// <summary>
    /// The optional handler group for OnError events.
    /// </summary>
    public KernelProcessDeclarativeConditionHandler? OnError { get; init; }
}


===== Process.Abstractions\ProcessTargetType.cs =====

// Copyright (c) Microsoft. All rights reserved.
namespace Microsoft.SemanticKernel;

/// <summary>
/// Represents the type of target for a process.
/// </summary>
public enum ProcessTargetType
{
    /// <summary>
    /// The target is a step.
    /// </summary>
    Invocation,

    /// <summary>
    /// The target is a function.
    /// </summary>
    KernelFunction,

    /// <summary>
    /// The target is a parameter.
    /// </summary>
    StateUpdate
}


===== Process.Abstractions\Serialization\Model\Workflow.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Runtime.Serialization;
using System.Text.Json.Serialization;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.Process.Internal;
using YamlDotNet.Serialization;

namespace Microsoft.SemanticKernel;

/// <summary>
/// A wrapper class that encapsulates the workflow definition for serialization and deserialization.
/// This class serves as the root container for workflow configurations in both YAML and JSON formats.
/// </summary>
public sealed class WorkflowWrapper
{
    /// <summary>
    /// Gets or sets the workflow definition contained within this wrapper.
    /// This property represents the complete workflow specification including all nodes, orchestration, and error handling.
    /// </summary>
    [YamlMember(Alias = "workflow")]
    [JsonPropertyName("workflow")]
    public Workflow? Workflow { get; set; }
}

/// <summary>
/// Represents the main workflow specification that defines the complete structure and behavior of a workflow.
/// A workflow consists of nodes, orchestration steps, variables, schemas, and error handling configurations.
/// </summary>
public sealed class Workflow
{
    /// <summary>
    /// Gets or sets the unique identifier of the workflow.
    /// This ID should be unique across all workflows within the system and is used for workflow identification and referencing.
    /// </summary>
    [YamlMember(Alias = "id")]
    [JsonPropertyName("id")]
    public string Id { get; set; } = string.Empty;

    /// <summary>
    /// Gets or sets the format version of the workflow specification.
    /// This version indicates the schema version used to define the workflow and ensures compatibility with the execution engine.
    /// </summary>
    [YamlMember(Alias = "format_version")]
    [JsonPropertyName("format_version")]
    public string FormatVersion { get; set; } = string.Empty;

    /// <summary>
    /// Gets or sets the version of the workflow implementation.
    /// This version tracks the evolution of the workflow definition and allows for versioning of workflow logic.
    /// </summary>
    [YamlMember(Alias = "workflow_version")]
    [JsonPropertyName("workflow_version")]
    public string WorkflowVersion { get; set; } = string.Empty;

    /// <summary>
    /// Gets or sets the human-readable name of the workflow.
    /// This name is used for display purposes and should clearly identify the workflow's purpose.
    /// </summary>
    [YamlMember(Alias = "name")]
    [JsonPropertyName("name")]
    public string Name { get; set; } = string.Empty;

    /// <summary>
    /// Gets or sets the optional description of the workflow.
    /// This description provides additional context about the workflow's purpose, behavior, and usage.
    /// </summary>
    [YamlMember(Alias = "description")]
    [JsonPropertyName("description")]
    public string? Description { get; set; }

    /// <summary>
    /// Gets or sets the suggested inputs for the workflow.
    /// These inputs provide examples or recommendations for how the workflow should be invoked.
    /// </summary>
    [YamlMember(Alias = "suggested_inputs")]
    [JsonPropertyName("suggested_inputs")]
    public SuggestedInputs? SuggestedInputs { get; set; }

    /// <summary>
    /// Gets or sets the input configuration for the workflow.
    /// This defines what types of inputs the workflow accepts, including events and messages.
    /// </summary>
    [YamlMember(Alias = "inputs")]
    [JsonPropertyName("inputs")]
    public Inputs? Inputs { get; set; }

    /// <summary>
    /// Gets or sets the variables defined within the workflow scope.
    /// These variables can be used throughout the workflow for state management and data passing between nodes.
    /// </summary>
    [YamlMember(Alias = "variables")]
    [JsonPropertyName("variables")]
    public Dictionary<string, VariableDefinition>? Variables { get; set; }

    /// <summary>
    /// Gets or sets the schemas used within the workflow.
    /// These schemas define the structure and validation rules for data used throughout the workflow.
    /// </summary>
    [YamlMember(Alias = "schemas")]
    [JsonPropertyName("schemas")]
    public Dictionary<string, WorkflowSchema>? Schemas { get; set; }

    /// <summary>
    /// Gets or sets the collection of nodes that make up the workflow.
    /// Each node represents a step or component in the workflow execution graph.
    /// </summary>
    [YamlMember(Alias = "nodes")]
    [JsonPropertyName("nodes")]
    public List<Node>? Nodes { get; set; }

    /// <summary>
    /// Gets or sets the orchestration steps that define the workflow execution flow.
    /// These steps specify the conditions and actions that control how the workflow progresses from node to node.
    /// </summary>
    [YamlMember(Alias = "orchestration")]
    [JsonPropertyName("orchestration")]
    public List<OrchestrationStep>? Orchestration { get; set; }

    /// <summary>
    /// Gets or sets the error handling configuration for the workflow.
    /// This defines how the workflow should respond to and recover from errors during execution.
    /// </summary>
    [YamlMember(Alias = "error_handling")]
    [JsonPropertyName("error_handling")]
    public ErrorHandling? ErrorHandling { get; set; }
}

/// <summary>
/// Defines the possible types of variables that can be used within a workflow.
/// Variables can represent different data structures and have different behaviors during workflow execution.
/// </summary>
public enum VariableType
{
    /// <summary>
    /// A thread type variable that represents a conversation thread or execution context.
    /// Thread variables maintain state and context across multiple interactions within the workflow.
    /// </summary>
    [JsonPropertyName("thread")]
    Thread,

    /// <summary>
    /// A message type variable that represents a collection of messages.
    /// Messages variables are used to store and pass communication data between workflow components.
    /// </summary>
    [JsonPropertyName("messages")]
    Messages,

    /// <summary>
    /// A user-defined variable with custom structure and behavior.
    /// User-defined variables allow for flexible data types specific to the workflow's requirements.
    /// </summary>
    [JsonPropertyName("user-defined")]
    UserDefined
}

/// <summary>
/// Represents the definition of a variable within a workflow, including its type, default value, and schema.
/// Variable definitions specify how variables should be initialized and validated during workflow execution.
/// </summary>
public sealed class VariableDefinition
{
    /// <summary>
    /// Gets or sets the type of the variable.
    /// The type determines how the variable is handled and what operations can be performed on it.
    /// </summary>
    public VariableType Type { get; set; } = VariableType.UserDefined;

    /// <summary>
    /// Gets or sets the default value of the variable.
    /// This value is used to initialize the variable when the workflow starts if no other value is provided.
    /// </summary>
    public object? DefaultValue { get; set; }

    /// <summary>
    /// Gets or sets the schema definition for the variable.
    /// The schema defines the structure, validation rules, and constraints for the variable's value.
    /// </summary>
    public object? Schema { get; set; }
}

/// <summary>
/// Contains suggested input configurations that provide guidance on how to invoke the workflow.
/// Suggested inputs help users understand the expected input format and provide examples for workflow execution.
/// </summary>
public sealed class SuggestedInputs
{
    /// <summary>
    /// Gets or sets the list of suggested events that can be used to trigger the workflow.
    /// These events serve as examples or templates for valid workflow inputs.
    /// </summary>
    [YamlMember(Alias = "events")]
    [JsonPropertyName("events")]
    public List<SuggestedEvent>? Events { get; set; }
}

/// <summary>
/// Represents a suggested event that demonstrates how to trigger the workflow with specific input data.
/// Suggested events provide examples of valid event types and their associated payloads.
/// </summary>
public sealed class SuggestedEvent
{
    /// <summary>
    /// Gets or sets the type identifier of the suggested event.
    /// This type should match one of the event types that the workflow is configured to handle.
    /// </summary>
    [YamlMember(Alias = "type")]
    [JsonPropertyName("type")]
    public string Type { get; set; } = string.Empty;

    /// <summary>
    /// Gets or sets the payload data for the suggested event.
    /// The payload contains the data structure and values that would be passed with this type of event.
    /// </summary>
    [YamlMember(Alias = "payload")]
    [JsonPropertyName("payload")]
    public Dictionary<string, object>? Payload { get; set; }
}

/// <summary>
/// Defines the input configuration for a workflow, specifying what types of data the workflow can accept.
/// Inputs can include both events and message collections, allowing for flexible workflow triggering mechanisms.
/// </summary>
public sealed class Inputs
{
    /// <summary>
    /// Gets or sets the event input configuration for the workflow.
    /// This defines which types of events can trigger the workflow and how they should be processed.
    /// </summary>
    [YamlMember(Alias = "events")]
    [JsonPropertyName("events")]
    public InputEvents? Events { get; set; }

    /// <summary>
    /// Gets or sets the message input configuration for the workflow.
    /// This allows the workflow to be triggered with a collection of messages rather than events.
    /// </summary>
    [YamlMember(Alias = "messages")]
    [JsonPropertyName("messages")]
    public Messages? Messages { get; set; }
}

/// <summary>
/// Contains the event input configuration for a workflow, defining which events can trigger execution.
/// Event inputs allow workflows to be triggered by various types of external or internal events.
/// </summary>
public sealed class InputEvents
{
    /// <summary>
    /// Gets or sets the list of cloud events that can trigger the workflow.
    /// Cloud events follow the CloudEvents specification and provide a standardized way to describe events.
    /// </summary>
    [YamlMember(Alias = "cloud_events")]
    [JsonPropertyName("cloud_events")]
    public List<CloudEvent>? CloudEvents { get; set; }
}

/// <summary>
/// Represents a collection of messages that can be used as input to a workflow.
/// This class extends List to provide a strongly-typed collection for message objects.
/// </summary>
public sealed class Messages : List<object>
{
}

/// <summary>
/// Represents a CloudEvent that can trigger workflow execution.
/// CloudEvents provide a standardized format for describing events in a vendor-neutral way.
/// </summary>
public sealed class CloudEvent
{
    /// <summary>
    /// Gets or sets the type of the cloud event.
    /// The event type identifies the nature of the event and determines how it should be processed.
    /// </summary>
    [YamlMember(Alias = "type")]
    [JsonPropertyName("type")]
    public string Type { get; set; } = string.Empty;

    /// <summary>
    /// Gets or sets the data schema for the cloud event's payload.
    /// The data schema defines the structure and validation rules for the event's data content.
    /// </summary>
    [YamlMember(Alias = "data_schema")]
    [JsonPropertyName("data_schema")]
    public object? DataSchema { get; set; }

    /// <summary>
    /// Gets or sets the list of filters that determine whether this event should trigger the workflow.
    /// Filters allow for conditional processing based on event content or metadata.
    /// </summary>
    [YamlMember(Alias = "filters")]
    [JsonPropertyName("filters")]
    public List<ProcessFilter>? Filters { get; set; }
}

/// <summary>
/// Represents a filter condition that can be applied to events or other workflow data.
/// Filters are used to conditionally process or route data based on specified criteria.
/// </summary>
public sealed class ProcessFilter
{
    /// <summary>
    /// Gets or sets the filter expression that defines the condition.
    /// The expression is evaluated against the event or data to determine if the filter matches.
    /// </summary>
    [YamlMember(Alias = "filter")]
    [JsonPropertyName("filter")]
    public string FilterExpression { get; set; } = string.Empty;
}

/// <summary>
/// Represents a variable within the workflow context, including its type, default value, and access controls.
/// Variables provide state management and data sharing capabilities within the workflow execution environment.
/// </summary>
public sealed class Variable
{
    /// <summary>
    /// Gets or sets the type identifier of the variable.
    /// The type determines how the variable is stored, accessed, and manipulated during execution.
    /// </summary>
    [YamlMember(Alias = "type")]
    [JsonPropertyName("type")]
    public string Type { get; set; } = string.Empty;

    /// <summary>
    /// Gets or sets the default value assigned to the variable when it is first created.
    /// This value is used if no explicit initialization value is provided.
    /// </summary>
    [YamlMember(Alias = "default")]
    [JsonPropertyName("default")]
    public object? Default { get; set; }

    /// <summary>
    /// Gets or sets the scope in which the variable is accessible.
    /// Scope determines which parts of the workflow can read and modify the variable.
    /// </summary>
    [YamlMember(Alias = "scope")]
    [JsonPropertyName("scope")]
    public string? Scope { get; set; }

    /// <summary>
    /// Gets or sets a value indicating whether the variable can be modified after initialization.
    /// Immutable variables provide read-only access after their initial assignment.
    /// </summary>
    [YamlMember(Alias = "is_mutable")]
    [JsonPropertyName("is_mutable")]
    public bool? IsMutable { get; set; }

    /// <summary>
    /// Gets or sets the access control list (ACL) that defines which nodes can access this variable.
    /// ACLs provide fine-grained security control over variable access within the workflow.
    /// </summary>
    [YamlMember(Alias = "acls")]
    [JsonPropertyName("acls")]
    public List<WorkflowAccessControl>? Acls { get; set; }
}

/// <summary>
/// Defines an access control entry that specifies permissions for a workflow node to access a variable.
/// Access control entries provide security and isolation by restricting variable access to authorized nodes.
/// </summary>
public sealed class WorkflowAccessControl
{
    /// <summary>
    /// Gets or sets the identifier of the node that is granted access.
    /// This should match the ID of a node defined in the workflow's node collection.
    /// </summary>
    [YamlMember(Alias = "node")]
    [JsonPropertyName("node")]
    public string Node { get; set; } = string.Empty;

    /// <summary>
    /// Gets or sets the level of access granted to the node.
    /// Access levels typically include read, write, or read-write permissions.
    /// </summary>
    [YamlMember(Alias = "access")]
    [JsonPropertyName("access")]
    public string Access { get; set; } = string.Empty;
}

/// <summary>
/// Represents a schema definition used to validate and structure data within the workflow.
/// Schemas ensure data integrity and provide a contract for data exchange between workflow components.
/// </summary>
public sealed class WorkflowSchema
{
    /// <summary>
    /// Gets or sets the type of the schema (e.g., object, array, string).
    /// The type defines the fundamental structure that the schema validates.
    /// </summary>
    [YamlMember(Alias = "type")]
    [JsonPropertyName("type")]
    public string Type { get; set; } = string.Empty;

    /// <summary>
    /// Gets or sets the properties defined within the schema.
    /// Properties specify the individual fields and their validation rules for object-type schemas.
    /// </summary>
    [YamlMember(Alias = "properties")]
    [JsonPropertyName("properties")]
    public Dictionary<string, SchemaProperty>? Properties { get; set; }

    /// <summary>
    /// Gets or sets the list of required property names within the schema.
    /// Required properties must be present in any data that conforms to this schema.
    /// </summary>
    [YamlMember(Alias = "required")]
    [JsonPropertyName("required")]
    public List<string>? Required { get; set; }
}

/// <summary>
/// Represents a property definition within a schema, including its type, constraints, and references.
/// Schema properties define the validation rules and structure for individual fields within a schema.
/// </summary>
public sealed class SchemaProperty
{
    /// <summary>
    /// Gets or sets the data type of the schema property.
    /// The type determines what kind of values are valid for this property.
    /// </summary>
    [YamlMember(Alias = "type")]
    [JsonPropertyName("type")]
    public string? Type { get; set; }

    /// <summary>
    /// Gets or sets the item definition for array-type properties.
    /// This defines the structure and validation rules for elements within an array property.
    /// </summary>
    [YamlMember(Alias = "items")]
    [JsonPropertyName("items")]
    public SchemaItems? Items { get; set; }

    /// <summary>
    /// Gets or sets a reference to another schema definition.
    /// References allow for reuse of schema definitions and creation of complex nested structures.
    /// </summary>
    [YamlMember(Alias = "$ref")]
    [JsonPropertyName("$ref")]
    public string? Ref { get; set; }
}

/// <summary>
/// Defines the schema for items within an array-type schema property.
/// Schema items specify how individual elements in an array should be validated and structured.
/// </summary>
public sealed class SchemaItems
{
    /// <summary>
    /// Gets or sets the data type of the array items.
    /// This type applies to each individual element within the array.
    /// </summary>
    [YamlMember(Alias = "type")]
    [JsonPropertyName("type")]
    public string? Type { get; set; }
}

/// <summary>
/// Represents a single node within the workflow execution graph.
/// Nodes are the fundamental building blocks of a workflow, each performing a specific task or operation.
/// </summary>
public sealed class Node
{
    /// <summary>
    /// Gets or sets the unique identifier of the node within the workflow.
    /// This ID is used to reference the node in orchestration steps and other workflow configurations.
    /// </summary>
    [YamlMember(Alias = "id")]
    [JsonPropertyName("id")]
    public string Id { get; set; } = string.Empty;

    /// <summary>
    /// Gets or sets the type of the node, which determines its behavior and capabilities.
    /// Node types define the category of operation that the node performs within the workflow.
    /// </summary>
    [YamlMember(Alias = "type")]
    [JsonPropertyName("type")]
    public string Type { get; set; } = string.Empty;

    /// <summary>
    /// Gets or sets the version of the node implementation.
    /// Versioning allows for evolution of node behavior while maintaining backward compatibility.
    /// </summary>
    [YamlMember(Alias = "version")]
    [JsonPropertyName("version")]
    public string Version { get; set; } = string.Empty;

    /// <summary>
    /// Gets or sets the optional description of the node's purpose and behavior.
    /// Descriptions provide documentation and context for understanding the node's role in the workflow.
    /// </summary>
    [YamlMember(Alias = "description")]
    [JsonPropertyName("description")]
    public string? Description { get; set; }

    /// <summary>
    /// Gets or sets the agent definition associated with this node.
    /// Agents provide the actual implementation and execution logic for the node.
    /// </summary>
    [YamlMember(Alias = "agent")]
    [JsonPropertyName("agent")]
    public AgentDefinition? Agent { get; set; }

    /// <summary>
    /// Gets or sets the human-in-the-loop (HITL) mode for this node.
    /// HITL mode determines when and how human intervention is required during node execution.
    /// </summary>
    [YamlMember(Alias = "human_in_loop_mode")]
    [JsonPropertyName("human_in_loop_mode")]
    public HITLMode? HumanInLoopType { get; set; } = null;

    /// <summary>
    /// Gets or sets the input configuration for the node.
    /// Inputs define what data the node expects to receive when it is executed.
    /// </summary>
    [YamlMember(Alias = "inputs")]
    [JsonPropertyName("inputs")]
    public Dictionary<string, object>? Inputs { get; set; }

    /// <summary>
    /// Gets or sets the mapping configuration for agent inputs.
    /// This mapping defines how workflow data is transformed and passed to the associated agent.
    /// </summary>
    [YamlMember(Alias = "agent_input_mapping")]
    [JsonPropertyName("agent_input_mapping")]
    public Dictionary<string, string>? AgentInputMapping { get; set; }

    /// <summary>
    /// Gets or sets the actions to be executed when the node encounters an error.
    /// Error actions provide a mechanism for graceful error handling and recovery.
    /// </summary>
    [YamlMember(Alias = "on_error")]
    [JsonPropertyName("on_error")]
    public List<OnEventAction>? OnError { get; set; } = null;

    /// <summary>
    /// Gets or sets the actions to be executed when the node completes successfully.
    /// Completion actions allow for post-processing and workflow continuation logic.
    /// </summary>
    [YamlMember(Alias = "on_complete")]
    [JsonPropertyName("on_complete")]
    public List<OnEventAction>? OnComplete { get; set; } = null;
}

/// <summary>
/// Represents an agent configuration within a workflow node.
/// Agents provide the concrete implementation for node functionality and define how the node operates.
/// </summary>
public sealed class WorkflowAgent
{
    /// <summary>
    /// Gets or sets the type of the agent.
    /// The agent type determines the implementation class and capabilities available to the node.
    /// </summary>
    [YamlMember(Alias = "type")]
    [JsonPropertyName("type")]
    public string Type { get; set; } = string.Empty;

    /// <summary>
    /// Gets or sets the unique identifier of the agent instance.
    /// This ID can be used to reference specific agent configurations or implementations.
    /// </summary>
    [YamlMember(Alias = "id")]
    [JsonPropertyName("id")]
    public string Id { get; set; } = string.Empty;
}

/// <summary>
/// Defines the different types of input handling modes for agents within workflow nodes.
/// Input types determine how data is passed to and processed by the agent.
/// </summary>
public enum AgentInputType
{
    /// <summary>
    /// Inputs are assumed to be part of the conversation thread and are not passed separately.
    /// In this mode, the agent reads input from the current thread context.
    /// </summary>
    Thread,

    /// <summary>
    /// The agent expects structured input data passed directly as parameters.
    /// This mode provides explicit data passing with defined structure and validation.
    /// </summary>
    Structured
}

/// <summary>
/// Represents the input configuration for a workflow node.
/// Node inputs define the expected data structure and schema for information passed to the node.
/// </summary>
public sealed class NodeInputs
{
    /// <summary>
    /// Gets or sets the schema reference for the node's input structure.
    /// The schema defines the validation rules and structure for data passed to this node.
    /// </summary>
    [YamlMember(Alias = "schema")]
    [JsonPropertyName("schema")]
    public string? Schema { get; set; }
}

/// <summary>
/// Represents a reference to a schema definition.
/// Schema references allow for reuse of schema definitions across multiple workflow components.
/// </summary>
public sealed class SchemaReference
{
    /// <summary>
    /// Gets or sets the reference path to the schema definition.
    /// This reference follows JSON Schema reference syntax to point to another schema.
    /// </summary>
    [YamlMember(Alias = "$ref")]
    [JsonPropertyName("$ref")]
    public string? Ref { get; set; }
}

/// <summary>
/// Represents an action that can be executed in response to a workflow event.
/// Event actions provide the mechanism for conditional logic and dynamic workflow behavior.
/// </summary>
public sealed class OnEventAction
{
    /// <summary>
    /// Gets or sets the condition that must be met for this action to execute.
    /// Conditions allow for sophisticated conditional logic based on workflow state and event data.
    /// </summary>
    [YamlMember(Alias = "on_condition")]
    [JsonPropertyName("on_condition")]
    public DeclarativeProcessCondition? OnCondition { get; set; }
}

/// <summary>
/// Defines the types of conditions that can be used in workflow decision-making.
/// Condition types determine how and when conditional logic is evaluated.
/// </summary>
public enum DeclarativeProcessConditionType
{
    /// <summary>
    /// A condition that evaluates a custom expression against the current workflow state.
    /// Eval conditions provide maximum flexibility for custom conditional logic.
    /// </summary>
    [JsonPropertyName("eval")]
    Eval,

    /// <summary>
    /// A condition that always evaluates to true, regardless of context.
    /// Always conditions provide unconditional execution paths.
    /// </summary>
    [JsonPropertyName("always")]
    Always,

    /// <summary>
    /// A default condition that activates when no other conditions are met.
    /// Default conditions provide fallback behavior for unmatched scenarios.
    /// </summary>
    [JsonPropertyName("default")]
    Default
}

/// <summary>
/// Represents a condition that controls workflow execution flow and decision-making.
/// Conditions evaluate workflow state and determine which actions should be executed.
/// </summary>
public sealed class DeclarativeProcessCondition
{
    /// <summary>
    /// Gets or sets the type of condition evaluation to perform.
    /// The condition type determines how the condition expression is interpreted and evaluated.
    /// </summary>
    [YamlMember(Alias = "type")]
    [JsonPropertyName("type")]
    public DeclarativeProcessConditionType Type { get; set; } = DeclarativeProcessConditionType.Eval;

    /// <summary>
    /// Gets or sets the expression to evaluate for this condition.
    /// The expression syntax depends on the condition type and evaluation context.
    /// </summary>
    [YamlMember(Alias = "expression")]
    [JsonPropertyName("expression")]
    public string? Expression { get; set; }

    /// <summary>
    /// Gets or sets the list of events to emit when this condition is satisfied.
    /// Event emissions allow conditions to trigger additional workflow behavior.
    /// </summary>
    [YamlMember(Alias = "emits")]
    [JsonPropertyName("emits")]
    public List<EventEmission>? Emits { get; set; }

    /// <summary>
    /// Gets or sets the list of variable updates to perform when this condition is satisfied.
    /// Variable updates allow conditions to modify workflow state as part of their execution.
    /// </summary>
    [YamlMember(Alias = "updates")]
    [JsonPropertyName("updates")]
    public List<VariableUpdate>? Updates { get; set; }
}

/// <summary>
/// Represents an event emission that occurs when a condition is satisfied or an action is executed.
/// Event emissions provide a way to communicate state changes and trigger reactions throughout the workflow.
/// </summary>
public sealed class EventEmission
{
    /// <summary>
    /// Gets or sets the type identifier of the event being emitted.
    /// The event type determines how the event is processed and which listeners will respond to it.
    /// </summary>
    [YamlMember(Alias = "event_type")]
    [JsonPropertyName("event_type")]
    public string EventType { get; set; } = string.Empty;

    /// <summary>
    /// Gets or sets the schema reference for the event's payload structure.
    /// The schema ensures that emitted events conform to expected data structures.
    /// </summary>
    [YamlMember(Alias = "schema")]
    [JsonPropertyName("schema")]
    public SchemaReference? Schema { get; set; }

    /// <summary>
    /// Gets or sets the data payload included with the emitted event.
    /// The payload contains the actual data that will be passed to event listeners.
    /// </summary>
    [YamlMember(Alias = "payload")]
    [JsonPropertyName("payload")]
    public object? Payload { get; set; }
}

/// <summary>
/// Represents a condition expression that can be evaluated against workflow data.
/// Condition expressions provide structured conditional logic for workflow decision-making.
/// </summary>
public sealed class ConditionExpression
{
    /// <summary>
    /// Gets or sets the path to the variable or data being evaluated.
    /// The path uses dot notation to navigate through complex data structures.
    /// </summary>
    public string Path { get; set; } = string.Empty;

    /// <summary>
    /// Gets or sets the comparison operator used in the condition.
    /// The operator determines how the value at the path is compared to the condition value.
    /// </summary>
    public ConditionOperator Operator { get; set; } = ConditionOperator.Equal;

    /// <summary>
    /// Gets or sets the value to compare against the path value.
    /// This value is used with the operator to determine if the condition is satisfied.
    /// </summary>
    public object Value { get; set; } = string.Empty;
}

/// <summary>
/// Defines the comparison operators available for use in condition expressions.
/// Operators determine how values are compared in conditional logic.
/// </summary>
public enum ConditionOperator
{
    /// <summary>
    /// Tests whether two values are equal.
    /// </summary>
    [JsonPropertyName("equal")]
    Equal,
    /// <summary>
    /// Tests whether two values are not equal.
    /// </summary>
    NotEqual,
    /// <summary>
    /// Tests whether the left value is greater than the right value.
    /// </summary>
    GreaterThan,
    /// <summary>
    /// Tests whether the left value is less than the right value.
    /// </summary>
    LessThan,
    /// <summary>
    /// Tests whether the left value is greater than or equal to the right value.
    /// </summary>
    GreaterThanOrEqual,
    /// <summary>
    /// Tests whether the left value is less than or equal to the right value.
    /// </summary>
    LessThanOrEqual
}

/// <summary>
/// Defines the types of operations that can be performed when updating workflow state variables.
/// Update operations provide different ways to modify variable values during workflow execution.
/// </summary>
public enum StateUpdateOperations
{
    /// <summary>
    /// Sets the variable to a specific value, replacing any existing value.
    /// </summary>
    [YamlMember(Alias = "set")]
    [JsonPropertyName("set")]
    Set,

    /// <summary>
    /// Increments the variable's value by a specified amount.
    /// This operation is typically used with numeric variables.
    /// </summary>
    [YamlMember(Alias = "increment")]
    [JsonPropertyName("increment")]
    Increment,

    /// <summary>
    /// Decrements the variable's value by a specified amount.
    /// This operation is typically used with numeric variables.
    /// </summary>
    [YamlMember(Alias = "decrement")]
    [JsonPropertyName("decrement")]
    Decrement
}

/// <summary>
/// Defines the modes for human-in-the-loop (HITL) interaction within workflow nodes.
/// HITL modes determine when and how human intervention is required during workflow execution.
/// </summary>
public enum HITLMode
{
    /// <summary>
    /// Always requires human input before the node can proceed with execution.
    /// This mode ensures that human oversight is mandatory for every execution of the node.
    /// </summary>
    [YamlMember(Alias = "always")]
    [JsonPropertyName("always")]
    Always,

    /// <summary>
    /// Never requires human input and allows the node to execute automatically.
    /// This mode provides fully automated execution without human intervention.
    /// </summary>
    [YamlMember(Alias = "never")]
    [JsonPropertyName("never")]
    Never,
}

/// <summary>
/// Represents an update operation to be performed on a workflow variable.
/// Variable updates allow workflows to modify state based on conditions and execution flow.
/// </summary>
[DataContract]
public sealed class VariableUpdate
{
    /// <summary>
    /// Gets or sets the path to the variable to be updated.
    /// The path uses dot notation to specify the exact location of the variable in the state.
    /// </summary>
    [YamlMember(Alias = "path")]
    [JsonPropertyName("path")]
    [DataMember]
    public string Path { get; set; } = string.Empty;

    /// <summary>
    /// Gets or sets the operation to be performed on the variable.
    /// The operation determines how the variable's value will be modified (set, increment, decrement).
    /// </summary>
    [YamlMember(Alias = "operation")]
    [JsonPropertyName("operation")]
    [DataMember]
    public StateUpdateOperations Operation { get; set; }

    /// <summary>
    /// Gets or sets the value to be used in the update operation.
    /// For set operations, this becomes the new value. For increment/decrement, this is the amount to change.
    /// </summary>
    [YamlMember(Alias = "value")]
    [JsonPropertyName("value")]

    public object? Value { get; set; } = string.Empty;
}

/// <summary>
/// Represents a single step in the workflow orchestration that defines conditional execution logic.
/// Orchestration steps control the flow of execution by listening for events and taking appropriate actions.
/// </summary>
public sealed class OrchestrationStep
{
    /// <summary>
    /// Gets or sets the condition that this orchestration step listens for.
    /// The listen condition determines when this step should be activated and executed.
    /// </summary>
    [YamlMember(Alias = "listen_for")]
    [JsonPropertyName("listen_for")]
    public ListenCondition? ListenFor { get; set; }

    /// <summary>
    /// Gets or sets the list of actions to execute when the listen condition is satisfied.
    /// These actions define what should happen when the orchestration step is triggered.
    /// </summary>
    [YamlMember(Alias = "then")]
    [JsonPropertyName("then")]
    public List<ThenAction>? Then { get; set; }
}

/// <summary>
/// Represents a condition that an orchestration step listens for to determine when to execute its actions.
/// Listen conditions can be based on events, state changes, or complex logical expressions.
/// </summary>
public sealed class ListenCondition
{
    /// <summary>
    /// Gets or sets the specific event name to listen for.
    /// When specified, the condition will trigger when this event is emitted.
    /// </summary>
    [YamlMember(Alias = "event")]
    [JsonPropertyName("event")]
    public string? Event { get; set; }

    /// <summary>
    /// Gets or sets the source of the event being listened for.
    /// This specifies which node or component must emit the event for the condition to trigger.
    /// </summary>
    [YamlMember(Alias = "from")]
    [JsonPropertyName("from")]
    public string? From { get; set; }

    /// <summary>
    /// Gets or sets a custom condition expression for more complex logic.
    /// This allows for sophisticated conditional logic beyond simple event matching.
    /// </summary>
    [YamlMember(Alias = "condition")]
    [JsonPropertyName("condition")]
    public string? Condition { get; set; }

    /// <summary>
    /// Gets or sets a list of events that must all occur for the condition to be satisfied.
    /// This provides AND logic for multiple event requirements.
    /// </summary>
    [YamlMember(Alias = "all_of")]
    [JsonPropertyName("all_of")]
    public List<ListenEvent>? AllOf { get; set; }
}

/// <summary>
/// Represents a specific event to listen for in workflow orchestration.
/// Listen events specify both the event name and its source for precise event matching.
/// </summary>
public sealed class ListenEvent
{
    /// <summary>
    /// Gets or sets the name of the event to listen for.
    /// This identifies the specific type of event that should trigger the condition.
    /// </summary>
    [YamlMember(Alias = "event")]
    [JsonPropertyName("event")]
    public string Event { get; set; } = string.Empty;

    /// <summary>
    /// Gets or sets the source identifier from which the event must originate.
    /// This ensures the event comes from the expected node or component.
    /// </summary>
    [YamlMember(Alias = "from")]
    [JsonPropertyName("from")]
    public string From { get; set; } = string.Empty;
}

/// <summary>
/// Represents an action to be executed as part of workflow orchestration logic.
/// Actions define what should happen when orchestration conditions are met.
/// </summary>
public sealed class ThenAction
{
    /// <summary>
    /// Gets or sets the type of action to be performed.
    /// The action type determines the specific operation (node invocation, state update, event emission).
    /// </summary>
    [YamlMember(Alias = "type")]
    [JsonPropertyName("type")]
    public ActionType Type { get; set; }

    /// <summary>
    /// Gets or sets the identifier of the node to execute when the action type is NodeInvocation.
    /// This specifies which workflow node should be activated.
    /// </summary>
    [YamlMember(Alias = "node")]
    [JsonPropertyName("node")]
    public string? Node { get; set; }

    /// <summary>
    /// Gets or sets the input mappings to pass to the invoked node.
    /// These inputs provide data that the target node needs for execution.
    /// </summary>
    [YamlMember(Alias = "inputs")]
    [JsonPropertyName("inputs")]
    public Dictionary<string, string>? Inputs { get; set; }

    /// <summary>
    /// Gets or sets the expression that resolves to messages to be passed to the node.
    /// This allows for dynamic message passing based on workflow state.
    /// </summary>
    [YamlMember(Alias = "messages_in")]
    [JsonPropertyName("messages_in")]
    public List<string>? MessagesIn { get; set; }

    /// <summary>
    /// Gets or sets the thread identifier to send the event to.
    /// This specifies which conversation thread should receive the action's output.
    /// </summary>
    [YamlMember(Alias = "thread")]
    [JsonPropertyName("thread")]
    public string? Thread { get; set; }

    /// <summary>
    /// Gets or sets the path to the variable to be updated when the action type is Update.
    /// This specifies which workflow variable should be modified.
    /// </summary>
    [YamlMember(Alias = "path")]
    [JsonPropertyName("path")]
    public string? Path { get; set; }

    /// <summary>
    /// Gets or sets the operation to be performed on the variable when the action type is Update.
    /// This determines how the variable's value should be changed.
    /// </summary>
    [YamlMember(Alias = "operation")]
    [JsonPropertyName("operation")]
    public StateUpdateOperations? Operation { get; set; }

    /// <summary>
    /// Gets or sets the value to be used in the update operation or as event payload.
    /// For updates, this is the value to set, increment by, or decrement by.
    /// </summary>
    [YamlMember(Alias = "value")]
    [JsonPropertyName("value")]
    public object? Value { get; set; }

    /// <summary>
    /// Gets or sets the type of message to emit when the action type is Emit.
    /// This specifies what kind of event should be generated by the action.
    /// </summary>
    [YamlMember(Alias = "event_type")]
    [JsonPropertyName("event_type")]
    public string? EmitMessageType { get; set; }

    /// <summary>
    /// Gets or sets the payload data to include with the emitted message.
    /// This provides the data content that will be sent with the emitted event.
    /// </summary>
    [YamlMember(Alias = "payload")]
    [JsonPropertyName("payload")]
    public Dictionary<string, string>? EmitMessagePayload { get; set; }

    /// <summary>
    /// Creates a new instance of the <see cref="ThenAction"/> class from a <see cref="KernelProcessEdge"/>.
    /// This factory method converts internal kernel edge representations to workflow action configurations.
    /// </summary>
    /// <param name="edge">The kernel process edge to convert.</param>
    /// <param name="defaultThread">The default thread identifier to use if none is specified.</param>
    /// <returns>A new <see cref="ThenAction"/> instance representing the edge's behavior.</returns>
    /// <exception cref="KernelException">Thrown when the edge target type is not supported.</exception>
    public static ThenAction FromKernelProcessEdge(KernelProcessEdge edge, string? defaultThread)
    {
        if (edge.OutputTarget is KernelProcessStateTarget stateTarget)
        {
            return new ThenAction
            {
                Type = ActionType.Update,
                Path = stateTarget.VariableUpdate.Path,
                Operation = stateTarget.VariableUpdate.Operation,
                Value = stateTarget.VariableUpdate.Value
            };
        }
        if (edge.OutputTarget is KernelProcessFunctionTarget functionTarget)
        {
            return new ThenAction()
            {
                Type = ActionType.NodeInvocation,
                Node = functionTarget.StepId == ProcessConstants.EndStepName ? "End" : functionTarget.StepId,
            };
        }
        if (edge.OutputTarget is KernelProcessEmitTarget emitTarget)
        {
            return new ThenAction
            {
                Type = ActionType.Emit,
                EmitMessageType = emitTarget.EventName,
                EmitMessagePayload = emitTarget.Payload,
            };
        }
        if (edge.OutputTarget is KernelProcessAgentInvokeTarget agentInvokeTarget)
        {
            return new ThenAction()
            {
                Type = ActionType.NodeInvocation,
                Node = agentInvokeTarget.StepId == ProcessConstants.EndStepName ? "End" : agentInvokeTarget.StepId,
                Inputs = agentInvokeTarget.InputEvals,
                MessagesIn = agentInvokeTarget.MessagesInEval,
                Thread = agentInvokeTarget.ThreadEval
            };
        }

        throw new KernelException("Unsupported target type");
    }
}

/// <summary>
/// Defines the types of actions that can be performed in workflow orchestration.
/// Action types determine what kind of operation should be executed when conditions are met.
/// </summary>
public enum ActionType
{
    /// <summary>
    /// An action that invokes a specific workflow node to execute its logic.
    /// Node invocation actions transfer control to another part of the workflow.
    /// </summary>
    NodeInvocation,

    /// <summary>
    /// An action that updates the value of a workflow variable or state.
    /// Update actions allow workflows to modify their internal state during execution.
    /// </summary>
    Update,

    /// <summary>
    /// An action that emits an event to notify other parts of the workflow.
    /// Emit actions provide a communication mechanism between workflow components.
    /// </summary>
    Emit
}

/// <summary>
/// Represents a version range specification for compatibility checking.
/// Version ranges allow workflows to specify which versions of components they are compatible with.
/// </summary>
public sealed class VersionRange
{
    /// <summary>
    /// Gets or sets the minimum version included in this range.
    /// The minimum version is inclusive, meaning this version is considered part of the range.
    /// </summary>
    [YamlMember(Alias = "min_version")]
    [JsonPropertyName("min_version")]
    public string MinVersion { get; set; } = string.Empty;

    /// <summary>
    /// Gets or sets the maximum version excluded from this range.
    /// The maximum version is exclusive, meaning this version is not included in the range.
    /// </summary>
    [YamlMember(Alias = "max_version_exclusive")]
    [JsonPropertyName("max_version_exclusive")]
    public string MaxVersionExclusive { get; set; } = string.Empty;
}

/// <summary>
/// Represents the error handling configuration for a workflow.
/// Error handling defines how the workflow should respond to and recover from various types of errors.
/// </summary>
public sealed class ErrorHandling
{
    /// <summary>
    /// Gets or sets the specific error handling steps that respond to particular error conditions.
    /// These steps provide targeted error handling for specific scenarios or error types.
    /// </summary>
    [YamlMember(Alias = "on_error")]
    [JsonPropertyName("on_error")]
    public List<ErrorHandlingStep>? OnError { get; set; }

    /// <summary>
    /// Gets or sets the default actions to be taken when no specific error handling matches.
    /// Default actions provide fallback behavior for unexpected or unhandled error conditions.
    /// </summary>
    [YamlMember(Alias = "default")]
    [JsonPropertyName("default")]
    public List<ThenAction>? Default { get; set; }
}

/// <summary>
/// Represents a single error handling step that responds to specific error conditions.
/// Error handling steps provide conditional logic for responding to different types of errors.
/// </summary>
public sealed class ErrorHandlingStep
{
    /// <summary>
    /// Gets or sets the condition that determines when this error handling step should be activated.
    /// The listen condition specifies which error events or conditions trigger this step.
    /// </summary>
    [YamlMember(Alias = "listen_for")]
    [JsonPropertyName("listen_for")]
    public ErrorListenCondition? ListenFor { get; set; }

    /// <summary>
    /// Gets or sets the actions to execute when the error condition is met.
    /// These actions define the error recovery or handling logic for the specific error scenario.
    /// </summary>
    [YamlMember(Alias = "then")]
    [JsonPropertyName("then")]
    public List<ThenAction>? Then { get; set; }
}

/// <summary>
/// Represents a condition that triggers error handling logic in the workflow.
/// Error listen conditions specify which types of errors should activate error handling steps.
/// </summary>
public sealed class ErrorListenCondition
{
    /// <summary>
    /// Gets or sets the name of the error event to listen for.
    /// This identifies the specific type of error that should trigger the associated error handling actions.
    /// </summary>
    [YamlMember(Alias = "event")]
    [JsonPropertyName("event")]
    public string Event { get; set; } = string.Empty;
}


===== Process.Core\AssemblyInfo.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Diagnostics.CodeAnalysis;

// This assembly is currently experimental.
[assembly: Experimental("SKEXP0080")]


===== Process.Core\DeclarativeConditionContentWrapper.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Text.Json.Serialization;

namespace Microsoft.SemanticKernel;

/// <summary>
/// Wrapper class for the content of a declarative condition.
/// </summary>
public class DeclarativeConditionContentWrapper
{
    /// <summary>
    /// The state of the process.
    /// </summary>
    [JsonPropertyName("_state_")]
    public object? State { get; set; }

    /// <summary>
    /// The event data associated with the process.
    /// </summary>
    [JsonPropertyName("_event_")]
    public object? Event { get; set; }
}

/// <summary>
/// Wrapper class for the content of a state resolver.
/// </summary>
public class StateResolverContentWrapper
{
    /// <summary>
    /// The state of the process.
    /// </summary>
    [JsonPropertyName("_state_")]
    public object? State { get; set; }
}


===== Process.Core\Internal\EndStep.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using Microsoft.SemanticKernel.Process.Internal;
using Microsoft.SemanticKernel.Process.Models;

namespace Microsoft.SemanticKernel;

/// <summary>
/// EndStep is a special purpose step that is used to trigger a process to stop. It is the last step in a process.
/// </summary>
internal sealed class EndStep : ProcessStepBuilder
{
    /// <summary>
    /// The static instance of the <see cref="EndStep"/> class.
    /// </summary>
    public static EndStep Instance { get; } = new EndStep();

    /// <summary>
    /// Represents the end of a process.
    /// </summary>
    internal EndStep()
        : base(id: ProcessConstants.EndStepName, null)
    {
    }

    internal override Dictionary<string, KernelFunctionMetadata> GetFunctionMetadataMap()
    {
        // The end step has no functions.
        return [];
    }

    internal override KernelProcessStepInfo BuildStep(ProcessBuilder processBuilder, KernelProcessStepStateMetadata? stateMetadata = null)
    {
        // The end step has no state.
        return new KernelProcessStepInfo(typeof(KernelProcessStepState), new KernelProcessStepState(ProcessConstants.EndStepName, version: ProcessConstants.InternalStepsVersion), []);
    }
}


===== Process.Core\Internal\KernelProcessStateMetadataExtension.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Linq;
using Microsoft.SemanticKernel.Process.Models;

namespace Microsoft.SemanticKernel.Process.Internal;

internal static class KernelProcessStateMetadataExtension
{
    public static List<KernelProcessStepInfo> BuildWithStateMetadata(this ProcessBuilder processBuilder, KernelProcessStateMetadata? stateMetadata)
    {
        List<KernelProcessStepInfo> builtSteps = [];
        // 1- Validate StateMetadata: Migrate previous state versions if needed + sanitize state
        KernelProcessStateMetadata? sanitizedMetadata = null;
        if (stateMetadata != null)
        {
            sanitizedMetadata = SanitizeProcessStateMetadata(processBuilder, stateMetadata, processBuilder.Steps);
        }

        // 2- Build steps info with validated stateMetadata
        foreach (ProcessStepBuilder step in processBuilder.Steps)
        {
            if (sanitizedMetadata != null && sanitizedMetadata.StepsState != null && sanitizedMetadata.StepsState.TryGetValue(step.Name, out var stepStateObject) && stepStateObject != null)
            {
                builtSteps.Add(step.BuildStep(processBuilder, stepStateObject));
                continue;
            }

            builtSteps.Add(step.BuildStep(processBuilder));
        }

        return builtSteps;
    }

    private static KernelProcessStateMetadata SanitizeProcessStateMetadata(ProcessBuilder processBuilder, KernelProcessStateMetadata stateMetadata, IReadOnlyList<ProcessStepBuilder> stepBuilders)
    {
        KernelProcessStateMetadata sanitizedStateMetadata = stateMetadata;
        foreach (ProcessStepBuilder step in stepBuilders)
        {
            // 1- find matching key name with exact match or by alias match
            string? stepKey = null;

            if (sanitizedStateMetadata.StepsState != null && sanitizedStateMetadata.StepsState.ContainsKey(step.Name))
            {
                stepKey = step.Name;
            }
            else
            {
                stepKey = step.Aliases
                    .Where(alias => sanitizedStateMetadata.StepsState != null && sanitizedStateMetadata.StepsState.ContainsKey(alias))
                    .FirstOrDefault();
            }

            // 2- stepKey match found
            if (stepKey != null)
            {
                var currentVersionStateMetadata = step.BuildStep(processBuilder).ToProcessStateMetadata();
                if (sanitizedStateMetadata.StepsState!.TryGetValue(stepKey, out var savedStateMetadata))
                {
                    if (stepKey != step.Name)
                    {
                        if (savedStateMetadata.VersionInfo == currentVersionStateMetadata.VersionInfo)
                        {
                            // key mismatch only, but same version
                            sanitizedStateMetadata.StepsState[step.Name] = savedStateMetadata;
                            // TODO: Should there be state formatting check too?
                        }
                        else
                        {
                            // version mismatch - check if migration logic in place
                            if (step is ProcessBuilder subprocessBuilder)
                            {
                                KernelProcessStateMetadata sanitizedStepState = SanitizeProcessStateMetadata(processBuilder, (KernelProcessStateMetadata)savedStateMetadata, subprocessBuilder.Steps);
                                sanitizedStateMetadata.StepsState[step.Name] = sanitizedStepState;
                            }
                            else if (step is ProcessMapBuilder mapBuilder)
                            {
                                KernelProcessStateMetadata sanitizedStepState = SanitizeProcessStateMetadata(processBuilder, (KernelProcessStateMetadata)savedStateMetadata, [mapBuilder.MapOperation]);
                                sanitizedStateMetadata.StepsState[step.Name] = sanitizedStepState;
                            }
                            else if (false)
                            {
                                // TODO: Improvements for support on advance versioning scenarios process M:N steps differences https://github.com/microsoft/semantic-kernel/issues/9555
                            }
                            else
                            {
                                // no compatible state found, migrating id only
                                sanitizedStateMetadata.StepsState[step.Name] = new KernelProcessStepStateMetadata()
                                {
                                    Name = step.Name,
                                    Id = step.Id,
                                };
                            }
                        }
                        sanitizedStateMetadata.StepsState[step.Name].Name = step.Name;
                        sanitizedStateMetadata.StepsState.Remove(stepKey);
                    }
                }
            }
        }

        return sanitizedStateMetadata;
    }
}


===== Process.Core\Internal\ProcessEventData.cs =====

// Copyright (c) Microsoft. All rights reserved.

namespace Microsoft.SemanticKernel.Process.Internal;
internal class ProcessEventData
{
    /// <summary>
    /// SK Process Event Id, id assigned during runtime
    /// </summary>
    public string EventId { get; init; } = string.Empty;

    /// <summary>
    /// SK Process Event Name, human readable, defined when creating the process builder
    /// </summary>
    public string EventName { get; init; } = string.Empty;
}


===== Process.Core\KernelProcessEdgeGroupBuilder.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;

namespace Microsoft.SemanticKernel;
/// <summary>
/// Represents a group of edges in a kernel process.
/// </summary>
public sealed class KernelProcessEdgeGroupBuilder
{
    /// <summary>
    /// Initializes a new instance of the <see cref="KernelProcessEdgeGroup"/> class.
    /// </summary>
    /// <param name="groupId"></param>
    /// <param name="messageSources"></param>
    public KernelProcessEdgeGroupBuilder(string groupId, List<MessageSourceBuilder> messageSources)
    {
        Verify.NotNullOrEmpty(messageSources, nameof(messageSources));

        this.GroupId = groupId;
        this.MessageSources = messageSources;
    }

    /// <summary>
    /// Gets the unique identifier for this edge group.
    /// </summary>
    public string GroupId { get; }

    /// <summary>
    /// Gets the list of message sources that this edge group is listening to.
    /// </summary>
    public List<MessageSourceBuilder> MessageSources { get; }

    /// <summary>
    /// Gets the input mapping function for this edge group.
    /// </summary>
    public Func<Dictionary<string, object?>, Dictionary<string, object?>>? InputMapping { get; internal set; }
}


===== Process.Core\ListenForBuilder.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Cryptography;
using System.Text;

namespace Microsoft.SemanticKernel;

/// <summary>
/// Builder class for defining conditions to listen for in a process.
/// </summary>
public sealed class ListenForBuilder
{
    private readonly ProcessBuilder _processBuilder;
    private ListenForTargetBuilder? _targetBuilder;

    /// <summary>
    /// Initializes a new instance of the <see cref="ListenForBuilder"/> class.
    /// </summary>
    /// <param name="processBuilder">The process builder.</param>
    public ListenForBuilder(ProcessBuilder processBuilder)
    {
        this._processBuilder = processBuilder;
    }

    /// <summary>
    /// Listens for an input event.
    /// </summary>
    /// <param name="eventName"></param>
    /// <param name="condition"></param>
    /// <returns></returns>
    internal ListenForTargetBuilder InputEvent(string eventName, KernelProcessEdgeCondition? condition = null)
    {
        this._targetBuilder = new ListenForTargetBuilder([new(eventName, this._processBuilder, condition)], this._processBuilder);
        return this._targetBuilder;
    }

    /// <summary>
    /// Defines a message to listen for from a specific process step.
    /// </summary>
    /// <param name="messageType">The type of the message.</param>
    /// <param name="from">The process step from which the message originates.</param>
    /// <param name="condition">Condition that must be met for the message to be processed</param>
    /// <returns>A builder for defining the target of the message.</returns>
    public ListenForTargetBuilder Message(string messageType, ProcessStepBuilder from, KernelProcessEdgeCondition? condition = null)
    {
        Verify.NotNullOrWhiteSpace(messageType, nameof(messageType));
        Verify.NotNull(from, nameof(from));

        this._targetBuilder = new ListenForTargetBuilder([new(messageType, from, condition)], this._processBuilder);
        return this._targetBuilder;
    }

    /// <summary>
    /// Defines a message to listen for from a specific process step.
    /// </summary>
    /// <param name="from">The process step from which the message originates.</param>
    /// <param name="condition">Condition that must be met for the message to be processed</param>
    /// <returns>A builder for defining the target of the message.</returns>
    public ListenForTargetBuilder OnResult(ProcessStepBuilder from, KernelProcessEdgeCondition? condition = null)
    {
        Verify.NotNull(from, nameof(from));

        this._targetBuilder = new ListenForTargetBuilder([new("Invoke.OnResult", from, condition)], this._processBuilder);
        return this._targetBuilder;
    }

    /// <summary>
    /// Defines a condition to listen for all of the specified message sources.
    /// </summary>
    /// <param name="messageSources">The list of message sources.</param>
    /// <returns>A builder for defining the target of the messages.</returns>
    public ListenForTargetBuilder AllOf(List<MessageSourceBuilder> messageSources)
    {
        Verify.NotNullOrEmpty(messageSources, nameof(messageSources));

        var edgeGroup = new KernelProcessEdgeGroupBuilder(this.GetGroupId(messageSources), messageSources);
        this._targetBuilder = new ListenForTargetBuilder(messageSources, this._processBuilder, edgeGroup: edgeGroup);
        return this._targetBuilder;
    }

    private string GetGroupId(List<MessageSourceBuilder> messageSources)
    {
        var sortedKeys = messageSources
            .Select(source => $"{source.Source.Id}.{source.MessageType}")
            .OrderBy(id => id, StringComparer.OrdinalIgnoreCase)
            .ToList();

        return GenerateHash(sortedKeys);
    }

    /// <summary>
    /// Produces a base-64 encoded hash for a set of input strings.
    /// </summary>
    /// <param name="keys">A set of input strings</param>
    /// <returns>A base-64 encoded hash</returns>
    private static string GenerateHash(IEnumerable<string> keys)
    {
        byte[] buffer = Encoding.UTF8.GetBytes(string.Join(":", keys));

#if NET
        Span<byte> hash = stackalloc byte[32];
        SHA256.HashData(buffer, hash);
#else
        using SHA256 shaProvider = SHA256.Create();
        byte[] hash = shaProvider.ComputeHash(buffer);
#endif

        return Convert.ToBase64String(hash);
    }
}


===== Process.Core\ListenForTargetBuilder.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using Microsoft.SemanticKernel.Process.Internal;

namespace Microsoft.SemanticKernel;

/// <summary>
/// Builder class for defining targets to listen for in a process.
/// </summary>
public sealed partial class ListenForTargetBuilder : ProcessStepEdgeBuilder
{
    private readonly ProcessBuilder _processBuilder;
    private readonly List<MessageSourceBuilder> _messageSources = [];

    /// <summary>
    /// Initializes a new instance of the <see cref="ListenForTargetBuilder"/> class.
    /// </summary>
    /// <param name="messageSources">The list of message sources.</param>
    /// <param name="processBuilder">The process builder.</param>
    /// <param name="edgeGroup">The group ID for the message sources.</param>
    public ListenForTargetBuilder(List<MessageSourceBuilder> messageSources, ProcessBuilder processBuilder, KernelProcessEdgeGroupBuilder? edgeGroup = null) : base(processBuilder, "Aggregate", "Aggregate", edgeGroupBuilder: edgeGroup)
    {
        Verify.NotNullOrEmpty(messageSources, nameof(messageSources));
        this._messageSources = messageSources;
        this._processBuilder = processBuilder;
    }

    /// <summary>
    /// Signals that the output of the source step should be sent to the specified target when the associated event fires.
    /// </summary>
    /// <param name="target">The output target.</param>
    /// <returns>A fresh builder instance for fluid definition</returns>
    public ProcessStepEdgeBuilder SendEventTo(ProcessStepTargetBuilder target)
    {
        return this.SendEventTo_Internal(target);
    }

    /// <summary>
    /// Signals that the specified state variable should be updated in the process state.
    /// </summary>
    /// <param name="path"></param>
    /// <param name="operation"></param>
    /// <param name="value"></param>
    /// <returns></returns>
    internal ListenForTargetBuilder UpdateProcessState(string path, StateUpdateOperations operation, object? value)
    {
        Verify.NotNullOrWhiteSpace(path);

        if (!path.StartsWith(ProcessConstants.Declarative.VariablePrefix, StringComparison.OrdinalIgnoreCase))
        {
            path = $"{ProcessConstants.Declarative.VariablePrefix}.{path}";
        }

        // TODO: Should metadata go into the target now?
        this.VariableUpdate = new VariableUpdate { Path = path, Operation = operation, Value = value };
        this.SendEventTo_Internal(new ProcessStateTargetBuilder(this.VariableUpdate));

        return new ListenForTargetBuilder(this._messageSources, this._processBuilder, this.EdgeGroupBuilder);
    }

    /// <summary>
    /// Signals that the specified event should be emitted.
    /// </summary>
    /// <param name="eventName"></param>
    /// <param name="payload"></param>
    /// <returns></returns>
    internal ListenForTargetBuilder EmitEvent(string eventName, Dictionary<string, string>? payload = null)
    {
        Verify.NotNullOrWhiteSpace(eventName, nameof(eventName));
        this.SendEventTo_Internal(new ProcessEmitTargetBuilder(eventName, payload));
        return new ListenForTargetBuilder(this._messageSources, this._processBuilder, this.EdgeGroupBuilder);
    }

    /// <summary>
    /// Sends the event to the specified target.
    /// </summary>
    /// <param name="target">The target to send the event to.</param>
    /// <returns>A new instance of <see cref="ListenForTargetBuilder"/>.</returns>
    internal override ProcessStepEdgeBuilder SendEventTo_Internal(ProcessTargetBuilder target)
    {
        foreach (var messageSource in this._messageSources)
        {
            if (messageSource.Source == null)
            {
                throw new InvalidOperationException("Source step cannot be null.");
            }

            // Link all the source steps to the event listener
            var onEventBuilder = messageSource.Source.OnEvent(messageSource.MessageType);
            onEventBuilder.EdgeGroupBuilder = this.EdgeGroupBuilder;

            if (messageSource.Condition != null)
            {
                onEventBuilder.Condition = messageSource.Condition;
            }
            onEventBuilder.SendEventTo(target);
        }

        return new ListenForTargetBuilder(this._messageSources, this._processBuilder, edgeGroup: this.EdgeGroupBuilder);
    }

    /// <summary>
    /// Signals that the process should be stopped.
    /// </summary>
    public override void StopProcess()
    {
        var target = new ProcessFunctionTargetBuilder(EndStep.Instance);

        foreach (var messageSource in this._messageSources)
        {
            if (messageSource.Source == null)
            {
                throw new InvalidOperationException("Source step cannot be null.");
            }

            // Link all the source steps to the event listener
            var onEventBuilder = messageSource.Source.OnEvent(messageSource.MessageType);
            onEventBuilder.EdgeGroupBuilder = this.EdgeGroupBuilder;
            onEventBuilder.SendEventTo(target);
        }
    }
}


===== Process.Core\MessageSourceBuilder.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Threading.Tasks;

namespace Microsoft.SemanticKernel;

/// <summary>
/// Represents a builder for defining the source of a message in a process.
/// </summary>
public sealed class MessageSourceBuilder
{
    /// <summary>
    /// Initializes a new instance of the <see cref="MessageSourceBuilder"/> class.
    /// </summary>
    /// <param name="messageType">The meassage type</param>
    /// <param name="source">The source step builder</param>
    /// <param name="condition">Condition that must be met for the message to be processed</param>
    public MessageSourceBuilder(string messageType, ProcessStepBuilder source, KernelProcessEdgeCondition? condition = null)
    {
        this.MessageType = messageType;
        this.Source = source;
        this.Condition = condition ?? new KernelProcessEdgeCondition((_, _) => Task.FromResult(true));
    }

    /// <summary>
    /// The message type
    /// </summary>
    public string MessageType { get; }

    /// <summary>
    /// The source step builder.
    /// </summary>
    public ProcessStepBuilder Source { get; }

    /// <summary>
    /// The condition that must be met for the message to be processed.
    /// </summary>
    public KernelProcessEdgeCondition Condition { get; }
}


===== Process.Core\ProcessAgentBuilder.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Text;
using Json.More;
using Json.Schema;
using Json.Schema.Generation;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.Process.Models;

namespace Microsoft.SemanticKernel;

/// <summary>
/// Builder for a process step that represents an agent.
/// </summary>
public class ProcessAgentBuilder<TProcessState> : ProcessStepBuilder<KernelProcessAgentExecutor> where TProcessState : class, new()
{
    private readonly AgentDefinition _agentDefinition;

    internal Dictionary<string, string> _defaultInputBindings = [];

    /// <summary>
    /// Creates a new instance of the <see cref="ProcessAgentBuilder"/> class.
    /// </summary>
    /// <param name="agentDefinition"></param>
    /// <param name="threadName"></param>
    /// <param name="nodeInputs"></param>
    /// <param name="processBuilder"></param>
    /// <param name="stepId">Id of the step. If not provided, the Id will come from the agent Id.</param>
    /// <exception cref="KernelException"></exception>
    public ProcessAgentBuilder(AgentDefinition agentDefinition, string threadName, Dictionary<string, Type> nodeInputs, ProcessBuilder? processBuilder, string? stepId = null)
        : base(id: stepId ?? agentDefinition.Id ?? agentDefinition.Name ?? throw new KernelException("All declarative agents must have an Id or a Name assigned."), processBuilder)
    {
        Verify.NotNull(agentDefinition);
        this._agentDefinition = agentDefinition;
        this.DefaultThreadName = threadName;
        this.Inputs = nodeInputs;
    }

    /// <summary>
    /// Creates a new instance of the <see cref="ProcessAgentBuilder"/> class.
    /// </summary>
    /// <param name="agentDefinition"></param>
    /// <param name="onComplete"></param>
    /// <param name="onError"></param>
    /// <param name="threadName"></param>
    /// <param name="nodeInputs"></param>
    /// <param name="processBuilder"></param>
    /// <exception cref="KernelException"></exception>
    public ProcessAgentBuilder(AgentDefinition agentDefinition, Action<object?, KernelProcessStepContext> onComplete, Action<object?, KernelProcessStepContext> onError, string threadName, Dictionary<string, Type> nodeInputs, ProcessBuilder processBuilder)
        : base(agentDefinition.Id ?? throw new KernelException("AgentDefinition Id must be set"), processBuilder)
    {
        Verify.NotNull(agentDefinition);
        this._agentDefinition = agentDefinition;
        this.OnCompleteCodeAction = onComplete;
        this.OnErrorCodeAction = onError;
        this.DefaultThreadName = threadName;
        this.Inputs = nodeInputs;
    }

    #region Public Interface

    /// <summary>
    /// The optional resolver for the agent ID. This is used to determine the ID of the agent at runtime.
    /// </summary>
    public KernelProcessStateResolver<string?>? AgentIdResolver { get; init; } = null;

    /// <summary>
    /// The name of the thread that this agent will run on.
    /// </summary>
    public string DefaultThreadName { get; init; }

    /// <summary>
    /// The optional handler group for OnComplete events.
    /// </summary>
    public Action<object?, KernelProcessStepContext>? OnCompleteCodeAction { get; init; }

    /// <summary>
    /// The optional handler group for OnError events.
    /// </summary>
    public Action<object?, KernelProcessStepContext>? OnErrorCodeAction { get; init; }

    /// <summary>
    /// The optional handler group for OnComplete events.
    /// </summary>
    public DeclarativeEventHandlerGroupBuilder? OnCompleteBuilder { get; internal set; }

    /// <summary>
    /// The optional handler group for OnError events.
    /// </summary>
    public DeclarativeEventHandlerGroupBuilder? OnErrorBuilder { get; internal set; }

    /// <summary>
    /// The inputs for this agent.
    /// </summary>
    //public NodeInputs Inputs { get; internal set; }
    public Dictionary<string, Type> Inputs { get; internal set; } = [];

    /// <summary>
    /// The human-in-the-loop mode for this agent. This determines whether the agent will wait for human input before proceeding.
    /// </summary>
    public HITLMode HumanInLoopMode { get; init; } = HITLMode.Never;

    /// <summary>
    /// Creates a new instance of the <see cref="DeclarativeEventHandlerGroupBuilder"/> class for the OnComplete event.
    /// </summary>
    /// <returns></returns>
    internal ProcessAgentBuilder<TProcessState> OnComplete(List<DeclarativeProcessCondition> conditions)
    {
        var builder = new DeclarativeEventHandlerGroupBuilder(conditions);
        this.OnCompleteBuilder = builder;
        return this;
    }

    /// <summary>
    /// Creates a new instance of the <see cref="DeclarativeEventHandlerGroupBuilder"/> class for the OnComplete event.
    /// </summary>
    /// <returns></returns>
    public ProcessAgentBuilder<TProcessState> OnError(List<DeclarativeProcessCondition> conditions)
    {
        var builder = new DeclarativeEventHandlerGroupBuilder(conditions);
        this.OnErrorBuilder = builder;
        return this;
    }

    /// <summary>
    /// Sets the inputs for this agent.
    /// </summary>
    /// <param name="inputName"></param>
    /// <param name="inputType"></param>
    /// <returns></returns>
    /// <exception cref="KernelException"></exception>
    internal ProcessAgentBuilder<TProcessState> WithStructuredInput(string inputName, Type inputType)
    {
        Verify.NotNull(inputType, nameof(inputType));

        var schemaBuilder = new JsonSchemaBuilder();
        JsonSchema schema = schemaBuilder
                    .FromType(inputType)
                    .Build();

        var json = schema.ToJsonDocument().RootElement.ToString();
        this.Inputs.Add(inputName, inputType);

        return this;
    }

    /// <summary>
    /// Sets the inputs for this agent.
    /// </summary>
    /// <typeparam name="TProperty"></typeparam>
    /// <param name="propertySelector"></param>
    /// <param name="inputName"></param>
    /// <returns></returns>
    public ProcessAgentBuilder<TProcessState> WithUserStateInput<TProperty>(Expression<Func<TProcessState, TProperty>> propertySelector, string? inputName = null)
    {
        // Extract the property path and type from the expression
        var (_boundPropertyName, _boundPropertyPath, _boundPropertyType) = this.ExtractPropertyInfo(propertySelector);

        this._defaultInputBindings[_boundPropertyName] = _boundPropertyPath;
        this.Inputs.Add(inputName ?? _boundPropertyName, _boundPropertyType);
        return this;
    }

    private (string Name, string Path, Type Type) ExtractPropertyInfo<TState, TProperty>(Expression<Func<TState, TProperty>> propertySelector)
    {
        string propertyName = "";
        var propertyPath = new StringBuilder();
        var expression = propertySelector.Body;
        Type? propertyType = null;

        // Walk up the expression tree to build the property path
        while (expression is MemberExpression memberExpression)
        {
            var member = memberExpression.Member;
            propertyName = member.Name;

            // Add the current member name to the path
            if (propertyPath.Length > 0)
            {
                propertyPath.Insert(0, ".");
            }

            propertyPath.Insert(0, member.Name);

            // If this is our first iteration, save the property type
            if (propertyType == null)
            {
                propertyType = ((PropertyInfo)member).PropertyType;
            }

            // Move to the next level in the expression
            expression = memberExpression.Expression;
        }

        if (expression is ParameterExpression)
        {
            // We've reached the parameter (e.g., 'myState'), which is good
            return (propertyName, propertyPath.ToString(), propertyType ?? typeof(TProperty));
        }

        throw new ArgumentException("Expression must be a property access expression", nameof(propertySelector));
    }

    #endregion

    internal override KernelProcessStepInfo BuildStep(ProcessBuilder processBuilder, KernelProcessStepStateMetadata? stateMetadata = null)
    {
        KernelProcessMapStateMetadata? mapMetadata = stateMetadata as KernelProcessMapStateMetadata;

        // Build the edges first
        var builtEdges = this.Edges.ToDictionary(kvp => kvp.Key, kvp => kvp.Value.Select(e => e.Build()).ToList());
        var agentActions = new ProcessAgentActions(
            codeActions: new ProcessAgentCodeActions
            {
                OnComplete = this.OnCompleteCodeAction,
                OnError = this.OnCompleteCodeAction
            },
            declarativeActions: new ProcessAgentDeclarativeActions
            {
                OnComplete = this.OnCompleteBuilder?.Build(),
                OnError = this.OnErrorBuilder?.Build()
            });

        var state = new KernelProcessStepState(this.Name, "1.0", this.Id);

        return new KernelProcessAgentStep(this._agentDefinition, agentActions, state, builtEdges, this.DefaultThreadName, this.Inputs) { AgentIdResolver = this.AgentIdResolver, HumanInLoopMode = this.HumanInLoopMode };
    }

    internal ProcessFunctionTargetBuilder GetInvokeAgentFunctionTargetBuilder()
    {
        return new ProcessFunctionTargetBuilder(this, functionName: KernelProcessAgentExecutor.ProcessFunctions.Invoke, parameterName: "message");
    }
}

/// <summary>
/// Builder for a process step that represents an agent.
/// </summary>
public class ProcessAgentBuilder : ProcessAgentBuilder<ProcessDefaultState>
{
    /// <summary>
    /// Creates a new instance of the <see cref="ProcessAgentBuilder"/> class.
    /// </summary>
    /// <param name="agentDefinition"></param>
    /// <param name="threadName"></param>
    /// <param name="nodeInputs"></param>
    /// <param name="processBuilder"></param>
    /// <param name="stepId"></param>
    public ProcessAgentBuilder(AgentDefinition agentDefinition, string threadName, Dictionary<string, Type> nodeInputs, ProcessBuilder? processBuilder, string? stepId = null) : base(agentDefinition, threadName, nodeInputs, processBuilder, stepId)
    {
    }
}

/// <summary>
/// Builder for a group of event handlers.
/// </summary>
public class DeclarativeEventHandlerGroupBuilder
{
    /// <summary>
    /// Creates a new instance of the <see cref="DeclarativeEventHandlerGroupBuilder"/> class.
    /// </summary>
    /// <param name="conditions"></param>
    /// <exception cref="KernelException"></exception>
    public DeclarativeEventHandlerGroupBuilder(List<DeclarativeProcessCondition> conditions)
    {
        if (conditions is not null)
        {
            foreach (var condition in conditions)
            {
                if (condition is null)
                {
                    continue;
                }

                if (condition.Type == DeclarativeProcessConditionType.Default)
                {
                    if (this.DefaultHandler is not null)
                    {
                        throw new KernelException("Only one `Default` handler is allowed in a group of event handlers.");
                    }

                    if (!string.IsNullOrWhiteSpace(condition.Expression))
                    {
                        throw new KernelException("`Default` handlers must not have an eval expression.");
                    }

                    this.DefaultHandler = new DeclarativeEventHandlerBuilder(condition);
                }
                else if (condition.Type == DeclarativeProcessConditionType.Eval)
                {
                    this.EvalHandlers ??= [];
                    this.EvalHandlers.Add(new DeclarativeEventHandlerBuilder(condition));
                }
                else if (condition.Type == DeclarativeProcessConditionType.Always)
                {
                    if (this.DefaultHandler is not null)
                    {
                        throw new KernelException("Only one `Always` handler is allowed in a group of event handlers.");
                    }

                    if (!string.IsNullOrWhiteSpace(condition.Expression))
                    {
                        throw new KernelException("`Always` handlers must not have an eval expression.");
                    }

                    this.AlwaysHandler = new DeclarativeEventHandlerBuilder(condition);
                }
                else
                {
                    throw new KernelException($"Unknown condition type: {condition.Type}");
                }
            }
        }
    }

    /// <summary>
    /// The list of semantic handlers for this group of event handlers.
    /// </summary>
    public DeclarativeEventHandlerBuilder? AlwaysHandler { get; init; }

    /// <summary>
    /// The optional default handler for this group of event handlers.
    /// </summary>
    public DeclarativeEventHandlerBuilder? DefaultHandler { get; set; }

    /// <summary>
    /// The list of state based handlers for this group of event handlers.
    /// </summary>
    public List<DeclarativeEventHandlerBuilder>? EvalHandlers { get; init; } = new List<DeclarativeEventHandlerBuilder>();

    /// <summary>
    /// Builds the declarative process condition for this event handler group.
    /// </summary>
    /// <returns></returns>
    public KernelProcessDeclarativeConditionHandler Build()
    {
        return new KernelProcessDeclarativeConditionHandler
        {
            DefaultCondition = this.DefaultHandler?.Build(),
            AlwaysCondition = this.AlwaysHandler?.Build(),
            EvalConditions = this.EvalHandlers?.Select(h => h.Build()).ToList(),
        };
    }
}

/// <summary>
/// Builder for events related to declarative steps
/// </summary>
public class DeclarativeEventHandlerBuilder
{
    /// <summary>
    /// The declarative process condition that this event handler is associated with.
    /// </summary>
    public DeclarativeProcessCondition DeclarativeProcessCondition { get; init; }

    /// <summary>
    /// Creates a new instance of the <see cref="DeclarativeEventHandlerBuilder"/> class.
    /// </summary>
    /// <param name="condition"></param>
    public DeclarativeEventHandlerBuilder(DeclarativeProcessCondition condition)
    {
        this.DeclarativeProcessCondition = condition;
    }

    /// <summary>
    /// Builds the declarative process condition for this event handler.
    /// </summary>
    /// <returns></returns>
    public DeclarativeProcessCondition Build()
    {
        return this.DeclarativeProcessCondition;
    }
}


===== Process.Core\ProcessBuilder.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.Agents.AzureAI;
using Microsoft.SemanticKernel.Process;
using Microsoft.SemanticKernel.Process.Internal;
using Microsoft.SemanticKernel.Process.Models;
using Microsoft.SemanticKernel.Process.Tools;

namespace Microsoft.SemanticKernel;

/// <summary>
/// Provides functionality for incrementally defining a process.
/// </summary>
public sealed partial class ProcessBuilder : ProcessStepBuilder
{
    /// <summary>The collection of steps within this process.</summary>
    private readonly List<ProcessStepBuilder> _steps = [];

    /// <summary>The collection of entry steps within this process.</summary>
    private readonly List<ProcessStepBuilder> _entrySteps = [];

    /// <summary>Maps external input event Ids to the target entry step for the event.</summary>
    private readonly Dictionary<string, ProcessTargetBuilder> _externalEventTargetMap = [];

    /// <summary>
    /// The collection of threads within this process.
    /// </summary>
    private readonly Dictionary<string, KernelProcessAgentThread> _threads = [];

    /// <summary>
    /// A boolean indicating if the current process is a step within another process.
    /// </summary>
    internal bool HasParentProcess { get; set; }

    /// <summary>
    /// Version of the process, used when saving the state of the process
    /// </summary>
    public string Version { get; init; } = "v1";

    /// <summary>
    /// The type of the state. This is optional.
    /// </summary>
    public Type? StateType { get; init; } = null;

    /// <summary>
    /// The description of the process.
    /// </summary>
    public string Description { get; init; } = string.Empty;

    /// <summary>
    /// Initializes a new instance of the <see cref="ProcessBuilder"/> class.
    /// </summary>
    /// <param name="id">The name of the process. This is required.</param>
    /// <param name="description">The semantic description of the Process being built.</param>
    /// <param name="processBuilder">ProcessBuilder to copy from</param>
    /// <param name="stateType">The type of the state. This is optional.</param>
    public ProcessBuilder(string id, string? description = null, ProcessBuilder? processBuilder = null, Type? stateType = null)
        : base(id, processBuilder)
    {
        Verify.NotNullOrWhiteSpace(id, nameof(id));
        this.StateType = stateType;
        this.Description = description ?? string.Empty;
    }

    /// <summary>
    /// Used to resolve the target function and parameter for a given optional function name and parameter name.
    /// This is used to simplify the process of creating a <see cref="KernelProcessFunctionTarget"/> by making it possible
    /// to infer the function and/or parameter names from the function metadata if only one option exists.
    /// </summary>
    /// <param name="functionName">The name of the function. May be null if only one function exists on the step.</param>
    /// <param name="parameterName">The name of the parameter. May be null if only one parameter exists on the function.</param>
    /// <returns>A valid instance of <see cref="KernelProcessFunctionTarget"/> for this step.</returns>
    /// <exception cref="InvalidOperationException"></exception>
    internal override KernelProcessFunctionTarget ResolveFunctionTarget(string? functionName, string? parameterName)
    {
        // Try to resolve the function target on each of the registered entry points.
        var targets = new List<KernelProcessFunctionTarget>();
        foreach (var step in this._entrySteps)
        {
            try
            {
                targets.Add(step.ResolveFunctionTarget(functionName, parameterName));
            }
            catch (KernelException)
            {
                // If the function is not found on the source step, then we can ignore it.
            }
        }

        // If no targets were found or if multiple targets were found, throw an exception.
        if (targets.Count == 0)
        {
            throw new InvalidOperationException($"No targets found for the specified function and parameter '{functionName}.{parameterName}'.");
        }
        else if (targets.Count > 1)
        {
            throw new InvalidOperationException($"Multiple targets found for the specified function and parameter '{functionName}.{parameterName}'.");
        }

        return targets[0];
    }

    /// <inheritdoc/>
    internal override void LinkTo(string eventId, ProcessStepEdgeBuilder edgeBuilder)
    {
        Verify.NotNull(edgeBuilder?.Source, nameof(edgeBuilder.Source));
        Verify.NotNull(edgeBuilder?.Target, nameof(edgeBuilder.Target));

        // Keep track of the entry point steps
        this._entrySteps.Add(edgeBuilder.Source);
        this._externalEventTargetMap[eventId] = edgeBuilder.Target;
        base.LinkTo(eventId, edgeBuilder);
    }

    /// <inheritdoc/>
    internal override Dictionary<string, KernelFunctionMetadata> GetFunctionMetadataMap()
    {
        // The process has no kernel functions of its own, but it does expose the functions from its entry steps.
        // Merge the function metadata map from each of the entry steps.
        return this._entrySteps.SelectMany(step => step.GetFunctionMetadataMap())
                               .ToDictionary(pair => pair.Key, pair => pair.Value);
    }

    /// <summary>
    /// Builds the step.
    /// </summary>
    /// <param name="processBuilder">ProcessBuilder to build the step for</param>
    /// <param name="stateMetadata">State to apply to the step on the build process</param>
    /// <returns></returns>
    internal override KernelProcessStepInfo BuildStep(ProcessBuilder processBuilder, KernelProcessStepStateMetadata? stateMetadata = null)
    {
        // The step is a, process so we can return the step info directly.
        return this.Build(stateMetadata as KernelProcessStateMetadata);
    }

    /// <summary>
    /// Add the provided step builder to the process.
    /// </summary>
    /// <remarks>
    /// Utilized by <see cref="ProcessMapBuilder"/> only.
    /// </remarks>
    internal void AddStepFromBuilder(ProcessStepBuilder stepBuilder)
    {
        this._steps.Add(stepBuilder);
    }

    /// <summary>
    /// Check to ensure stepName is not used yet in another step
    /// </summary>
    private bool StepNameAlreadyExists(string stepName)
    {
        return this._steps.Select(step => step.Name).Contains(stepName);
    }

    /// <summary>
    /// Verify step is unique and add to the process.
    /// </summary>
    private TBuilder AddStep<TBuilder>(TBuilder builder, IReadOnlyList<string>? aliases) where TBuilder : ProcessStepBuilder
    {
        if (this.StepNameAlreadyExists(builder.Name))
        {
            throw new InvalidOperationException($"Step name {builder.Name} is already used, assign a different name for step");
        }

        if (aliases != null && aliases.Count > 0)
        {
            builder.Aliases = aliases;
        }

        this._steps.Add(builder);

        return builder;
    }

    #region Public Interface

    /// <summary>
    /// A read-only collection of steps in the process.
    /// </summary>
    public IReadOnlyList<ProcessStepBuilder> Steps => this._steps.AsReadOnly();

    /// <summary>
    /// Adds a step to the process.
    /// </summary>
    /// <typeparam name="TStep">The step Type.</typeparam>
    /// <param name="id">The unique Id of the step. If not provided, the name of the step Type will be used.</param>
    /// <param name="aliases">Aliases that have been used by previous versions of the step, used for supporting backward compatibility when reading old version Process States</param>
    /// <returns>An instance of <see cref="ProcessStepBuilder"/></returns>
    public ProcessStepBuilder AddStepFromType<TStep>(string? id = null, IReadOnlyList<string>? aliases = null) where TStep : KernelProcessStep
    {
        ProcessStepBuilder<TStep> stepBuilder = new(id: id ?? typeof(TStep).Name, this.ProcessBuilder);

        return this.AddStep(stepBuilder, aliases);
    }

    /// <summary>
    /// Adds a step to the process.
    /// </summary>
    /// <param name="stepType">The step Type.</param>
    /// <param name="id">The unique Id of the step. If not provided, the name of the step Type will be used.</param>
    /// <param name="aliases">Aliases that have been used by previous versions of the step, used for supporting backward compatibility when reading old version Process States</param>
    /// <returns>An instance of <see cref="ProcessStepBuilder"/></returns>
    public ProcessStepBuilder AddStepFromType(Type stepType, string? id = null, IReadOnlyList<string>? aliases = null)
    {
        ProcessStepBuilderTyped stepBuilder = new(stepType: stepType, id: id ?? stepType.Name, this.ProcessBuilder);

        return this.AddStep(stepBuilder, aliases);
    }

    /// <summary>
    /// Adds a step to the process and define it's initial user-defined state.
    /// </summary>
    /// <typeparam name="TStep">The step Type.</typeparam>
    /// <typeparam name="TState">The state Type.</typeparam>
    /// <param name="initialState">The initial state of the step.</param>
    /// <param name="id">The unique Id of the step. If not provided, the name of the step Type will be used.</param>
    /// <param name="aliases">Aliases that have been used by previous versions of the step, used for supporting backward compatibility when reading old version Process States</param>
    /// <returns>An instance of <see cref="ProcessStepBuilder"/></returns>
    public ProcessStepBuilder AddStepFromType<TStep, TState>(TState initialState, string? id = null, IReadOnlyList<string>? aliases = null) where TStep : KernelProcessStep<TState> where TState : class, new()
    {
        ProcessStepBuilder<TStep> stepBuilder = new(id ?? typeof(TStep).Name, this.ProcessBuilder, initialState: initialState);

        return this.AddStep(stepBuilder, aliases);
    }

    /// <summary>
    /// Adds a step to the process from a declarative agent.
    /// </summary>
    /// <param name="agentDefinition">The <see cref="AgentDefinition"/></param>
    /// <param name="id">The unique Id of the step. If not provided, the name of the step Type will be used.</param>
    /// <param name="aliases">Aliases that have been used by previous versions of the step, used for supporting backward compatibility when reading old version Process States</param>
    /// <param name="threadName">Specifies the thread reference to be used by the agent. If not provided, the agent will create a new thread for each invocation.</param>
    /// <param name="humanInLoopMode">Specifies the human-in-the-loop mode for the agent. If not provided, the default is <see cref="HITLMode.Never"/>.</param>
    public ProcessAgentBuilder<TProcessState> AddStepFromAgent<TProcessState>(AgentDefinition agentDefinition, string? id = null, IReadOnlyList<string>? aliases = null, string? threadName = null, HITLMode humanInLoopMode = HITLMode.Never) where TProcessState : class, new()
    {
        Verify.NotNull(agentDefinition, nameof(agentDefinition));

        if (string.IsNullOrWhiteSpace(agentDefinition.Name))
        {
            throw new ArgumentException("AgentDefinition.Name cannot be null or empty.", nameof(agentDefinition));
        }

        if (string.IsNullOrWhiteSpace(threadName))
        {
            // No thread name was specified so add a new thread for the agent.
            this.AddThread(agentDefinition.Name, KernelProcessThreadLifetime.Scoped);
            threadName = agentDefinition.Name;
        }

        var stepBuilder = new ProcessAgentBuilder<TProcessState>(agentDefinition, threadName: threadName, [], this.ProcessBuilder, id) { HumanInLoopMode = humanInLoopMode }; // TODO: Add inputs to the agent
        return this.AddStep(stepBuilder, aliases);
    }

    /// <summary>
    /// Adds a step to the process from a declarative agent.
    /// </summary>
    /// <param name="agentDefinition">The <see cref="AgentDefinition"/></param>
    /// <param name="id">The unique Id of the step. If not provided, the name of the step Type will be used.</param>
    /// <param name="aliases">Aliases that have been used by previous versions of the step, used for supporting backward compatibility when reading old version Process States</param>
    /// <param name="threadName">Specifies the thread reference to be used by the agent. If not provided, the agent will create a new thread for each invocation.</param>
    /// <param name="humanInLoopMode">Specifies the human-in-the-loop mode for the agent. If not provided, the default is <see cref="HITLMode.Never"/>.</param>
    public ProcessAgentBuilder AddStepFromAgent(AgentDefinition agentDefinition, string? id = null, IReadOnlyList<string>? aliases = null, string? threadName = null, HITLMode humanInLoopMode = HITLMode.Never)
    {
        Verify.NotNull(agentDefinition, nameof(agentDefinition));

        if (string.IsNullOrWhiteSpace(agentDefinition.Name))
        {
            throw new ArgumentException("AgentDefinition.Name cannot be null or empty.", nameof(agentDefinition));
        }

        if (string.IsNullOrWhiteSpace(threadName))
        {
            // No thread name was specified so add a new thread for the agent.
            this.AddThread(agentDefinition.Name, KernelProcessThreadLifetime.Scoped);
            threadName = agentDefinition.Name;
        }

        var stepBuilder = new ProcessAgentBuilder(agentDefinition, threadName: threadName, [], this.ProcessBuilder, id) { HumanInLoopMode = humanInLoopMode };
        return this.AddStep(stepBuilder, aliases);
    }

    /// <summary>
    /// Adds a step to the process from a declarative agent.
    /// </summary>
    /// <param name="agentDefinition">The <see cref="AgentDefinition"/></param>
    /// <param name="threadName">Specifies the thread reference to be used by the agent. If not provided, the agent will create a new thread for each invocation.</param>
    /// <param name="stepId">Id of the step. If not provided, the Id will come from the agent Id.</param>
    /// <param name="humanInLoopMode">Specifies the human-in-the-loop mode for the agent. If not provided, the default is <see cref="HITLMode.Never"/>.</param>
    /// <param name="aliases"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public ProcessAgentBuilder<TProcessState> AddStepFromAgentProxy<TProcessState>(AgentDefinition agentDefinition, string? threadName = null, string? stepId = null, HITLMode humanInLoopMode = HITLMode.Never, IReadOnlyList<string>? aliases = null) where TProcessState : class, new()
    {
        Verify.NotNull(agentDefinition, nameof(agentDefinition));

        if (string.IsNullOrWhiteSpace(agentDefinition.Id))
        {
            throw new ArgumentException("AgentDefinition.Id cannot be null or empty.", nameof(agentDefinition));
        }

        if (string.IsNullOrWhiteSpace(agentDefinition.Name))
        {
            throw new ArgumentException("AgentDefinition.Name cannot be null or empty.", nameof(agentDefinition));
        }

        if (string.IsNullOrWhiteSpace(threadName))
        {
            // No thread name was specified so add a new thread for the agent.
            this.AddThread(agentDefinition.Name, KernelProcessThreadLifetime.Scoped);
            threadName = agentDefinition.Name;
        }

        KernelProcessStateResolver<string?> agentIdResolver = new((s) =>
        {
            StateResolverContentWrapper wrapper = new() { State = s };
            var result = JMESPathConditionEvaluator.EvaluateToString(wrapper, agentDefinition.Id);
            return Task.FromResult(result);
        });

        var stepBuilder = new ProcessAgentBuilder<TProcessState>(agentDefinition, threadName: threadName, [], this.ProcessBuilder, stepId) { AgentIdResolver = agentIdResolver, HumanInLoopMode = humanInLoopMode }; // TODO: Add inputs to the agent
        return this.AddStep(stepBuilder, aliases);
    }

    /// <summary>
    /// Adds a step to the process that represents the end of the process.
    /// </summary>
    /// <returns></returns>
    public ProcessStepBuilder AddEndStep()
    {
        var stepBuilder = EndStep.Instance;
        return this.AddStep(stepBuilder, null);
    }

    /// <summary>
    /// Adds a sub process to the process.
    /// </summary>
    /// <param name="kernelProcess">The process to add as a step.</param>
    /// <param name="aliases">Aliases that have been used by previous versions of the step, used for supporting backward compatibility when reading old version Process States</param>
    /// <returns>An instance of <see cref="ProcessStepBuilder"/></returns>
    public ProcessBuilder AddStepFromProcess(ProcessBuilder kernelProcess, IReadOnlyList<string>? aliases = null)
    {
        kernelProcess.HasParentProcess = true;

        return this.AddStep(kernelProcess, aliases);
    }

    /// <summary>
    /// Adds a step to the process.
    /// </summary>
    /// <typeparam name="TStep">The step Type.</typeparam>
    /// <param name="id">The unique Id of the step. If not provided, the name of the step Type will be used.</param>
    /// <param name="aliases">Aliases that have been used by previous versions of the step, used for supporting backward compatibility when reading old version Process States</param>
    /// <returns>An instance of <see cref="ProcessMapBuilder"/></returns>
    public ProcessMapBuilder AddMapStepFromType<TStep>(string? id = null, IReadOnlyList<string>? aliases = null) where TStep : KernelProcessStep
    {
        ProcessStepBuilder<TStep> stepBuilder = new(id ?? typeof(TStep).Name, this.ProcessBuilder);

        ProcessMapBuilder mapBuilder = new(stepBuilder);

        return this.AddStep(mapBuilder, aliases);
    }

    /// <summary>
    /// Adds a step to the process and define it's initial user-defined state.
    /// </summary>
    /// <typeparam name="TStep">The step Type.</typeparam>
    /// <typeparam name="TState">The state Type.</typeparam>
    /// <param name="initialState">The initial state of the step.</param>
    /// <param name="id">The unique Id of the step.</param>
    /// <param name="aliases">Aliases that have been used by previous versions of the step, used for supporting backward compatibility when reading old version Process States</param>
    /// <returns>An instance of <see cref="ProcessMapBuilder"/></returns>
    public ProcessMapBuilder AddMapStepFromType<TStep, TState>(TState initialState, string id, IReadOnlyList<string>? aliases = null) where TStep : KernelProcessStep<TState> where TState : class, new()
    {
        ProcessStepBuilder<TStep> stepBuilder = new(id, this.ProcessBuilder, initialState: initialState);

        ProcessMapBuilder mapBuilder = new(stepBuilder);

        return this.AddStep(mapBuilder, aliases);
    }

    /// <summary>
    /// Adds a map operation to the process that accepts an enumerable input parameter and
    /// processes each individual parameter value by the specified map operation (TStep).
    /// Results are coalesced into a result set of the same dimension as the input set.
    /// </summary>
    /// <param name="process">The target for the map operation</param>
    /// <param name="aliases">Aliases that have been used by previous versions of the step, used for supporting backward compatibility when reading old version Process States</param>
    /// <returns>An instance of <see cref="ProcessMapBuilder"/></returns>
    public ProcessMapBuilder AddMapStepFromProcess(ProcessBuilder process, IReadOnlyList<string>? aliases = null)
    {
        process.HasParentProcess = true;

        ProcessMapBuilder mapBuilder = new(process);

        return this.AddStep(mapBuilder, aliases);
    }

    /// <summary>
    /// Adds proxy step to the process that allows emitting events externally. For making use of it, there should be an implementation
    /// of <see cref="IExternalKernelProcessMessageChannel"/> passed.
    /// For now, the current implementation only allows for 1 implementation of <see cref="IExternalKernelProcessMessageChannel"/> at the time.
    /// </summary>
    /// <param name="id">The unique Id of the proxy step.</param>
    /// <param name="externalTopics">topic names to be used externally.</param>
    /// <param name="aliases">Aliases that have been used by previous versions of the step, used for supporting backward compatibility when reading old version Process States</param>
    /// <returns>An instance of <see cref="ProcessProxyBuilder"/></returns>
    public ProcessProxyBuilder AddProxyStep(string id, IReadOnlyList<string> externalTopics, IReadOnlyList<string>? aliases = null)
    {
        ProcessProxyBuilder proxyBuilder = new(externalTopics, id ?? nameof(KernelProxyStep), this);

        return this.AddStep(proxyBuilder, aliases);
    }

    /// <summary>
    /// Adds a thread to the process.
    /// </summary>
    /// <typeparam name="T">The concrete type of the <see cref="AgentThread"/></typeparam>
    /// <param name="threadName">The name of the thread.</param>
    /// <param name="threadPolicy">The policy that determines the lifetime of the <see cref="AgentThread"/></param>
    /// <param name="threadId">The Id of an existing thread that should be used.</param>
    public ProcessBuilder AddThread<T>(string threadName, KernelProcessThreadLifetime threadPolicy, string? threadId = null) where T : AgentThread
    {
        Verify.NotNullOrWhiteSpace(threadName, nameof(threadName));

        var threadType = typeof(T) switch
        {
            Type t when t == typeof(AzureAIAgentThread) => KernelProcessThreadType.AzureAI,
            _ => throw new ArgumentException($"Unsupported thread type: {typeof(T).Name}")
        };

        var processThread = new KernelProcessAgentThread() { ThreadName = threadName, ThreadId = threadId, ThreadType = threadType };
        this._threads[threadName] = processThread;
        return this;
    }

    /// <summary>
    /// Adds a thread to the process.
    /// </summary>
    /// <param name="threadName">The name of the thread.</param>
    /// <param name="threadPolicy">The policy that determines the lifetime of the <see cref="AgentThread"/></param>
    public ProcessBuilder AddThread(string threadName, KernelProcessThreadLifetime threadPolicy)
    {
        Verify.NotNullOrWhiteSpace(threadName, nameof(threadName));
        Verify.NotNull(threadPolicy, nameof(threadPolicy));

        var processThread = new KernelProcessAgentThread() { ThreadName = threadName, ThreadPolicy = threadPolicy };
        this._threads[threadName] = processThread;
        return this;
    }

    /// <summary>
    /// Provides an instance of <see cref="ProcessEdgeBuilder"/> for defining an input edge to a process.
    /// </summary>
    /// <param name="eventId">The Id of the external event.</param>
    /// <returns>An instance of <see cref="ProcessEdgeBuilder"/></returns>
    public ProcessEdgeBuilder OnInputEvent(string eventId)
    {
        return new ProcessEdgeBuilder(this, eventId);
    }

    /// <summary>
    /// Provides an instance of <see cref="ProcessEdgeBuilder"/> for defining an edge to a
    /// step that responds to an unhandled process error.
    /// </summary>
    /// <returns>An instance of <see cref="ProcessEdgeBuilder"/></returns>
    /// <remarks>
    /// To target a specific error source, use the <see cref="ProcessStepBuilder.OnFunctionError"/> on the step.
    /// </remarks>
    public ProcessEdgeBuilder OnError()
    {
        return new ProcessEdgeBuilder(this, ProcessConstants.GlobalErrorEventId);
    }

    /// <summary>
    /// Creates a <see cref="ListenForBuilder"/> instance to define a listener for incoming messages.
    /// </summary>
    /// <returns></returns>
    internal ListenForBuilder ListenFor()
    {
        return new ListenForBuilder(this);
    }

    /// <summary>
    /// Retrieves the target for a given external event. The step associated with the target is the process itself (this).
    /// </summary>
    /// <param name="eventId">The Id of the event</param>
    /// <returns>An instance of <see cref="ProcessFunctionTargetBuilder"/></returns>
    /// <exception cref="KernelException"></exception>
    public ProcessFunctionTargetBuilder WhereInputEventIs(string eventId)
    {
        Verify.NotNullOrWhiteSpace(eventId, nameof(eventId));

        if (!this._externalEventTargetMap.TryGetValue(eventId, out var target))
        {
            throw new KernelException($"The process named '{this.Name}' does not expose an event with Id '{eventId}'.");
        }

        if (target is not ProcessFunctionTargetBuilder functionTargetBuilder)
        {
            throw new KernelException($"The process named '{this.Name}' does not expose an event with Id '{eventId}'.");
        }

        // Targets for external events on a process should be scoped to the process itself rather than the step inside the process.
        var processTarget = functionTargetBuilder with { Step = this, TargetEventId = eventId };
        return processTarget;
    }

    /// <summary>
    /// Builds the process.
    /// </summary>
    /// <returns>An instance of <see cref="KernelProcess"/></returns>
    public KernelProcess Build(KernelProcessStateMetadata? stateMetadata = null)
    {
        // Build the edges first
        var builtEdges = this.Edges.ToDictionary(kvp => kvp.Key, kvp => kvp.Value.Select(e => e.Build()).ToList());

        // Build the steps and injecting initial state if any is provided
        var builtSteps = this.BuildWithStateMetadata(stateMetadata);

        // Create the process
        KernelProcessState state = new(this.Name, version: this.Version, id: this.Id);
        KernelProcess process = new(state, builtSteps, builtEdges) { Threads = this._threads, UserStateType = this.StateType, Description = this.Description };

        return process;
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ProcessBuilder"/> class.
    /// </summary>
    /// <param name="yaml">Workflow definition in YAML format.</param>
    /// <returns>An instance of <see cref="KernelProcess"/></returns>
    public static Task<KernelProcess?> LoadFromYamlAsync(string yaml)
        => LoadFromYamlInternalAsync(yaml);

    /// <summary>
    /// Initializes a new instance of the <see cref="ProcessBuilder"/> class.
    /// </summary>
    /// <param name="yaml">Workflow definition in YAML format.</param>
    /// <param name="stepTypes">Collection of preloaded step types.</param>
    /// <returns>An instance of <see cref="KernelProcess"/></returns>
    public static Task<KernelProcess?> LoadFromYamlAsync(string yaml, Dictionary<string, Type> stepTypes)
        => LoadFromYamlInternalAsync(yaml, stepTypes: stepTypes);

    /// <summary>
    /// Initializes a new instance of the <see cref="ProcessBuilder"/> class.
    /// </summary>
    /// <param name="yaml">Workflow definition in YAML format.</param>
    /// <param name="assemblyPaths">Collection of names or paths of the files that contain the manifest of the assembly.</param>
    /// <returns>An instance of <see cref="KernelProcess"/></returns>
    public static Task<KernelProcess?> LoadFromYamlAsync(string yaml, List<string> assemblyPaths)
        => LoadFromYamlInternalAsync(yaml, assemblyPaths: assemblyPaths);

    #endregion

    #region private

    /// <summary>
    /// Initializes a new instance of the <see cref="ProcessBuilder"/> class.
    /// </summary>
    /// <param name="yaml">Workflow definition in YAML format.</param>
    /// <param name="assemblyPaths">Collection of names or paths of the files that contain the manifest of the assembly.</param>
    /// <param name="stepTypes">Collection of preloaded step types.</param>
    /// <returns>An instance of <see cref="KernelProcess"/></returns>
    private static async Task<KernelProcess?> LoadFromYamlInternalAsync(
        string yaml,
        List<string>? assemblyPaths = null,
        Dictionary<string, Type>? stepTypes = null)
    {
        Verify.NotNullOrWhiteSpace(yaml);

        try
        {
            var workflow = WorkflowSerializer.DeserializeFromYaml(yaml);
            var builder = new WorkflowBuilder();

            if (stepTypes is not null)
            {
                return await builder.BuildProcessAsync(workflow, yaml, stepTypes).ConfigureAwait(false);
            }
            else if (assemblyPaths is { Count: > 0 })
            {
                var loadedStepTypes = ProcessStepLoader.LoadStepTypesFromAssemblies(assemblyPaths);
                return await builder.BuildProcessAsync(workflow, yaml, loadedStepTypes).ConfigureAwait(false);
            }

            return await builder.BuildProcessAsync(workflow, yaml).ConfigureAwait(false);
        }
        catch (Exception ex)
        {
            throw new ArgumentException("Failed to deserialize the process string.", ex);
        }
    }
    #endregion
}


===== Process.Core\ProcessDefaultState.cs =====

// Copyright (c) Microsoft. All rights reserved.

namespace Microsoft.SemanticKernel;

/// <summary>
/// A default process state for the <see cref="ProcessBuilder"/>.
/// </summary>
public class ProcessDefaultState
{
}


===== Process.Core\ProcessEdgeBuilder.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;

namespace Microsoft.SemanticKernel;

/// <summary>
/// Provides functionality for incrementally defining a process edge.
/// </summary>
public sealed class ProcessEdgeBuilder : ProcessStepEdgeBuilder
{
    /// <summary>
    /// The source step of the edge.
    /// </summary>
    internal new ProcessBuilder Source { get; }

    /// <summary>
    /// Initializes a new instance of the <see cref="ProcessEdgeBuilder"/> class.
    /// </summary>
    /// <param name="source">The source step.</param>
    /// <param name="eventId">The Id of the event.</param>
    internal ProcessEdgeBuilder(ProcessBuilder source, string eventId) : base(source, eventId, eventId)
    {
        this.Source = source;
    }

    /// <summary>
    /// Sends the output of the source step to the specified target when the associated event fires.
    /// </summary>
    public ProcessEdgeBuilder SendEventTo(ProcessFunctionTargetBuilder target)
    {
        return this.SendEventTo(target as ProcessTargetBuilder);
    }

    /// <summary>
    /// Sends the output of the source step to the specified target when the associated event fires.
    /// </summary>
    public new ProcessEdgeBuilder SendEventTo(ProcessTargetBuilder target)
    {
        if (this.Target is not null)
        {
            throw new InvalidOperationException("An output target has already been set.");
        }

        this.Target = target;
        ProcessStepEdgeBuilder edgeBuilder = new(this.Source, this.EventData.EventId, this.EventData.EventId) { Target = this.Target };
        this.Source.LinkTo(this.EventData.EventId, edgeBuilder);

        return new ProcessEdgeBuilder(this.Source, this.EventData.EventId);
    }
}


===== Process.Core\ProcessFunctionTargetBuilder.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.Collections.Generic;

namespace Microsoft.SemanticKernel;

/// <summary>
/// Provides functionality for incrementally defining a process target.
/// </summary>
public abstract record ProcessTargetBuilder
{
    /// <summary>
    /// Initializes a new instance of the <see cref="ProcessTargetBuilder"/> class.
    /// </summary>
    /// <param name="type"></param>
    internal ProcessTargetBuilder(ProcessTargetType type)
    {
        this.Type = type;
    }

    /// <summary>
    /// The type of target.
    /// </summary>
    public ProcessTargetType Type { get; init; }

    /// <summary>
    /// Builds the target.
    /// </summary>
    /// <param name="processBuilder"></param>
    /// <returns></returns>
    /// <exception cref="InvalidOperationException"></exception>
    internal abstract KernelProcessTarget Build(ProcessBuilder? processBuilder = null);
}

/// <summary>
/// Provides functionality for incrementally defining a process invocation target.
/// </summary>
public record ProcessStateTargetBuilder : ProcessTargetBuilder
{
    /// <summary>
    /// Initializes a new instance of the <see cref="ProcessStateTargetBuilder"/> class.
    /// </summary>
    /// <param name="variableUpdate"></param>
    public ProcessStateTargetBuilder(VariableUpdate variableUpdate) : base(ProcessTargetType.StateUpdate)
    {
        Verify.NotNull(variableUpdate, nameof(variableUpdate));
        this.VariableUpdate = variableUpdate;
    }

    /// <summary>
    /// The variable update to be performed when the target is reached.
    /// </summary>
    public VariableUpdate VariableUpdate { get; init; }

    internal override KernelProcessTarget Build(ProcessBuilder? processBuilder = null)
    {
        return new KernelProcessStateTarget(this.VariableUpdate);
    }
}

/// <summary>
/// Provides functionality for incrementally defining a process invocation target.
/// </summary>
public record ProcessEmitTargetBuilder : ProcessTargetBuilder
{
    /// <summary>
    /// Initializes a new instance of the <see cref="ProcessEmitTargetBuilder"/> class.
    /// </summary>
    /// <param name="eventName"></param>
    /// <param name="payload"></param>
    public ProcessEmitTargetBuilder(string eventName, Dictionary<string, string>? payload = null) : base(ProcessTargetType.StateUpdate)
    {
        Verify.NotNullOrWhiteSpace(eventName, nameof(eventName));
        this.EventName = eventName;
        this.Payload = payload;
    }

    /// <summary>
    /// The name or type of the event to be emitted.
    /// </summary>
    public string EventName { get; init; }

    /// <summary>
    /// /// The payload to be sent with the event.
    /// </summary>
    public Dictionary<string, string>? Payload { get; init; }

    internal override KernelProcessTarget Build(ProcessBuilder? processBuilder = null)
    {
        return new KernelProcessEmitTarget(this.EventName, this.Payload);
    }
}

/// <summary>
/// Provides functionality for incrementally defining a process agent invocation target.
/// </summary>
public record ProcessAgentInvokeTargetBuilder : ProcessTargetBuilder
{
    /// <summary>
    /// Creates an instance of the <see cref="KernelProcessAgentInvokeTarget"/> class.
    /// </summary>
    /// <param name="step"></param>
    /// <param name="threadEval"></param>
    /// <param name="messagesInEval"></param>
    /// <param name="inputEvals"></param>
    public ProcessAgentInvokeTargetBuilder(ProcessStepBuilder step, string? threadEval, List<string>? messagesInEval, Dictionary<string, string> inputEvals) : base(ProcessTargetType.Invocation)
    {
        Verify.NotNull(step);
        Verify.NotNull(inputEvals);

        this.Step = step;
        this.ThreadEval = threadEval;
        this.MessagesInEval = messagesInEval;
        this.InputEvals = inputEvals;
    }

    /// <summary>
    /// The unique identifier of the Step being targeted.
    /// </summary>
    public ProcessStepBuilder Step { get; init; }

    /// <summary>
    /// An evaluation string that will be evaluated to determine the thread to run on.
    /// </summary>
    public string? ThreadEval { get; init; }

    /// <summary>
    /// An evaluation string that will be evaluated to determine the messages to send to the target.
    /// </summary>
    public List<string>? MessagesInEval { get; init; }

    /// <summary>
    /// An evaluation string that will be evaluated to determine the inputs to send to the target.
    /// </summary>
    public Dictionary<string, string> InputEvals { get; init; }

    internal override KernelProcessTarget Build(ProcessBuilder? processBuilder = null)
    {
        return new KernelProcessAgentInvokeTarget(this.Step.Id, this.ThreadEval, this.MessagesInEval, this.InputEvals);
    }
}

/// <summary>
/// Provides functionality for incrementally defining a process function target.
/// </summary>
public record ProcessFunctionTargetBuilder : ProcessTargetBuilder
{
    /// <summary>
    /// Initializes a new instance of the <see cref="ProcessFunctionTargetBuilder"/> class.
    /// </summary>
    /// <param name="step">The step to target.</param>
    /// <param name="functionName">The function to target.</param>
    /// <param name="parameterName">The parameter to target.</param>
    public ProcessFunctionTargetBuilder(ProcessStepBuilder step, string? functionName = null, string? parameterName = null) : base(ProcessTargetType.KernelFunction)
    {
        Verify.NotNull(step, nameof(step));

        this.Step = step;

        // If the step is an EndStep, we don't need to resolve the function target.
        if (step is EndStep)
        {
            this.FunctionName = "END";
            this.ParameterName = null;
            return;
        }

        // Make sure the function target is valid.
        var target = step.ResolveFunctionTarget(functionName, parameterName);
        if (target == null)
        {
            throw new InvalidOperationException($"Failed to resolve function target for {step.GetType().Name}, {step.Name}: Function - {functionName ?? "any"} / Parameter - {parameterName ?? "any"}");
        }

        this.FunctionName = target.FunctionName!;
        this.ParameterName = target.ParameterName;
    }

    /// <summary>
    /// Builds the function target.
    /// </summary>
    /// <returns>An instance of <see cref="KernelProcessFunctionTarget"/></returns>
    internal override KernelProcessTarget Build(ProcessBuilder? processBuilder = null)
    {
        Verify.NotNull(this.Step.Id);
        return new KernelProcessFunctionTarget(this.Step.Id, this.FunctionName, this.ParameterName, this.TargetEventId);
    }

    /// <summary>
    /// An instance of <see cref="ProcessStepBuilder"/> representing the target Step.
    /// </summary>
    public ProcessStepBuilder Step { get; init; }

    /// <summary>
    /// The name of the function to target.
    /// </summary>
    public string FunctionName { get; init; }

    /// <summary>
    /// The name of the parameter to target. This may be null if the function has no parameters.
    /// </summary>
    public string? ParameterName { get; init; }

    /// <summary>
    /// The unique identifier for the event to target. This may be null if the target is not a sub-process.
    /// </summary>
    public string? TargetEventId { get; init; }
}

/// <summary>
/// Provides functionality for incrementally defining a process step target.
/// </summary>
public sealed record ProcessStepTargetBuilder : ProcessFunctionTargetBuilder
{
    /// <summary>
    /// Initializes a new instance of the <see cref="ProcessStepTargetBuilder"/> class.
    /// </summary>
    /// <param name="stepBuilder"></param>
    /// <param name="inputMapping"></param>
    public ProcessStepTargetBuilder(ProcessStepBuilder stepBuilder, Func<Dictionary<string, object?>, Dictionary<string, object?>>? inputMapping = null) : base(stepBuilder)
    {
        this.InputMapping = inputMapping ?? new Func<Dictionary<string, object?>, Dictionary<string, object?>>((input) => input);
    }

    /// <summary>
    /// An instance of <see cref="ProcessStepBuilder"/> representing the target Step.
    /// </summary>
    public Func<Dictionary<string, object?>, Dictionary<string, object?>> InputMapping { get; init; }
}


===== Process.Core\ProcessMapBuilder.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.SemanticKernel.Process.Models;

namespace Microsoft.SemanticKernel;

/// <summary>
/// Provides functionality to define a step that maps an enumerable input for parallel processing
/// targeting the provided operation and provides the resulting value as an enumerable parameter
/// with equivalent dimension as the input.
/// </summary>
public sealed class ProcessMapBuilder : ProcessStepBuilder
{
    /// <summary>
    /// Initializes a new instance of the <see cref="ProcessMapBuilder"/> class.
    /// </summary>
    /// <param name="mapOperation">The target of the map operation.  May target a step or process</param>
    internal ProcessMapBuilder(ProcessStepBuilder mapOperation)
        : base($"Map{mapOperation.Name}", mapOperation.ProcessBuilder)
    {
        this.MapOperation = mapOperation;
    }

    /// <summary>
    /// Version of the map-step, used when saving the state of the step.
    /// </summary>
    public string Version { get; init; } = "v1";

    /// <summary>
    /// Retrieves the target for a given external event. The step associated with the target is the process itself (this).
    /// </summary>
    /// <param name="eventId">The Id of the event</param>
    /// <returns>An instance of <see cref="ProcessFunctionTargetBuilder"/></returns>
    /// <exception cref="KernelException"></exception>
    public ProcessFunctionTargetBuilder WhereInputEventIs(string eventId)
    {
        Verify.NotNullOrWhiteSpace(eventId, nameof(eventId));

        if (this.MapOperation is not ProcessBuilder process)
        {
            throw new KernelException("Map operation is not a process.");
        }

        ProcessFunctionTargetBuilder operationTarget = process.WhereInputEventIs(eventId);

        return operationTarget with { Step = this, TargetEventId = eventId };
    }

    /// <summary>
    /// The map operation that will be executed for each element in the input.
    /// </summary>
    internal ProcessStepBuilder MapOperation { get; }

    /// <inheritdoc/>
    /// <remarks>
    /// Never called as the map is a proxy for the map operation and does not have a function target.
    /// </remarks>
    internal override Dictionary<string, KernelFunctionMetadata> GetFunctionMetadataMap()
    {
        throw new NotImplementedException($"{nameof(ProcessMapBuilder)}.{nameof(GetFunctionMetadataMap)} should never be invoked");
    }

    /// <inheritdoc/>
    internal override KernelProcessFunctionTarget ResolveFunctionTarget(string? functionName, string? parameterName)
    {
        if (this.MapOperation is ProcessBuilder processOperation)
        {
            throw new KernelException($"Map operation is a process.  Use {nameof(ProcessMapBuilder)}.{nameof(WhereInputEventIs)} to resolve target.");
        }

        return this.MapOperation.ResolveFunctionTarget(functionName, parameterName);
    }

    /// <inheritdoc/>
    internal override KernelProcessStepInfo BuildStep(ProcessBuilder processBuilder, KernelProcessStepStateMetadata? stateMetadata = null)
    {
        KernelProcessMapStateMetadata? mapMetadata = stateMetadata as KernelProcessMapStateMetadata;

        // Build the edges first
        var builtEdges = this.Edges.ToDictionary(kvp => kvp.Key, kvp => kvp.Value.Select(e => e.Build()).ToList());

        // Define the map state
        KernelProcessMapState state = new(this.Name, this.Version, this.Id);

        return new KernelProcessMap(state, this.MapOperation.BuildStep(processBuilder, mapMetadata?.OperationState), builtEdges);
    }
}


===== Process.Core\ProcessProxyBuilder.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.SemanticKernel.Process;
using Microsoft.SemanticKernel.Process.Internal;
using Microsoft.SemanticKernel.Process.Models;

namespace Microsoft.SemanticKernel;

/// <summary>
/// Provides functionality to allow emitting external messages from within the SK
/// process.
/// </summary>
public sealed class ProcessProxyBuilder : ProcessStepBuilder<KernelProxyStep>
{
    /// <summary>
    /// Initializes a new instance of the <see cref="ProcessProxyBuilder"/> class.
    /// </summary>
    internal ProcessProxyBuilder(IReadOnlyList<string> externalTopics, string name, ProcessBuilder? processBuilder)
        : base(name, processBuilder)
    {
        if (externalTopics.Count == 0)
        {
            throw new ArgumentException("No topic names registered");
        }

        this._externalTopicUsage = externalTopics.ToDictionary(topic => topic, topic => false);
        if (this._externalTopicUsage.Count < externalTopics.Count)
        {
            throw new ArgumentException("Topic names registered must be different");
        }
    }

    /// <summary>
    /// Version of the proxy step, used when saving the state of the step.
    /// </summary>
    public string Version { get; init; } = "v1";

    internal readonly Dictionary<string, bool> _externalTopicUsage;

    // For supporting multiple step edges getting linked to the same external topic, current implementation needs to be updated
    // to instead have a list of potential edges in case event names in different steps have same name
    internal readonly Dictionary<string, KernelProcessProxyEventMetadata> _eventMetadata = [];

    internal ProcessFunctionTargetBuilder GetExternalFunctionTargetBuilder()
    {
        return new ProcessFunctionTargetBuilder(this, functionName: KernelProxyStep.ProcessFunctions.EmitExternalEvent, parameterName: "proxyEvent");
    }

    internal void LinkTopicToStepEdgeInfo(string topicName, ProcessStepBuilder sourceStep, ProcessEventData eventData)
    {
        if (!this._externalTopicUsage.TryGetValue(topicName, out bool usedTopic))
        {
            throw new InvalidOperationException($"Topic name {topicName} is not registered as proxy publish event, register first before using");
        }

        if (usedTopic)
        {
            throw new InvalidOperationException($"Topic name {topicName} is is already linked to another step edge");
        }

        this._eventMetadata[eventData.EventName] = new() { EventId = eventData.EventId, TopicName = topicName };
        this._externalTopicUsage[topicName] = true;
    }

    /// <inheritdoc/>
    internal override KernelProcessStepInfo BuildStep(ProcessBuilder processBuilder, KernelProcessStepStateMetadata? stateMetadata = null)
    {
        if (this._externalTopicUsage.All(topic => !topic.Value))
        {
            throw new InvalidOperationException("Proxy step does not have linked steps to it, link step edges to proxy or remove proxy step");
        }

        KernelProcessProxyStateMetadata proxyMetadata = new()
        {
            Name = this.Name,
            Id = this.Id,
            EventMetadata = this._eventMetadata,
            PublishTopics = this._externalTopicUsage.ToList().Select(topic => topic.Key).ToList(),
        };

        // Build the edges first
        var builtEdges = this.Edges.ToDictionary(kvp => kvp.Key, kvp => kvp.Value.Select(e => e.Build()).ToList());

        KernelProcessStepState state = new(this.Name, this.Version, this.Id);

        return new KernelProcessProxy(state, builtEdges)
        {
            ProxyMetadata = proxyMetadata
        };
    }
}


===== Process.Core\ProcessStepBuilder.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.Json;
using Microsoft.SemanticKernel.Process;
using Microsoft.SemanticKernel.Process.Internal;
using Microsoft.SemanticKernel.Process.Models;

namespace Microsoft.SemanticKernel;

/// <summary>
/// An abstract class that provides functionality for incrementally defining a process step and linking it to other steps within a Process.
/// </summary>
public abstract class ProcessStepBuilder
{
    #region Public Interface

    /// <summary>
    /// The unique identifier for the step. This may be null until the step is run within a process.
    /// </summary>
    public string Id { get; }

    /// <summary>
    /// The name of the step. This is intended to be a human-readable name and is not required to be unique.
    /// </summary>
    public string Name { get; }

    /// <summary>
    /// Alternative names that have been used to previous versions of the step
    /// </summary>
    public IReadOnlyList<string> Aliases { get; internal set; } = [];

    /// <summary>
    /// A mapping of group Ids to functions that will be used to map the input of the step to the input of the group.
    /// </summary>
    public Dictionary<string, KernelProcessEdgeGroup> IncomingEdgeGroups { get; internal set; } = [];

    /// <summary>
    /// Define the behavior of the step when the event with the specified Id is fired.
    /// </summary>
    /// <param name="eventId">The Id of the event of interest.</param>
    /// <returns>An instance of <see cref="ProcessStepEdgeBuilder"/>.</returns>
    public ProcessStepEdgeBuilder OnEvent(string eventId)
    {
        // scope the event to this instance of this step
        var scopedEventId = this.GetScopedEventId(eventId);
        return new ProcessStepEdgeBuilder(this, scopedEventId, eventId);
    }

    /// <summary>
    /// Define the behavior of the step when the specified function has been successfully invoked.
    /// </summary>
    /// <param name="functionName">Optional: The name of the function of interest.</param>
    /// If the function name is not provided, it will be inferred if there's exactly one function in the step.
    /// <returns>An instance of <see cref="ProcessStepEdgeBuilder"/>.</returns>
    public ProcessStepEdgeBuilder OnFunctionResult(string? functionName = null)
    {
        if (string.IsNullOrWhiteSpace(functionName))
        {
            functionName = this.ResolveFunctionName();
        }
        return this.OnEvent($"{functionName}.OnResult");
    }

    /// <summary>
    /// Define the behavior of the step when the specified function has thrown an exception.
    /// If the function name is not provided, it will be inferred if there's exactly one function in the step.
    /// </summary>
    /// <param name="functionName">Optional: The name of the function of interest.</param>
    /// <returns>An instance of <see cref="ProcessStepEdgeBuilder"/>.</returns>
    public ProcessStepEdgeBuilder OnFunctionError(string? functionName = null)
    {
        if (string.IsNullOrWhiteSpace(functionName))
        {
            functionName = this.ResolveFunctionName();
        }
        return this.OnEvent($"{functionName}.OnError");
    }

    #endregion

    /// <summary>The namespace for events that are scoped to this step.</summary>
    private readonly string _eventNamespace;

    /// <summary>
    /// A mapping of function names to the functions themselves.
    /// </summary>
    internal Dictionary<string, KernelFunctionMetadata> FunctionsDict { get; set; }

    /// <summary>
    /// A mapping of event Ids to the edges that are triggered by those events.
    /// </summary>
    internal Dictionary<string, List<ProcessStepEdgeBuilder>> Edges { get; }

    /// <summary>
    /// The process builder that this step is a part of. This may be null if the step is itself a process.
    /// </summary>
    internal ProcessBuilder? ProcessBuilder { get; }

    /// <summary>
    /// Builds the step with step state
    /// </summary>
    /// <returns>an instance of <see cref="KernelProcessStepInfo"/>.</returns>
    internal abstract KernelProcessStepInfo BuildStep(ProcessBuilder processBuilder, KernelProcessStepStateMetadata? stateMetadata = null);

    /// <summary>
    /// Registers a group input mapping for the step.
    /// </summary>
    /// <param name="edgeGroup"></param>
    internal void RegisterGroupInputMapping(KernelProcessEdgeGroup edgeGroup)
    {
        // If the group is alrwady registered, then we don't need to register it again.
        if (this.IncomingEdgeGroups.ContainsKey(edgeGroup.GroupId))
        {
            return;
        }

        // Register the group by GroupId.
        this.IncomingEdgeGroups[edgeGroup.GroupId] = edgeGroup;
    }

    /// <summary>
    /// Resolves the function name for the step.
    /// </summary>
    /// <returns></returns>
    /// <exception cref="KernelException"></exception>
    private string ResolveFunctionName()
    {
        if (this.FunctionsDict.Count == 0)
        {
            throw new KernelException($"The step {this.Name} has no functions.");
        }
        else if (this.FunctionsDict.Count > 1)
        {
            throw new KernelException($"The step {this.Name} has more than one function, so a function name must be provided.");
        }

        return this.FunctionsDict.Keys.First();
    }

    /// <summary>
    /// Links the output of the current step to the an input of another step via the specified event type.
    /// </summary>
    /// <param name="eventId">The Id of the event.</param>
    /// <param name="edgeBuilder">The targeted function.</param>
    internal virtual void LinkTo(string eventId, ProcessStepEdgeBuilder edgeBuilder)
    {
        if (!this.Edges.TryGetValue(eventId, out List<ProcessStepEdgeBuilder>? edges) || edges == null)
        {
            edges = [];
            this.Edges[eventId] = edges;
        }

        edges.Add(edgeBuilder);
    }

    /// <summary>
    /// Used to resolve the target function and parameter for a given optional function name and parameter name.
    /// This is used to simplify the process of creating a <see cref="KernelProcessFunctionTarget"/> by making it possible
    /// to infer the function and/or parameter names from the function metadata if only one option exists.
    /// </summary>
    /// <param name="functionName">The name of the function. May be null if only one function exists on the step.</param>
    /// <param name="parameterName">The name of the parameter. May be null if only one parameter exists on the function.</param>
    /// <returns>A valid instance of <see cref="KernelProcessFunctionTarget"/> for this step.</returns>
    /// <exception cref="InvalidOperationException"></exception>
    internal virtual KernelProcessFunctionTarget ResolveFunctionTarget(string? functionName, string? parameterName)
    {
        string? verifiedFunctionName = functionName;
        string? verifiedParameterName = parameterName;

        if (this.FunctionsDict.Count == 0)
        {
            throw new KernelException($"The target step {this.Name} has no functions.");
        }

        // If the function name is null or whitespace, then there can only one function on the step
        if (string.IsNullOrWhiteSpace(verifiedFunctionName))
        {
            if (this.FunctionsDict.Count > 1)
            {
                throw new KernelException("The target step has more than one function, so a function name must be provided.");
            }

            verifiedFunctionName = this.FunctionsDict.Keys.First();
        }

        // Verify that the target function exists
        if (!this.FunctionsDict.TryGetValue(verifiedFunctionName!, out var kernelFunctionMetadata) || kernelFunctionMetadata is null)
        {
            throw new KernelException($"The function {functionName} does not exist on step {this.Name}");
        }

        // If the parameter name is null or whitespace, then the function must have 0 or 1 parameters
        if (string.IsNullOrWhiteSpace(verifiedParameterName))
        {
            var undeterminedParameters = kernelFunctionMetadata.Parameters.Where(p => p.ParameterType != typeof(KernelProcessStepContext)).ToList();

            if (undeterminedParameters.Count > 1)
            {
                // TODO: Uncomment the following line if we want to enforce parameter specification.
                //throw new KernelException($"The function {functionName} on step {this.Name} has more than one parameter, so a parameter name must be provided.");
            }

            // We can infer the parameter name from the function metadata
            if (undeterminedParameters.Count == 1)
            {
                parameterName = undeterminedParameters[0].Name;
                verifiedParameterName = parameterName;
            }
        }

        Verify.NotNull(verifiedFunctionName);

        return new KernelProcessFunctionTarget(
            stepId: this.Id!,
            functionName: verifiedFunctionName,
            parameterName: verifiedParameterName
        );
    }

    /// <summary>
    /// Loads a mapping of function names to the associated functions metadata.
    /// </summary>
    /// <returns>A <see cref="Dictionary{TKey, TValue}"/> where TKey is <see cref="string"/> and TValue is <see cref="KernelFunctionMetadata"/></returns>
    internal abstract Dictionary<string, KernelFunctionMetadata> GetFunctionMetadataMap();

    /// <summary>
    /// Given an event Id, returns a scoped event Id that is unique to this instance of the step.
    /// </summary>
    /// <param name="eventId">The Id of the event.</param>
    /// <returns>An Id that represents the provided event Id scoped to this step instance.</returns>
    protected string GetScopedEventId(string eventId)
    {
        // Scope the event to this instance of this step by prefixing the event Id with the step's namespace.
        return $"{this._eventNamespace}.{eventId}";
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ProcessStepBuilder"/> class.
    /// </summary>
    /// <param name="id">The unique Id of the step.</param>
    /// <param name="processBuilder">The process builder that this step is a part of.</param>
    protected ProcessStepBuilder(string id, ProcessBuilder? processBuilder)
    {
        Verify.NotNullOrWhiteSpace(id, nameof(id));

        this.Id ??= id;
        this.Name = id;
        this.FunctionsDict = [];
        this._eventNamespace = this.Id;
        this.Edges = new Dictionary<string, List<ProcessStepEdgeBuilder>>(StringComparer.OrdinalIgnoreCase);
        this.ProcessBuilder = processBuilder;
    }
}

/// <summary>
/// Provides functionality for incrementally defining a process step.
/// </summary>
public class ProcessStepBuilderTyped : ProcessStepBuilder
{
    /// <summary>
    /// The initial state of the step. This may be null if the step does not have any state.
    /// </summary>
    private object? _initialState;

    private readonly Type _stepType;

    /// <summary>
    /// Creates a new instance of the <see cref="ProcessStepBuilder"/> class. If a name is not provided, the name will be derived from the type of the step.
    /// </summary>
    /// <param name="stepType">The <see cref="Type"/> of the step.</param>
    /// <param name="id">The unique id of the step.</param>
    /// <param name="processBuilder">The process builder that this step is a part of.</param>
    /// <param name="initialState">Initial state of the step to be used on the step building stage</param>
    internal ProcessStepBuilderTyped(Type stepType, string id, ProcessBuilder? processBuilder, object? initialState = default)
        : base(id, processBuilder)
    {
        Verify.NotNull(stepType);

        this._stepType = stepType;
        this.FunctionsDict = this.GetFunctionMetadataMap();
        this._initialState = initialState;
    }

    /// <summary>
    /// Builds the step with a state if provided
    /// </summary>
    /// <returns>An instance of <see cref="KernelProcessStepInfo"/></returns>
    internal override KernelProcessStepInfo BuildStep(ProcessBuilder processBuilder, KernelProcessStepStateMetadata? stateMetadata = null)
    {
        KernelProcessStepState? stateObject = null;
        KernelProcessStepMetadataAttribute stepMetadataAttributes = KernelProcessStepMetadataFactory.ExtractProcessStepMetadataFromType(this._stepType);

        if (this._stepType.TryGetSubtypeOfStatefulStep(out Type? genericStepType) && genericStepType is not null)
        {
            // The step is a subclass of KernelProcessStep<>, so we need to extract the generic type argument
            // and create an instance of the corresponding KernelProcessStepState<>.
            var userStateType = genericStepType.GetGenericArguments()[0];
            Verify.NotNull(userStateType);

            var stateType = typeof(KernelProcessStepState<>).MakeGenericType(userStateType);
            Verify.NotNull(stateType);

            if (stateMetadata != null && stateMetadata.State != null && stateMetadata.State is JsonElement jsonState)
            {
                try
                {
                    this._initialState = jsonState.Deserialize(userStateType);
                }
                catch (JsonException)
                {
                    throw new KernelException($"The initial state provided for step {this.Name} is not of the correct type. The expected type is {userStateType.Name}.");
                }
            }

            // If the step has a user-defined state then we need to validate that the initial state is of the correct type.
            if (this._initialState is not null && this._initialState.GetType() != userStateType)
            {
                throw new KernelException($"The initial state provided for step {this.Name} is not of the correct type. The expected type is {userStateType.Name}.");
            }

            var initialState = this._initialState ?? Activator.CreateInstance(userStateType);
            stateObject = (KernelProcessStepState?)Activator.CreateInstance(stateType, this.Name, stepMetadataAttributes.Version, this.Id);
            stateType.GetProperty(nameof(KernelProcessStepState<object>.State))?.SetValue(stateObject, initialState);
        }
        else
        {
            // The step is a KernelProcessStep with no user-defined state, so we can use the base KernelProcessStepState.
            stateObject = new KernelProcessStepState(this.Name, stepMetadataAttributes.Version, this.Id);
        }

        Verify.NotNull(stateObject);

        // Build the edges first
        var builtEdges = this.Edges.ToDictionary(kvp => kvp.Key, kvp => kvp.Value.Select(e => e.Build()).ToList());

        // Then build the step with the edges and state.
        var builtStep = new KernelProcessStepInfo(this._stepType, stateObject, builtEdges, this.IncomingEdgeGroups);
        return builtStep;
    }

    /// <inheritdoc/>
    internal override Dictionary<string, KernelFunctionMetadata> GetFunctionMetadataMap()
    {
        var metadata = KernelFunctionMetadataFactory.CreateFromType(this._stepType);
        return metadata.ToDictionary(m => m.Name, m => m);
    }
}

/// <summary>
/// Provides functionality for incrementally defining a process step.
/// </summary>
public class ProcessStepBuilder<TStep> : ProcessStepBuilderTyped where TStep : KernelProcessStep
{
    /// <summary>
    /// Creates a new instance of the <see cref="ProcessStepBuilder"/> class. If a name is not provided, the name will be derived from the type of the step.
    /// </summary>
    /// <param name="id">The unique Id of the step.</param>
    /// <param name="processBuilder">The process builder that this step is a part of.</param>
    /// <param name="initialState">Initial state of the step to be used on the step building stage</param>
    internal ProcessStepBuilder(string id, ProcessBuilder? processBuilder = null, object? initialState = default)
        : base(typeof(TStep), id, processBuilder, initialState)
    {
    }
}


===== Process.Core\ProcessStepEdgeBuilder.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Linq;
using Microsoft.SemanticKernel.Process.Internal;

namespace Microsoft.SemanticKernel;

/// <summary>
/// Provides functionality for incrementally defining a process edge.
/// </summary>
public class ProcessStepEdgeBuilder
{
    internal ProcessTargetBuilder? Target { get; set; }

    /// <summary>
    /// The event data that the edge fires on.
    /// </summary>
    internal ProcessEventData EventData { get; }

    /// <summary>
    /// The source step of the edge.
    /// </summary>
    internal ProcessStepBuilder Source { get; }

    /// <summary>
    /// The EdgeGroupBuilder for the edge
    /// </summary>
    internal KernelProcessEdgeGroupBuilder? EdgeGroupBuilder { get; set; }

    /// <summary>
    /// The condition that must be met for the edge to fire.
    /// </summary>
    internal KernelProcessEdgeCondition? Condition { get; set; }

    /// <summary>
    /// An optional variable update to be performed when the edge fires.
    /// </summary>
    internal VariableUpdate? VariableUpdate { get; set; }

    /// <summary>
    /// Initializes a new instance of the <see cref="ProcessStepEdgeBuilder"/> class.
    /// </summary>
    /// <param name="source">The source step.</param>
    /// <param name="eventId">The Id of the event.</param>
    /// <param name="eventName"></param>
    /// <param name="edgeGroupBuilder">The group Id for the edge.</param>
    /// <param name="condition">The condition that must be met for the edge to fire.</param>
    internal ProcessStepEdgeBuilder(ProcessStepBuilder source, string eventId, string eventName, KernelProcessEdgeGroupBuilder? edgeGroupBuilder = null, KernelProcessEdgeCondition? condition = null)
    {
        Verify.NotNull(source, nameof(source));
        Verify.NotNullOrWhiteSpace(eventId, nameof(eventId));

        this.Source = source;
        this.EventData = new() { EventId = eventId, EventName = eventName };
        this.EdgeGroupBuilder = edgeGroupBuilder;
        this.Condition = condition;
    }

    /// <summary>
    /// Builds the edge.
    /// </summary>
    internal KernelProcessEdge Build(ProcessBuilder? processBuilder = null)
    {
        Verify.NotNull(this.Source?.Id);

        if (this.Target is null || this.Source?.Id is null)
        {
            throw new InvalidOperationException("A target and Source must be specified before building the edge.");
        }

        if (this.Target is ProcessFunctionTargetBuilder functionTargetBuilder)
        {
            if (this.EdgeGroupBuilder is not null && this.Target is ProcessStepTargetBuilder stepTargetBuilder)
            {
                var messageSources = this.EdgeGroupBuilder.MessageSources.Select(e => new KernelProcessMessageSource(e.MessageType, e.Source.Id)).ToList();
                var edgeGroup = new KernelProcessEdgeGroup(this.EdgeGroupBuilder.GroupId, messageSources, stepTargetBuilder.InputMapping);
                functionTargetBuilder.Step.RegisterGroupInputMapping(edgeGroup);
            }
        }

        return new KernelProcessEdge(this.Source.Id, this.Target.Build(processBuilder), groupId: this.EdgeGroupBuilder?.GroupId, this.Condition, this.VariableUpdate);
    }

    /// <summary>
    /// Signals that the output of the source step should be sent to the specified target when the associated event fires.
    /// </summary>
    /// <param name="target">The output target.</param>
    /// <returns>A fresh builder instance for fluid definition</returns>
    public ProcessStepEdgeBuilder SendEventTo(ProcessTargetBuilder target)
    {
        return this.SendEventTo_Internal(target);
    }

    /// <summary>
    /// Sets the condition for the edge.
    /// </summary>
    /// <param name="condition"></param>
    /// <returns></returns>
    public ProcessStepEdgeBuilder OnCondition(KernelProcessEdgeCondition condition)
    {
        Verify.NotNull(condition, nameof(condition));
        this.Condition = condition;
        return this;
    }

    /// <summary>
    /// Internally overridable implementation: Signals that the output of the source step should be sent to the specified target when the associated event fires.
    /// </summary>
    /// <param name="target">The output target.</param>
    /// <returns>A fresh builder instance for fluid definition</returns>
    /// <exception cref="InvalidOperationException"></exception>
    /// <exception cref="ArgumentException"></exception>
    internal virtual ProcessStepEdgeBuilder SendEventTo_Internal(ProcessTargetBuilder target)
    {
        if (this.Target is not null)
        {
            throw new InvalidOperationException("An output target has already been set.");
        }

        if (target is ProcessFunctionTargetBuilder functionTargetBuilder)
        {
            if (functionTargetBuilder.Step is ProcessMapBuilder && this.Source is ProcessMapBuilder)
            {
                throw new ArgumentException($"{nameof(ProcessMapBuilder)} may not target another {nameof(ProcessMapBuilder)}.", nameof(target));
            }
        }

        this.Target = target;
        this.Source.LinkTo(this.EventData.EventId, this);

        return new ProcessStepEdgeBuilder(this.Source, this.EventData.EventId, this.EventData.EventName, this.EdgeGroupBuilder, this.Condition);
    }

    /// <summary>
    /// Emit the SK step event as an external event with specific topic name
    /// </summary>
    /// <returns></returns>
    public ProcessStepEdgeBuilder EmitExternalEvent(ProcessProxyBuilder proxyStep, string topicName)
    {
        // 1. Link sk event and topic
        proxyStep.LinkTopicToStepEdgeInfo(topicName, this.Source, this.EventData);

        // 2. Regular SK step link step functions/edge connection
        var targetBuilder = proxyStep.GetExternalFunctionTargetBuilder();

        return this.SendEventTo(targetBuilder);
    }

    /// <summary>
    /// Emit the SK step event as an external event with specific topic name
    /// </summary>
    /// <returns></returns>
    public ProcessStepEdgeBuilder SentToAgentStep(ProcessAgentBuilder agentStep)
    {
        var targetBuilder = agentStep.GetInvokeAgentFunctionTargetBuilder();

        return this.SendEventTo(targetBuilder);
    }

    /// <summary>
    /// Signals that the process should be stopped.
    /// </summary>
    public virtual void StopProcess()
    {
        if (this.Target is not null)
        {
            throw new InvalidOperationException("An output target has already been set.");
        }

        var outputTarget = new ProcessFunctionTargetBuilder(EndStep.Instance);
        this.Target = outputTarget;
        this.Source.LinkTo(ProcessConstants.EndStepName, this);
    }
}


===== Process.Core\Tools\ProcessStepLoader.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

namespace Microsoft.SemanticKernel.Process.Tools;

/// <summary>
/// Helper class to load process steps.
/// </summary>
public static class ProcessStepLoader
{
    /// <summary>
    /// Returns a collection of step types from provided assembly paths.
    /// </summary>
    /// <param name="assemblyPaths">Collection of names or paths of the files that contain the manifest of the assembly.</param>
    public static Dictionary<string, Type> LoadStepTypesFromAssemblies(List<string> assemblyPaths)
    {
        Dictionary<string, Type> stepTypes = [];

        if (assemblyPaths is { Count: > 0 })
        {
            foreach (var assemblyPath in assemblyPaths)
            {
                if (!string.IsNullOrWhiteSpace(assemblyPath))
                {
                    var assembly = Assembly.LoadFrom(assemblyPath);

                    var assemblyStepTypes = assembly.GetTypes()
                        .Where(type => typeof(KernelProcessStep).IsAssignableFrom(type));

                    foreach (var stepType in assemblyStepTypes)
                    {
                        var stepTypeName = stepType.FullName!;
                        var stepAssemblyName = stepType.Assembly.GetName().Name;
                        var stepName = $"{stepType}, {stepAssemblyName}";

                        stepTypes.Add(stepName, stepType);
                    }
                }
            }
        }

        return stepTypes;
    }
}


===== Process.Core\Tools\ProcessVisualizationExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Linq;
using System.Text;

namespace Microsoft.SemanticKernel.Process.Tools;

/// <summary>
/// Provides extension methods to visualize a process as a Mermaid diagram.
/// </summary>
public static class ProcessVisualizationExtensions
{
    /// <summary>
    /// Generates a Mermaid diagram from a process builder.
    /// </summary>
    /// <param name="processBuilder"></param>
    /// <param name="maxLevel">The maximum indentation level to reach for nested processes, 1 is basically no nesting</param>
    /// <returns></returns>
    public static string ToMermaid(this ProcessBuilder processBuilder, int maxLevel = 2)
    {
        var process = processBuilder.Build();
        return process.ToMermaid(maxLevel);
    }

    /// <summary>
    /// Generates a Mermaid diagram from a kernel process.
    /// </summary>
    /// <param name="process"></param>
    /// <param name="maxLevel">The maximum indentation level to reach for nested processes, 1 is basically no nesting</param>
    /// <returns></returns>
    public static string ToMermaid(this KernelProcess process, int maxLevel = 2)
    {
        // Check that the maximum level is at least 1
        if (maxLevel < 1)
        {
            throw new InvalidOperationException("The maximum indentation level must be at least 1.");
        }

        StringBuilder sb = new();
        sb.AppendLine("flowchart LR");

        // Generate the Mermaid flowchart content with indentation
        string flowchartContent = RenderProcess(process, 1, isSubProcess: false, maxLevel);

        // Append the formatted content to the main StringBuilder
        sb.Append(flowchartContent);

        return sb.ToString();
    }

    /// <summary>
    /// Renders a process and its nested processes recursively as a Mermaid flowchart.
    /// </summary>
    /// <param name="process">The process to render.</param>
    /// <param name="level">The indentation level for nested processes.</param>
    /// <param name="isSubProcess">Indicates if the current process is a sub-process.</param>
    /// <param name="maxLevel">The maximum indentation level to reach for nested processes, 1 is basically no nesting</param>
    /// <returns>A string representation of the process in Mermaid syntax.</returns>
    private static string RenderProcess(KernelProcess process, int level, bool isSubProcess, int maxLevel = 2)
    {
        StringBuilder sb = new();
        string indentation = new(' ', 4 * level);

        // Dictionary to map step IDs to step names
        var stepNames = process.Steps
            .Where(step => step.State.Id != null && step.State.Name != null)
            .ToDictionary(
                step => step.State.Id!,
                step => step.State.Name!
            );

        // Add Start and End nodes only if this is not a sub-process
        if (!isSubProcess)
        {
            sb.AppendLine($"{indentation}Start[\"Start\"]");
            sb.AppendLine($"{indentation}End[\"End\"]");
        }

        // Process each step
        foreach (var step in process.Steps)
        {
            var stepId = step.State.Id;
            var stepName = step.State.Name;

            // Check if the step is a nested process (sub-process)
            if (step is KernelProcess nestedProcess && level < maxLevel)
            {
                sb.AppendLine($"{indentation}subgraph {stepName.Replace(" ", "")}[\"{stepName}\"]");
                sb.AppendLine($"{indentation}    direction LR");

                // Render the nested process content without its own Start/End nodes
                string nestedFlowchart = RenderProcess(nestedProcess, level + 1, isSubProcess: true, maxLevel);

                sb.Append(nestedFlowchart);
                sb.AppendLine($"{indentation}end");
            }
            else if (step is KernelProcess nestedProcess2 && level >= maxLevel)
            {
                // Render a subprocess step
                sb.AppendLine($"{indentation}{stepName}[[\"{stepName}\"]]");
            }
            else
            {
                // Render the regular step
                sb.AppendLine($"{indentation}{stepName}[\"{stepName}\"]");
            }

            // Handle edges from this step
            if (step.Edges != null)
            {
                foreach (var kvp in step.Edges)
                {
                    var eventId = kvp.Key;
                    var stepEdges = kvp.Value;

                    // Skip drawing edges that point to a nested process as an entry point
                    if (stepNames.ContainsKey(eventId) && process.Steps.Any(s => s.State.Name == eventId && s is KernelProcess))
                    {
                        continue;
                    }

                    foreach (var edge in stepEdges)
                    {
                        string source = $"{stepName}[\"{stepName}\"]";
                        string target;

                        if (edge.OutputTarget is KernelProcessFunctionTarget functionTarget)
                        {
                            // Check if the target step is the end node by function name
                            if (functionTarget.FunctionName.Equals("end", StringComparison.OrdinalIgnoreCase) && !isSubProcess)
                            {
                                target = "End[\"End\"]";
                            }
                            else if (stepNames.TryGetValue(functionTarget.StepId, out string? targetStepName))
                            {
                                target = $"{targetStepName}[\"{targetStepName}\"]";
                            }
                            else
                            {
                                // Handle cases where the target step is not in the current dictionary, possibly a nested step or placeholder
                                // As we have events from the step that, when it is a subprocess, that go to a step in the subprocess
                                // Those are triggered by events and do not have an origin step, also they are not connected to the Start node
                                // So we need to handle them separately - we ignore them for now
                                continue;
                            }

                            // Append the connection
                            sb.AppendLine($"{indentation}{source} --> {target}");
                        }
                    }
                }
            }
        }

        // Connect Start to the first step and the last step to End (only for the main process)
        if (!isSubProcess && process.Steps.Count > 0)
        {
            var firstStepName = process.Steps.First().State.Name;
            var lastStepName = process.Steps.Last().State.Name;

            sb.AppendLine($"{indentation}Start --> {firstStepName}[\"{firstStepName}\"]");
            sb.AppendLine($"{indentation}{lastStepName}[\"{lastStepName}\"] --> End");
        }

        return sb.ToString();
    }
}


===== Process.Core\Workflow\WorkflowBuilder.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text.Json;
using System.Text.Json.Nodes;
using System.Threading.Tasks;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.Process.Internal;
using YamlDotNet.RepresentationModel;
using YamlDotNet.Serialization;
using YamlDotNet.Serialization.NamingConventions;

namespace Microsoft.SemanticKernel;

/// <summary>
/// Builds a workflow from a YAML definition.
/// </summary>
internal class WorkflowBuilder
{
    private readonly Dictionary<string, ProcessStepBuilder> _stepBuilders = [];
    private readonly Dictionary<string, CloudEvent> _inputEvents = [];
    private string? _yaml;

    /// <summary>
    /// Builds a process from a workflow definition.
    /// </summary>
    /// <param name="workflow">An instance of <see cref="Workflow"/>.</param>
    /// <param name="yaml">Workflow definition in YAML format.</param>
    /// <param name="stepTypes">Collection of preloaded step types.</param>
    public async Task<KernelProcess?> BuildProcessAsync(Workflow workflow, string yaml, Dictionary<string, Type>? stepTypes = null)
    {
        this._yaml = yaml;
        var stepBuilders = new Dictionary<string, ProcessStepBuilder>();

        if (workflow.Nodes is null || workflow.Nodes.Count == 0)
        {
            throw new ArgumentException("Workflow nodes are not specified.");
        }

        if (workflow.Inputs is null)
        {
            throw new ArgumentException("Workflow inputs are not specified.");
        }

        // TODO: Process outputs
        // TODO: Process variables

        ProcessBuilder processBuilder = new(workflow.Id, description: workflow.Description, stateType: typeof(ProcessDefaultState));

        if (workflow.Inputs.Events?.CloudEvents is not null)
        {
            foreach (CloudEvent inputEvent in workflow.Inputs.Events.CloudEvents)
            {
                await this.AddInputEventAsync(inputEvent, processBuilder).ConfigureAwait(false);
            }
        }

        if (workflow.Inputs.Messages is not null)
        {
            await this.AddInputMessagesEventAsync(processBuilder).ConfigureAwait(false);
        }

        // Process the nodes
        foreach (var step in workflow.Nodes)
        {
            await this.AddStepAsync(step, processBuilder, stepTypes).ConfigureAwait(false);
        }

        // Process the orchestration
        if (workflow.Orchestration is not null)
        {
            await this.BuildOrchestrationAsync(workflow.Orchestration, processBuilder).ConfigureAwait(false);
        }

        return processBuilder.Build();
    }

    #region Inputs

    private Task AddInputEventAsync(CloudEvent inputEvent, ProcessBuilder processBuilder)
    {
        this._inputEvents[inputEvent.Type] = inputEvent;
        return Task.CompletedTask;
    }

    private Task AddInputMessagesEventAsync(ProcessBuilder processBuilder)
    {
        string inputMessageEventType = "input_message_received";
        this._inputEvents[inputMessageEventType] = new CloudEvent() { Type = inputMessageEventType };
        return Task.CompletedTask;
    }

    #endregion

    #region Nodes and Steps

    internal async Task AddStepAsync(Node node, ProcessBuilder processBuilder, Dictionary<string, Type>? stepTypes = null)
    {
        Verify.NotNull(node);

        if (node.Type == "dotnet")
        {
            await this.BuildDotNetStepAsync(node, processBuilder, stepTypes).ConfigureAwait(false);
        }
        else if (node.Type == "python")
        {
            await this.BuildPythonStepAsync(node, processBuilder).ConfigureAwait(false);
        }
        else if (node.Type == "declarative")
        {
            await this.BuildDeclarativeStepAsync(node, processBuilder).ConfigureAwait(false);
        }
        else
        {
            throw new ArgumentException($"Unsupported node type: {node.Type}");
        }
    }

    private Task BuildDeclarativeStepAsync(Node node, ProcessBuilder processBuilder)
    {
        Verify.NotNull(node);

        // Check for built-in step types
        if (node.Id.Equals("End", StringComparison.OrdinalIgnoreCase))
        {
            var endBuilder = processBuilder.AddEndStep();
            this._stepBuilders["End"] = endBuilder;
            return Task.CompletedTask;
        }

        AgentDefinition? agentDefinition = node.Agent ?? throw new KernelException("Declarative steps must have an agent defined.");
        var stepBuilder = processBuilder.AddStepFromAgent(agentDefinition, node.Id);
        if (stepBuilder is not ProcessAgentBuilder agentBuilder)
        {
            throw new KernelException($"Failed to build step from agent definition: {node.Id}");
        }

        // ########################### Parsing on_complete and on_error conditions ###########################

        if (node.OnComplete != null)
        {
            if (node.OnComplete.Any(c => c is null || c.OnCondition is null))
            {
                throw new ArgumentException("A complete on_complete condition is required for declarative steps.");
            }

            agentBuilder.OnComplete([.. node.OnComplete.Select(c => c.OnCondition!)]);
        }

        if (node.OnError != null)
        {
            if (node.OnError.Any(c => c is null || c.OnCondition is null))
            {
                throw new ArgumentException("A complete on_complete condition is required for declarative steps.");
            }

            agentBuilder.OnComplete([.. node.OnError.Select(c => c.OnCondition!)]);
        }

        // ########################### Parsing node inputs ###########################

        if (node.Inputs != null)
        {
            var inputMapping = this.ExtractNodeInputs(node.Id);
            //agentBuilder.WithNodeInputs(node.Inputs); TODO: What to do here?
        }

        this._stepBuilders[node.Id] = stepBuilder;
        return Task.CompletedTask;
    }

    private Task BuildPythonStepAsync(Node node, ProcessBuilder processBuilder)
    {
        throw new KernelException("Python nodes are not supported in the dotnet runtime.");
    }

    private Task BuildDotNetStepAsync(Node node, ProcessBuilder processBuilder, Dictionary<string, Type>? stepTypes = null)
    {
        Verify.NotNull(node);

        if (node.Agent is null || string.IsNullOrEmpty(node.Agent.Type))
        {
            throw new ArgumentException($"The agent specified in the Node with id {node.Id} is not fully specified.");
        }

        // For dotnet node type, the agent type specifies the assembly qualified namespace of the class to be executed.
        Type? dotnetAgentType = null;
        try
        {
            if (stepTypes is not null && stepTypes.TryGetValue(node.Agent.Type, out var type) && type is not null)
            {
                dotnetAgentType = type;
            }
            else
            {
                dotnetAgentType = Type.GetType(node.Agent.Type);
            }
        }
        catch (TypeLoadException tle)
        {
            throw new KernelException($"Failed to load the agent for node with id {node.Id}.", tle);
        }

        if (dotnetAgentType == null)
        {
            throw new KernelException("The agent type specified in the node is not found.");
        }

        var stepBuilder = processBuilder.AddStepFromType(dotnetAgentType, id: node.Id);
        this._stepBuilders[node.Id] = stepBuilder;
        return Task.CompletedTask;
    }

    #endregion

    #region Orchestration

    private Task BuildOrchestrationAsync(List<OrchestrationStep> orchestrationSteps, ProcessBuilder processBuilder)
    {
        // If there are no orchestration steps, return
        if (orchestrationSteps.Count == 0)
        {
            return Task.CompletedTask;
        }

        // Process the orchestration steps
        foreach (var step in orchestrationSteps)
        {
            ListenCondition? listenCondition = step.ListenFor;
            if (listenCondition is null)
            {
                throw new ArgumentException("A complete listen_for condition is required for orchestration steps.");
            }

            List<ThenAction>? thenActions = step.Then;
            if (thenActions is null || thenActions.Count == 0)
            {
                throw new ArgumentException("At least one then action is required for orchestration steps.");
            }

            ProcessStepEdgeBuilder? edgeBuilder = null;

            if (listenCondition.AllOf != null && listenCondition.AllOf.Count > 0)
            {
                MessageSourceBuilder GetSourceBuilder(ListenEvent listenEvent)
                {
                    var sourceBuilder = this.FindSourceBuilder(new() { Event = listenEvent.Event, From = listenEvent.From }, processBuilder);
                    return new MessageSourceBuilder
                    (
                        messageType: listenEvent.Event,
                        source: this._stepBuilders[listenEvent.From],
                        null // TODO: Pass through condition.
                    );
                }

                // Handle AllOf condition
                edgeBuilder = processBuilder.ListenFor().AllOf(listenCondition.AllOf.Select(c => GetSourceBuilder(c)).ToList());
            }
            else if (!string.IsNullOrWhiteSpace(listenCondition.Event) && !string.IsNullOrWhiteSpace(listenCondition.From))
            {
                // Find the source of the edge, it could either be a step, or an input event.
                if (this._stepBuilders.TryGetValue(listenCondition.From, out ProcessStepBuilder? sourceStepBuilder))
                {
                    // The source is a step.
                    edgeBuilder = sourceStepBuilder.OnEvent(listenCondition.Event);
                }
                else if (listenCondition.From.Equals("_workflow_", StringComparison.OrdinalIgnoreCase) && this._inputEvents.ContainsKey(listenCondition.Event))
                {
                    // The source is an input event.
                    edgeBuilder = processBuilder.OnInputEvent(listenCondition.Event);
                }
                else
                {
                    throw new ArgumentException($"An orchestration is referencing a node with Id `{listenCondition.From}` that does not exist.");
                }
            }
            else
            {
                throw new ArgumentException("A complete listen_for condition is required for orchestration steps.");
            }

            // Now that we have a validated edge source, we can add the then actions
            foreach (var action in thenActions)
            {
                if (action is null || string.IsNullOrWhiteSpace(action.Node))
                {
                    throw new ArgumentException("A complete then action is required for orchestration steps.");
                }

                if (!this._stepBuilders.TryGetValue(action.Node, out ProcessStepBuilder? destinationStepBuilder))
                {
                    if (action.Node.Equals("End", StringComparison.OrdinalIgnoreCase))
                    {
                        edgeBuilder.StopProcess();
                        continue;
                    }

                    throw new ArgumentException($"An orchestration is referencing a node with Id `{action.Node}` that does not exist.");
                }

                // Add the edge to the node
                edgeBuilder = edgeBuilder.SendEventTo(new ProcessFunctionTargetBuilder(destinationStepBuilder));
            }
        }

        return Task.CompletedTask;
    }

    #endregion

    #region FromProcess

    /// <summary>
    /// Builds a workflow from a kernel process.
    /// </summary>
    /// <param name="process"></param>
    /// <returns></returns>
    public static Task<Workflow> BuildWorkflow(KernelProcess process)
    {
        Verify.NotNull(process);

        Workflow workflow = new()
        {
            Id = process.State.Id ?? throw new KernelException("The process must have an Id set"),
            Description = process.Description,
            FormatVersion = "1.0",
            Name = process.State.Name,
            Nodes = [new Node { Id = "End", Type = "declarative", Version = "1.0", Description = "Terminal state" }],
            Variables = [],
        };

        // Add variables
        foreach (var thread in process.Threads)
        {
            workflow.Variables.Add(thread.Key, new VariableDefinition()
            {
                Type = VariableType.Thread,
            });
        }

        if (process.UserStateType != null)
        {
            // Get all public properties
            PropertyInfo[] properties = process.UserStateType.GetProperties(BindingFlags.Public | BindingFlags.Instance);

            // Loop through each property and output its type
            foreach (PropertyInfo property in properties)
            {
                if (property.PropertyType == typeof(List<ChatMessageContent>))
                {
                    workflow.Variables.Add(property.Name, new VariableDefinition()
                    {
                        Type = VariableType.Messages,
                    });

                    continue;
                }

                var schema = KernelJsonSchemaBuilder.Build(property.PropertyType);
                var schemaJson = JsonSerializer.Serialize(schema.RootElement);

                var deserializer = new DeserializerBuilder()
                .WithNamingConvention(UnderscoredNamingConvention.Instance)
                .IgnoreUnmatchedProperties()
                .Build();

                var yamlSchema = deserializer.Deserialize(schemaJson) ?? throw new KernelException("Failed to deserialize schema.");
                workflow.Variables.Add(property.Name, new VariableDefinition { Type = VariableType.UserDefined, Schema = yamlSchema });
            }
        }

        // Add edges
        var orchestration = new List<OrchestrationStep>();
        foreach (var edge in process.Edges)
        {
            // Get all the input events
            OrchestrationStep orchestrationStep = new()
            {
                ListenFor = new ListenCondition()
                {
                    From = "_workflow_",
                    Event = ResolveEventName(edge.Key)
                },
                Then = [.. edge.Value.Select(e => ThenAction.FromKernelProcessEdge(e, null))]
            };

            orchestration.Add(orchestrationStep);
        }

        var steps = process.Steps;
        foreach (var step in steps)
        {
            workflow.Nodes?.Add(BuildNode(step, orchestration));
        }

        workflow.Orchestration = orchestration;
        return Task.FromResult(workflow);
    }

    private static Node BuildNode(KernelProcessStepInfo step, List<OrchestrationStep> orchestrationSteps)
    {
        Verify.NotNullOrWhiteSpace(step?.State?.Id, nameof(step.State.Id));

        if (step is KernelProcessAgentStep agentStep)
        {
            return BuildAgentNode(agentStep, orchestrationSteps);
        }

        var innerStepTypeString = step.InnerStepType.AssemblyQualifiedName;
        if (string.IsNullOrWhiteSpace(innerStepTypeString))
        {
            throw new InvalidOperationException("Attempt to build a workflow node from step with no Id");
        }

        var node = new Node()
        {
            Id = step.State.Id,
            Type = "dotnet",
            Agent = new AgentDefinition()
            {
                Type = innerStepTypeString,
                Id = step.State.Id
            }
        };

        foreach (var edge in step.Edges)
        {
            OrchestrationStep orchestrationStep = new()
            {
                ListenFor = new ListenCondition()
                {
                    From = step.State.Id,
                    Event = edge.Key,
                    Condition = edge.Value.FirstOrDefault()?.Condition.DeclarativeDefinition
                },
                Then = [.. edge.Value.Select(e =>
                {
                    if (e.OutputTarget is KernelProcessFunctionTarget functionTarget)
                    {
                        return new ThenAction()
                        {
                            Node = functionTarget.StepId switch
                            {
                                ProcessConstants.EndStepName => "End",
                                string s => s
                            }
                        };
                    }

                    throw new KernelException($"The edge target is not a function target: {e.OutputTarget}");
                })]
            };

            orchestrationSteps.Add(orchestrationStep);
        }

        return node;
    }

    private static Node BuildAgentNode(KernelProcessAgentStep agentStep, List<OrchestrationStep> orchestrationSteps)
    {
        Verify.NotNull(agentStep);

        if (agentStep.AgentDefinition is null || string.IsNullOrWhiteSpace(agentStep.State?.Id) || string.IsNullOrWhiteSpace(agentStep.AgentDefinition.Type))
        {
            throw new InvalidOperationException("Attempt to build a workflow node from step with no Id");
        }

        var node = new Node()
        {
            Id = agentStep.State.Id!,
            Type = agentStep.AgentDefinition.Type!,
            Agent = agentStep.AgentDefinition,
            HumanInLoopType = agentStep.HumanInLoopMode,
            OnComplete = ToEventActions(agentStep.Actions?.DeclarativeActions?.OnComplete),
            OnError = ToEventActions(agentStep.Actions?.DeclarativeActions?.OnError),
            Inputs = agentStep.Inputs.ToDictionary((kvp) => kvp.Key, (kvp) =>
            {
                var value = kvp.Value;
                var schema = KernelJsonSchemaBuilder.Build(value);
                var schemaJson = JsonSerializer.Serialize(schema.RootElement);

                var deserializer = new DeserializerBuilder()
                .WithNamingConvention(UnderscoredNamingConvention.Instance)
                .IgnoreUnmatchedProperties()
                .Build();

                var yamlSchema = deserializer.Deserialize(schemaJson);
                if (yamlSchema is null)
                {
                    throw new KernelException("Failed to deserialize schema.");
                }

                return yamlSchema;
            })
        };

        // re-group the edges to account for different conditions
        var conditionGroupedEdges = agentStep.Edges
            .SelectMany(kvp => kvp.Value, (kvp, k) => new { key = kvp.Key, edge = k })
            .GroupBy(e => new { e.key, e.edge.Condition?.DeclarativeDefinition })
            .ToDictionary(g => g.Key, g => g.ToList());

        foreach (var edge in conditionGroupedEdges)
        {
            OrchestrationStep orchestrationStep = new()
            {
                ListenFor = new ListenCondition()
                {
                    From = agentStep.State.Id,
                    Event = ResolveEventName(edge.Key.key),
                    Condition = edge.Key.DeclarativeDefinition
                },
                Then = [.. edge.Value.Select(e => ThenAction.FromKernelProcessEdge(e.edge, defaultThread: agentStep.ThreadName))]
            };

            orchestrationSteps.Add(orchestrationStep);
        }

        return node;
    }

    private static string ResolveEventName(string eventName)
    {
        Verify.NotNullOrWhiteSpace(eventName);

        if (eventName.EndsWith("Invoke.OnResult", StringComparison.Ordinal) || eventName.EndsWith(ProcessConstants.Declarative.OnCompleteEvent, StringComparison.OrdinalIgnoreCase))
        {
            return ProcessConstants.Declarative.OnExitEvent;
        }
        if (eventName.EndsWith(ProcessConstants.Declarative.OnErrorEvent, StringComparison.Ordinal))
        {
            return ProcessConstants.Declarative.OnErrorEvent;
        }
        if (eventName.EndsWith(ProcessConstants.Declarative.OnEnterEvent, StringComparison.Ordinal))
        {
            return ProcessConstants.Declarative.OnEnterEvent;
        }
        if (eventName.EndsWith(ProcessConstants.Declarative.OnExitEvent, StringComparison.Ordinal))
        {
            return ProcessConstants.Declarative.OnExitEvent;
        }

        // remove the first part of the event name before the first period
        int index = eventName.IndexOf(ProcessConstants.EventIdSeparator);
        if (index > 0)
        {
            eventName = eventName.Substring(index + 1);
        }

        return eventName;
    }

    private static List<OnEventAction>? ToEventActions(KernelProcessDeclarativeConditionHandler? handler)
    {
        if (handler is null)
        {
            return null;
        }

        List<OnEventAction> actions = [];
        if (handler.EvalConditions is not null && handler.EvalConditions.Count > 0)
        {
            actions.AddRange(handler.EvalConditions.Select(h =>
            {
                return new OnEventAction
                {
                    OnCondition = new DeclarativeProcessCondition
                    {
                        Type = DeclarativeProcessConditionType.Eval,
                        Expression = h.Expression,
                        Emits = h.Emits,
                        Updates = h.Updates
                    }
                };
            }));
        }

        if (handler.AlwaysCondition is not null)
        {
            actions.Add(
                new OnEventAction
                {
                    OnCondition = new DeclarativeProcessCondition
                    {
                        Type = DeclarativeProcessConditionType.Always,
                        Expression = handler.AlwaysCondition.Expression,
                        Emits = handler.AlwaysCondition.Emits,
                        Updates = handler.AlwaysCondition.Updates
                    }
                });
        }

        if (handler.DefaultCondition is not null)
        {
            actions.Add(
                new OnEventAction
                {
                    OnCondition = new DeclarativeProcessCondition
                    {
                        Type = DeclarativeProcessConditionType.Default,
                        Expression = handler.DefaultCondition.Expression,
                        Emits = handler.DefaultCondition.Emits,
                        Updates = handler.DefaultCondition.Updates
                    }
                });
        }

        return actions;
    }

    /// <summary>
    /// Find the source of the edge, it could either be a step, or an input event.
    /// </summary>
    /// <param name="listenCondition"></param>
    /// <param name="processBuilder"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    private ProcessStepEdgeBuilder FindSourceBuilder(ListenEvent listenCondition, ProcessBuilder processBuilder)
    {
        Verify.NotNull(listenCondition);

        ProcessStepEdgeBuilder? edgeBuilder = null;

        // Find the source of the edge, it could either be a step, or an input event.
        if (this._stepBuilders.TryGetValue(listenCondition.From, out ProcessStepBuilder? sourceStepBuilder))
        {
            // The source is a step.
            edgeBuilder = sourceStepBuilder.OnEvent(listenCondition.Event);
        }
        else if (listenCondition.From.Equals("$.inputs.events", StringComparison.OrdinalIgnoreCase) && this._inputEvents.ContainsKey(listenCondition.Event))
        {
            // The source is an input event.
            edgeBuilder = processBuilder.OnInputEvent(listenCondition.Event);
        }
        else
        {
            throw new ArgumentException($"An orchestration is referencing a node with Id `{listenCondition.From}` that does not exist.");
        }

        return edgeBuilder;
    }

    #endregion

    private Dictionary<string, JsonNode> ExtractNodeInputs(string nodeId)
    {
        var input = new StringReader(this._yaml ?? "");
        var yamlStream = new YamlStream();
        yamlStream.Load(input);

        var rootNode = yamlStream.Documents[0].RootNode;
        var agentsNode = rootNode["nodes"] as YamlSequenceNode;
        var node = agentsNode?.Children
            .OfType<YamlMappingNode>()
            .FirstOrDefault(node => node["id"]?.ToString() == nodeId);

        if (node is null || !node.Children.TryGetValue("inputs", out YamlNode? inputs) || input is null || inputs is not YamlMappingNode inputMap)
        {
            throw new KernelException("Failed to deserialize workflow.");
        }

        // This dance to convert the YamlMappingNode to a string and then back to a JsonSchema is rather inefficient, need to find a better option.
        // Serialize the YamlMappingNode to a Yaml string
        var serializer = new SerializerBuilder().Build();
        string rawYaml = serializer.Serialize(inputMap);

        // Deserialize the Yaml string to an object
        var deserializer = new DeserializerBuilder().WithNamingConvention(UnderscoredNamingConvention.Instance).Build();
        var yamlObject = deserializer.Deserialize(rawYaml);

        // Serialize the object to a JSON string
        var jsonSchema = JsonSerializer.Serialize(yamlObject);
        var jsonNode = JsonNode.Parse(jsonSchema) ?? throw new KernelException("Failed to parse schema.");

        var inputsDictionary = inputMap.Select(inputMap => new KeyValuePair<string, JsonNode>(inputMap.Key.ToString(), jsonNode))
            .ToDictionary(kvp => kvp.Key, kvp => kvp.Value);

        return inputsDictionary;
    }
}


===== Process.Core\WorkflowSerializer.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.Serialization;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading.Tasks;
using YamlDotNet.Core;
using YamlDotNet.Core.Events;
using YamlDotNet.Serialization;
using YamlDotNet.Serialization.NamingConventions;

namespace Microsoft.SemanticKernel;

/// <summary>
/// Helper class for serializing and deserializing workflows
/// </summary>
internal static class WorkflowSerializer
{
    private static readonly JsonSerializerOptions s_jsonOptions = new()
    {
        PropertyNamingPolicy = JsonNamingPolicy.SnakeCaseLower,
        DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull,
        PropertyNameCaseInsensitive = true,
        Converters = { new JsonEnumMemberStringEnumConverter(JsonNamingPolicy.SnakeCaseLower) }
    };

    /// <summary>
    /// Deserializes a workflow from YAML
    /// </summary>
    /// <param name="yaml">The YAML string</param>
    /// <returns>The deserialized workflow</returns>
    public static Workflow DeserializeFromYaml(string yaml)
    {
        var deserializer = new DeserializerBuilder()
                .WithNamingConvention(UnderscoredNamingConvention.Instance)
                .IgnoreUnmatchedProperties()
                .Build();

        Workflow? workflow = null;

        try
        {
            // Try to deserialize workflow wrapper version first.
            var wrapper = deserializer.Deserialize<WorkflowWrapper>(yaml);
            workflow = wrapper?.Workflow;
        }
#pragma warning disable CA1031 // Do not catch general exception types
        catch
#pragma warning restore CA1031 // Do not catch general exception types
        {
            // If it's not a workflow wrapper version, continue with parsing non-wrapper version.
        }

        if (workflow is null)
        {
            workflow = deserializer.Deserialize<Workflow>(yaml);
        }

        return workflow;
    }

    /// <summary>
    /// Deserializes a workflow from a YAML file
    /// </summary>
    /// <param name="filePath">Path to the YAML file</param>
    /// <returns>The deserialized workflow</returns>
    public static async Task<Workflow> DeserializeFromYamlFileAsync(string filePath)
    {
        using var reader = new StreamReader(filePath);
        var yaml = await reader.ReadToEndAsync().ConfigureAwait(false);
        return DeserializeFromYaml(yaml);
    }

    /// <summary>
    /// Serializes a workflow to YAML
    /// </summary>
    /// <param name="workflow">The workflow to serialize</param>
    /// <returns>The YAML string</returns>
    public static string SerializeToYaml(Workflow workflow)
    {
        var serializer = new SerializerBuilder()
            .WithNamingConvention(UnderscoredNamingConvention.Instance)
            .WithTypeConverter(new SnakeCaseEnumConverter())
            .ConfigureDefaultValuesHandling(DefaultValuesHandling.OmitNull | DefaultValuesHandling.OmitEmptyCollections)
            .Build();

        return serializer.Serialize(workflow);
    }

    /// <summary>
    /// Serializes a workflow to a YAML file
    /// </summary>
    /// <param name="workflow">The workflow to serialize</param>
    /// <param name="filePath">Path to the YAML file</param>
    public static async Task SerializeToYamlFileAsync(Workflow workflow, string filePath)
    {
        var yaml = SerializeToYaml(workflow);
        using var writer = new StreamWriter(filePath);
        await writer.WriteAsync(yaml).ConfigureAwait(false);
    }

    /// <summary>
    /// Deserializes a workflow from JSON
    /// </summary>
    /// <param name="json">The JSON string</param>
    /// <returns>The deserialized workflow</returns>
    public static Workflow DeserializeFromJson(string json)
    {
        return JsonSerializer.Deserialize<Workflow>(json, s_jsonOptions)!;
    }

    /// <summary>
    /// Deserializes a workflow from a JSON file
    /// </summary>
    /// <param name="filePath">Path to the JSON file</param>
    /// <returns>The deserialized workflow</returns>
    public static async Task<Workflow> DeserializeFromJsonFileAsync(string filePath)
    {
        using var reader = new StreamReader(filePath);
        var json = await reader.ReadToEndAsync().ConfigureAwait(false);
        return DeserializeFromJson(json);
    }

    /// <summary>
    /// Serializes a workflow to JSON
    /// </summary>
    /// <param name="workflow">The workflow to serialize</param>
    /// <returns>The JSON string</returns>
    public static string SerializeToJson(Workflow workflow)
    {
        return JsonSerializer.Serialize(workflow, s_jsonOptions);
    }

    /// <summary>
    /// Serializes a workflow to a JSON file
    /// </summary>
    /// <param name="workflow">The workflow to serialize</param>
    /// <param name="filePath">Path to the JSON file</param>
    public static async Task SerializeToJsonFileAsync(Workflow workflow, string filePath)
    {
        var json = SerializeToJson(workflow);
        using var writer = new StreamWriter(filePath);
        await writer.WriteAsync(json).ConfigureAwait(false);
    }

    internal class SnakeCaseEnumConverter : IYamlTypeConverter
    {
        public bool Accepts(Type type) => type.IsEnum;

        public object ReadYaml(IParser parser, Type type, ObjectDeserializer rootDeserializer)
        {
            var value = parser.Consume<Scalar>().Value;
            return Enum.Parse(type, value.Replace("_", ""), true);
        }

        public void WriteYaml(IEmitter emitter, object? value, Type type, ObjectSerializer serializer)
        {
            var enumValue = value?.ToString();
            if (enumValue == null)
            {
                return;
            }

#pragma warning disable CA1308 // Normalize strings to uppercase
            var snakeCaseValue = string.Concat(enumValue.Select((x, i) =>
                i > 0 && char.IsUpper(x) ? "_" + x : x.ToString())).ToLowerInvariant();
#pragma warning restore CA1308 // Normalize strings to uppercase
            emitter.Emit(new Scalar(snakeCaseValue));
        }
    }

    internal class JsonEnumMemberStringEnumConverter : JsonConverterFactory
    {
        private readonly JsonNamingPolicy? _namingPolicy;
        private readonly bool _allowIntegerValues;
        private readonly JsonStringEnumConverter _baseConverter;

        public JsonEnumMemberStringEnumConverter() : this(null, true) { }

        public JsonEnumMemberStringEnumConverter(JsonNamingPolicy? namingPolicy = null, bool allowIntegerValues = true)
        {
            this._namingPolicy = namingPolicy;
            this._allowIntegerValues = allowIntegerValues;
            this._baseConverter = new JsonStringEnumConverter(namingPolicy, allowIntegerValues);
        }

        public override bool CanConvert(Type typeToConvert) => this._baseConverter.CanConvert(typeToConvert);

        public override JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options)
        {
            var query = from field in typeToConvert.GetFields(BindingFlags.Public | BindingFlags.Static)
                        let attr = field.GetCustomAttribute<EnumMemberAttribute>()
                        where attr != null && attr.Value != null
                        select (field.Name, attr.Value);
            var dictionary = query.ToDictionary(p => p.Item1, p => p.Item2);
            if (dictionary.Count > 0)
            {
                return new JsonStringEnumConverter(new DictionaryLookupNamingPolicy(dictionary, this._namingPolicy), this._allowIntegerValues).CreateConverter(typeToConvert, options);
            }

            return this._baseConverter.CreateConverter(typeToConvert, options);
        }
    }

    internal class JsonNamingPolicyDecorator : JsonNamingPolicy
    {
        private readonly JsonNamingPolicy? _underlyingNamingPolicy;

        public JsonNamingPolicyDecorator(JsonNamingPolicy? underlyingNamingPolicy) => this._underlyingNamingPolicy = underlyingNamingPolicy;
        public override string ConvertName(string name) => this._underlyingNamingPolicy?.ConvertName(name) ?? name;
    }

    internal class DictionaryLookupNamingPolicy : JsonNamingPolicyDecorator
    {
        private readonly Dictionary<string, string> _dictionary;

        public DictionaryLookupNamingPolicy(Dictionary<string, string> dictionary, JsonNamingPolicy? underlyingNamingPolicy) : base(underlyingNamingPolicy) => this._dictionary = dictionary ?? throw new KernelException("Failed to serialize Enum Name");
        public override string ConvertName(string name) => this._dictionary.TryGetValue(name, out var value) ? value : base.ConvertName(name);
    }
}


===== Process.IntegrationTestHost.Dapr\Contracts\ProcessStartRequest.cs =====

// Copyright (c) Microsoft. All rights reserved.

using Microsoft.SemanticKernel;

namespace SemanticKernel.Process.IntegrationTests;

/// <summary>
/// Represents the body of a POST request to start a process in the test host.
/// </summary>
public record ProcessStartRequest
{
    /// <summary>
    /// The process to start.
    /// </summary>
    public required DaprProcessInfo Process { get; set; }

    /// <summary>
    /// The initial event to send to the process.
    /// </summary>
    public required string InitialEvent { get; set; }
}


===== Process.IntegrationTestHost.Dapr\Controllers\ProcessTestController.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Text.Json;
using Dapr.Actors.Client;
using Microsoft.AspNetCore.Mvc;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Process.Serialization;
using SemanticKernel.Process.TestsShared.CloudEvents;

namespace SemanticKernel.Process.IntegrationTests.Controllers;

/// <summary>
/// A controller for starting and managing processes.
/// </summary>
[ApiController]
[Route("/")]
[Produces("application/json")]
public class ProcessTestController : Controller
{
    private static readonly Dictionary<string, DaprKernelProcessContext> s_processes = new();
    private readonly Kernel _kernel;

    /// <summary>
    /// Initializes a new instance of the <see cref="ProcessTestController"/> class.
    /// </summary>
    /// <param name="kernel"></param>
    public ProcessTestController(Kernel kernel)
    {
        this._kernel = kernel;
    }

    /// <summary>
    /// Starts a process.
    /// </summary>
    /// <param name="processId">The Id of the process</param>
    /// <param name="request">The request</param>
    /// <returns></returns>
    [HttpPost("processes/{processId}")]
    public async Task<IActionResult> StartProcessAsync(string processId, [FromBody] ProcessStartRequest request)
    {
        if (s_processes.ContainsKey(processId))
        {
            return this.BadRequest("Process already started");
        }

        KernelProcessEvent initialEvent = request.InitialEvent.ToKernelProcessEvent();

        var kernelProcess = request.Process.ToKernelProcess();
        var context = await kernelProcess.StartAsync(initialEvent);
        s_processes.Add(processId, context);

        return this.Ok();
    }

    /// <summary>
    /// Retrieves information about a process.
    /// </summary>
    /// <param name="processId">The Id of the process.</param>
    /// <returns></returns>
    [HttpGet("processes/{processId}")]
    public async Task<IActionResult> GetProcessAsync(string processId)
    {
        if (!s_processes.TryGetValue(processId, out DaprKernelProcessContext? context))
        {
            return this.NotFound();
        }

        var process = await context.GetStateAsync();
        var daprProcess = DaprProcessInfo.FromKernelProcess(process);

        var serialized = JsonSerializer.Serialize(daprProcess);

        return this.Ok(daprProcess);
    }

    /// <summary>
    /// Retrieves current state of the MockCloudEventClient used in the running process
    /// </summary>
    /// <param name="processId">The Id of the process.</param>
    /// <param name="cloudClient">Mock Cloud client ingested via dependency injection</param>
    /// <returns></returns>
    [HttpGet("processes/{processId}/mockCloudClient")]
    public Task<IActionResult> GetMockCloudClient(string processId, MockCloudEventClient cloudClient)
    {
        if (!s_processes.TryGetValue(processId, out DaprKernelProcessContext? context))
        {
            return Task.FromResult<IActionResult>(this.NotFound());
        }

        var cloudClientCopy = JsonSerializer.Deserialize<MockCloudEventClient>(JsonSerializer.Serialize<MockCloudEventClient>(cloudClient));
        cloudClient.Reset();

        return Task.FromResult<IActionResult>(this.Ok(cloudClientCopy));
    }

    /// <summary>
    /// Checks the health of the Dapr runtime by attempting to send a message to a health actor.
    /// </summary>
    /// <returns></returns>
    [HttpGet("daprHealth")]
    public async Task<IActionResult> HealthCheckAsync()
    {
        var healthActor = ActorProxy.Create<IHealthActor>(new Dapr.Actors.ActorId(Guid.NewGuid().ToString("n")), nameof(HealthActor));
        await healthActor.HealthCheckAsync();
        return this.Ok();
    }
}


===== Process.IntegrationTestHost.Dapr\HealthActor.cs =====

// Copyright (c) Microsoft. All rights reserved.

using Dapr.Actors.Runtime;

namespace SemanticKernel.Process.IntegrationTests;

/// <summary>
/// An implementation of the health actor that is only used for testing the health of the Dapr runtime.
/// </summary>
public class HealthActor : Actor, IHealthActor
{
    /// <summary>
    /// Initializes a new instance of the <see cref="HealthActor"/> class.
    /// </summary>
    /// <param name="host"></param>
    public HealthActor(ActorHost host) : base(host)
    {
    }

    /// <inheritdoc />
    public Task HealthCheckAsync()
    {
        return Task.CompletedTask;
    }
}


===== Process.IntegrationTestHost.Dapr\IHealthActor.cs =====

// Copyright (c) Microsoft. All rights reserved.

using Dapr.Actors;

namespace SemanticKernel.Process.IntegrationTests;

/// <summary>
/// An interface for a health actor that is only used for testing the health of the Dapr runtime.
/// </summary>
public interface IHealthActor : IActor
{
    /// <summary>
    /// An empty method used to determine if Dapr runtime is up and reachable.
    /// </summary>
    /// <returns></returns>
    Task HealthCheckAsync();
}


===== Process.IntegrationTestHost.Dapr\ProcessStateTypeResolver.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Text.Json;
using System.Text.Json.Serialization;
using System.Text.Json.Serialization.Metadata;
using Microsoft.SemanticKernel;

namespace SemanticKernel.Process.IntegrationTests;

/// <summary>
/// An implementation of <see cref="JsonTypeInfoResolver"/> that resolves the type information for <see cref="KernelProcessStepState{T}"/>.
/// </summary>
public class ProcessStateTypeResolver<T> : DefaultJsonTypeInfoResolver where T : KernelProcessStep
{
    private static readonly Type s_genericType = typeof(KernelProcessStep<>);
    private readonly Dictionary<string, Type> _types =
        new()
        {
            { "process", typeof(KernelProcessState) },
            { "map", typeof(KernelProcessMapState) },
        };

    /// <summary>
    /// Initializes a new instance of the <see cref="ProcessStateTypeResolver{T}"/> class.
    /// </summary>
    public ProcessStateTypeResolver()
    {
        // Load all types from the resources assembly that derive from KernelProcessStep
        var assembly = typeof(T).Assembly;
        var stepTypes = assembly.GetTypes().Where(t => t.IsSubclassOf(typeof(KernelProcessStep)));

        foreach (var type in stepTypes)
        {
            if (TryGetSubtypeOfStatefulStep(type, out Type? genericStepType) && genericStepType is not null)
            {
                var userStateType = genericStepType.GetGenericArguments()[0];
                var stateType = typeof(KernelProcessStepState<>).MakeGenericType(userStateType);
                this._types.TryAdd(userStateType.Name, stateType);
            }
        }
    }

    /// <inheritdoc />
    public override JsonTypeInfo GetTypeInfo(Type type, JsonSerializerOptions options)
    {
        JsonTypeInfo jsonTypeInfo = base.GetTypeInfo(type, options);

        Type baseType = typeof(KernelProcessStepState);
        if (jsonTypeInfo.Type == baseType)
        {
            var jsonDerivedTypes = this._types.Select(t => new JsonDerivedType(t.Value, t.Key)).ToList();

            jsonTypeInfo.PolymorphismOptions = new JsonPolymorphismOptions
            {
                TypeDiscriminatorPropertyName = "$state-type",
                IgnoreUnrecognizedTypeDiscriminators = true,
                UnknownDerivedTypeHandling = JsonUnknownDerivedTypeHandling.FailSerialization
            };

            // Add the known derived types to the collection
            var derivedTypesCollection = jsonTypeInfo.PolymorphismOptions.DerivedTypes;
            if (derivedTypesCollection is List<JsonDerivedType> list)
            {
                list.AddRange(jsonDerivedTypes);
            }
            else
            {
                foreach (var item in jsonDerivedTypes!)
                {
                    derivedTypesCollection!.Add(item);
                }
            }
        }
        else if (jsonTypeInfo.Type == typeof(DaprStepInfo))
        {
            jsonTypeInfo.PolymorphismOptions = new JsonPolymorphismOptions
            {
                TypeDiscriminatorPropertyName = "$state-type",
                IgnoreUnrecognizedTypeDiscriminators = true,
                UnknownDerivedTypeHandling = JsonUnknownDerivedTypeHandling.FailSerialization,
                DerivedTypes =
                {
                    new JsonDerivedType(typeof(DaprProcessInfo), nameof(DaprProcessInfo)),
                    new JsonDerivedType(typeof(DaprMapInfo), nameof(DaprMapInfo)),
                    new JsonDerivedType(typeof(DaprProxyInfo), nameof(DaprProxyInfo)),
                }
            };
        }

        return jsonTypeInfo;
    }

    private static bool TryGetSubtypeOfStatefulStep(Type? type, out Type? genericStateType)
    {
        while (type != null && type != typeof(object))
        {
            if (type.IsGenericType && type.GetGenericTypeDefinition() == s_genericType)
            {
                genericStateType = type;
                return true;
            }

            type = type.BaseType;
        }

        genericStateType = null;
        return false;
    }
}


===== Process.IntegrationTestHost.Dapr\Program.cs =====

// Copyright (c) Microsoft. All rights reserved.

using Microsoft.SemanticKernel;
using SemanticKernel.Process.IntegrationTests;
using SemanticKernel.Process.TestsShared.CloudEvents;

var builder = WebApplication.CreateBuilder(args);

// Configure logging
builder.Services.AddLogging((logging) =>
{
    logging.AddConsole();
    logging.AddDebug();
});

// Configure the Kernel with DI. This is required for dependency injection to work with processes.
builder.Services.AddKernel();

// Configure IExternalKernelProcessMessageChannel used for testing purposes
builder.Services.AddSingleton<IExternalKernelProcessMessageChannel>(MockCloudEventClient.Instance);
builder.Services.AddSingleton(MockCloudEventClient.Instance);

// Configure Dapr
builder.Services.AddActors(static options =>
{
    // Register the actors required to run Processes
    options.AddProcessActors();
    options.Actors.RegisterActor<HealthActor>();
});

builder.Services.AddControllers().AddJsonOptions(options =>
{
    options.JsonSerializerOptions.TypeInfoResolver = new ProcessStateTypeResolver<KickoffStep>();
});

var app = builder.Build();

app.MapControllers();
app.MapActorsHandlers();
app.Run();


===== Process.IntegrationTestRunner.Dapr\DaprTestProcessContext.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Net.Http.Json;
using System.Text.Json;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Process;
using Microsoft.SemanticKernel.Process.Serialization;
using SemanticKernel.Process.TestsShared.CloudEvents;

namespace SemanticKernel.Process.IntegrationTests;
internal sealed class DaprTestProcessContext : KernelProcessContext
{
    private readonly HttpClient _httpClient;
    private readonly KernelProcess _process;
    private readonly string _processId;
    private readonly JsonSerializerOptions _serializerOptions;

    internal DaprTestProcessContext(KernelProcess process, HttpClient httpClient)
    {
        if (string.IsNullOrWhiteSpace(process.State.Id))
        {
            process = process with { State = process.State with { Id = Guid.NewGuid().ToString() } };
        }

        this._process = process;
        this._processId = process.State.Id;
        this._httpClient = httpClient;

        this._serializerOptions = new JsonSerializerOptions()
        {
            TypeInfoResolver = new ProcessStateTypeResolver<KickoffStep>(),
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        };
    }

    /// <summary>
    /// Starts the process with an initial event.
    /// </summary>
    /// <param name="initialEvent">The initial event.</param>
    /// <returns></returns>
    internal async Task StartWithEventAsync(KernelProcessEvent initialEvent)
    {
        var daprProcess = DaprProcessInfo.FromKernelProcess(this._process);
        var request = new ProcessStartRequest { Process = daprProcess, InitialEvent = initialEvent.ToJson() };

        var response = await this._httpClient.PostAsJsonAsync($"http://localhost:5200/processes/{this._processId}", request, options: this._serializerOptions).ConfigureAwait(false);
        if (!response.IsSuccessStatusCode)
        {
            throw new InvalidOperationException("Failed to start process");
        }
    }

    public override async Task<KernelProcess> GetStateAsync()
    {
        var response = await this._httpClient.GetFromJsonAsync<DaprProcessInfo>($"http://localhost:5200/processes/{this._processId}", options: this._serializerOptions);
        return response switch
        {
            null => throw new InvalidOperationException("Process not found"),
            _ => response.ToKernelProcess()
        };
    }

    public override Task SendEventAsync(KernelProcessEvent processEvent)
    {
        throw new NotImplementedException();
    }

    public override Task StopAsync()
    {
        throw new NotImplementedException();
    }

    public override async Task<IExternalKernelProcessMessageChannel?> GetExternalMessageChannelAsync()
    {
        var response = await this._httpClient.GetFromJsonAsync<MockCloudEventClient>($"http://localhost:5200/processes/{this._processId}/mockCloudClient", options: this._serializerOptions);
        return response switch
        {
            null => throw new InvalidOperationException("Process not found"),
            _ => response
        };
    }

    public override Task<string> GetProcessIdAsync() => Task.FromResult(this._process.State.Id!);
}


===== Process.IntegrationTestRunner.Dapr\ProcessTestFixture.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Diagnostics;
using System.Net;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Process;
using Xunit;

namespace SemanticKernel.Process.IntegrationTests;

/// <summary>
/// A test fixture for running shared process tests across multiple runtimes.
/// </summary>
public sealed class ProcessTestFixture : IDisposable, IAsyncLifetime
{
    private System.Diagnostics.Process? _process;
    private HttpClient? _httpClient;

    /// <summary>
    /// Called by xUnit before the test is run.
    /// </summary>
    /// <returns></returns>
    public async Task InitializeAsync()
    {
        this._httpClient = new HttpClient();
        await this.StartTestHostAsync();
    }

    /// <summary>
    /// Starts the test host by creating a new process with the Dapr cli. The startup process can take 30 seconds or more and so we wait for this to complete before returning.
    /// </summary>
    /// <returns></returns>
    private async Task StartTestHostAsync()
    {
        try
        {
            string workingDirectory = Path.GetFullPath(Path.Combine(Directory.GetCurrentDirectory(), @"..\..\..\..\Process.IntegrationTestHost.Dapr"));
            var processStartInfo = new ProcessStartInfo
            {
                FileName = "dapr",
                Arguments = "run --app-id daprprocesstests --app-port 5200 --dapr-http-port 3500 -- dotnet run --urls http://localhost:5200",
                WorkingDirectory = workingDirectory,
                RedirectStandardOutput = false,
                RedirectStandardError = false,
                UseShellExecute = true,
                CreateNoWindow = false
            };

            this._process = new System.Diagnostics.Process
            {
                StartInfo = processStartInfo
            };

            this._process.Start();
            await this.WaitForHostStartupAsync();
        }
        catch (Exception)
        {
            throw;
        }
    }

    private async Task ShutdownTestHostAsync()
    {
        var processStartInfo = new ProcessStartInfo
        {
            FileName = "dapr",
            Arguments = "stop --app-id daprprocesstests",
            RedirectStandardOutput = false,
            RedirectStandardError = false,
            UseShellExecute = true,
            CreateNoWindow = false
        };

        using var shutdownProcess = new System.Diagnostics.Process
        {
            StartInfo = processStartInfo
        };

        shutdownProcess.Start();
        await shutdownProcess.WaitForExitAsync();
    }

    /// <summary>
    /// Waits for the test host to be ready to accept requests. This is determined by making a request to the health endpoint.
    /// </summary>
    /// <returns></returns>
    /// <exception cref="InvalidProgramException"></exception>
    private async Task WaitForHostStartupAsync()
    {
        // Wait for the process to start
        var now = DateTime.Now;
        while (DateTime.Now - now < TimeSpan.FromSeconds(120))
        {
            if (this._process!.HasExited)
            {
                break;
            }

            try
            {
                var healthResponse = await this._httpClient!.GetAsync(new Uri("http://localhost:5200/daprHealth"));
                if (healthResponse.StatusCode == HttpStatusCode.OK)
                {
                    await Task.Delay(TimeSpan.FromSeconds(10));
                    return;
                }
            }
            catch (HttpRequestException)
            {
                // Do nothing, just wait
            }
        }

        throw new InvalidProgramException("Dapr Test Host did not start");
    }

    /// <summary>
    /// Starts a process.
    /// </summary>
    /// <param name="process">The process to start.</param>
    /// <param name="kernel">An instance of <see cref="Kernel"/></param>
    /// <param name="initialEvent">An optional initial event.</param>
    /// <param name="externalMessageChannel">channel used for external messages</param>
    /// <returns>A <see cref="Task{KernelProcessContext}"/></returns>
    public async Task<KernelProcessContext> StartProcessAsync(KernelProcess process, Kernel kernel, KernelProcessEvent initialEvent, IExternalKernelProcessMessageChannel? externalMessageChannel = null)
    {
        // Actual Kernel injection of Kernel and ExternalKernelProcessMessageChannel is in dotnet\src\Experimental\Process.IntegrationTestHost.Dapr\Program.cs
        var context = new DaprTestProcessContext(process, this._httpClient!);
        await context.StartWithEventAsync(initialEvent);
        return context;
    }

    /// <summary>
    /// Disposes of the test fixture.
    /// </summary>
    public void Dispose()
    {
        if (this._process is not null && this._process.HasExited)
        {
            this._process?.Kill();
            this._process?.WaitForExit();
        }

        this._process?.Dispose();
        this._httpClient?.Dispose();
    }

    /// <summary>
    /// Called by xUnit after the test is run.
    /// </summary>
    /// <returns></returns>
    public Task DisposeAsync()
    {
        return this.ShutdownTestHostAsync();
    }
}


===== Process.IntegrationTestRunner.Dapr\README.md =====

# Dapr Process Integration Tests Runner

**_ Dapr must be running on the machine to run these tests _**

Make sure you setup Dapr for local development before running these tests. Follow this guide: [Dapr local development](https://docs.dapr.io/getting-started/install-dapr-selfhost/)


===== Process.IntegrationTestRunner.Local\ProcessTestFixture.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Threading.Tasks;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Process;

namespace SemanticKernel.Process.IntegrationTests;

/// <summary>
/// A test fixture for running shared process tests across multiple runtimes.
/// </summary>
public class ProcessTestFixture
{
    /// <summary>
    /// Starts a process.
    /// </summary>
    /// <param name="process">The process to start.</param>
    /// <param name="kernel">An instance of <see cref="Kernel"/></param>
    /// <param name="initialEvent">An optional initial event.</param>
    /// <param name="externalMessageChannel">channel used for external messages</param>
    /// <returns>A <see cref="Task{KernelProcessContext}"/></returns>
    public async Task<KernelProcessContext> StartProcessAsync(KernelProcess process, Kernel kernel, KernelProcessEvent initialEvent, IExternalKernelProcessMessageChannel? externalMessageChannel = null)
    {
        return await process.StartAsync(kernel, initialEvent, externalMessageChannel);
    }

    /// <summary>
    /// Starts the specified process.
    /// </summary>
    /// <param name="key"></param>
    /// <param name="processId"></param>
    /// <param name="initialEvent"></param>
    /// <returns></returns>
    public Task<KernelProcessContext> StartAsync(string key, string processId, KernelProcessEvent initialEvent)
    {
        throw new NotImplementedException("This method is not implemented in this test fixture.");
    }
}


===== Process.IntegrationTests.Resources\ProcessCloudEventsResources.cs =====

// Copyright (c) Microsoft. All rights reserved.

namespace SemanticKernel.Process.IntegrationTests;

#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member

public static class MockTopicNames
{
    public const string RepeatExternalTopic = nameof(RepeatExternalTopic);
    public const string EchoExternalTopic = nameof(EchoExternalTopic);
}

#pragma warning restore CS1591 // Missing XML comment for publicly visible type or member


===== Process.IntegrationTests.Resources\ProcessCycleTestResources.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Linq;
using System.Runtime.Serialization;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.SemanticKernel;

namespace SemanticKernel.Process.IntegrationTests;

#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member

/// <summary>
/// Kick off step for the process.
/// </summary>
public sealed class KickoffStep : KernelProcessStep
{
    public static class ProcessFunctions
    {
        public const string KickOff = nameof(KickOff);
    }

    [KernelFunction(ProcessFunctions.KickOff)]
    public async ValueTask PrintWelcomeMessageAsync(KernelProcessStepContext context)
    {
        await context.EmitEventAsync(new() { Id = CommonEvents.StartARequested, Data = "Get Going A" });
        await context.EmitEventAsync(new() { Id = CommonEvents.StartBRequested, Data = "Get Going B" });
    }
}

/// <summary>
/// A step in the process.
/// </summary>
public sealed class AStep : KernelProcessStep
{
    [KernelFunction]
    public async ValueTask DoItAsync(KernelProcessStepContext context)
    {
        await Task.Delay(TimeSpan.FromSeconds(1));
        await context.EmitEventAsync(new() { Id = CommonEvents.AStepDone, Data = "I did A" });
    }
}

/// <summary>
/// A step in the process.
/// </summary>
public sealed class BStep : KernelProcessStep
{
    [KernelFunction]
    public async ValueTask DoItAsync(KernelProcessStepContext context)
    {
        await Task.Delay(TimeSpan.FromSeconds(2));
        await context.EmitEventAsync(new() { Id = CommonEvents.BStepDone, Data = "I did B" });
    }
}

/// <summary>
/// A step in the process.
/// </summary>
public sealed class CStep : KernelProcessStep<CStepState>
{
    private CStepState? _state = new();

    public override ValueTask ActivateAsync(KernelProcessStepState<CStepState> state)
    {
        this._state = state.State;
        return base.ActivateAsync(state);
    }

    [KernelFunction]
    public async ValueTask DoItAsync(KernelProcessStepContext context, string astepdata, string bstepdata)
    {
        this._state!.CurrentCycle++;
        if (this._state.CurrentCycle == 3)
        {
            // Exit the processes
            await context.EmitEventAsync(new() { Id = CommonEvents.ExitRequested });
            return;
        }

        // Cycle back to the start
        await context.EmitEventAsync(new() { Id = CommonEvents.CStepDone });
    }
}

/// <summary>
/// A state object for the CStep.
/// </summary>
[DataContract]
public sealed record CStepState
{
    [DataMember]
    public int CurrentCycle { get; set; }
}

/// <summary>
/// Common Events used in the process.
/// </summary>
public static class CommonEvents
{
    public const string UserInputReceived = nameof(UserInputReceived);
    public const string CompletionResponseGenerated = nameof(CompletionResponseGenerated);
    public const string WelcomeDone = nameof(WelcomeDone);
    public const string AStepDone = nameof(AStepDone);
    public const string BStepDone = nameof(BStepDone);
    public const string CStepDone = nameof(CStepDone);
    public const string StartARequested = nameof(StartARequested);
    public const string StartBRequested = nameof(StartBRequested);
    public const string ExitRequested = nameof(ExitRequested);
    public const string StartProcess = nameof(StartProcess);
}

/// <summary>
/// A step that repeats its input. Emits data internally AND publicly
/// </summary>
public sealed class RepeatStep : KernelProcessStep<StepState>
{
    private StepState? _state;

    public override ValueTask ActivateAsync(KernelProcessStepState<StepState> state)
    {
        this._state = state.State;
        return default;
    }

    [KernelFunction]
    public async Task RepeatAsync(string message, KernelProcessStepContext context, int count = 2)
    {
        var output = string.Join(" ", Enumerable.Repeat(message, count));
        Console.WriteLine($"[REPEAT] {output}");
        this._state!.LastMessage = output;

        // Emit the OnReady event with a public visibility and an internal visibility to aid in testing
        await context.EmitEventAsync(new() { Id = ProcessTestsEvents.OutputReadyPublic, Data = output, Visibility = KernelProcessEventVisibility.Public });
        await context.EmitEventAsync(new() { Id = ProcessTestsEvents.OutputReadyInternal, Data = output, Visibility = KernelProcessEventVisibility.Internal });
    }
}

/// <summary>
/// A step that emits the input received internally OR publicly.
/// </summary>
public sealed class EmitterStep : KernelProcessStep<StepState>
{
    public const string EventId = "Next";
    public const string PublicEventId = "PublicNext";
    public const string InputEvent = "OnInput";
    public const string Name = nameof(EmitterStep);

    public const string InternalEventFunction = "SomeInternalFunctionName";
    public const string PublicEventFunction = "SomePublicFunctionName";
    public const string DualInputPublicEventFunction = "SomeDualInputPublicEventFunctionName";

    private readonly int _sleepDurationMs = 150;

    private StepState? _state;

    public override ValueTask ActivateAsync(KernelProcessStepState<StepState> state)
    {
        this._state = state.State;
        return default;
    }

    [KernelFunction(InternalEventFunction)]
    public async Task InternalTestFunctionAsync(KernelProcessStepContext context, string data)
    {
        Thread.Sleep(this._sleepDurationMs);

        Console.WriteLine($"[EMIT_INTERNAL] {data}");
        this._state!.LastMessage = data;
        await context.EmitEventAsync(new() { Id = EventId, Data = data });
    }

    [KernelFunction(PublicEventFunction)]
    public async Task PublicTestFunctionAsync(KernelProcessStepContext context, string data)
    {
        Thread.Sleep(this._sleepDurationMs);

        Console.WriteLine($"[EMIT_PUBLIC] {data}");
        this._state!.LastMessage = data;
        await context.EmitEventAsync(new() { Id = PublicEventId, Data = data, Visibility = KernelProcessEventVisibility.Public });
    }

    [KernelFunction(DualInputPublicEventFunction)]
    public async Task DualInputPublicTestFunctionAsync(KernelProcessStepContext context, string firstInput, string secondInput)
    {
        Thread.Sleep(this._sleepDurationMs);

        string outputText = $"{firstInput}-{secondInput}";
        Console.WriteLine($"[EMIT_PUBLIC_DUAL] {outputText}");
        this._state!.LastMessage = outputText;
        await context.EmitEventAsync(new() { Id = ProcessTestsEvents.OutputReadyPublic, Data = outputText, Visibility = KernelProcessEventVisibility.Public });
    }
}

/// <summary>
/// A step that emits a startProcess event
/// </summary>
public sealed class StartStep : KernelProcessStep
{
    [KernelFunction]
    public async Task SendStartMessageAsync(KernelProcessStepContext context, string text)
    {
        Console.WriteLine($"[START] {text}");
        await context.EmitEventAsync(new()
        {
            Id = ProcessTestsEvents.StartProcess,
            Data = text,
            Visibility = KernelProcessEventVisibility.Public
        });
    }
}

/// <summary>
/// A step that combines string inputs received.
/// </summary>
public sealed class FanInStep : KernelProcessStep<StepState>
{
    private StepState? _state;

    public override ValueTask ActivateAsync(KernelProcessStepState<StepState> state)
    {
        this._state = state.State;
        return default;
    }

    [KernelFunction]
    public async Task EmitCombinedMessageAsync(KernelProcessStepContext context, string firstInput, string secondInput)
    {
        var output = $"{firstInput}-{secondInput}";
        Console.WriteLine($"[EMIT_COMBINED] {output}");
        this._state!.LastMessage = output;

        await context.EmitEventAsync(new()
        {
            Id = ProcessTestsEvents.OutputReadyInternal,
            Data = output,
            Visibility = KernelProcessEventVisibility.Internal
        });
        await context.EmitEventAsync(new()
        {
            Id = ProcessTestsEvents.OutputReadyPublic,
            Data = output,
            Visibility = KernelProcessEventVisibility.Public
        });
    }
}

/// <summary>
/// A step that conditionally throws an exception.
/// </summary>
public sealed class ErrorStep : KernelProcessStep<StepState>
{
    private StepState? _state;

    public override ValueTask ActivateAsync(KernelProcessStepState<StepState> state)
    {
        this._state = state.State;
        return default;
    }

    [KernelFunction]
    public async Task ErrorWhenTrueAsync(KernelProcessStepContext context, bool shouldError)
    {
        this._state!.InvocationCount++;

        if (shouldError)
        {
            throw new InvalidOperationException("This is an error");
        }

        await context.EmitEventAsync(new()
        {
            Id = ProcessTestsEvents.ErrorStepSuccess,
            Data = null,
            Visibility = KernelProcessEventVisibility.Internal
        });
    }
}

/// <summary>
/// A step that reports an error sent to it by logging it to the console.
/// </summary>
public sealed class ReportStep : KernelProcessStep<StepState>
{
    private StepState? _state;

    public override ValueTask ActivateAsync(KernelProcessStepState<StepState> state)
    {
        this._state = state.State;
        return default;
    }

    [KernelFunction]
    public Task ReportError(KernelProcessStepContext context, object error)
    {
        this._state!.InvocationCount++;
        Console.WriteLine(error.ToString());
        return Task.CompletedTask;
    }
}

/// <summary>
/// The state object for the repeat and fanIn step.
/// </summary>
[DataContract]
public sealed record StepState
{
    [DataMember]
    public string? LastMessage { get; set; }

    [DataMember]
    public int InvocationCount { get; set; }
}

/// <summary>
/// A class that defines the events that can be emitted by the chat bot process. This is
/// not required but used to ensure that the event names are consistent.
/// </summary>
public static class ProcessTestsEvents
{
    public const string StartProcess = "StartProcess";
    public const string StartInnerProcess = "StartInnerProcess";
    public const string OutputReadyPublic = "OutputReadyPublic";
    public const string OutputReadyInternal = "OutputReadyInternal";
    public const string ErrorStepSuccess = "ErrorStepSuccess";
}

#pragma warning restore CS1591 // Missing XML comment for publicly visible type or member


===== Process.IntegrationTests.Resources\ProcessMapTestResources.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.SemanticKernel;

namespace SemanticKernel.Process.IntegrationTests;

#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member

/// <summary>
/// A step that contains a map operation that emits two events.
/// </summary>
public sealed class ComputeStep : KernelProcessStep
{
    public const string SquareEventId = "SquareResult";
    public const string CubicEventId = "CubicResult";
    public const string ComputeFunction = "MapCompute";

    [KernelFunction(ComputeFunction)]
    public async ValueTask ComputeAsync(KernelProcessStepContext context, long value)
    {
        long square = value * value;
        await context.EmitEventAsync(new() { Id = SquareEventId, Data = square });
        await context.EmitEventAsync(new() { Id = CubicEventId, Data = square * value });
    }
}

/// <summary>
/// State for union step to capture results.
/// </summary>
public sealed record UnionState
{
    public long SquareResult { get; set; }
    public long CubicResult { get; set; }
};

/// <summary>
/// The step that combines the results of the map operation.
/// </summary>
public sealed class UnionStep : KernelProcessStep<UnionState>
{
    public const string EventId = "MapUnion";
    public const string SumSquareFunction = "UnionSquare";
    public const string SumCubicFunction = "UnionCubic";

    private UnionState _state = new();

    public override ValueTask ActivateAsync(KernelProcessStepState<UnionState> state)
    {
        this._state = state.State ?? throw new InvalidDataException();

        return ValueTask.CompletedTask;
    }

    [KernelFunction(SumSquareFunction)]
    public void SumSquare(IList<long> values)
    {
        long sum = values.Sum();
        this._state.SquareResult = sum;
    }

    [KernelFunction(SumCubicFunction)]
    public void SumCubic(IList<long> values)
    {
        long sum = values.Sum();
        this._state.CubicResult = sum;
    }
}


===== Process.IntegrationTests.Shared\ProcessCloudEventsTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

#pragma warning disable IDE0005 // Using directive is unnecessary.
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.Serialization;
using System.Text.Json;
using System.Threading.Tasks;
using Microsoft.Extensions.Configuration;
using Microsoft.SemanticKernel;
using SemanticKernel.IntegrationTests.TestSettings;
using SemanticKernel.Process.TestsShared.CloudEvents;
using SemanticKernel.Process.TestsShared.Steps;
using Xunit;
#pragma warning restore IDE0005 // Using directive is unnecessary.

namespace SemanticKernel.Process.IntegrationTests;

/// <summary>
/// Integration tests for processes.
/// </summary>
[Collection(nameof(ProcessTestGroup))]
public sealed class ProcessCloudEventsTests : IClassFixture<ProcessTestFixture>
{
    private readonly ProcessTestFixture _fixture;
    private readonly IKernelBuilder _kernelBuilder = Kernel.CreateBuilder();
    private readonly IConfigurationRoot _configuration = new ConfigurationBuilder()
            .AddJsonFile(path: "testsettings.json", optional: true, reloadOnChange: true)
            .AddJsonFile(path: "testsettings.development.json", optional: true, reloadOnChange: true)
            .AddEnvironmentVariables()
            .AddUserSecrets<OpenAIConfiguration>()
            .Build();

    private readonly string _topic1 = "myTopic1";
    private readonly string _topic2 = "MyTopic2";

    /// <summary>
    /// Initializes a new instance of the <see cref="ProcessTests"/> class. This is called by the test framework.
    /// </summary>
    /// <param name="fixture"></param>
    public ProcessCloudEventsTests(ProcessTestFixture fixture)
    {
        this._fixture = fixture;
    }

    /// <summary>
    /// Tests that evaluates basic behavior of process using "EmitExternalEvent" in the processBuilder
    /// </summary>
    /// <returns>A <see cref="Task"/></returns>
    [Fact]
    public async Task LinearProcessWithCloudEventSubscribersUsingEmitToTopicAsync()
    {
        // Arrange
        MockCloudEventClient.Instance.Reset();
        OpenAIConfiguration configuration = this._configuration.GetSection("OpenAI").Get<OpenAIConfiguration>()!;
        this._kernelBuilder.AddOpenAIChatCompletion(
            modelId: configuration.ModelId!,
            apiKey: configuration.ApiKey);

        Kernel kernel = this._kernelBuilder.Build();
        var process = this.CreateLinearProcessWithEmitTopic("SimpleWithCloudEvents").Build();

        // Act
        string testInput = "Test";
        var processHandle = await this._fixture.StartProcessAsync(process, kernel, new() { Id = ProcessTestsEvents.StartProcess, Data = testInput }, MockCloudEventClient.Instance);
        var externalMessageChannel = await processHandle.GetExternalMessageChannelAsync();
        var runningProcessId = await processHandle.GetProcessIdAsync();

        // Assert
        Assert.NotNull(externalMessageChannel);
        var mockClient = (MockCloudEventClient)externalMessageChannel;
        Assert.NotNull(mockClient);
        Assert.True(mockClient.InitializationCounter > 0);
        Assert.Equal(2, mockClient.CloudEvents.Count);
        Assert.Equal(runningProcessId, mockClient.CloudEvents[0].ProcessId);
        Assert.Equal(runningProcessId, mockClient.CloudEvents[1].ProcessId);
        this.AssertProxyMessage(mockClient.CloudEvents[0], expectedPublishTopic: MockTopicNames.EchoExternalTopic, expectedTopicData: testInput);
        this.AssertProxyMessage(mockClient.CloudEvents[1], expectedPublishTopic: MockTopicNames.RepeatExternalTopic, expectedTopicData: $"{testInput} {testInput}");
    }

    /// <summary>
    /// Validates the proxy used in subprocesses act as expected with different external topics
    /// </summary>
    [Fact]
    public async Task ProcessWithSubprocessWithProxyEmittingDifferentTopicsAsync()
    {
        // Arrange
        MockCloudEventClient.Instance.Reset();
        ProcessBuilder processBuilder = new(nameof(ProcessWithSubprocessWithProxyEmittingDifferentTopicsAsync));

        var subprocess1 = processBuilder.AddStepFromProcess(this.CreateSimpleEchoProcess("subprocess1", this._topic1));
        var subprocess2 = processBuilder.AddStepFromProcess(this.CreateSimpleEchoProcess("subprocess2", this._topic2));

        processBuilder
            .OnInputEvent(ProcessTestsEvents.StartProcess)
            .SendEventTo(subprocess1.WhereInputEventIs(ProcessTestsEvents.StartInnerProcess))
            .SendEventTo(subprocess2.WhereInputEventIs(ProcessTestsEvents.StartInnerProcess));

        KernelProcess process = processBuilder.Build();
        Kernel kernel = new();

        // Act
        string testInput = "Test";
        var processHandle = await this._fixture.StartProcessAsync(process, kernel, new() { Id = ProcessTestsEvents.StartProcess, Data = testInput }, MockCloudEventClient.Instance);
        var externalMessageChannel = await processHandle.GetExternalMessageChannelAsync();

        // Assert
        Assert.NotNull(externalMessageChannel);
        var mockClient = (MockCloudEventClient)externalMessageChannel;
        Assert.NotNull(mockClient);
        Assert.True(mockClient.InitializationCounter > 0);
        Assert.Equal(2, mockClient.CloudEvents.Count);
        if (mockClient.CloudEvents[0].ExternalTopicName == this._topic1)
        {
            this.AssertProxyMessage(mockClient.CloudEvents[0], expectedPublishTopic: this._topic1, expectedTopicData: testInput);
            this.AssertProxyMessage(mockClient.CloudEvents[1], expectedPublishTopic: this._topic2, expectedTopicData: testInput);
        }
        else
        {
            this.AssertProxyMessage(mockClient.CloudEvents[0], expectedPublishTopic: this._topic2, expectedTopicData: testInput);
            this.AssertProxyMessage(mockClient.CloudEvents[1], expectedPublishTopic: this._topic1, expectedTopicData: testInput);
        }
    }

    /// <summary>
    /// Validates the proxy used in subprocesses act as expected with same external topics
    /// </summary>
    [Fact]
    public async Task ProcessWithSubprocessWithProxyEmittingSameTopicsAsync()
    {
        // Arrange
        MockCloudEventClient.Instance.Reset();
        ProcessBuilder processBuilder = new(nameof(ProcessWithSubprocessWithProxyEmittingSameTopicsAsync));

        var subprocess1 = processBuilder.AddStepFromProcess(this.CreateSimpleEchoProcess("subprocess1", this._topic1));
        var subprocess2 = processBuilder.AddStepFromProcess(this.CreateSimpleEchoProcess("subprocess2", this._topic1));

        processBuilder
            .OnInputEvent(ProcessTestsEvents.StartProcess)
            .SendEventTo(subprocess1.WhereInputEventIs(ProcessTestsEvents.StartInnerProcess))
            .SendEventTo(subprocess2.WhereInputEventIs(ProcessTestsEvents.StartInnerProcess));

        KernelProcess process = processBuilder.Build();
        Kernel kernel = new();

        // Act
        string testInput = "Test";
        var processHandle = await this._fixture.StartProcessAsync(process, kernel, new() { Id = ProcessTestsEvents.StartProcess, Data = testInput }, MockCloudEventClient.Instance);
        var externalMessageChannel = await processHandle.GetExternalMessageChannelAsync();

        // Assert
        Assert.NotNull(externalMessageChannel);
        var mockClient = (MockCloudEventClient)externalMessageChannel;
        Assert.NotNull(mockClient);
        Assert.True(mockClient.InitializationCounter > 0);
        Assert.Equal(2, mockClient.CloudEvents.Count);
        this.AssertProxyMessage(mockClient.CloudEvents[0], expectedPublishTopic: this._topic1, expectedTopicData: testInput);
        this.AssertProxyMessage(mockClient.CloudEvents[1], expectedPublishTopic: this._topic1, expectedTopicData: testInput);
    }

    /// <summary>
    /// Creates a simple linear process with two steps and a proxy step to emit events externally<br/>
    /// Input Event: <see cref="ProcessTestsEvents.StartProcess"/><br/>
    /// Output Events: [<see cref="ProcessTestsEvents.OutputReadyInternal"/>, <see cref="ProcessTestsEvents.OutputReadyPublic"/>]<br/>
    /// <code>
    ///     
    ///   echo   repeat 
    ///     
    ///
    ///                
    ///             proxy 
    ///               
    /// </code>
    /// </summary>
    private ProcessBuilder CreateLinearProcessWithEmitTopic(string name)
    {
        var processBuilder = new ProcessBuilder(name);
        var echoStep = processBuilder.AddStepFromType<CommonSteps.EchoStep>();
        var repeatStep = processBuilder.AddStepFromType<RepeatStep>();

        var proxyTopics = new List<string>() { MockTopicNames.RepeatExternalTopic, MockTopicNames.EchoExternalTopic };
        var proxyStep = processBuilder.AddProxyStep(id: "proxy", proxyTopics);

        processBuilder
            .OnInputEvent(ProcessTestsEvents.StartProcess)
            .SendEventTo(new ProcessFunctionTargetBuilder(echoStep));

        echoStep
            .OnFunctionResult(nameof(CommonSteps.EchoStep.Echo))
            .SendEventTo(new ProcessFunctionTargetBuilder(repeatStep, parameterName: "message"));

        echoStep
            .OnFunctionResult()
            .EmitExternalEvent(proxyStep, MockTopicNames.EchoExternalTopic);

        repeatStep
            .OnEvent(ProcessTestsEvents.OutputReadyInternal)
            .EmitExternalEvent(proxyStep, MockTopicNames.RepeatExternalTopic);

        return processBuilder;
    }

    private ProcessBuilder CreateSimpleEchoProcess(string processName, string proxyTopicName)
    {
        ProcessBuilder process = new(processName);

        var echoStep = process.AddStepFromType<CommonSteps.EchoStep>();
        var proxyStep = process.AddProxyStep(id: "proxy", [this._topic1, this._topic2]);

        process
            .OnInputEvent(ProcessTestsEvents.StartInnerProcess)
            .SendEventTo(new(echoStep));

        echoStep
            .OnFunctionResult()
            .EmitExternalEvent(proxyStep, proxyTopicName);

        return process;
    }

    #region Assert Utils
    private void AssertProxyMessage(KernelProcessProxyMessage? proxyMessage, string expectedPublishTopic, object? expectedTopicData = null)
    {
        Assert.NotNull(proxyMessage);
        Assert.IsType<KernelProcessProxyMessage>(proxyMessage);
        Assert.Equal(expectedPublishTopic, proxyMessage.ExternalTopicName);

        Assert.IsType<KernelProcessEventData>(proxyMessage.EventData);
        var outputEventData = proxyMessage.EventData.ToObject();
        Assert.IsType<string>(outputEventData);
        Assert.Equal(expectedTopicData, outputEventData);
    }
    #endregion
}


===== Process.IntegrationTests.Shared\ProcessCycleTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

#pragma warning disable IDE0005 // Using directive is unnecessary.
using System.Linq;
using System.Threading.Tasks;
using Microsoft.SemanticKernel;
using Xunit;
#pragma warning restore IDE0005 // Using directive is unnecessary.

namespace SemanticKernel.Process.IntegrationTests;

/// <summary>
/// Integration test focusing on cycles in a process.
/// </summary>
[Collection(nameof(ProcessTestGroup))]
public class ProcessCycleTests : IClassFixture<ProcessTestFixture>
{
    private readonly ProcessTestFixture _fixture;

    /// <summary>
    /// Initializes a new instance of the <see cref="ProcessCycleTests"/> class. This is called by the test framework.
    /// </summary>
    /// <param name="fixture"></param>
    public ProcessCycleTests(ProcessTestFixture fixture)
    {
        this._fixture = fixture;
    }

    /// <summary>
    /// Tests a process which cycles a fixed number of times and then exits.
    /// </summary>
    /// <returns>A <see cref="Task"/></returns>
    [Fact]
    public async Task TestCycleAndExitWithFanInAsync()
    {
        Kernel kernel = new();

        ProcessBuilder process = new("Test Process");

        var kickoffStep = process.AddStepFromType<KickoffStep>();
        var myAStep = process.AddStepFromType<AStep>();
        var myBStep = process.AddStepFromType<BStep>();
        var myCStep = process.AddStepFromType<CStep>();

        process
            .OnInputEvent(CommonEvents.StartProcess)
            .SendEventTo(new ProcessFunctionTargetBuilder(kickoffStep));

        kickoffStep
            .OnEvent(CommonEvents.StartARequested)
            .SendEventTo(new ProcessFunctionTargetBuilder(myAStep));

        kickoffStep
            .OnEvent(CommonEvents.StartBRequested)
            .SendEventTo(new ProcessFunctionTargetBuilder(myBStep));

        myAStep
            .OnEvent(CommonEvents.AStepDone)
            .SendEventTo(new ProcessFunctionTargetBuilder(myCStep, parameterName: "astepdata"));

        myBStep
            .OnEvent(CommonEvents.BStepDone)
            .SendEventTo(new ProcessFunctionTargetBuilder(myCStep, parameterName: "bstepdata"));

        myCStep
            .OnEvent(CommonEvents.CStepDone)
            .SendEventTo(new ProcessFunctionTargetBuilder(kickoffStep));

        myCStep
            .OnEvent(CommonEvents.ExitRequested)
            .StopProcess();

        KernelProcess kernelProcess = process.Build();
        var processContext = await this._fixture.StartProcessAsync(kernelProcess, kernel, new KernelProcessEvent() { Id = CommonEvents.StartProcess, Data = "foo" });

        var processState = await processContext.GetStateAsync();
        var cStepState = processState.Steps.Where(s => s.State.Name == "CStep").FirstOrDefault()?.State as KernelProcessStepState<CStepState>;

        Assert.NotNull(cStepState?.State);
        Assert.Equal(3, cStepState.State.CurrentCycle);
    }
}


===== Process.IntegrationTests.Shared\ProcessMapTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

#pragma warning disable IDE0005 // Using directive is unnecessary.
using System;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Process;
using Xunit;
#pragma warning restore IDE0005 // Using directive is unnecessary.

namespace SemanticKernel.Process.IntegrationTests;

/// <summary>
/// Integration test focusing on <see cref="KernelProcessMap"/>.
/// </summary>
[Collection(nameof(ProcessTestGroup))]
public class ProcessMapTests : IClassFixture<ProcessTestFixture>
{
    private readonly ProcessTestFixture _fixture;

    /// <summary>
    /// Initializes a new instance of the <see cref="ProcessMapTests"/> class. This is called by the test framework.
    /// </summary>
    public ProcessMapTests(ProcessTestFixture fixture)
    {
        this._fixture = fixture;
    }

    /// <summary>
    /// Tests a map-step with a step as the map-operation.
    /// </summary>
    [Fact]
    public async Task TestMapWithStepAsync()
    {
        // Arrange
        ProcessBuilder process = new(nameof(TestMapWithStepAsync));

        ProcessMapBuilder mapStep = process.AddMapStepFromType<ComputeStep>();
        process
            .OnInputEvent("Start")
            .SendEventTo(new ProcessFunctionTargetBuilder(mapStep));

        ProcessStepBuilder unionStep = process.AddStepFromType<UnionStep>("Union");
        mapStep
            .OnEvent(ComputeStep.SquareEventId)
            .SendEventTo(new ProcessFunctionTargetBuilder(unionStep, UnionStep.SumSquareFunction));
        mapStep
            .OnEvent(ComputeStep.CubicEventId)
            .SendEventTo(new ProcessFunctionTargetBuilder(unionStep, UnionStep.SumCubicFunction));

        KernelProcess processInstance = process.Build();
        Kernel kernel = new();

        // Act
        KernelProcessContext processContext =
            await this._fixture.StartProcessAsync(
                processInstance,
                kernel,
                new KernelProcessEvent()
                {
                    Id = "Start",
                    Data = new int[] { 1, 2, 3, 4, 5 }
                });

        // Assert
        KernelProcess processState = await processContext.GetStateAsync();
        KernelProcessStepState<UnionState> unionState = (KernelProcessStepState<UnionState>)processState.Steps.Where(s => s.State.Name == "Union").Single().State;

        Assert.NotNull(unionState?.State);
        Assert.Equal(55L, unionState.State.SquareResult);
        Assert.Equal(225L, unionState.State.CubicResult);
    }

    /// <summary>
    /// Tests a map-step with a process as the map-operation.
    /// </summary>
    [Fact]
    public async Task TestMapWithProcessAsync()
    {
        // Arrange
        ProcessBuilder process = new(nameof(TestMapWithStepAsync));

        ProcessBuilder mapProcess = new("MapOperation");
        ProcessStepBuilder computeStep = mapProcess.AddStepFromType<ComputeStep>();
        mapProcess
            .OnInputEvent("Anything")
            .SendEventTo(new ProcessFunctionTargetBuilder(computeStep));

        ProcessMapBuilder mapStep = process.AddMapStepFromProcess(mapProcess);
        process
            .OnInputEvent("Start")
            .SendEventTo(mapStep.WhereInputEventIs("Anything"));

        ProcessStepBuilder unionStep = process.AddStepFromType<UnionStep>("Union");
        mapStep
            .OnEvent(ComputeStep.SquareEventId)
            .SendEventTo(new ProcessFunctionTargetBuilder(unionStep, UnionStep.SumSquareFunction));
        mapStep
            .OnEvent(ComputeStep.CubicEventId)
            .SendEventTo(new ProcessFunctionTargetBuilder(unionStep, UnionStep.SumCubicFunction));

        KernelProcess processInstance = process.Build();
        Kernel kernel = new();

        // Act
        KernelProcessContext processContext =
            await this._fixture.StartProcessAsync(
                processInstance with { State = processInstance.State with { Id = Guid.NewGuid().ToString() } },
                kernel,
                new KernelProcessEvent()
                {
                    Id = "Start",
                    Data = new int[] { 1, 2, 3, 4, 5 }
                });

        // Assert
        KernelProcess processState = await processContext.GetStateAsync();
        KernelProcessStepState<UnionState> unionState = (KernelProcessStepState<UnionState>)processState.Steps.Where(s => s.State.Name == "Union").Single().State;

        Assert.NotNull(unionState?.State);
        Assert.Equal(55L, unionState.State.SquareResult);
        Assert.Equal(225L, unionState.State.CubicResult);
    }
}


===== Process.IntegrationTests.Shared\ProcessTestFixture.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Threading.Tasks;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Process;

namespace SemanticKernel.Process.IntegrationTests;

/// <summary>
/// A test fixture for running shared process tests across multiple runtimes.
/// </summary>
public abstract class ProcessTestFixture
{
    /// <summary>
    /// Starts a process.
    /// </summary>
    /// <param name="process">The process to start.</param>
    /// <param name="kernel">An instance of <see cref="Kernel"/></param>
    /// <param name="initialEvent">An optional initial event.</param>
    /// <param name="externalMessageChannel">channel used for external messages</param>
    /// <returns>A <see cref="Task{KernelProcessContext}"/></returns>
    public abstract Task<KernelProcessContext> StartProcessAsync(KernelProcess process, Kernel kernel, KernelProcessEvent initialEvent, IExternalKernelProcessMessageChannel? externalMessageChannel = null);

    /// <summary>
    /// Starts the specified process.
    /// </summary>
    /// <param name="key"></param>
    /// <param name="processId"></param>
    /// <param name="initialEvent"></param>
    /// <returns></returns>
    public abstract Task<KernelProcessContext> StartAsync(string key, string processId, KernelProcessEvent initialEvent);
}


===== Process.IntegrationTests.Shared\ProcessTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

#pragma warning disable IDE0005 // Using directive is unnecessary.
using System.Linq;
using System.Threading.Tasks;
using Microsoft.Extensions.Configuration;
using Microsoft.SemanticKernel;
using SemanticKernel.IntegrationTests.TestSettings;
using SemanticKernel.Process.TestsShared.Steps;
using Xunit;
#pragma warning restore IDE0005 // Using directive is unnecessary.

namespace SemanticKernel.Process.IntegrationTests;

/// <summary>
/// Integration tests for processes.
/// </summary>
[Collection(nameof(ProcessTestGroup))]
public sealed class ProcessTests : IClassFixture<ProcessTestFixture>
{
    private readonly ProcessTestFixture _fixture;
    private readonly IKernelBuilder _kernelBuilder = Kernel.CreateBuilder();
    private readonly IConfigurationRoot _configuration = new ConfigurationBuilder()
            .AddJsonFile(path: "testsettings.json", optional: true, reloadOnChange: true)
            .AddJsonFile(path: "testsettings.development.json", optional: true, reloadOnChange: true)
            .AddEnvironmentVariables()
            .AddUserSecrets<OpenAIConfiguration>()
            .Build();

    /// <summary>
    /// Initializes a new instance of the <see cref="ProcessTests"/> class. This is called by the test framework.
    /// </summary>
    /// <param name="fixture"></param>
    public ProcessTests(ProcessTestFixture fixture)
    {
        this._fixture = fixture;
    }

    /// <summary>
    /// Tests a simple linear process with two steps and no sub processes.
    /// </summary>
    /// <returns>A <see cref="Task"/></returns>
    [Fact]
    public async Task LinearProcessAsync()
    {
        // Arrange
        OpenAIConfiguration configuration = this._configuration.GetSection("OpenAI").Get<OpenAIConfiguration>()!;
        this._kernelBuilder.AddOpenAIChatCompletion(
            modelId: configuration.ModelId!,
            apiKey: configuration.ApiKey);

        Kernel kernel = this._kernelBuilder.Build();
        var process = this.CreateLinearProcess("Simple").Build();

        // Act
        string testInput = "Test";
        var processHandle = await this._fixture.StartProcessAsync(process, kernel, new() { Id = ProcessTestsEvents.StartProcess, Data = testInput });
        var processInfo = await processHandle.GetStateAsync();

        // Assert
        this.AssertStepStateLastMessage(processInfo, nameof(RepeatStep), expectedLastMessage: string.Join(" ", Enumerable.Repeat(testInput, 2)));
    }

    /// <summary>
    /// Tests a process with three steps where the third step is a nested process. Ev/ts from the outer process
    /// are routed to the inner process.
    /// </summary>
    /// <returns>A <see cref="Task"/></returns>
    [Fact]
    public async Task NestedProcessOuterToInnerWorksAsync()
    {
        // Arrange
        OpenAIConfiguration configuration = this._configuration.GetSection("OpenAI").Get<OpenAIConfiguration>()!;
        this._kernelBuilder.AddOpenAIChatCompletion(
            modelId: configuration.ModelId!,
            apiKey: configuration.ApiKey);

        Kernel kernel = this._kernelBuilder.Build();

        // Create the outer process
        var processBuilder = this.CreateLinearProcess("Outer");

        // Create the inner process and add it as a step to the outer process
        var nestedProcessStep = processBuilder.AddStepFromProcess(this.CreateLinearProcess("Inner"));

        // Route the last step of the outer process to trigger the external event that starts the inner process
        processBuilder.Steps[1].OnEvent(ProcessTestsEvents.OutputReadyInternal)
            .SendEventTo(nestedProcessStep.WhereInputEventIs(ProcessTestsEvents.StartProcess));

        // Build the outer process
        var process = processBuilder.Build();

        // Act
        string testInput = "Test";
        var processHandle = await this._fixture.StartProcessAsync(process, kernel, new() { Id = ProcessTestsEvents.StartProcess, Data = testInput });
        var processInfo = await processHandle.GetStateAsync();

        // Assert
        var innerProcess = processInfo.Steps.Where(s => s.State.Name == "Inner").Single() as KernelProcess;
        Assert.NotNull(innerProcess);
        this.AssertStepStateLastMessage(innerProcess, nameof(RepeatStep), expectedLastMessage: string.Join(" ", Enumerable.Repeat(testInput, 4)));
    }

    /// <summary>
    /// Tests a process with three steps where the third step is a nested process. Events from the inner process
    /// are routed to the outer process.
    /// </summary>
    /// <returns>A <see cref="Task"/></returns>
    [Fact]
    public async Task NestedProcessInnerToOuterWorksWithPublicEventAsync()
    {
        // Arrange
        OpenAIConfiguration configuration = this._configuration.GetSection("OpenAI").Get<OpenAIConfiguration>()!;
        this._kernelBuilder.AddOpenAIChatCompletion(
            modelId: configuration.ModelId!,
            apiKey: configuration.ApiKey);

        Kernel kernel = this._kernelBuilder.Build();

        // Create the outer process
        var processBuilder = this.CreateLinearProcess("Outer");

        // Create the inner process and add it as a step to the outer process
        var nestedProcessStep = processBuilder.AddStepFromProcess(this.CreateLinearProcess("Inner"));

        // Add a new external event to start the outer process and handoff to the inner process directly
        processBuilder.OnInputEvent(ProcessTestsEvents.StartInnerProcess)
            .SendEventTo(nestedProcessStep.WhereInputEventIs(ProcessTestsEvents.StartProcess));

        // Route the last step of the inner process to trigger the echo step of the outer process
        nestedProcessStep.OnEvent(ProcessTestsEvents.OutputReadyPublic)
            .SendEventTo(new ProcessFunctionTargetBuilder(processBuilder.Steps[0]));

        // Build the outer process
        var process = processBuilder.Build();

        // Act
        string testInput = "Test";
        var processHandle = await this._fixture.StartProcessAsync(process, kernel, new() { Id = ProcessTestsEvents.StartInnerProcess, Data = testInput });
        var processInfo = await processHandle.GetStateAsync();

        // Assert
        this.AssertStepStateLastMessage(processInfo, nameof(RepeatStep), expectedLastMessage: string.Join(" ", Enumerable.Repeat(testInput, 4)));
    }

    /// <summary>
    /// Tests a process with three steps where the third step is a nested process. Events from the inner process
    /// are routed to the outer process.
    /// </summary>
    /// <returns>A <see cref="Task"/></returns>
    [Fact]
    public async Task NestedProcessInnerToOuterDoesNotWorkWithInternalEventAsync()
    {
        // Arrange
        OpenAIConfiguration configuration = this._configuration.GetSection("OpenAI").Get<OpenAIConfiguration>()!;
        this._kernelBuilder.AddOpenAIChatCompletion(
            modelId: configuration.ModelId!,
            apiKey: configuration.ApiKey);

        Kernel kernel = this._kernelBuilder.Build();

        // Create the outer process
        var processBuilder = this.CreateLinearProcess("Outer");

        // Create the inner process and add it as a step to the outer process
        var nestedProcessStep = processBuilder.AddStepFromProcess(this.CreateLinearProcess("Inner"));

        // Add a new external event to start the outer process and handoff to the inner process directly
        processBuilder.OnInputEvent(ProcessTestsEvents.StartInnerProcess)
            .SendEventTo(nestedProcessStep.WhereInputEventIs(ProcessTestsEvents.StartProcess));

        // Route the last step of the inner process to trigger the echo step of the outer process
        nestedProcessStep.OnEvent(ProcessTestsEvents.OutputReadyInternal)
            .SendEventTo(new ProcessFunctionTargetBuilder(processBuilder.Steps[0]));

        // Build the outer process
        var process = processBuilder.Build();

        // Act
        string testInput = "Test";
        var processHandle = await this._fixture.StartProcessAsync(process, kernel, new() { Id = ProcessTestsEvents.StartInnerProcess, Data = testInput });
        var processInfo = await processHandle.GetStateAsync();

        // Assert
        this.AssertStepStateLastMessage(processInfo, nameof(RepeatStep), expectedLastMessage: null);
    }

    /// <summary>
    /// Test with a fan in process where the same event triggers 2 steps inside the process that then connect to a step that expects
    /// the outputs of these steps
    /// </summary>
    /// <returns>A <see cref="Task"/></returns>
    [Fact]
    public async Task FanInProcessAsync()
    {
        // Arrange
        Kernel kernel = this._kernelBuilder.Build();
        var process = this.CreateFanInProcess("FanIn").Build();

        // Act
        string testInput = "Test";
        var processHandle = await this._fixture.StartProcessAsync(process, kernel, new() { Id = ProcessTestsEvents.StartProcess, Data = testInput });
        var processInfo = await processHandle.GetStateAsync();

        // Assert
        this.AssertStepStateLastMessage(processInfo, nameof(FanInStep), expectedLastMessage: $"{testInput}-{testInput} {testInput}");
    }

    /// <summary>
    /// Test with a process that has an error step that emits an error event
    /// </summary>
    /// <returns></returns>
    [Fact]
    public async Task ProcessWithErrorEmitsErrorEventAsync()
    {
        // Arrange
        Kernel kernel = this._kernelBuilder.Build();
        var process = this.CreateProcessWithError("ProcessWithError").Build();

        // Act
        bool shouldError = true;
        var processHandle = await this._fixture.StartProcessAsync(process, kernel, new() { Id = ProcessTestsEvents.StartProcess, Data = shouldError });
        var processInfo = await processHandle.GetStateAsync();

        // Assert
        this.AssertStepStateLastMessage(processInfo, nameof(ReportStep), expectedLastMessage: null, expectedInvocationCount: 1);
        this.AssertStepStateLastMessage(processInfo, nameof(RepeatStep), expectedLastMessage: null);
    }

    /// <summary>
    /// Test with a single step that then connects to a nested fan in process with 2 input steps
    /// </summary>
    /// <returns>A <see cref="Task"/></returns>
    [Fact]
    public async Task StepAndFanInProcessAsync()
    {
        // Arrange
        Kernel kernel = this._kernelBuilder.Build();
        var processBuilder = new ProcessBuilder("StepAndFanIn");
        var startStep = processBuilder.AddStepFromType<StartStep>(id: "startStep");
        var fanInStepName = "InnerFanIn";
        var fanInStep = processBuilder.AddStepFromProcess(this.CreateFanInProcess(fanInStepName));

        processBuilder.OnInputEvent(ProcessTestsEvents.StartProcess).SendEventTo(new ProcessFunctionTargetBuilder(startStep));
        startStep.OnEvent(ProcessTestsEvents.StartProcess).SendEventTo(fanInStep.WhereInputEventIs(ProcessTestsEvents.StartProcess));
        var process = processBuilder.Build();

        // Act
        string testInput = "Test";
        var processHandle = await this._fixture.StartProcessAsync(process, kernel, new() { Id = ProcessTestsEvents.StartProcess, Data = testInput });
        var processInfo = await processHandle.GetStateAsync();

        // Assert
        var subprocessStepInfo = processInfo.Steps.Where(s => s.State.Name == fanInStepName)?.FirstOrDefault() as KernelProcess;
        Assert.NotNull(subprocessStepInfo);
        this.AssertStepStateLastMessage(subprocessStepInfo, nameof(FanInStep), expectedLastMessage: $"{testInput}-{testInput} {testInput}");
    }

    /// <summary>
    /// Process with multiple "long" nested sequential subprocesses and with multiple single step
    /// output fan out only steps
    /// <code>
    ///            
    ///                                                           
    ///               
    ///   1st    2nd-nested    3rd-nested   last 
    ///             
    ///                                                    
    ///                           
    ///        output1             output2           output3 
    ///                           
    /// </code>
    /// </summary>
    /// <returns><see cref="Task"/></returns>
    [Fact]
    public async Task ProcessWith2NestedSubprocessSequentiallyAndMultipleOutputStepsAsync()
    {
        // Arrange
        Kernel kernel = this._kernelBuilder.Build();
        string lastStepName = "lastEmitterStep";
        string outputStepName1 = "outputStep1";
        string outputStepName2 = "outputStep2";
        string outputStepName3 = "outputStep3";
        ProcessBuilder processBuilder = new(nameof(ProcessWith2NestedSubprocessSequentiallyAndMultipleOutputStepsAsync));

        ProcessStepBuilder firstStep = processBuilder.AddStepFromType<EmitterStep>("firstEmitterStep");
        ProcessBuilder secondStep = processBuilder.AddStepFromProcess(this.CreateLongSequentialProcessWithFanInAsOutputStep("subprocess1"));
        ProcessBuilder thirdStep = processBuilder.AddStepFromProcess(this.CreateLongSequentialProcessWithFanInAsOutputStep("subprocess2"));
        ProcessStepBuilder outputStep1 = processBuilder.AddStepFromType<EmitterStep>(outputStepName1);
        ProcessStepBuilder outputStep2 = processBuilder.AddStepFromType<EmitterStep>(outputStepName2);
        ProcessStepBuilder outputStep3 = processBuilder.AddStepFromType<EmitterStep>(outputStepName3);
        ProcessStepBuilder lastStep = processBuilder.AddStepFromType<FanInStep>(lastStepName);

        processBuilder
            .OnInputEvent(EmitterStep.InputEvent)
            .SendEventTo(new ProcessFunctionTargetBuilder(firstStep, functionName: EmitterStep.InternalEventFunction));
        firstStep
            .OnEvent(EmitterStep.EventId)
            .SendEventTo(secondStep.WhereInputEventIs(EmitterStep.InputEvent))
            .SendEventTo(new ProcessFunctionTargetBuilder(outputStep1, functionName: EmitterStep.PublicEventFunction));
        secondStep
            .OnEvent(ProcessTestsEvents.OutputReadyPublic)
            .SendEventTo(thirdStep.WhereInputEventIs(EmitterStep.InputEvent))
            .SendEventTo(new ProcessFunctionTargetBuilder(outputStep2, functionName: EmitterStep.PublicEventFunction));
        thirdStep
            .OnEvent(ProcessTestsEvents.OutputReadyPublic)
            .SendEventTo(new ProcessFunctionTargetBuilder(lastStep, parameterName: "secondInput"))
            .SendEventTo(new ProcessFunctionTargetBuilder(outputStep3, functionName: EmitterStep.PublicEventFunction));

        firstStep
            .OnEvent(EmitterStep.EventId)
            .SendEventTo(new ProcessFunctionTargetBuilder(lastStep, parameterName: "firstInput"));

        KernelProcess process = processBuilder.Build();

        // Act
        string testInput = "SomeData";
        var processHandle = await this._fixture.StartProcessAsync(process, kernel, new KernelProcessEvent() { Id = EmitterStep.InputEvent, Data = testInput });
        var processInfo = await processHandle.GetStateAsync();

        // Assert
        this.AssertStepStateLastMessage(processInfo, outputStepName1, expectedLastMessage: testInput);
        this.AssertStepStateLastMessage(processInfo, outputStepName2, expectedLastMessage: $"{testInput}-{testInput}");
        this.AssertStepStateLastMessage(processInfo, outputStepName3, expectedLastMessage: $"{testInput}-{testInput}-{testInput}-{testInput}");
        this.AssertStepStateLastMessage(processInfo, lastStepName, expectedLastMessage: $"{testInput}-{testInput}-{testInput}-{testInput}-{testInput}");
    }

    #region Predefined ProcessBuilders for testing

    /// <summary>
    /// Sample long sequential process, each step has a delay.<br/>
    /// Input Event: <see cref="EmitterStep.InputEvent"/><br/>
    /// Output Event: <see cref="ProcessTestsEvents.OutputReadyPublic"/><br/>
    /// <code>
    ///            
    ///                                                           
    ///                  
    ///   1st    2nd    ...    10th   last 
    ///                   
    /// </code>
    /// </summary>
    /// <param name="name">name of the process</param>
    /// <returns><see cref="ProcessBuilder"/></returns>
    private ProcessBuilder CreateLongSequentialProcessWithFanInAsOutputStep(string name)
    {
        ProcessBuilder processBuilder = new(name);
        ProcessStepBuilder firstNestedStep = processBuilder.AddStepFromType<EmitterStep>("firstNestedStep");
        ProcessStepBuilder secondNestedStep = processBuilder.AddStepFromType<EmitterStep>("secondNestedStep");
        ProcessStepBuilder thirdNestedStep = processBuilder.AddStepFromType<EmitterStep>("thirdNestedStep");
        ProcessStepBuilder fourthNestedStep = processBuilder.AddStepFromType<EmitterStep>("fourthNestedStep");
        ProcessStepBuilder fifthNestedStep = processBuilder.AddStepFromType<EmitterStep>("fifthNestedStep");
        ProcessStepBuilder sixthNestedStep = processBuilder.AddStepFromType<EmitterStep>("sixthNestedStep");
        ProcessStepBuilder seventhNestedStep = processBuilder.AddStepFromType<EmitterStep>("seventhNestedStep");
        ProcessStepBuilder eighthNestedStep = processBuilder.AddStepFromType<EmitterStep>("eighthNestedStep");
        ProcessStepBuilder ninthNestedStep = processBuilder.AddStepFromType<EmitterStep>("ninthNestedStep");
        ProcessStepBuilder tenthNestedStep = processBuilder.AddStepFromType<EmitterStep>("tenthNestedStep");

        processBuilder.OnInputEvent(EmitterStep.InputEvent).SendEventTo(new ProcessFunctionTargetBuilder(firstNestedStep, functionName: EmitterStep.InternalEventFunction));
        firstNestedStep.OnEvent(EmitterStep.EventId).SendEventTo(new ProcessFunctionTargetBuilder(secondNestedStep, functionName: EmitterStep.InternalEventFunction));
        secondNestedStep.OnEvent(EmitterStep.EventId).SendEventTo(new ProcessFunctionTargetBuilder(thirdNestedStep, functionName: EmitterStep.InternalEventFunction));
        thirdNestedStep.OnEvent(EmitterStep.EventId).SendEventTo(new ProcessFunctionTargetBuilder(fourthNestedStep, functionName: EmitterStep.InternalEventFunction));
        fourthNestedStep.OnEvent(EmitterStep.EventId).SendEventTo(new ProcessFunctionTargetBuilder(fifthNestedStep, functionName: EmitterStep.InternalEventFunction));
        fifthNestedStep.OnEvent(EmitterStep.EventId).SendEventTo(new ProcessFunctionTargetBuilder(sixthNestedStep, functionName: EmitterStep.InternalEventFunction));
        sixthNestedStep.OnEvent(EmitterStep.EventId).SendEventTo(new ProcessFunctionTargetBuilder(seventhNestedStep, functionName: EmitterStep.InternalEventFunction));
        seventhNestedStep.OnEvent(EmitterStep.EventId).SendEventTo(new ProcessFunctionTargetBuilder(eighthNestedStep, functionName: EmitterStep.InternalEventFunction));
        eighthNestedStep.OnEvent(EmitterStep.EventId).SendEventTo(new ProcessFunctionTargetBuilder(ninthNestedStep, functionName: EmitterStep.InternalEventFunction));
        ninthNestedStep.OnEvent(EmitterStep.EventId).SendEventTo(new ProcessFunctionTargetBuilder(tenthNestedStep, functionName: EmitterStep.DualInputPublicEventFunction, parameterName: "secondInput"));

        firstNestedStep.OnEvent(EmitterStep.EventId).SendEventTo(new ProcessFunctionTargetBuilder(tenthNestedStep, functionName: EmitterStep.DualInputPublicEventFunction, parameterName: "firstInput"));

        return processBuilder;
    }

    /// <summary>
    /// Creates a simple linear process with two steps.<br/>
    /// Input Event: <see cref="ProcessTestsEvents.StartProcess"/><br/>
    /// Output Events: [<see cref="ProcessTestsEvents.OutputReadyInternal"/>, <see cref="ProcessTestsEvents.OutputReadyPublic"/>]<br/>
    /// <code>
    ///     
    ///   echo   repeat 
    ///     
    /// </code>
    /// </summary>
    private ProcessBuilder CreateLinearProcess(string name)
    {
        var processBuilder = new ProcessBuilder(name);
        var echoStep = processBuilder.AddStepFromType<CommonSteps.EchoStep>(id: nameof(CommonSteps.EchoStep));
        var repeatStep = processBuilder.AddStepFromType<RepeatStep>(id: nameof(RepeatStep));

        processBuilder.OnInputEvent(ProcessTestsEvents.StartProcess)
            .SendEventTo(new ProcessFunctionTargetBuilder(echoStep));

        echoStep.OnFunctionResult(nameof(CommonSteps.EchoStep.Echo))
            .SendEventTo(new ProcessFunctionTargetBuilder(repeatStep, parameterName: "message"));

        return processBuilder;
    }

    /// <summary>
    /// Simple process with fan in functionality.<br/>
    /// Input Event: <see cref="ProcessTestsEvents.StartProcess"/><br/>
    /// Output Events: <see cref="ProcessTestsEvents.OutputReadyPublic"/><br/>
    /// <code>
    /// 
    ///   echoA  
    ///       
    ///              
    ///               fanInC 
    ///              
    ///       
    ///  repeatB 
    /// 
    /// </code>
    /// </summary>
    /// <param name="name">name of the process</param>
    /// <returns><see cref="ProcessBuilder"/></returns>
    private ProcessBuilder CreateFanInProcess(string name)
    {
        var processBuilder = new ProcessBuilder(name);
        var echoAStep = processBuilder.AddStepFromType<CommonSteps.EchoStep>("EchoStepA");
        var repeatBStep = processBuilder.AddStepFromType<RepeatStep>("RepeatStepB");
        var fanInCStep = processBuilder.AddStepFromType<FanInStep>(id: nameof(FanInStep));

        processBuilder.OnInputEvent(ProcessTestsEvents.StartProcess).SendEventTo(new ProcessFunctionTargetBuilder(echoAStep));
        processBuilder.OnInputEvent(ProcessTestsEvents.StartProcess).SendEventTo(new ProcessFunctionTargetBuilder(repeatBStep, parameterName: "message"));

        echoAStep.OnFunctionResult(nameof(CommonSteps.EchoStep.Echo)).SendEventTo(new ProcessFunctionTargetBuilder(fanInCStep, parameterName: "firstInput"));
        repeatBStep.OnEvent(ProcessTestsEvents.OutputReadyPublic).SendEventTo(new ProcessFunctionTargetBuilder(fanInCStep, parameterName: "secondInput"));

        return processBuilder;
    }

    /// <summary>
    /// Creates a simple linear process with that emit error events.<br/>
    /// Input Event: <see cref="ProcessTestsEvents.StartProcess"/><br/>
    /// Output Events: <see cref="ProcessStepBuilder.OnFunctionError(string?)"/> <br/>
    /// <code>
    ///               
    ///       repeat 
    ///              
    ///  
    ///   error 
    ///  
    ///              
    ///       report 
    ///               
    /// </code>
    /// </summary>
    private ProcessBuilder CreateProcessWithError(string name)
    {
        var processBuilder = new ProcessBuilder(name);
        var errorStep = processBuilder.AddStepFromType<ErrorStep>("ErrorStep");
        var repeatStep = processBuilder.AddStepFromType<RepeatStep>("RepeatStep");
        var reportStep = processBuilder.AddStepFromType<ReportStep>("ReportStep");

        processBuilder.OnInputEvent(ProcessTestsEvents.StartProcess).SendEventTo(new ProcessFunctionTargetBuilder(errorStep));
        errorStep.OnEvent(ProcessTestsEvents.ErrorStepSuccess).SendEventTo(new ProcessFunctionTargetBuilder(repeatStep, parameterName: "message"));
        errorStep.OnFunctionError("ErrorWhenTrue").SendEventTo(new ProcessFunctionTargetBuilder(reportStep));

        return processBuilder;
    }
    #endregion

    #region Assert Utils
    private void AssertStepStateLastMessage(KernelProcess processInfo, string stepName, string? expectedLastMessage, int? expectedInvocationCount = null)
    {
        KernelProcessStepInfo? stepInfo = processInfo.Steps.FirstOrDefault(s => s.State.Name == stepName);
        Assert.NotNull(stepInfo);
        var outputStepResult = stepInfo.State as KernelProcessStepState<StepState>;
        Assert.NotNull(outputStepResult?.State);
        Assert.Equal(expectedLastMessage, outputStepResult.State.LastMessage);
        if (expectedInvocationCount.HasValue)
        {
            Assert.Equal(expectedInvocationCount.Value, outputStepResult.State.InvocationCount);
        }
    }

#if !NET
    private void AssertStepState<T>(KernelProcess processInfo, string stepName, Predicate<KernelProcessStepState<T>> predicate) where T : class, new()
    {
        KernelProcessStepInfo? stepInfo = processInfo.Steps.FirstOrDefault(s => s.State.Name == stepName);
        Assert.NotNull(stepInfo);
        var outputStepResult = stepInfo.State as KernelProcessStepState<T>;
        Assert.NotNull(outputStepResult?.State);
        Assert.True(predicate(outputStepResult));
    }
#endif
    #endregion
}


===== Process.IntegrationTests.Shared\TestSettings\AzureOpenAIConfiguration.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Diagnostics.CodeAnalysis;

namespace SemanticKernel.Process.IntegrationTests.TestSettings;

[SuppressMessage("Performance", "CA1812:Internal class that is apparently never instantiated",
    Justification = "Configuration classes are instantiated through IConfiguration.")]
internal sealed class AzureOpenAIConfiguration(string serviceId, string deploymentName, string endpoint, string? apiKey = null, string? chatDeploymentName = null, string? modelId = null, string? chatModelId = null, string? embeddingModelId = null)
{
    public string ServiceId { get; set; } = serviceId;

    public string DeploymentName { get; set; } = deploymentName;

    public string ModelId { get; set; } = modelId ?? deploymentName;

    public string? ChatDeploymentName { get; set; } = chatDeploymentName ?? deploymentName;

    public string ChatModelId { get; set; } = chatModelId ?? deploymentName;

    public string EmbeddingModelId { get; set; } = embeddingModelId ?? "text-embedding-ada-002";

    public string Endpoint { get; set; } = endpoint;

    public string? ApiKey { get; set; } = apiKey;
}


===== Process.IntegrationTests.Shared\TestSettings\OpenAIConfiguration.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Diagnostics.CodeAnalysis;

namespace SemanticKernel.IntegrationTests.TestSettings;

[SuppressMessage("Performance", "CA1812:Internal class that is apparently never instantiated",
    Justification = "Configuration classes are instantiated through IConfiguration.")]
internal sealed class OpenAIConfiguration(string serviceId, string modelId, string apiKey, string? chatModelId = null)
{
    public string ServiceId { get; set; } = serviceId;
    public string ModelId { get; set; } = modelId;
    public string? ChatModelId { get; set; } = chatModelId;
    public string ApiKey { get; set; } = apiKey;
}


===== Process.IntegrationTests.Shared\TestSettings\ProcessTestGroup.cs =====

// Copyright (c) Microsoft. All rights reserved.

#pragma warning disable IDE0005 // Using directive is unnecessary.
using Xunit;
#pragma warning restore IDE0005 // Using directive is unnecessary.

namespace SemanticKernel.Process.IntegrationTests;

/// <summary>
/// A collection definition for shared process tests.
/// </summary>
[CollectionDefinition(nameof(ProcessTestGroup))]
public class ProcessTestGroup : ICollectionFixture<ProcessTestFixture>;


===== Process.LocalRuntime\AssemblyInfo.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Diagnostics.CodeAnalysis;

// This assembly is currently experimental.
[assembly: Experimental("SKEXP0080")]


===== Process.LocalRuntime\LocalAgentStep.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Text.Json;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.SemanticKernel.Process.Internal;
using Microsoft.SemanticKernel.Process.Runtime;

namespace Microsoft.SemanticKernel.Process;
internal class LocalAgentStep : LocalStep
{
    private new readonly KernelProcessAgentStep _stepInfo;
    private readonly KernelProcessAgentThread _agentThread;
    private readonly ProcessStateManager _processStateManager;
    private readonly ILogger _logger;

    public LocalAgentStep(KernelProcessAgentStep stepInfo, Kernel kernel, KernelProcessAgentThread agentThread, ProcessStateManager processStateManager, string? parentProcessId = null) : base(stepInfo, kernel, parentProcessId)
    {
        this._stepInfo = stepInfo;
        this._agentThread = agentThread;
        this._processStateManager = processStateManager;
        this._logger = this._kernel.LoggerFactory?.CreateLogger(this._stepInfo.InnerStepType) ?? new NullLogger<LocalAgentStep>();
    }

    protected override ValueTask InitializeStepAsync()
    {
        this._stepInstance = new KernelProcessAgentExecutorInternal(this._stepInfo, this._agentThread, this._processStateManager);
        var kernelPlugin = KernelPluginFactory.CreateFromObject(this._stepInstance, pluginName: this._stepInfo.State.Name);

        // Load the kernel functions
        foreach (KernelFunction f in kernelPlugin)
        {
            this._functions.Add(f.Name, f);
        }
        return default;
    }

    internal override async Task HandleMessageAsync(ProcessMessage message)
    {
        Verify.NotNull(message, nameof(message));

        // Lazy one-time initialization of the step before processing a message
        await this._initializeTask.Value.ConfigureAwait(false);

        string targetFunction = "Invoke";
        KernelArguments arguments = new()
        {
            { "message", message.TargetEventData switch
                {
                    KernelProcessEventData proxyData => proxyData.ToObject(),
                    _ => message.TargetEventData
                }
            },
            { "writtenToThread", message.writtenToThread == this._agentThread.ThreadId }
        };
        if (!this._functions.TryGetValue(targetFunction, out KernelFunction? function) || function == null)
        {
            throw new ArgumentException($"Function Invoke not found in plugin {this.Name}");
        }

        object? result = null;

        // Invoke the function, catching all exceptions that it may throw, and then post the appropriate event.
#pragma warning disable CA1031 // Do not catch general exception types
        try
        {
            FunctionResult invokeResult = await this.InvokeFunction(function, this._kernel, arguments).ConfigureAwait(false);
            result = invokeResult.GetValue<object>();
            this.EmitEvent(
                ProcessEvent.Create(
                    result,
                    this._eventNamespace,
                    sourceId: $"{targetFunction}.OnResult",
                    eventVisibility: KernelProcessEventVisibility.Public,
                    writtenToThread: this._agentThread.ThreadId)); // TODO: This is keeping track of the thread the message has been written to, clean it up, name it better, etc. 
        }
        catch (Exception ex)
        {
            this._logger.LogError(ex, "Error in Step {StepName}: {ErrorMessage}", this.Name, ex.Message);
            var processError = KernelProcessError.FromException(ex);
            this.EmitEvent(
                ProcessEvent.Create(
                    processError,
                    this._eventNamespace,
                    sourceId: $"{targetFunction}.OnError",
                    eventVisibility: KernelProcessEventVisibility.Public,
                    isError: true));

            if (this._stepInfo.Actions.DeclarativeActions?.OnError is not null)
            {
                await this.ProcessDeclarativeConditionsAsync(processError, this._stepInfo.Actions.DeclarativeActions.OnError).ConfigureAwait(false);
            }
            if (this._stepInfo.Actions.CodeActions?.OnError is not null)
            {
                this._stepInfo.Actions.CodeActions?.OnError(processError, new KernelProcessStepContext(this));
            }

            return;
        }
#pragma warning restore CA1031 // Do not catch general exception types

        // TODO: Should these be handled within the try or out of it?
        if (this._stepInfo.Actions.DeclarativeActions?.OnComplete is not null)
        {
            await this.ProcessDeclarativeConditionsAsync(result, this._stepInfo.Actions.DeclarativeActions.OnComplete).ConfigureAwait(false);
        }
        if (this._stepInfo.Actions.CodeActions?.OnComplete is not null)
        {
            this._stepInfo.Actions.CodeActions?.OnComplete(result, new KernelProcessStepContext(this));
        }
    }

    private async Task ProcessDeclarativeConditionsAsync(object? result, KernelProcessDeclarativeConditionHandler conditionHandler)
    {
        int executedConditionCount = 0;
        foreach (var onCompleteStateCondition in conditionHandler.EvalConditions ?? [])
        {
            // process state conditions
            await this.ProcessConditionsAsync(result, onCompleteStateCondition).ConfigureAwait(false);
            executedConditionCount++;
            // Test condition
            // TODO: Apply state conditions to the result and emit events
        }

        var alwaysCondition = conditionHandler.AlwaysCondition;
        if (alwaysCondition != null)
        {
            // process semantic conditions
            await this.ProcessConditionsAsync(result, alwaysCondition).ConfigureAwait(false);
            executedConditionCount++;
            // TODO: Apply state conditions to the result and emit events
        }

        var defaultCondition = conditionHandler.DefaultCondition;
        if (executedConditionCount == 0 && defaultCondition != null)
        {
            await this.ProcessConditionsAsync(result, defaultCondition).ConfigureAwait(false);
            executedConditionCount++;
        }
    }

    private async Task ProcessConditionsAsync(object? result, DeclarativeProcessCondition declarativeCondition)
    {
        await this._processStateManager.ReduceAsync((stateType, state) =>
        {
            var stateJson = JsonDocument.Parse(JsonSerializer.Serialize(state));

            if (string.IsNullOrWhiteSpace(declarativeCondition.Expression) || JMESPathConditionEvaluator.EvaluateCondition(state, declarativeCondition.Expression))
            {
                if (declarativeCondition.Updates is not null)
                {
                    foreach (var update in declarativeCondition.Updates)
                    {
                        stateJson = JMESUpdate.UpdateState(stateJson, update.Path, update.Operation, update.Value);
                    }
                }

                if (declarativeCondition.Emits is not null)
                {
                    foreach (var emit in declarativeCondition.Emits)
                    {
                        this.EmitEvent(
                            ProcessEvent.Create(
                                result, // TODO: Use the correct value as defined in emit.Payload
                                this._eventNamespace,
                                sourceId: emit.EventType,
                                eventVisibility: KernelProcessEventVisibility.Public));
                    }
                }
            }

            return Task.FromResult(stateJson.Deserialize(stateType));
        }).ConfigureAwait(false);
    }
}


===== Process.LocalRuntime\LocalEdgeGroupProcessor.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using Microsoft.SemanticKernel.Process.Runtime;

namespace Microsoft.SemanticKernel;
internal class LocalEdgeGroupProcessor
{
    private readonly KernelProcessEdgeGroup _edgeGroup;
    private readonly Dictionary<string, object?> _messageData = [];
    private HashSet<string> _requiredMessages = new();
    private HashSet<string> _absentMessages = new();

    public LocalEdgeGroupProcessor(KernelProcessEdgeGroup edgeGroup)
    {
        Verify.NotNull(edgeGroup, nameof(edgeGroup));
        this._edgeGroup = edgeGroup;

        this.InitializeEventTracking();
    }

    public bool TryGetResult(ProcessMessage message, out Dictionary<string, object?>? result)
    {
        string messageKey = this.GetKeyForMessageSource(message);
        if (!this._requiredMessages.Contains(messageKey))
        {
            throw new KernelException($"Message {messageKey} is not expected for edge group {this._edgeGroup.GroupId}.");
        }

        this._messageData[messageKey] = (message.TargetEventData as KernelProcessEventData)!.ToObject();

        this._absentMessages.Remove(messageKey);
        if (this._absentMessages.Count == 0)
        {
            // We have received all required events so forward them to the target
            result = (Dictionary<string, object?>?)this._edgeGroup.InputMapping(this._messageData);

            // TODO: Reset state according to configured logic i.e. reset after first message or after all messages are received.
            this.InitializeEventTracking();

            return true;
        }

        result = null;
        return false;
    }

    private void InitializeEventTracking()
    {
        this._requiredMessages = this.BuildRequiredEvents(this._edgeGroup.MessageSources);
        this._absentMessages = [.. this._requiredMessages];
    }

    private HashSet<string> BuildRequiredEvents(List<KernelProcessMessageSource> messageSources)
    {
        var requiredEvents = new HashSet<string>();
        foreach (var source in messageSources)
        {
            requiredEvents.Add(this.GetKeyForMessageSource(source));
        }

        return requiredEvents;
    }

    private string GetKeyForMessageSource(KernelProcessMessageSource messageSource)
    {
        return $"{messageSource.SourceStepId}.{messageSource.MessageType}";
    }

    private string GetKeyForMessageSource(ProcessMessage message)
    {
        return $"{message.SourceId}.{message.SourceEventId}";
    }
}


===== Process.LocalRuntime\LocalKernelProcessContext.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Threading.Tasks;
using Microsoft.SemanticKernel.Process;

namespace Microsoft.SemanticKernel;

/// <summary>
/// Provides context and actions on a process that is running locally.
/// </summary>
public sealed class LocalKernelProcessContext : KernelProcessContext, System.IAsyncDisposable
{
    private readonly LocalProcess _localProcess;
    private readonly Kernel _kernel;

    internal LocalKernelProcessContext(KernelProcess process, Kernel kernel, ProcessEventProxy? eventProxy = null, IExternalKernelProcessMessageChannel? externalMessageChannel = null)
    {
        Verify.NotNull(process, nameof(process));
        Verify.NotNull(kernel, nameof(kernel));
        Verify.NotNullOrWhiteSpace(process.State?.Name);

        this._kernel = kernel;
        this._localProcess = new LocalProcess(process, kernel)
        {
            EventProxy = eventProxy,
            ExternalMessageChannel = externalMessageChannel,
        };
    }

    internal Task StartWithEventAsync(KernelProcessEvent initialEvent, Kernel? kernel = null) =>
        this._localProcess.RunOnceAsync(initialEvent, kernel);

    //internal RunUntilEndAsync(KernelProcessEvent initialEvent, Kernel? kernel = null, TimeSpan? timeout = null)
    //{

    //}

    /// <summary>
    /// Sends a message to the process.
    /// </summary>
    /// <param name="processEvent">The event to sent to the process.</param>
    /// <returns>A <see cref="Task"/></returns>
    public override Task SendEventAsync(KernelProcessEvent processEvent) =>
        this._localProcess.SendMessageAsync(processEvent);

    /// <summary>
    /// Stops the process.
    /// </summary>
    /// <returns>A <see cref="Task"/></returns>
    public override Task StopAsync() => this._localProcess.StopAsync();

    /// <summary>
    /// Gets a snapshot of the current state of the process.
    /// </summary>
    /// <returns>A <see cref="Task{T}"/> where T is <see cref="KernelProcess"/></returns>
    public override Task<KernelProcess> GetStateAsync() => this._localProcess.GetProcessInfoAsync();

    /// <summary>
    /// Disposes of the resources used by the process.
    /// </summary>
    public async ValueTask DisposeAsync()
    {
        await this._localProcess.DisposeAsync().ConfigureAwait(false);
    }

    /// <inheritdoc/>
    public override Task<IExternalKernelProcessMessageChannel?> GetExternalMessageChannelAsync()
    {
        return Task.FromResult(this._localProcess.ExternalMessageChannel);
    }

    /// <inheritdoc/>
    public override Task<string> GetProcessIdAsync() => Task.FromResult(this._localProcess.Id);
}


===== Process.LocalRuntime\LocalKernelProcessFactory.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Threading.Tasks;

namespace Microsoft.SemanticKernel;

/// <summary>
/// A class that can run a process locally or in-process.
/// </summary>
public static class LocalKernelProcessFactory
{
    /// <summary>
    /// Starts the specified process.
    /// </summary>
    /// <param name="process">Required: The <see cref="KernelProcess"/> to start running.</param>
    /// <param name="kernel">Required: An instance of <see cref="Kernel"/></param>
    /// <param name="initialEvent">Required: The initial event to start the process.</param>
    /// <param name="externalMessageChannel">Optional: an instance of <see cref="IExternalKernelProcessMessageChannel"/>.</param>
    /// <returns>An instance of <see cref="KernelProcess"/> that can be used to interrogate or stop the running process.</returns>
    public static async Task<LocalKernelProcessContext> StartAsync(this KernelProcess process, Kernel kernel, KernelProcessEvent initialEvent, IExternalKernelProcessMessageChannel? externalMessageChannel = null)
    {
        Verify.NotNull(initialEvent, nameof(initialEvent));

        LocalKernelProcessContext processContext = new(process, kernel, null, externalMessageChannel);
        await processContext.StartWithEventAsync(initialEvent).ConfigureAwait(false);
        return processContext;
    }

    /// <summary>
    /// Starts the specified process and runs it to completion.
    /// </summary>
    /// <param name="process"></param>
    /// <param name="kernel"></param>
    /// <param name="initialEvent"></param>
    /// <param name="timeout"></param>
    /// <param name="externalMessageChannel"></param>
    /// <returns></returns>
    public static async Task<LocalKernelProcessContext> RunToEndAsync(this KernelProcess process, Kernel kernel, KernelProcessEvent initialEvent, TimeSpan? timeout = null, IExternalKernelProcessMessageChannel? externalMessageChannel = null)
    {
        Verify.NotNull(initialEvent, nameof(initialEvent));
        TimeSpan timeoutValue = timeout ?? TimeSpan.FromSeconds(60);

        LocalKernelProcessContext processContext = new(process, kernel, null, externalMessageChannel);
        await processContext.StartWithEventAsync(initialEvent).ConfigureAwait(false);
        return processContext;
    }
}


===== Process.LocalRuntime\LocalMap.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.Collections;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.SemanticKernel.Process.Internal;
using Microsoft.SemanticKernel.Process.Runtime;

namespace Microsoft.SemanticKernel;

internal sealed class LocalMap : LocalStep
{
    private readonly HashSet<string> _mapEvents;
    private readonly KernelProcessMap _map;
    private readonly ILogger _logger;

    /// <summary>
    /// Initializes a new instance of the <see cref="LocalMap"/> class.
    /// </summary>
    /// <param name="map">The <see cref="KernelProcessMap"/> instance.</param>
    /// <param name="kernel">An instance of <see cref="Kernel"/></param>
    internal LocalMap(KernelProcessMap map, Kernel kernel)
        : base(map, kernel)
    {
        this._map = map;
        this._logger = this._kernel.LoggerFactory?.CreateLogger(this._map.State.Name) ?? new NullLogger<LocalStep>();
        this._mapEvents = [.. map.Edges.Keys.Select(key => key.Split(ProcessConstants.EventIdSeparator).Last())];
    }

    /// <inheritdoc/>
    internal override async Task HandleMessageAsync(ProcessMessage message)
    {
        // Initialize the current operation
        (IEnumerable inputValues, KernelProcess mapOperation, string startEventId) = this._map.Initialize(message, this._logger);

        // Prepare state for map execution
        int index = 0;
        List<(Task Task, LocalKernelProcessContext ProcessContext, MapOperationContext Context)> mapOperations = [];
        ConcurrentDictionary<string, Type> capturedEvents = [];
        try
        {
            // Execute the map operation for each value
            foreach (var value in inputValues)
            {
                ++index;

                KernelProcess process = mapOperation.CloneProcess(this._logger);
                MapOperationContext context = new(this._mapEvents, capturedEvents);
#pragma warning disable CA2000 // Dispose objects before losing scope
                LocalKernelProcessContext processContext = new(process, this._kernel, context.Filter);
                Task processTask =
                    processContext.StartWithEventAsync(
                        new KernelProcessEvent
                        {
                            Id = startEventId,
                            Data = value
                        });
#pragma warning restore CA2000 // Dispose objects before losing scope

                mapOperations.Add((processTask, processContext, context));
            }

            // Wait for all the map operations to complete
            await Task.WhenAll(mapOperations.Select(p => p.Task)).ConfigureAwait(false);

            // Correlate the operation results to emit as the map result
            Dictionary<string, Array> resultMap = [];
            for (index = 0; index < mapOperations.Count; ++index)
            {
                foreach (KeyValuePair<string, Type> capturedEvent in capturedEvents)
                {
                    string eventName = capturedEvent.Key;
                    Type resultType = capturedEvent.Value;

                    mapOperations[index].Context.Results.TryGetValue(eventName, out object? result);
                    if (result is KernelProcessEventData eventData)
                    {
                        result = eventData.ToObject();
                        resultType = Type.GetType(eventData.ObjectType)!;
                    }

                    if (!resultMap.TryGetValue(eventName, out Array? results))
                    {
                        results = Array.CreateInstance(resultType, mapOperations.Count);
                        resultMap[eventName] = results;
                    }

                    results.SetValue(result, index);
                }
            }

            // Emit map results
            foreach (string eventName in capturedEvents.Keys)
            {
                Array eventResult = resultMap[eventName];
                await this.EmitEventAsync(new() { Id = eventName, Data = eventResult }).ConfigureAwait(false);
            }
        }
        finally
        {
            foreach (var operation in mapOperations)
            {
                await operation.ProcessContext.DisposeAsync().ConfigureAwait(false);
            }
        }
    }

    /// <inheritdoc/>
    protected override ValueTask InitializeStepAsync()
    {
        // The map does not need any further initialization as it's already been initialized.
        // Override the base method to prevent it from being called.
        return default;
    }

    private sealed record MapOperationContext(in HashSet<string> EventTargets, in IDictionary<string, Type> CapturedEvents)
    {
        public ConcurrentDictionary<string, object?> Results { get; } = [];

        public bool Filter(ProcessEvent processEvent)
        {
            string eventName = processEvent.SourceId;
            if (this.EventTargets.Contains(eventName))
            {
                this.CapturedEvents.TryGetValue(eventName, out Type? resultType);
                if (resultType is null || resultType == typeof(object))
                {
                    this.CapturedEvents[eventName] = processEvent.Data?.GetType() ?? typeof(object);
                }

                this.Results[eventName] = processEvent.Data;
            }

            return true;
        }
    }
}


===== Process.LocalRuntime\LocalProcess.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.Json;
using System.Threading;
using System.Threading.Channels;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.Process;
using Microsoft.SemanticKernel.Process.Internal;
using Microsoft.SemanticKernel.Process.Runtime;
using Microsoft.VisualStudio.Threading;

namespace Microsoft.SemanticKernel;

internal delegate bool ProcessEventProxy(ProcessEvent processEvent);

internal sealed class LocalProcess : LocalStep, System.IAsyncDisposable
{
    private readonly JoinableTaskFactory _joinableTaskFactory;
    private readonly JoinableTaskContext _joinableTaskContext;
    private readonly Channel<KernelProcessEvent> _externalEventChannel;
    private new readonly Lazy<ValueTask> _initializeTask;
    private readonly Dictionary<string, KernelProcessAgentThread> _threads = [];

    internal readonly List<KernelProcessStepInfo> _stepsInfos;
    internal readonly List<LocalStep> _steps = [];
    internal readonly KernelProcess _process;

    private readonly ILogger _logger;

    private JoinableTask? _processTask;
    private CancellationTokenSource? _processCancelSource;
    private ProcessStateManager? _processStateManager;

    /// <summary>
    /// Initializes a new instance of the <see cref="LocalProcess"/> class.
    /// </summary>
    /// <param name="process">The <see cref="KernelProcess"/> instance.</param>
    /// <param name="kernel">An instance of <see cref="Kernel"/></param>
    internal LocalProcess(KernelProcess process, Kernel kernel)
        : base(process, kernel)
    {
        Verify.NotNull(process.Steps);

        this._stepsInfos = new List<KernelProcessStepInfo>(process.Steps);
        this._process = process;
        this._initializeTask = new Lazy<ValueTask>(this.InitializeProcessAsync);
        this._externalEventChannel = Channel.CreateUnbounded<KernelProcessEvent>();
        this._joinableTaskContext = new JoinableTaskContext();
        this._joinableTaskFactory = new JoinableTaskFactory(this._joinableTaskContext);
        this._logger = this._kernel.LoggerFactory?.CreateLogger(this.Name) ?? new NullLogger<LocalStep>();
        // if parent id is null this is the root process
        this.RootProcessId = this.ParentProcessId == null ? this.Id : null;
    }

    /// <summary>
    /// The Id of the root process.
    /// </summary>
    internal string? RootProcessId { get; init; }

    /// <summary>
    /// Starts the process with an initial event and an optional kernel.
    /// </summary>
    /// <param name="kernel">The <see cref="Kernel"/> instance to use within the running process.</param>
    /// <param name="keepAlive">Indicates if the process should wait for external events after it's finished processing.</param>
    /// <returns> <see cref="Task"/></returns>
    internal async Task StartAsync(Kernel? kernel = null, bool keepAlive = true)
    {
        // Lazy one-time initialization of the process before staring it.
        await this._initializeTask.Value.ConfigureAwait(false);

        this._processCancelSource = new CancellationTokenSource();
        this._processTask = this._joinableTaskFactory.RunAsync(()
            => this.Internal_ExecuteAsync(kernel, keepAlive: keepAlive, cancellationToken: this._processCancelSource.Token));
    }

    /// <summary>
    /// Starts the process with an initial event and then waits for the process to finish. In this case the process will not
    /// keep alive waiting for external events after the internal messages have stopped.
    /// </summary>
    /// <param name="processEvent">Required. The <see cref="KernelProcessEvent"/> to start the process with.</param>
    /// <param name="kernel">Optional. A <see cref="Kernel"/> to use when executing the process.</param>
    /// <returns>A <see cref="Task"/></returns>
    internal async Task RunOnceAsync(KernelProcessEvent processEvent, Kernel? kernel = null)
    {
        Verify.NotNull(processEvent, nameof(processEvent));
        Verify.NotNullOrWhiteSpace(processEvent.Id, $"{nameof(processEvent)}.{nameof(KernelProcessEvent.Id)}");

        await Task.Yield(); // Ensure that the process has an opportunity to run in a different synchronization context.
        await this._externalEventChannel.Writer.WriteAsync(processEvent).ConfigureAwait(false);
        await this.StartAsync(kernel, keepAlive: false).ConfigureAwait(false);
        await this._processTask!.JoinAsync().ConfigureAwait(false);
    }

    /// <summary>
    /// Starts the process with an initial event and then waits for the process to finish. In this case the process will not
    /// keep alive waiting for external events after the internal messages have stopped.
    /// </summary>
    /// <param name="processEvent">Required. The <see cref="KernelProcessEvent"/> to start the process with.</param>
    /// <param name="kernel">Optional. A <see cref="Kernel"/> to use when executing the process.</param>
    /// <param name="timeout">Optional. A <see cref="TimeSpan"/> to wait for the process to finish.</param>
    /// <returns>A <see cref="Task"/></returns>
    internal async Task RunUntilEndAsync(KernelProcessEvent processEvent, Kernel? kernel = null, TimeSpan? timeout = null)
    {
        Verify.NotNull(processEvent, nameof(processEvent));
        Verify.NotNullOrWhiteSpace(processEvent.Id, $"{nameof(processEvent)}.{nameof(KernelProcessEvent.Id)}");

        await Task.Yield(); // Ensure that the process has an opportunity to run in a different synchronization context.
        await this._externalEventChannel.Writer.WriteAsync(processEvent).ConfigureAwait(false);
        await this.StartAsync(kernel, keepAlive: true).ConfigureAwait(false);
        await this._processTask!.JoinAsync().ConfigureAwait(false);
    }

    /// <summary>
    /// Stops a running process. This will cancel the process and wait for it to complete before returning.
    /// </summary>
    /// <returns>A <see cref="Task"/></returns>
    internal async Task StopAsync()
    {
        if (this._processTask is null || this._processCancelSource is null || this._processTask.IsCompleted)
        {
            return;
        }

        // Cancel the process and wait for it to complete.
        this._processCancelSource.Cancel();

        try
        {
            await this._processTask;
        }
        catch (OperationCanceledException)
        {
            // The task was cancelled, so we can ignore this exception.
        }
        finally
        {
            this._processCancelSource.Dispose();
        }
    }

    /// <summary>
    /// Sends a message to the process. This does not start the process if it's not already running, in
    /// this case the message will remain queued until the process is started.
    /// </summary>
    /// <param name="processEvent">Required. The <see cref="KernelProcessEvent"/> to start the process with.</param>
    /// <param name="kernel">Optional. A <see cref="Kernel"/> to use when executing the process.</param>
    /// <returns>A <see cref="Task"/></returns>
    internal async Task SendMessageAsync(KernelProcessEvent processEvent, Kernel? kernel = null)
    {
        Verify.NotNull(processEvent, nameof(processEvent));
        await this._externalEventChannel.Writer.WriteAsync(processEvent).AsTask().ConfigureAwait(false);

        // make sure the process is running in case it was already cancelled
        if (this._processCancelSource == null)
        {
            await this.StartAsync(this._kernel).ConfigureAwait(false);
        }
    }

    /// <summary>
    /// Gets the process information.
    /// </summary>
    /// <returns>An instance of <see cref="KernelProcess"/></returns>
    internal Task<KernelProcess> GetProcessInfoAsync() => this.ToKernelProcessAsync();

    /// <summary>
    /// Handles a <see cref="ProcessMessage"/> that has been sent to the process. This happens only in the case
    /// of a process (this one) running as a step within another process (this one's parent). In this case the
    /// entire sub-process should be executed within a single superstep.
    /// </summary>
    /// <param name="message">The message to process.</param>
    /// <returns>A <see cref="Task"/></returns>
    /// <exception cref="KernelException"></exception>
    internal override async Task HandleMessageAsync(ProcessMessage message)
    {
        if (string.IsNullOrWhiteSpace(message.TargetEventId))
        {
            throw new KernelException("Internal Process Error: The target event id must be specified when sending a message to a step.").Log(this._logger);
        }

        string eventId = message.TargetEventId!;
        if (this._outputEdges.TryGetValue(eventId, out List<KernelProcessEdge>? edges) && edges is not null)
        {
            // Create the external event that will be used to start the nested process. Since this event came
            // from outside this processes, we set the visibility to internal so that it's not emitted back out again.
            KernelProcessEvent nestedEvent = new() { Id = eventId, Data = message.TargetEventData, Visibility = KernelProcessEventVisibility.Internal };

            // Run the nested process completely within a single superstep.
            await this.RunOnceAsync(nestedEvent, this._kernel).ConfigureAwait(false);
        }
    }

    #region Private Methods

    /// <summary>
    /// Loads the process and initializes the steps. Once this is complete the process can be started.
    /// </summary>
    /// <returns>A <see cref="Task"/></returns>
    private async ValueTask InitializeProcessAsync()
    {
        // Initialize the input and output edges for the process
        this._outputEdges = this._process.Edges.ToDictionary(kvp => kvp.Key, kvp => kvp.Value.ToList());

        // TODO: Pull user state from persisted state on resume.
        this._processStateManager = new ProcessStateManager(this._process.UserStateType, null);

        // Initialize threads. TODO: Need to implement state management here.
        foreach (var kvp in this._process.Threads)
        {
            var threadDefinition = kvp.Value;
            KernelProcessAgentThread? processThread = null;
            if (threadDefinition.ThreadPolicy == KernelProcessThreadLifetime.Scoped)
            {
                // Create scoped threads now as they may be shared across steps
                AgentThread thread = await threadDefinition.CreateAgentThreadAsync(this._kernel).ConfigureAwait(false);
                processThread = new KernelProcessAgentThread
                {
                    ThreadId = thread.Id,
                    ThreadName = kvp.Key,
                    ThreadType = threadDefinition.ThreadType,
                    ThreadPolicy = threadDefinition.ThreadPolicy
                };
            }
            else
            {
                var thread = new KernelProcessAgentThread
                {
                    ThreadId = null,
                    ThreadName = kvp.Key,
                    ThreadType = threadDefinition.ThreadType,
                    ThreadPolicy = threadDefinition.ThreadPolicy
                };
            }

            this._threads.Add(kvp.Key, processThread ?? throw new KernelException("Failed to create process thread."));
        }

        // Initialize the steps within this process
        foreach (var step in this._stepsInfos)
        {
            LocalStep? localStep = null;

            // The current step should already have a name.
            Verify.NotNull(step.State?.Name);

            if (step is KernelProcess processStep)
            {
                // The process will only have an Id if its already been executed.
                if (string.IsNullOrWhiteSpace(processStep.State.Id))
                {
                    processStep = processStep with { State = processStep.State with { Id = Guid.NewGuid().ToString() } };
                }

                localStep =
                    new LocalProcess(processStep, this._kernel)
                    {
                        ParentProcessId = this.Id,
                        RootProcessId = this.RootProcessId,
                        EventProxy = this.EventProxy,
                        ExternalMessageChannel = this.ExternalMessageChannel,
                    };
            }
            else if (step is KernelProcessMap mapStep)
            {
                localStep =
                    new LocalMap(mapStep, this._kernel)
                    {
                        ParentProcessId = this.Id,
                    };
            }
            else if (step is KernelProcessProxy proxyStep)
            {
                localStep =
                    new LocalProxy(proxyStep, this._kernel)
                    {
                        ParentProcessId = this.RootProcessId,
                        EventProxy = this.EventProxy,
                        ExternalMessageChannel = this.ExternalMessageChannel
                    };
            }
            else if (step is KernelProcessAgentStep agentStep)
            {
                if (!this._threads.TryGetValue(agentStep.ThreadName, out KernelProcessAgentThread? thread) || thread is null)
                {
                    throw new KernelException($"The thread name {agentStep.ThreadName} does not have a matching thread variable defined.").Log(this._logger);
                }

                localStep = new LocalAgentStep(agentStep, this._kernel, thread, this._processStateManager, this.ParentProcessId);
            }
            else
            {
                // The current step should already have an Id.
                Verify.NotNull(step.State?.Id);

                localStep =
                    new LocalStep(step, this._kernel)
                    {
                        ParentProcessId = this.Id,
                        EventProxy = this.EventProxy
                    };
            }

            this._steps.Add(localStep);
        }
    }

    /// <summary>
    /// Initializes this process as a step within another process.
    /// </summary>
    /// <returns>A <see cref="ValueTask"/></returns>
    /// <exception cref="KernelException"></exception>
    protected override ValueTask InitializeStepAsync()
    {
        // The process does not need any further initialization as it's already been initialized.
        // Override the base method to prevent it from being called.
        return default;
    }

    private async Task Internal_ExecuteAsync(Kernel? kernel = null, int maxSupersteps = 100, bool keepAlive = true, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
    {
        Kernel localKernel = kernel ?? this._kernel;
        Queue<ProcessMessage> messageChannel = new();

        try
        {
            // 
            await this.EnqueueOnEnterMessagesAsync(messageChannel).ConfigureAwait(false);

            // Run the Pregel algorithm until there are no more messages being sent.
            LocalStep? finalStep = null;
            for (int superstep = 0; superstep < maxSupersteps; superstep++)
            {
                // Check for external events
                this.EnqueueExternalMessages(messageChannel);

                // Get all of the messages that have been sent to the steps within the process and queue them up for processing.
                foreach (var step in this._steps)
                {
                    await this.EnqueueStepMessagesAsync(step, messageChannel).ConfigureAwait(false);
                }

                // Complete the writing side, indicating no more messages in this superstep.
                var messagesToProcess = messageChannel.ToArray();
                messageChannel.Clear();

                // If there are no messages to process, wait for an external event.
                if (messagesToProcess.Length == 0)
                {
                    if (!keepAlive || !await this._externalEventChannel.Reader.WaitToReadAsync(cancellationToken).ConfigureAwait(false))
                    {
                        this._processCancelSource?.Cancel();
                        break;
                    }
                }

                List<Task> messageTasks = [];
                foreach (var message in messagesToProcess)
                {
                    // Check for end condition
                    if (message.DestinationId.Equals(ProcessConstants.EndStepName, StringComparison.OrdinalIgnoreCase))
                    {
                        this._processCancelSource?.Cancel();
                        break;
                    }

                    var destinationStep = this._steps.First(v => v.Id == message.DestinationId);

                    // Send a message to the step
                    messageTasks.Add(destinationStep.HandleMessageAsync(message));
                    finalStep = destinationStep;
                }

                await Task.WhenAll(messageTasks).ConfigureAwait(false);
            }
        }
        catch (Exception ex)
        {
            this._logger?.LogError(ex, "An error occurred while running the process.");
            throw;
        }
        finally
        {
            this._processCancelSource?.Dispose();
            this._processCancelSource = null;
        }

        return;
    }

    private async Task EnqueueEdgesAsync(IEnumerable<KernelProcessEdge> edges, Queue<ProcessMessage> messageChannel, ProcessEvent processEvent)
    {
        bool foundEdge = false;
        List<KernelProcessEdge> defaultConditionedEdges = [];
        foreach (var edge in edges)
        {
            if (edge.Condition.DeclarativeDefinition?.Equals(ProcessConstants.Declarative.DefaultCondition, StringComparison.OrdinalIgnoreCase) ?? false)
            {
                defaultConditionedEdges.Add(edge);
                continue;
            }

            bool isConditionMet = await edge.Condition.Callback(processEvent.ToKernelProcessEvent(), this._processStateManager?.GetState()).ConfigureAwait(false);
            if (!isConditionMet)
            {
                continue;
            }

            // Handle different target types
            if (edge.OutputTarget is KernelProcessStateTarget stateTarget)
            {
                if (this._processStateManager is null)
                {
                    throw new KernelException("The process state manager is not initialized.").Log(this._logger);
                }

                await (this._processStateManager.ReduceAsync((stateType, state) =>
                {
                    var stateJson = JsonDocument.Parse(JsonSerializer.Serialize(state));
                    stateJson = JMESUpdate.UpdateState(stateJson, stateTarget.VariableUpdate.Path, stateTarget.VariableUpdate.Operation, stateTarget.VariableUpdate.Value);
                    return Task.FromResult(stateJson.Deserialize(stateType));
                })).ConfigureAwait(false);
            }
            else if (edge.OutputTarget is KernelProcessEmitTarget emitTarget)
            {
                // Emit target from process
            }
            else if (edge.OutputTarget is KernelProcessFunctionTarget functionTarget)
            {
                ProcessMessage message = ProcessMessageFactory.CreateFromEdge(edge, processEvent.SourceId, processEvent.Data);
                messageChannel.Enqueue(message);
            }
            else if (edge.OutputTarget is KernelProcessAgentInvokeTarget agentInvokeTarget)
            {
                ProcessMessage message = ProcessMessageFactory.CreateFromEdge(edge, processEvent.SourceId, processEvent.Data);
                messageChannel.Enqueue(message);
            }
            else
            {
                throw new KernelException("Failed to process edge type.");
            }

            foundEdge = true;
        }

        // If no edges were found for the event, check if there are any default conditioned edges to process.
        if (!foundEdge && defaultConditionedEdges.Count > 0)
        {
            foreach (KernelProcessEdge edge in defaultConditionedEdges)
            {
                ProcessMessage message = ProcessMessageFactory.CreateFromEdge(edge, this._process.State.Id!, null, null);
                messageChannel.Enqueue(message);

                // TODO: Handle state here as well
            }
        }

        // Error event was raised with no edge to handle it, send it to an edge defined as the global error target.
        if (!foundEdge && processEvent.IsError)
        {
            if (this._outputEdges.TryGetValue(ProcessConstants.GlobalErrorEventId, out List<KernelProcessEdge>? errorEdges))
            {
                foreach (KernelProcessEdge edge in errorEdges)
                {
                    ProcessMessage message = ProcessMessageFactory.CreateFromEdge(edge, processEvent.SourceId, processEvent.Data);
                    messageChannel.Enqueue(message);
                }
            }
        }
    }

    private async Task EnqueueOnEnterMessagesAsync(Queue<ProcessMessage> messageChannel)
    {
        // TODO: Process edges for the OnProcessStart event
        foreach (var kvp in this._process.Edges.Where(e => e.Key.EndsWith(ProcessConstants.Declarative.OnEnterEvent, StringComparison.OrdinalIgnoreCase)))
        {
            var processEvent = new ProcessEvent
            {
                Namespace = this.Name,
                SourceId = this._process.State.Id!,
                Data = null,
                Visibility = KernelProcessEventVisibility.Internal
            };

            await this.EnqueueEdgesAsync(kvp.Value, messageChannel, processEvent).ConfigureAwait(false);
        }
    }

    /// <summary>
    /// Processes external events that have been sent to the process, translates them to <see cref="ProcessMessage"/>s, and enqueues
    /// them to the provided message channel so that they can be processed in the next superstep.
    /// </summary>
    /// <param name="messageChannel">The message channel where messages should be enqueued.</param>
    private void EnqueueExternalMessages(Queue<ProcessMessage> messageChannel)
    {
        while (this._externalEventChannel.Reader.TryRead(out var externalEvent))
        {
            if (this._outputEdges.TryGetValue(externalEvent.Id, out List<KernelProcessEdge>? edges) && edges is not null)
            {
                foreach (var edge in edges)
                {
                    ProcessMessage message = ProcessMessageFactory.CreateFromEdge(edge, externalEvent.Id, externalEvent.Data);
                    messageChannel.Enqueue(message);
                }
            }
        }
    }

    /// <summary>
    /// Processes events emitted by the given step in the last superstep, translates them to <see cref="ProcessMessage"/>s, and enqueues
    /// them to the provided message channel so that they can be processed in the next superstep.
    /// </summary>
    /// <param name="step">The step containing outgoing events to process.</param>
    /// <param name="messageChannel">The message channel where messages should be enqueued.</param>
    private async Task EnqueueStepMessagesAsync(LocalStep step, Queue<ProcessMessage> messageChannel)
    {
        var allStepEvents = step.GetAllEvents();
        foreach (ProcessEvent stepEvent in allStepEvents)
        {
            // Emit the event out of the process (this one) if it's visibility is public.
            if (stepEvent.Visibility == KernelProcessEventVisibility.Public)
            {
                base.EmitEvent(stepEvent);
            }

            await this.EnqueueEdgesAsync(step.GetEdgeForEvent(stepEvent.QualifiedId), messageChannel, stepEvent).ConfigureAwait(false);

            //// Get the edges for the event and queue up the messages to be sent to the next steps.
            //bool foundEdge = false;
            //List<KernelProcessEdge> defaultConditionedEdges = [];
            //foreach (KernelProcessEdge edge in step.GetEdgeForEvent(stepEvent.QualifiedId))
            //{
            //    // TODO: Make this not a string comparison
            //    // Save default conditions for the end
            //    if (edge.Condition.DeclarativeDefinition?.Equals(ProcessConstants.Declarative.DefaultCondition, StringComparison.OrdinalIgnoreCase) ?? false)
            //    {
            //        defaultConditionedEdges.Add(edge);
            //        continue;
            //    }

            //    bool isConditionMet = await edge.Condition.Callback(stepEvent.ToKernelProcessEvent(), this._processStateManager?.GetState()).ConfigureAwait(false);
            //    if (!isConditionMet)
            //    {
            //        continue;
            //    }

            //    // Handle different target types
            //    if (edge.OutputTarget is KernelProcessStateTarget stateTarget)
            //    {
            //        // TODO: Update state
            //    }
            //    else if (edge.OutputTarget is KernelProcessEmitTarget emitTarget)
            //    {
            //        // Emit target from process
            //    }
            //    else if (edge.OutputTarget is KernelProcessFunctionTarget functionTarget)
            //    {
            //        ProcessMessage message = ProcessMessageFactory.CreateFromEdge(edge, stepEvent.SourceId, stepEvent.Data, stepEvent.WrittenToThread);
            //        messageChannel.Enqueue(message);
            //    }
            //    else
            //    {
            //        throw new KernelException("Failed to process edge type.");
            //    }

            //    foundEdge = true;
            //}

            //// If no edges were found for the event, check if there are any default conditioned edges to process.
            //if (!foundEdge && defaultConditionedEdges.Count > 0)
            //{
            //    foreach (KernelProcessEdge edge in defaultConditionedEdges)
            //    {
            //        ProcessMessage message = ProcessMessageFactory.CreateFromEdge(edge, stepEvent.SourceId, stepEvent.Data, stepEvent.WrittenToThread);
            //        messageChannel.Enqueue(message);

            //        // TODO: Handle state here as well
            //    }
            //}

            //// Error event was raised with no edge to handle it, send it to an edge defined as the global error target.
            //if (!foundEdge && stepEvent.IsError)
            //{
            //    if (this._outputEdges.TryGetValue(ProcessConstants.GlobalErrorEventId, out List<KernelProcessEdge>? edges))
            //    {
            //        foreach (KernelProcessEdge edge in edges)
            //        {
            //            ProcessMessage message = ProcessMessageFactory.CreateFromEdge(edge, stepEvent.SourceId, stepEvent.Data);
            //            messageChannel.Enqueue(message);
            //        }
            //    }
            //}
        }
    }

    /// <summary>
    /// Builds a <see cref="KernelProcess"/> from the current <see cref="LocalProcess"/>.
    /// </summary>
    /// <returns>An instance of <see cref="KernelProcess"/></returns>
    /// <exception cref="InvalidOperationException"></exception>
    private async Task<KernelProcess> ToKernelProcessAsync()
    {
        var processState = new KernelProcessState(this.Name, this._stepState.Version, this.Id);
        var stepTasks = this._steps.Select(step => step.ToKernelProcessStepInfoAsync()).ToList();
        var steps = await Task.WhenAll(stepTasks).ConfigureAwait(false);
        return new KernelProcess(processState, steps, this._outputEdges, this._process.Threads);
    }

    /// <summary>
    /// When the process is used as a step within another process, this method will be called
    /// rather than ToKernelProcessAsync when extracting the state.
    /// </summary>
    /// <returns>A <see cref="Task{T}"/> where T is <see cref="KernelProcess"/></returns>
    internal override async Task<KernelProcessStepInfo> ToKernelProcessStepInfoAsync()
    {
        return await this.ToKernelProcessAsync().ConfigureAwait(false);
    }

    #endregion

    /// <inheritdoc/>
    public override async Task DeinitializeStepAsync()
    {
        await this.DisposeAsync().ConfigureAwait(false);
    }

    public async ValueTask DisposeAsync()
    {
        this._externalEventChannel.Writer.Complete();
        this._joinableTaskContext.Dispose();
        foreach (var step in this._steps)
        {
            await step.DeinitializeStepAsync().ConfigureAwait(false);
        }
        this._processCancelSource?.Dispose();
    }
}


===== Process.LocalRuntime\LocalProxy.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.SemanticKernel.Process;
using Microsoft.SemanticKernel.Process.Internal;
using Microsoft.SemanticKernel.Process.Runtime;

namespace Microsoft.SemanticKernel;

internal sealed class LocalProxy : LocalStep
{
    private readonly KernelProcessProxy _proxy;
    private readonly ILogger _logger;

    private bool _isInitialized = false;

    /// <summary>
    /// Initializes a new instance of the <see cref="LocalMap"/> class.
    /// </summary>
    /// <param name="proxy">an instance of <see cref="KernelProcessProxy"/></param>
    /// <param name="kernel">An instance of <see cref="Kernel"/></param>
    internal LocalProxy(KernelProcessProxy proxy, Kernel kernel)
        : base(proxy, kernel)
    {
        this._proxy = proxy;
        this._logger = this._kernel.LoggerFactory?.CreateLogger(this._proxy.State.Name) ?? new NullLogger<LocalStep>();
    }

    internal override void AssignStepFunctionParameterValues(ProcessMessage message)
    {
        if (this._functions is null || this._inputs is null || this._initialInputs is null)
        {
            throw new KernelException("The step has not been initialized.").Log(this._logger);
        }

        if (message.Values.Count != 1)
        {
            throw new KernelException("The proxy step can only handle 1 parameter object").Log(this._logger);
        }

        var kvp = message.Values.Single();

        if (this._inputs.TryGetValue(message.FunctionName, out Dictionary<string, object?>? functionName) && functionName != null && functionName.TryGetValue(kvp.Key, out object? parameterName) && parameterName != null)
        {
            this._logger.LogWarning("Step {StepName} already has input for {FunctionName}.{Key}, it is being overwritten with a message from Step named '{SourceId}'.", this.Name, message.FunctionName, kvp.Key, message.SourceId);
        }

        if (!this._inputs.TryGetValue(message.FunctionName, out Dictionary<string, object?>? functionParameters))
        {
            this._inputs[message.FunctionName] = [];
            functionParameters = this._inputs[message.FunctionName];
        }

        if (this._proxy.ProxyMetadata != null && message.SourceEventId != null && this._proxy.ProxyMetadata.EventMetadata.TryGetValue(message.SourceEventId, out var metadata) && metadata != null)
        {
            functionParameters![kvp.Key] = KernelProcessProxyMessageFactory.CreateProxyMessage(this.ParentProcessId!, message.SourceEventId, metadata.TopicName, kvp.Value);
        }
    }

    /// <inheritdoc/>
    protected override async ValueTask InitializeStepAsync()
    {
        if (this._isInitialized)
        {
            return;
        }

        // Ensure initialization happens only once if first time or again if "deinitialization" was called
        if (this.ExternalMessageChannel == null)
        {
            throw new KernelException("No IExternalKernelProcessMessageChannel found, need at least 1 to emit external messages");
        }

        await this.ExternalMessageChannel.Initialize().ConfigureAwait(false);
        await base.InitializeStepAsync().ConfigureAwait(false);
        this._isInitialized = true;
    }

    /// <summary>
    /// Deinitialization of the Proxy Step, calling <see cref="KernelProxyStep.DeactivateAsync(KernelProcessStepExternalContext)"/>
    /// </summary>
    /// <returns></returns>
    public override async Task DeinitializeStepAsync()
    {
        MethodInfo? derivedMethod = this._stepInfo.InnerStepType.GetMethod(
            nameof(KernelProxyStep.DeactivateAsync),
            BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance,
            binder: null,
            types: [typeof(KernelProcessStepExternalContext)],
            modifiers: null);

        if (derivedMethod != null && this._stepInstance != null)
        {
            var context = new KernelProcessStepExternalContext(this.ExternalMessageChannel);
            ValueTask deactivateTask =
                (ValueTask?)derivedMethod.Invoke(this._stepInstance, [context]) ??
                throw new KernelException($"The derived DeactivateAsync method failed to complete for step {this.Name}.").Log(this._logger);

            await deactivateTask.ConfigureAwait(false);
        }
    }
}


===== Process.LocalRuntime\LocalStep.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Threading.Tasks;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.SemanticKernel.Process.Internal;
using Microsoft.SemanticKernel.Process.Runtime;

namespace Microsoft.SemanticKernel;

/// <summary>
/// Represents a step in a process that is running in-process.
/// </summary>
internal class LocalStep : IKernelProcessMessageChannel
{
    private readonly Queue<ProcessEvent> _outgoingEventQueue = new();
    protected readonly Lazy<ValueTask> _initializeTask;
    private readonly ILogger _logger;

    protected readonly Kernel _kernel;
    protected readonly Dictionary<string, KernelFunction> _functions = [];
    private readonly Dictionary<string, LocalEdgeGroupProcessor> _edgeGroupProcessors = [];

    protected KernelProcessStepState _stepState;
    protected Dictionary<string, Dictionary<string, object?>?>? _inputs = [];
    protected Dictionary<string, Dictionary<string, object?>?>? _initialInputs = [];
    protected Dictionary<string, List<KernelProcessEdge>> _outputEdges;

    internal KernelProcessStep? _stepInstance = null;
    internal readonly KernelProcessStepInfo _stepInfo;
    internal readonly string _eventNamespace;

    /// <summary>
    /// Represents a step in a process that is running in-process.
    /// </summary>
    /// <param name="stepInfo">An instance of <see cref="KernelProcessStepInfo"/></param>
    /// <param name="kernel">Required. An instance of <see cref="Kernel"/>.</param>
    /// <param name="parentProcessId">Optional. The Id of the parent process if one exists.</param>
    public LocalStep(KernelProcessStepInfo stepInfo, Kernel kernel, string? parentProcessId = null)
    {
        Verify.NotNull(kernel, nameof(kernel));
        Verify.NotNull(stepInfo, nameof(stepInfo));

        // This special handling will be removed with the refactoring of KernelProcessState
        if (string.IsNullOrEmpty(stepInfo.State.Id) && stepInfo is KernelProcess)
        {
            stepInfo = stepInfo with { State = stepInfo.State with { Id = Guid.NewGuid().ToString() } };
        }

        Verify.NotNull(stepInfo.State.Id);

        this.ParentProcessId = parentProcessId;
        this._kernel = kernel;
        this._stepInfo = stepInfo;
        this._stepState = stepInfo.State;
        this._initializeTask = new Lazy<ValueTask>(this.InitializeStepAsync);
        this._logger = this._kernel.LoggerFactory?.CreateLogger(this._stepInfo.InnerStepType) ?? new NullLogger<LocalStep>();
        this._outputEdges = this._stepInfo.Edges.ToDictionary(kvp => kvp.Key, kvp => kvp.Value.ToList());
        this._eventNamespace = this.Id;
        this._edgeGroupProcessors = this._stepInfo.IncomingEdgeGroups?.ToDictionary(kvp => kvp.Key, kvp => new LocalEdgeGroupProcessor(kvp.Value)) ?? [];
    }

    /// <summary>
    /// The Id of the parent process if one exists.
    /// </summary>
    internal string? ParentProcessId { get; init; }

    /// <summary>
    /// The name of the step.
    /// </summary>
    internal string Name => this._stepInfo.State.Name!;

    /// <summary>
    /// The Id of the step.
    /// </summary>
    internal string Id => this._stepInfo.State.Id!;

    /// <summary>
    /// An event proxy that can be used to intercept events emitted by the step.
    /// </summary>
    internal ProcessEventProxy? EventProxy { get; init; }

    internal IExternalKernelProcessMessageChannel? ExternalMessageChannel { get; init; }

    /// <summary>
    /// Retrieves all events that have been emitted by this step in the previous superstep.
    /// </summary>
    /// <returns>An <see cref="IEnumerable{T}"/> where T is <see cref="KernelProcessEvent"/></returns>
    internal IEnumerable<ProcessEvent> GetAllEvents()
    {
        var allEvents = this._outgoingEventQueue.ToArray();
        this._outgoingEventQueue.Clear();
        return allEvents;
    }

    /// <summary>
    /// Retrieves all edges that are associated with the provided event Id.
    /// </summary>
    /// <param name="eventId">The event Id of interest.</param>
    /// <returns>A <see cref="IEnumerable{T}"/> where T is <see cref="KernelProcessEdge"/></returns>
    internal IEnumerable<KernelProcessEdge> GetEdgeForEvent(string eventId)
    {
        if (this._outputEdges is null)
        {
            return [];
        }

        if (this._outputEdges.TryGetValue(eventId, out List<KernelProcessEdge>? edges) && edges is not null)
        {
            return edges;
        }

        return [];
    }

    /// <summary>
    /// Emits an event from the step.
    /// </summary>
    /// <param name="processEvent">The event to emit.</param>
    /// <returns>A <see cref="ValueTask"/></returns>
    public ValueTask EmitEventAsync(KernelProcessEvent processEvent)
    {
        Verify.NotNullOrWhiteSpace(processEvent.Id, $"{nameof(processEvent)}.{nameof(KernelProcessEvent.Id)}");

        ProcessEvent emitEvent = ProcessEvent.Create(processEvent, this._eventNamespace);
        if (this.EventProxy?.Invoke(emitEvent) ?? true)
        {
            this.EmitEvent(emitEvent);
        }

        return default;
    }

    internal virtual void AssignStepFunctionParameterValues(ProcessMessage message)
    {
        if (this._functions is null || this._inputs is null || this._initialInputs is null)
        {
            throw new KernelException("The step has not been initialized.").Log(this._logger);
        }

        // Add the message values to the inputs for the function
        foreach (var kvp in message.Values)
        {
            if (this._inputs.TryGetValue(message.FunctionName, out Dictionary<string, object?>? functionName) && functionName != null && functionName.TryGetValue(kvp.Key, out object? parameterName) && parameterName != null)
            {
                this._logger.LogWarning("Step {StepName} already has input for {FunctionName}.{Key}, it is being overwritten with a message from Step named '{SourceId}'.", this.Name, message.FunctionName, kvp.Key, message.SourceId);
            }

            if (!this._inputs.TryGetValue(message.FunctionName, out Dictionary<string, object?>? functionParameters))
            {
                this._inputs[message.FunctionName] = [];
                functionParameters = this._inputs[message.FunctionName];
            }

            if (kvp.Value is KernelProcessEventData proxyData)
            {
                functionParameters![kvp.Key] = proxyData.ToObject();
            }
            else
            {
                functionParameters![kvp.Key] = kvp.Value;
            }
        }
    }

    /// <summary>
    /// Handles a <see cref="ProcessMessage"/> that has been sent to the step.
    /// </summary>
    /// <param name="message">The message to process.</param>
    /// <returns>A <see cref="Task"/></returns>
    /// <exception cref="KernelException"></exception>
    internal virtual async Task HandleMessageAsync(ProcessMessage message)
    {
        Verify.NotNull(message, nameof(message));

        // Lazy one-time initialization of the step before processing a message
        await this._initializeTask.Value.ConfigureAwait(false);

        if (this._functions is null || this._inputs is null || this._initialInputs is null)
        {
            throw new KernelException("The step has not been initialized.").Log(this._logger);
        }

        string messageLogParameters = string.Join(", ", message.Values.Select(kvp => $"{kvp.Key}: {kvp.Value}"));
        this._logger.LogDebug("Received message from '{SourceId}' targeting function '{FunctionName}' and parameters '{Parameters}'.", message.SourceId, message.FunctionName, messageLogParameters);

        if (!string.IsNullOrEmpty(message.GroupId))
        {
            this._logger.LogDebug("Step {StepName} received message from Step named '{SourceId}' with group Id '{GroupId}'.", this.Name, message.SourceId, message.GroupId);
            if (!this._edgeGroupProcessors.TryGetValue(message.GroupId, out LocalEdgeGroupProcessor? edgeGroupProcessor) || edgeGroupProcessor is null)
            {
                throw new KernelException($"Step {this.Name} received message from Step named '{message.SourceId}' with group Id '{message.GroupId}' that is not registered.").Log(this._logger);
            }

            if (!edgeGroupProcessor.TryGetResult(message, out Dictionary<string, object?>? result))
            {
                // The edge group processor has not received all required messages yet.
                return;
            }

            // The edge group processor has received all required messages and has produced a result.
            message = message with { Values = result ?? [] };
        }

        // Add the message values to the inputs for the function
        this.AssignStepFunctionParameterValues(message);

        // If we're still waiting for inputs on all of our functions then don't do anything.
        List<string> invocableFunctions = this._inputs.Where(i => i.Value != null && i.Value.All(v => v.Value != null)).Select(i => i.Key).ToList();
        var missingKeys = this._inputs.Where(i => i.Value is null || i.Value.Any(v => v.Value is null));

        if (invocableFunctions.Count == 0)
        {
            string missingKeysLog() => string.Join(", ", missingKeys.Select(k => $"{k.Key}: {string.Join(", ", k.Value?.Where(v => v.Value == null).Select(v => v.Key) ?? [])}"));
            this._logger.LogDebug("No invocable functions, missing keys: {MissingKeys}", missingKeysLog());
            return;
        }

        // A message can only target one function and should not result in a different function being invoked.
        var targetFunction = invocableFunctions.FirstOrDefault((name) => name == message.FunctionName) ??
            throw new InvalidOperationException($"A message targeting function '{message.FunctionName}' has resulted in a function named '{invocableFunctions.First()}' becoming invocable. Are the function names configured correctly?");

        this._logger.LogDebug("Step with Id `{StepId}` received all required input for function [{TargetFunction}] and is executing.", this.Name, targetFunction);

        // Concat all the inputs and run the function
        KernelArguments arguments = new(this._inputs[targetFunction]!);
        if (!this._functions.TryGetValue(targetFunction, out KernelFunction? function) || function == null)
        {
            throw new ArgumentException($"Function {targetFunction} not found in plugin {this.Name}");
        }

        // Invoke the function, catching all exceptions that it may throw, and then post the appropriate event.
#pragma warning disable CA1031 // Do not catch general exception types
        try
        {
            // TODO: Process edges for the OnStepEnter event: This feels like a good use for filters in the non-declarative version

            FunctionResult invokeResult = await this.InvokeFunction(function, this._kernel, arguments).ConfigureAwait(false);
            this.EmitEvent(
                ProcessEvent.Create(
                    invokeResult.GetValue<object>(),
                    this._eventNamespace,
                    sourceId: $"{targetFunction}.OnResult",
                    eventVisibility: KernelProcessEventVisibility.Public));

            // TODO: Process edges for the OnStepExit event: This feels like a good use for filters in the non-declarative version
        }
        catch (Exception ex)
        {
            this._logger.LogError(ex, "Error in Step {StepName}: {ErrorMessage}", this.Name, ex.Message);
            this.EmitEvent(
                ProcessEvent.Create(
                    KernelProcessError.FromException(ex),
                    this._eventNamespace,
                    sourceId: $"{targetFunction}.OnError",
                    eventVisibility: KernelProcessEventVisibility.Public,
                    isError: true));
        }
        finally
        {
            // Reset the inputs for the function that was just executed
            this._inputs[targetFunction] = new(this._initialInputs[targetFunction] ?? []);
        }
#pragma warning restore CA1031 // Do not catch general exception types
    }

    /// <summary>
    /// Initializes the step with the provided step information.
    /// </summary>
    /// <returns>A <see cref="ValueTask"/></returns>
    /// <exception cref="KernelException"></exception>
    protected virtual async ValueTask InitializeStepAsync()
    {
        // Instantiate an instance of the inner step object
        this._stepInstance = (KernelProcessStep)ActivatorUtilities.CreateInstance(this._kernel.Services, this._stepInfo.InnerStepType);
        var kernelPlugin = KernelPluginFactory.CreateFromObject(this._stepInstance, pluginName: this._stepInfo.State.Name);

        // Load the kernel functions
        foreach (KernelFunction f in kernelPlugin)
        {
            this._functions.Add(f.Name, f);
        }

        // Initialize the input channels
        if (this._stepInfo is KernelProcessAgentStep agentStep)
        {
            this._initialInputs = this.FindInputChannels(this._functions, this._logger, this.ExternalMessageChannel, agentStep.AgentDefinition);
        }
        else
        {
            this._initialInputs = this.FindInputChannels(this._functions, this._logger, this.ExternalMessageChannel);
        }

        this._inputs = this._initialInputs.ToDictionary(kvp => kvp.Key, kvp => kvp.Value?.ToDictionary(kvp => kvp.Key, kvp => kvp.Value));

        // Activate the step with user-defined state if needed
        Type stateType = this._stepInfo.InnerStepType.ExtractStateType(out Type? userStateType, this._logger);
        KernelProcessStepState stateObject = this._stepInfo.State;
        stateObject.InitializeUserState(stateType, userStateType);

        if (stateObject is null)
        {
            throw new KernelException("The state object for the KernelProcessStep could not be created.").Log(this._logger);
        }

        MethodInfo methodInfo =
            this._stepInfo.InnerStepType.GetMethod(nameof(KernelProcessStep.ActivateAsync), [stateType]) ??
            throw new KernelException("The ActivateAsync method for the KernelProcessStep could not be found.").Log(this._logger);

        this._stepState = stateObject;

        ValueTask activateTask =
            (ValueTask?)methodInfo.Invoke(this._stepInstance, [stateObject]) ??
            throw new KernelException("The ActivateAsync method failed to complete.").Log(this._logger);

        await this._stepInstance.ActivateAsync(stateObject).ConfigureAwait(false);
        await activateTask.ConfigureAwait(false);
    }

    /// <summary>
    /// Deinitializes the step
    /// </summary>
    public virtual Task DeinitializeStepAsync()
    {
        this._logger.LogInformation("Step {Name} has deinitialized", this.Name);
        return Task.CompletedTask;
    }

    /// <summary>
    /// Invokes the provides function with the provided kernel and arguments.
    /// </summary>
    /// <param name="function">The function to invoke.</param>
    /// <param name="kernel">The kernel to use for invocation.</param>
    /// <param name="arguments">The arguments to invoke with.</param>
    /// <returns>A <see cref="Task"/> containing the result of the function invocation.</returns>
    internal Task<FunctionResult> InvokeFunction(KernelFunction function, Kernel kernel, KernelArguments arguments)
    {
        return kernel.InvokeAsync(function, arguments: arguments);
    }

    /// <summary>
    /// Extracts the current state of the step and returns it as a <see cref="KernelProcessStepInfo"/>.
    /// </summary>
    /// <returns>An instance of <see cref="KernelProcessStepInfo"/></returns>
    internal virtual async Task<KernelProcessStepInfo> ToKernelProcessStepInfoAsync()
    {
        // Lazy one-time initialization of the step before extracting state information.
        // This allows state information to be extracted even if the step has not been activated.
        await this._initializeTask.Value.ConfigureAwait(false);

        KernelProcessStepInfo stepInfo = new(this._stepInfo.InnerStepType, this._stepState!, this._outputEdges);
        return stepInfo;
    }

    /// <summary>
    /// Emits an event from the step.
    /// </summary>
    /// <param name="localEvent">The event to emit.</param>
    protected void EmitEvent(ProcessEvent localEvent)
    {
        var scopedEvent = this.ScopedEvent(localEvent);
        this._outgoingEventQueue.Enqueue(scopedEvent);
    }

    /// <summary>
    /// Generates a scoped event for the step.
    /// </summary>
    /// <param name="localEvent">The event.</param>
    /// <returns>A <see cref="ProcessEvent"/> with the correctly scoped namespace.</returns>
    protected ProcessEvent ScopedEvent(ProcessEvent localEvent)
    {
        Verify.NotNull(localEvent, nameof(localEvent));
        return localEvent with { Namespace = this.Id };
    }
}


===== Process.Runtime.Dapr.UnitTests\KernelProcessEventSerializationTests.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.Collections.Generic;
using System.IO;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Process.Runtime;
using Microsoft.SemanticKernel.Process.Serialization;
using Xunit;

namespace SemanticKernel.Process.Dapr.Runtime.UnitTests;

/// <summary>
/// Unit tests for the <see cref="ProcessEvent"/> class.
/// </summary>
public class KernelProcessEventSerializationTests
{
    /// <summary>
    /// Validates that a <see cref="KernelProcessEvent"/> can be serialized and deserialized correctly
    /// with out an explicit type definition for <see cref="KernelProcessEvent.Data"/>
    /// </summary>
    [Fact]
    public void VerifySerializeEventSingleTest()
    {
        // Arrange, Act & Assert
        VerifyContainerSerialization([new() { Id = "Test", Data = 3 }]);
        VerifyContainerSerialization([new() { Id = "Test", Data = "test" }]);
        VerifyContainerSerialization([new() { Id = "Test", Data = Guid.NewGuid() }]);
        VerifyContainerSerialization([new() { Id = "Test", Data = new int[] { 1, 2, 3, 4 } }]);
        VerifyContainerSerialization([new() { Id = "Test", Data = new ComplexData { Id = "test", Value = 3 } }]);
        VerifyContainerSerialization([new() { Id = "testid", Data = KernelProcessError.FromException(new InvalidOperationException()) }]);
    }

    /// <summary>
    /// Validates that a list <see cref="KernelProcessEvent"/> can be serialized and deserialized correctly
    /// with out varying types assigned to for <see cref="KernelProcessEvent.Data"/>
    /// </summary>
    [Fact]
    public void VerifySerializeEventMixedTest()
    {
        // Arrange, Act & Assert
        VerifyContainerSerialization(
            [
                new() { Id = "Test", Data = 3 },
                new() { Id = "Test", Data = "test" },
                new() { Id = "Test", Data = Guid.NewGuid() },
                new() { Id = "Test", Data = new int[] { 1, 2, 3, 4 } },
                new() { Id = "Test", Data = new ComplexData { Id = "test", Value = 3 } },
                new() { Id = "testid", Data = KernelProcessError.FromException(new InvalidOperationException()) },
            ]);
    }

    /// <summary>
    /// Validates that a list <see cref="KernelProcessEvent"/> can be serialized and deserialized correctly
    /// with out varying types assigned to for <see cref="KernelProcessEvent.Data"/>
    /// </summary>
    [Fact]
    public void VerifyDataContractSerializationTest()
    {
        // Arrange
        KernelProcessEvent[] processEvents =
            [
                new() { Id = "Test", Data = 3 },
                new() { Id = "Test", Data = "test" },
                new() { Id = "Test", Data = Guid.NewGuid() },
                new() { Id = "Test", Data = new int[] { 1, 2, 3, 4 } },
                new() { Id = "Test", Data = new ComplexData { Id = "test", Value = 3 } },
                new() { Id = "testid", Data = KernelProcessError.FromException(new InvalidOperationException()) },
            ];
        List<string> jsonEvents = [];
        foreach (KernelProcessEvent processEvent in processEvents)
        {
            jsonEvents.Add(KernelProcessEventSerializer.ToJson(processEvent));
        }

        // Act
        using MemoryStream stream = new();
        jsonEvents.Serialize(stream);
        stream.Position = 0;

        List<string>? copy = stream.Deserialize<List<string>>();

        // Assert
        Assert.NotNull(copy);

        // Act
        IList<KernelProcessEvent> copiedEvents = KernelProcessEventSerializer.ToKernelProcessEvents(jsonEvents);

        // Assert
        Assert.Equivalent(processEvents, copiedEvents);
    }

    private static void VerifyContainerSerialization(KernelProcessEvent[] processEvents)
    {
        // Arrange
        List<string> jsonEvents = [];
        foreach (KernelProcessEvent processEvent in processEvents)
        {
            jsonEvents.Add(KernelProcessEventSerializer.ToJson(processEvent));
        }

        // Act
        IList<KernelProcessEvent> copiedEvents = KernelProcessEventSerializer.ToKernelProcessEvents(jsonEvents);

        // Assert
        Assert.Equivalent(processEvents, copiedEvents);
    }

    internal sealed class ComplexData
    {
        public string Id { get; init; } = string.Empty;

        public int Value { get; init; }
    }
}


===== Process.Runtime.Dapr.UnitTests\ProcessEventSerializationTests.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.Collections.Generic;
using System.IO;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Process.Runtime;
using Microsoft.SemanticKernel.Process.Serialization;
using Xunit;

namespace SemanticKernel.Process.Dapr.Runtime.UnitTests;

/// <summary>
/// Unit tests for the <see cref="ProcessEvent"/> class.
/// </summary>
public class ProcessEventSerializationTests
{
    /// <summary>
    /// Validates that a <see cref="ProcessEvent"/> can be serialized and deserialized correctly
    /// with out an explicit type definition for <see cref="ProcessEvent.Data"/>
    /// </summary>
    [Fact]
    public void VerifySerializeEventSingleTest()
    {
        // Arrange, Act & Assert
        VerifyContainerSerialization([new() { Namespace = "testname", SourceId = "testid", Data = 3 }]);
        VerifyContainerSerialization([new() { Namespace = "testname", SourceId = "testid", Data = "test" }]);
        VerifyContainerSerialization([new() { Namespace = "testname", SourceId = "testid", Data = Guid.NewGuid() }]);
        VerifyContainerSerialization([new() { Namespace = "testname", SourceId = "testid", Data = new int[] { 1, 2, 3, 4 } }]);
        VerifyContainerSerialization([new() { Namespace = "testname", SourceId = "testid", Data = new ComplexData { Value = 3 } }]);
        VerifyContainerSerialization([new() { Namespace = "testname", SourceId = "testid", Data = KernelProcessError.FromException(new InvalidOperationException()) }]);
    }

    /// <summary>
    /// Validates that a list <see cref="ProcessEvent"/> can be serialized and deserialized correctly
    /// with out varying types assigned to for <see cref="ProcessEvent.Data"/>
    /// </summary>
    [Fact]
    public void VerifySerializeEventMixedTest()
    {
        // Arrange, Act & Assert
        VerifyContainerSerialization(
            [
                new() { Namespace = "testname", SourceId = "testid", Data = 3 },
                new() { Namespace = "testname", SourceId = "testid", Data = "test" },
                new() { Namespace = "testname", SourceId = "testid", Data = Guid.NewGuid() },
                new() { Namespace = "testname", SourceId = "testid", Data = new int[] { 1, 2, 3, 4 } },
                new() { Namespace = "testname", SourceId = "testid", Data = new ComplexData { Value = 3 } },
                new() { Namespace = "testname", SourceId = "testid", Data = KernelProcessError.FromException(new InvalidOperationException()) },
            ]);
    }

    /// <summary>
    /// Validates that a list <see cref="ProcessEvent"/> can be serialized and deserialized correctly
    /// with out varying types assigned to for <see cref="ProcessEvent.Data"/>
    /// </summary>
    [Fact]
    public void VerifyDataContractSerializationTest()
    {
        // Arrange
        ProcessEvent[] processEvents =
            [
                new() { Namespace = "testname", SourceId = "testid", Data = 3 },
                new() { Namespace = "testname", SourceId = "testid", Data = "test" },
                new() { Namespace = "testname", SourceId = "testid", Data = Guid.NewGuid() },
                new() { Namespace = "testname", SourceId = "testid", Data = new int[] { 1, 2, 3, 4 } },
                new() { Namespace = "testname", SourceId = "testid", Data = new ComplexData { Value = 3 } },
                new() { Namespace = "testname", SourceId = "testid", Data = KernelProcessError.FromException(new InvalidOperationException()) },
            ];
        List<string> jsonEvents = [];
        foreach (ProcessEvent processEvent in processEvents)
        {
            jsonEvents.Add(ProcessEventSerializer.ToJson(processEvent));
        }

        // Act
        using MemoryStream stream = new();
        jsonEvents.Serialize(stream);
        stream.Position = 0;

        List<string>? copy = stream.Deserialize<List<string>>();

        // Assert
        Assert.NotNull(copy);

        // Act
        IList<ProcessEvent> copiedEvents = ProcessEventSerializer.ToProcessEvents(jsonEvents);

        // Assert
        Assert.Equivalent(processEvents, copiedEvents);
    }

    private static void VerifyContainerSerialization(ProcessEvent[] processEvents)
    {
        // Arrange
        List<string> jsonEvents = [];
        foreach (ProcessEvent processEvent in processEvents)
        {
            jsonEvents.Add(ProcessEventSerializer.ToJson(processEvent));
        }

        // Act
        IList<ProcessEvent> copiedEvents = ProcessEventSerializer.ToProcessEvents(jsonEvents);

        // Assert
        Assert.Equivalent(processEvents, copiedEvents);
    }

    internal sealed class ComplexData
    {
        public string Id { get; init; } = string.Empty;

        public int Value { get; init; }
    }
}


===== Process.Runtime.Dapr.UnitTests\ProcessMessageSerializationTests.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.Collections.Generic;
using System.IO;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Process.Runtime;
using Microsoft.SemanticKernel.Process.Serialization;
using Xunit;

namespace SemanticKernel.Process.Dapr.Runtime.UnitTests;

/// <summary>
/// Unit tests for the <see cref="ProcessMessage"/> class.
/// </summary>
public class ProcessMessageSerializationTests
{
    /// <summary>
    /// Validates that a <see cref="ProcessMessage"/> can be serialized and deserialized correctly
    /// with out an explicit type definition for <see cref="ProcessMessage.Values"/>
    /// </summary>
    [Fact]
    public void VerifySerializeMessageSingleTest()
    {
        // Arrange, Act & Assert
        VerifyContainerSerialization([CreateMessage(new() { { "Data", 3 } })]);
        VerifyContainerSerialization([CreateMessage(new() { { "Data", "test" } })]);
        VerifyContainerSerialization([CreateMessage(new() { { "Data", Guid.NewGuid() } })]);
        VerifyContainerSerialization([CreateMessage(new() { { "Data", new int[] { 1, 2, 3, 4 } } })]);
        VerifyContainerSerialization([CreateMessage(new() { { "Data", new ComplexData { Value = 3 } } })]);
        VerifyContainerSerialization([CreateMessage(new() { { "Data", KernelProcessError.FromException(new InvalidOperationException()) } })]);
    }

    /// <summary>
    /// Validates that a list <see cref="ProcessEvent"/> can be serialized and deserialized correctly
    /// with out varying types assigned to for <see cref="ProcessMessage.Values"/>
    /// </summary>
    [Fact]
    public void VerifySerializeMessageMixedTest()
    {
        // Arrange, Act & Assert
        VerifyContainerSerialization(
            [
                CreateMessage(new() { { "Data", 3 } }),
                CreateMessage(new() { { "Data", "test" } }),
                CreateMessage(new() { { "Data", Guid.NewGuid() } }),
                CreateMessage(new() { { "Data", new int[] { 1, 2, 3, 4 } } }),
                CreateMessage(new() { { "Data", new ComplexData { Value = 3 } } }),
                CreateMessage(new() { { "Data", KernelProcessError.FromException(new InvalidOperationException()) } }),
            ]);
    }

    /// <summary>
    /// Validates that a list <see cref="ProcessEvent"/> can be serialized and deserialized correctly
    /// with out varying types assigned to for <see cref="ProcessMessage.Values"/>
    /// </summary>
    [Fact]
    public void VerifySerializeMessageManyTest()
    {
        // Arrange, Act & Assert
        VerifyContainerSerialization(
            [
                CreateMessage(new() {
                    { "Data1", 3 },
                    { "Data2", "test" },
                    { "Data3", Guid.NewGuid() },
                    { "Data4", new int[] { 1, 2, 3, 4 } },
                    { "Data5", new ComplexData { Value = 3 } },
                    { "Data6", KernelProcessError.FromException(new InvalidOperationException()) } })
            ]);
    }

    /// <summary>
    /// Validates that a list <see cref="ProcessMessage"/> can be serialized and deserialized correctly
    /// with out varying types assigned to for <see cref="ProcessMessage.Values"/>
    /// </summary>
    [Fact]
    public void VerifyDataContractSerializationTest()
    {
        // Arrange
        ProcessMessage[] processMessages =
            [
                CreateMessage(new() { { "Data", 3 } }),
                CreateMessage(new() { { "Data", "test" } }),
                CreateMessage(new() { { "Data", Guid.NewGuid() } }),
                CreateMessage(new() { { "Data", new int[] { 1, 2, 3, 4 } } }),
                CreateMessage(new() { { "Data", new ComplexData { Value = 3 } } }),
                CreateMessage(new() { { "Data", KernelProcessError.FromException(new InvalidOperationException()) } }),
            ];
        List<string> jsonEvents = [];
        foreach (ProcessMessage processMessage in processMessages)
        {
            jsonEvents.Add(ProcessMessageSerializer.ToJson(processMessage));
        }

        // Act
        using MemoryStream stream = new();
        jsonEvents.Serialize(stream);
        stream.Position = 0;

        List<string>? copy = stream.Deserialize<List<string>>();

        // Assert
        Assert.NotNull(copy);

        // Act
        IList<ProcessMessage> copiedEvents = ProcessMessageSerializer.ToProcessMessages(jsonEvents);

        // Assert
        Assert.Equivalent(processMessages, copiedEvents);
    }

    private static void VerifyContainerSerialization(ProcessMessage[] processMessages)
    {
        // Arrange
        List<string> jsonEvents = [];
        foreach (ProcessMessage processMessage in processMessages)
        {
            jsonEvents.Add(ProcessMessageSerializer.ToJson(processMessage));
        }

        // Act
        IList<ProcessMessage> copiedEvents = ProcessMessageSerializer.ToProcessMessages(jsonEvents);

        // Assert
        Assert.Equivalent(processMessages, copiedEvents);
    }

    private static ProcessMessage CreateMessage(Dictionary<string, object?> values)
    {
        return new ProcessMessage("test-source", "test-destination", "test-function", values)
        {
            TargetEventData = "testdata",
            TargetEventId = "targetevent",
        };
    }

    internal sealed class ComplexData
    {
        public string Id { get; init; } = string.Empty;

        public int Value { get; init; }
    }
}


===== Process.Runtime.Dapr.UnitTests\TestSerializer.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Xml;

namespace SemanticKernel.Process.Dapr.Runtime.UnitTests;

internal static class TestSerializer
{
    public static void Serialize<T>(this T obj, Stream stream) where T : class
    {
        DataContractSerializer serializer = new(obj.GetType());
        using XmlDictionaryWriter writer = XmlDictionaryWriter.CreateTextWriter(stream, Encoding.Default, ownsStream: false);
        serializer.WriteObject(writer, obj);
        writer.Flush();
    }

    public static T? Deserialize<T>(this Stream stream)
    {
        DataContractSerializer serializer = new(typeof(T));
        stream.Position = 0;
        return (T?)serializer.ReadObject(stream);
    }
}


===== Process.Runtime.Dapr\Actors\ActorStateKeys.cs =====

// Copyright (c) Microsoft. All rights reserved.

namespace Microsoft.SemanticKernel;

/// <summary>
/// State keys utilized by DAPR actor classes.
/// </summary>
internal static class ActorStateKeys
{
    // Shared Actor keys
    public const string StepParentProcessId = "parentProcessId";

    // StepActor keys
    public const string StepInfoState = nameof(DaprStepInfo);
    public const string StepStateJson = "kernelStepStateJson";
    public const string StepStateType = "kernelStepStateType";
    public const string StepIncomingMessagesState = "incomingMessagesState";

    // MapActor keys
    public const string MapInfoState = nameof(DaprMapInfo);

    // ProcessActor keys
    public const string ProcessInfoState = nameof(DaprProcessInfo);
    public const string EventProxyStepId = "processEventProxyId";
    public const string StepActivatedState = "kernelStepActivated";

    // MessageBufferActor keys
    public const string MessageQueueState = "DaprMessageBufferState";

    // ExternalEventBufferActor keys
    public const string ExternalEventQueueState = "DaprExternalEventBufferState";

    // EventBufferActor keys
    public const string EventQueueState = "DaprEventBufferState";
}


===== Process.Runtime.Dapr\Actors\EventBufferActor.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Threading.Tasks;
using Dapr.Actors.Runtime;
using Microsoft.SemanticKernel.Process.Runtime;

namespace Microsoft.SemanticKernel;

/// <summary>
/// An actor that represents an event queue.
/// </summary>
internal class EventBufferActor : Actor, IEventBuffer
{
    private List<string> _queue = [];

    /// <summary>
    /// Required constructor for Dapr Actor.
    /// </summary>
    /// <param name="host">The actor host.</param>
    public EventBufferActor(ActorHost host) : base(host)
    {
    }

    /// <summary>
    /// Dequeues an event.
    /// </summary>
    /// <returns>A <see cref="List{T}"/> where T is <see cref="ProcessEvent"/></returns>
    public async Task<IList<string>> DequeueAllAsync()
    {
        // Dequeue and clear the queue.
        string[] items = [.. this._queue];
        this._queue.Clear();

        // Save the state.
        await this.StateManager.SetStateAsync(ActorStateKeys.EventQueueState, this._queue).ConfigureAwait(false);
        await this.StateManager.SaveStateAsync().ConfigureAwait(false);

        return items;
    }

    public async Task EnqueueAsync(string stepEvent)
    {
        this._queue.Add(stepEvent);

        // Save the state.
        await this.StateManager.SetStateAsync(ActorStateKeys.EventQueueState, this._queue).ConfigureAwait(false);
        await this.StateManager.SaveStateAsync().ConfigureAwait(false);
    }

    /// <summary>
    /// Called when the actor is activated. Used to initialize the state of the actor.
    /// </summary>
    /// <returns>A <see cref="Task"/></returns>
    protected override async Task OnActivateAsync()
    {
        var eventQueueState = await this.StateManager.TryGetStateAsync<List<string>>(ActorStateKeys.EventQueueState).ConfigureAwait(false);
        if (eventQueueState.HasValue)
        {
            this._queue = eventQueueState.Value;
        }
        else
        {
            this._queue = [];
        }
    }
}


===== Process.Runtime.Dapr\Actors\ExternalEventBufferActor.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Threading.Tasks;
using Dapr.Actors.Runtime;
using Microsoft.SemanticKernel.Process.Runtime;

namespace Microsoft.SemanticKernel;

/// <summary>
/// An actor that represents an external event queue.
/// </summary>
internal class ExternalEventBufferActor : Actor, IExternalEventBuffer
{
    private List<string> _queue = [];

    /// <summary>
    /// Required constructor for Dapr Actor.
    /// </summary>
    /// <param name="host">The actor host.</param>
    public ExternalEventBufferActor(ActorHost host) : base(host)
    {
    }

    /// <summary>
    /// Dequeues an event.
    /// </summary>
    /// <returns>A <see cref="List{T}"/> where T is <see cref="ProcessEvent"/></returns>
    public async Task<IList<string>> DequeueAllAsync()
    {
        // Dequeue and clear the queue.
        string[] items = [.. this._queue];
        this._queue!.Clear();

        // Save the state.
        await this.StateManager.SetStateAsync(ActorStateKeys.ExternalEventQueueState, this._queue).ConfigureAwait(false);
        await this.StateManager.SaveStateAsync().ConfigureAwait(false);

        return items;
    }

    public async Task EnqueueAsync(string externalEvent)
    {
        this._queue.Add(externalEvent);

        // Save the state.
        await this.StateManager.SetStateAsync(ActorStateKeys.ExternalEventQueueState, this._queue).ConfigureAwait(false);
        await this.StateManager.SaveStateAsync().ConfigureAwait(false);
    }

    /// <summary>
    /// Called when the actor is activated. Used to initialize the state of the actor.
    /// </summary>
    /// <returns>A <see cref="Task"/></returns>
    protected override async Task OnActivateAsync()
    {
        var eventQueueState = await this.StateManager.TryGetStateAsync<List<string>>(ActorStateKeys.ExternalEventQueueState).ConfigureAwait(false);
        if (eventQueueState.HasValue)
        {
            this._queue = [.. eventQueueState.Value];
        }
        else
        {
            this._queue = [];
        }
    }
}


===== Process.Runtime.Dapr\Actors\ExternalMessageBufferActor.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Threading.Tasks;
using Dapr.Actors.Runtime;

namespace Microsoft.SemanticKernel;

/// <summary>
/// An actor that represents en external event messaging buffer.
/// </summary>
internal sealed class ExternalMessageBufferActor : Actor, IExternalMessageBuffer
{
    private readonly IExternalKernelProcessMessageChannel _externalMessageChannel;

    /// <summary>
    /// Required constructor for Dapr Actor.
    /// </summary>
    /// <param name="host">The actor host.</param>
    /// <param name="externalMessageChannel">Instance of <see cref="IExternalKernelProcessMessageChannel"/></param>
    public ExternalMessageBufferActor(ActorHost host, IExternalKernelProcessMessageChannel externalMessageChannel) : base(host)
    {
        this._externalMessageChannel = externalMessageChannel;
    }

    public async Task EmitExternalEventAsync(string externalTopicEvent, KernelProcessProxyMessage eventData)
    {
        await this._externalMessageChannel.EmitExternalEventAsync(externalTopicEvent, eventData).ConfigureAwait(false);
    }

    protected override async Task OnDeactivateAsync()
    {
        await this._externalMessageChannel.Uninitialize().ConfigureAwait(false);
    }

    protected override async Task OnActivateAsync()
    {
        await this._externalMessageChannel.Initialize().ConfigureAwait(false);
    }
}


===== Process.Runtime.Dapr\Actors\ExternalMessageBufferActorWrapper.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Runtime.Serialization;
using System.Threading.Tasks;

namespace Microsoft.SemanticKernel;

/// <summary>
/// Class used to allow using <see cref="IExternalEventBuffer"/> as <see cref="IExternalKernelProcessMessageChannel"/>
/// in SK Process shared abstractions
/// </summary>
[KnownType(typeof(KernelProcessProxyMessage))]
public class ExternalMessageBufferActorWrapper : IExternalKernelProcessMessageChannel
{
    private readonly IExternalMessageBuffer _actor;

    /// <summary>
    /// Constructor to wrap <see cref="IExternalMessageBuffer"/> as <see cref="IExternalKernelProcessMessageChannel"/>
    /// </summary>
    /// <param name="actor">The actor host.</param>
    public ExternalMessageBufferActorWrapper(IExternalMessageBuffer actor)
    {
        this._actor = actor;
    }

    /// <inheritdoc cref="IExternalMessageBuffer.EmitExternalEventAsync(string, KernelProcessProxyMessage)"/>
    public async Task EmitExternalEventAsync(string externalTopicEvent, KernelProcessProxyMessage message)
    {
        await this._actor.EmitExternalEventAsync(externalTopicEvent, message).ConfigureAwait(false);
    }

    /// <inheritdoc/>
    public ValueTask Initialize()
    {
        // When using Dapr initialization is already taken care of by Dapr Actors
        throw new System.NotImplementedException();
    }

    /// <inheritdoc/>
    public ValueTask Uninitialize()
    {
        // When using Dapr uninitialization is already taken care of by Dapr Actors
        throw new System.NotImplementedException();
    }
}


===== Process.Runtime.Dapr\Actors\MapActor.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Dapr.Actors.Runtime;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.SemanticKernel.Process.Internal;
using Microsoft.SemanticKernel.Process.Runtime;
using Microsoft.SemanticKernel.Process.Serialization;

namespace Microsoft.SemanticKernel;

internal sealed class MapActor : StepActor, IMap
{
    private const string DaprProcessMapStateName = nameof(DaprMapInfo);

    private bool _isInitialized;
    private HashSet<string> _mapEvents = [];
    private ILogger? _logger;
    private KernelProcessMap? _map;

    internal DaprMapInfo? _mapInfo;

    /// <summary>
    /// Initializes a new instance of the <see cref="MapActor"/> class.
    /// </summary>
    /// <param name="host">The Dapr host actor</param>
    /// <param name="kernel">An instance of <see cref="Kernel"/></param>
    public MapActor(ActorHost host, Kernel kernel)
        : base(host, kernel)
    {
    }

    #region Public Actor Methods

    public async Task InitializeMapAsync(DaprMapInfo mapInfo, string? parentProcessId)
    {
        // Only initialize once. This check is required as the actor can be re-activated from persisted state and
        // this should not result in multiple initializations.
        if (this._isInitialized)
        {
            return;
        }

        this.InitializeMapActor(mapInfo, parentProcessId);

        this._isInitialized = true;

        // Save the state
        await this.StateManager.AddStateAsync(DaprProcessMapStateName, mapInfo).ConfigureAwait(false);
        await this.StateManager.AddStateAsync(ActorStateKeys.StepParentProcessId, parentProcessId).ConfigureAwait(false);
        await this.StateManager.SaveStateAsync().ConfigureAwait(false);
    }

    /// <summary>
    /// When the process is used as a step within another process, this method will be called
    /// rather than ToKernelProcessAsync when extracting the state.
    /// </summary>
    /// <returns>A <see cref="Task{T}"/> where T is <see cref="KernelProcess"/></returns>
    public override Task<DaprStepInfo> ToDaprStepInfoAsync() => Task.FromResult<DaprStepInfo>(this._mapInfo!);

    protected override async Task OnActivateAsync()
    {
        var existingMapInfo = await this.StateManager.TryGetStateAsync<DaprMapInfo>(DaprProcessMapStateName).ConfigureAwait(false);
        if (existingMapInfo.HasValue)
        {
            this.ParentProcessId = await this.StateManager.GetStateAsync<string>(ActorStateKeys.StepParentProcessId).ConfigureAwait(false);
            this.InitializeMapActor(existingMapInfo.Value, this.ParentProcessId);
        }
    }

    /// <summary>
    /// The name of the step.
    /// </summary>
    protected override string Name => this._mapInfo?.State.Name ?? throw new KernelException("The Map must be initialized before accessing the Name property.");

    #endregion

    /// <summary>
    /// Handles a <see cref="ProcessMessage"/> that has been sent to the map.
    /// </summary>
    /// <param name="message">The message to map.</param>
    internal override async Task HandleMessageAsync(ProcessMessage message)
    {
        // Initialize the current operation
        (IEnumerable inputValues, KernelProcess mapOperation, string startEventId) = this._map!.Initialize(message, this._logger);

        List<Task> mapOperations = [];
        foreach (var value in inputValues)
        {
            KernelProcess mapProcess = mapOperation with { State = mapOperation.State with { Id = $"{this.Name}-{mapOperations.Count}-{Guid.NewGuid():N}" } };
            DaprKernelProcessContext processContext = new(mapProcess);
            Task processTask =
                processContext.StartWithEventAsync(
                    new KernelProcessEvent
                    {
                        Id = startEventId,
                        Data = value
                    },
                    eventProxyStepId: this.Id);

            mapOperations.Add(processTask);
        }

        // Wait for all the map operations to complete
        await Task.WhenAll(mapOperations).ConfigureAwait(false);

        // Retrieve all proxied events from the map operations
        IEventBuffer proxyBuffer = this.ProxyFactory.CreateActorProxy<IEventBuffer>(this.Id, nameof(EventBufferActor));
        IList<string> proxyEvents = await proxyBuffer.DequeueAllAsync().ConfigureAwait(false);
        IList<ProcessEvent> processEvents = proxyEvents.ToProcessEvents();

        // Survey the events to determine the type of the results associated with each event proxied by the map
        Dictionary<string, Type> capturedEvents = [];
        foreach (ProcessEvent processEvent in processEvents)
        {
            string eventName = processEvent.SourceId;
            if (this._mapEvents.Contains(eventName))
            {
                capturedEvents.TryGetValue(eventName, out Type? resultType);
                if (resultType is null || resultType == typeof(object))
                {
                    capturedEvents[eventName] = processEvent.Data?.GetType() ?? typeof(object);
                }
            }
        }

        // Correlate the operation results to emit as the map result
        Dictionary<string, Array> resultMap = [];
        Dictionary<string, int> resultCounts = [];

        foreach (ProcessEvent processEvent in processEvents)
        {
            string eventName = processEvent.SourceId;
            if (capturedEvents.TryGetValue(eventName, out Type? resultType))
            {
                var eventData = processEvent.Data;
                if (resultType == typeof(KernelProcessEventData) && eventData is KernelProcessEventData kernelProcessData)
                {
                    eventData = kernelProcessData.ToObject();
                    resultType = Type.GetType(kernelProcessData.ObjectType);
                }

                if (!resultMap.TryGetValue(eventName, out Array? results))
                {
                    results = Array.CreateInstance(resultType!, mapOperations.Count);
                    resultMap[eventName] = results;
                }

                resultCounts.TryGetValue(eventName, out int resultIndex); // resultIndex defaults to 0 when not found
                results.SetValue(eventData, resultIndex);
                resultCounts[eventName] = resultIndex + 1;
            }
        }

        // Emit map results
        foreach (string eventName in capturedEvents.Keys)
        {
            Array eventResult = resultMap[eventName];
            await this.EmitEventAsync(new KernelProcessEvent() { Id = eventName, Data = eventResult }).ConfigureAwait(false);
        }
    }

    private void InitializeMapActor(DaprMapInfo mapInfo, string? parentProcessId)
    {
        Verify.NotNull(mapInfo);
        Verify.NotNull(mapInfo.Operation);

        this._mapInfo = mapInfo;
        this._map = mapInfo.ToKernelProcessMap();
        this.ParentProcessId = parentProcessId;
        this._logger = this._kernel.LoggerFactory?.CreateLogger(this._mapInfo.State.Name) ?? new NullLogger<MapActor>();
        this._outputEdges = this._mapInfo.Edges.ToDictionary(kvp => kvp.Key, kvp => kvp.Value.ToList());
        this._eventNamespace = $"{this._mapInfo.State.Name}_{this._mapInfo.State.Id}";

        // Capture the events that the map is interested in as hashtable for performant lookup
        this._mapEvents = [.. this._mapInfo.Edges.Keys.Select(key => key.Split(ProcessConstants.EventIdSeparator).Last())];

        this._isInitialized = true;
    }

    private sealed record TypedResult(Type ResultType, Array Results);
}


===== Process.Runtime.Dapr\Actors\MessageBufferActor.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Threading.Tasks;
using Dapr.Actors.Runtime;
using Microsoft.SemanticKernel.Process.Runtime;

namespace Microsoft.SemanticKernel;

/// <summary>
/// An actor that represents an external event queue.
/// </summary>
internal class MessageBufferActor : Actor, IMessageBuffer
{
    private List<string> _queue = [];

    /// <summary>
    /// Required constructor for Dapr Actor.
    /// </summary>
    /// <param name="host">The actor host.</param>
    public MessageBufferActor(ActorHost host) : base(host)
    {
    }

    /// <summary>
    /// Dequeues an event.
    /// </summary>
    /// <returns>A <see cref="List{T}"/> where T is <see cref="ProcessEvent"/></returns>
    public async Task<IList<string>> DequeueAllAsync()
    {
        // Dequeue and clear the queue.
        string[] items = [.. this._queue];
        this._queue.Clear();

        // Save the state.
        await this.StateManager.SetStateAsync(ActorStateKeys.MessageQueueState, this._queue).ConfigureAwait(false);
        await this.StateManager.SaveStateAsync().ConfigureAwait(false);

        return items;
    }

    public async Task EnqueueAsync(string message)
    {
        this._queue.Add(message);

        // Save the state.
        await this.StateManager.SetStateAsync(ActorStateKeys.MessageQueueState, this._queue).ConfigureAwait(false);
        await this.StateManager.SaveStateAsync().ConfigureAwait(false);
    }

    /// <summary>
    /// Called when the actor is activated. Used to initialize the state of the actor.
    /// </summary>
    /// <returns>A <see cref="Task"/></returns>
    protected override async Task OnActivateAsync()
    {
        var eventQueueState = await this.StateManager.TryGetStateAsync<List<string>>(ActorStateKeys.MessageQueueState).ConfigureAwait(false);
        if (eventQueueState.HasValue)
        {
            this._queue = eventQueueState.Value;
        }
        else
        {
            this._queue = [];
        }
    }
}


===== Process.Runtime.Dapr\Actors\ProcessActor.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Channels;
using System.Threading.Tasks;
using Dapr.Actors;
using Dapr.Actors.Runtime;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.SemanticKernel.Process.Internal;
using Microsoft.SemanticKernel.Process.Runtime;
using Microsoft.SemanticKernel.Process.Serialization;
using Microsoft.VisualStudio.Threading;

namespace Microsoft.SemanticKernel;

internal sealed class ProcessActor : StepActor, IProcess, IDisposable
{
    private readonly JoinableTaskFactory _joinableTaskFactory;
    private readonly JoinableTaskContext _joinableTaskContext;
    private readonly Channel<KernelProcessEvent> _externalEventChannel;

    internal readonly List<IStep> _steps = [];

    internal IList<DaprStepInfo>? _stepsInfos;
    internal DaprProcessInfo? _process;
    private JoinableTask? _processTask;
    private CancellationTokenSource? _processCancelSource;
    private bool _isInitialized;
    private ILogger? _logger;

    /// <summary>
    /// Initializes a new instance of the <see cref="ProcessActor"/> class.
    /// </summary>
    /// <param name="host">The Dapr host actor</param>
    /// <param name="kernel">An instance of <see cref="Kernel"/></param>
    public ProcessActor(ActorHost host, Kernel kernel)
        : base(host, kernel)
    {
        this._externalEventChannel = Channel.CreateUnbounded<KernelProcessEvent>();
        this._joinableTaskContext = new JoinableTaskContext();
        this._joinableTaskFactory = new JoinableTaskFactory(this._joinableTaskContext);
    }

    #region Public Actor Methods

    public async Task InitializeProcessAsync(DaprProcessInfo processInfo, string? parentProcessId, string? eventProxyStepId = null)
    {
        Verify.NotNull(processInfo);
        Verify.NotNull(processInfo.Steps);

        // Only initialize once. This check is required as the actor can be re-activated from persisted state and
        // this should not result in multiple initializations.
        if (this._isInitialized)
        {
            return;
        }

        // Initialize the process
        await this.InitializeProcessActorAsync(processInfo, parentProcessId, eventProxyStepId).ConfigureAwait(false);

        // Save the state
        await this.StateManager.AddStateAsync(ActorStateKeys.ProcessInfoState, processInfo).ConfigureAwait(false);
        await this.StateManager.AddStateAsync(ActorStateKeys.StepParentProcessId, parentProcessId).ConfigureAwait(false);
        await this.StateManager.AddStateAsync(ActorStateKeys.StepActivatedState, true).ConfigureAwait(false);
        if (!string.IsNullOrWhiteSpace(eventProxyStepId))
        {
            await this.StateManager.AddStateAsync(ActorStateKeys.EventProxyStepId, eventProxyStepId).ConfigureAwait(false);
        }
        await this.StateManager.SaveStateAsync().ConfigureAwait(false);
    }

    /// <summary>
    /// Starts the process with an initial event and an optional kernel.
    /// </summary>
    /// <param name="keepAlive">Indicates if the process should wait for external events after it's finished processing.</param>
    /// <returns> <see cref="Task"/></returns>
    public Task StartAsync(bool keepAlive)
    {
        if (!this._isInitialized)
        {
            throw new InvalidOperationException("The process cannot be started before it has been initialized.").Log(this._logger);
        }

        this._processCancelSource = new CancellationTokenSource();
        this._processTask = this._joinableTaskFactory.RunAsync(()
            => this.Internal_ExecuteAsync(keepAlive: keepAlive, cancellationToken: this._processCancelSource.Token));

        return Task.CompletedTask;
    }

    /// <summary>
    /// Starts the process with an initial event and then waits for the process to finish. In this case the process will not
    /// keep alive waiting for external events after the internal messages have stopped.
    /// </summary>
    /// <param name="processEvent">Required. The <see cref="KernelProcessEvent"/> to start the process with.</param>
    /// <returns>A <see cref="Task"/></returns>
    public async Task RunOnceAsync(string processEvent)
    {
        Verify.NotNull(processEvent, nameof(processEvent));
        IExternalEventBuffer externalEventQueue = this.ProxyFactory.CreateActorProxy<IExternalEventBuffer>(new ActorId(this.Id.GetId()), nameof(ExternalEventBufferActor));
        await externalEventQueue.EnqueueAsync(processEvent).ConfigureAwait(false);
        await this.StartAsync(keepAlive: false).ConfigureAwait(false);
        await this._processTask!.JoinAsync().ConfigureAwait(false);
    }

    /// <summary>
    /// Stops a running process. This will cancel the process and wait for it to complete before returning.
    /// </summary>
    /// <returns>A <see cref="Task"/></returns>
    public async Task StopAsync()
    {
        if (this._processTask is null || this._processCancelSource is null || this._processTask.IsCompleted)
        {
            return;
        }

        // Cancel the process and wait for it to complete.
        this._processCancelSource.Cancel();

        try
        {
            await this._processTask;
        }
        catch (OperationCanceledException)
        {
            // The task was cancelled, so we can ignore this exception.
        }
        finally
        {
            this._processCancelSource.Dispose();
        }
    }

    /// <summary>
    /// Sends a message to the process. This does not start the process if it's not already running, in
    /// this case the message will remain queued until the process is started.
    /// </summary>
    /// <param name="processEvent">Required. The <see cref="KernelProcessEvent"/> to start the process with.</param>
    /// <returns>A <see cref="Task"/></returns>
    public async Task SendMessageAsync(string processEvent)
    {
        Verify.NotNull(processEvent, nameof(processEvent));
        await this._externalEventChannel.Writer.WriteAsync(processEvent.ToKernelProcessEvent()).ConfigureAwait(false);
    }

    /// <summary>
    /// Gets the process information.
    /// </summary>
    /// <returns>An instance of <see cref="KernelProcess"/></returns>
    public async Task<DaprProcessInfo> GetProcessInfoAsync()
    {
        return await this.ToDaprProcessInfoAsync().ConfigureAwait(false);
    }

    /// <summary>
    /// When the process is used as a step within another process, this method will be called
    /// rather than ToKernelProcessAsync when extracting the state.
    /// </summary>
    /// <returns>A <see cref="Task{DaprStepInfo}"/></returns>
    public override async Task<DaprStepInfo> ToDaprStepInfoAsync()
    {
        return await this.ToDaprProcessInfoAsync().ConfigureAwait(false);
    }

    protected override async Task OnActivateAsync()
    {
        var existingProcessInfo = await this.StateManager.TryGetStateAsync<DaprProcessInfo>(ActorStateKeys.ProcessInfoState).ConfigureAwait(false);
        if (existingProcessInfo.HasValue)
        {
            this.ParentProcessId = await this.StateManager.GetStateAsync<string>(ActorStateKeys.StepParentProcessId).ConfigureAwait(false);
            string? eventProxyStepId = null;
            if (await this.StateManager.ContainsStateAsync(ActorStateKeys.EventProxyStepId).ConfigureAwait(false))
            {
                eventProxyStepId = await this.StateManager.GetStateAsync<string>(ActorStateKeys.EventProxyStepId).ConfigureAwait(false);
            }
            await this.InitializeProcessActorAsync(existingProcessInfo.Value, this.ParentProcessId, eventProxyStepId).ConfigureAwait(false);
        }
    }

    /// <summary>
    /// The name of the step.
    /// </summary>
    protected override string Name => this._process?.State.Name ?? throw new KernelException("The Process must be initialized before accessing the Name property.").Log(this._logger);

    #endregion

    /// <summary>
    /// Handles a <see cref="ProcessMessage"/> that has been sent to the process. This happens only in the case
    /// of a process (this one) running as a step within another process (this one's parent). In this case the
    /// entire sub-process should be executed within a single superstep.
    /// </summary>
    /// <param name="message">The message to process.</param>
    internal override async Task HandleMessageAsync(ProcessMessage message)
    {
        if (string.IsNullOrWhiteSpace(message.TargetEventId))
        {
            throw new KernelException("Internal Process Error: The target event id must be specified when sending a message to a step.").Log(this._logger);
        }

        string eventId = message.TargetEventId!;
        if (this._outputEdges!.TryGetValue(eventId, out List<KernelProcessEdge>? edges) && edges is not null)
        {
            foreach (var edge in edges)
            {
                // Create the external event that will be used to start the nested process. Since this event came
                // from outside this processes, we set the visibility to internal so that it's not emitted back out again.
                KernelProcessEvent nestedEvent = new() { Id = eventId, Data = message.TargetEventData };

                // Run the nested process completely within a single superstep.
                await this.RunOnceAsync(nestedEvent.ToJson()).ConfigureAwait(false);
            }
        }
    }

    internal static ActorId GetScopedGlobalErrorEventBufferId(string processId) => new($"{ProcessConstants.GlobalErrorEventId}_{processId}");

    #region Private Methods

    /// <summary>
    /// Initializes this process as a step within another process.
    /// </summary>
    protected override ValueTask ActivateStepAsync()
    {
        // The process does not need any further initialization as it's already been initialized.
        // Override the base method to prevent it from being called.
        return default;
    }

    private async Task InitializeProcessActorAsync(DaprProcessInfo processInfo, string? parentProcessId, string? eventProxyStepId)
    {
        Verify.NotNull(processInfo, nameof(processInfo));
        Verify.NotNull(processInfo.Steps);

        this.ParentProcessId = parentProcessId;
        this._process = processInfo;
        this._stepsInfos = [.. this._process.Steps];
        this._logger = this._kernel.LoggerFactory?.CreateLogger(this._process.State.Name) ?? new NullLogger<ProcessActor>();
        if (!string.IsNullOrWhiteSpace(eventProxyStepId))
        {
            this.EventProxyStepId = new ActorId(eventProxyStepId);
        }

        // Initialize the input and output edges for the process
        this._outputEdges = this._process.Edges.ToDictionary(kvp => kvp.Key, kvp => kvp.Value.ToList());

        // Initialize the steps within this process
        foreach (var step in this._stepsInfos)
        {
            IStep? stepActor = null;

            // The current step should already have a name.
            Verify.NotNull(step.State?.Name);

            if (step is DaprProcessInfo processStep)
            {
                // The process will only have an Id if its already been executed.
                if (string.IsNullOrWhiteSpace(processStep.State.Id))
                {
                    processStep = processStep with { State = processStep.State with { Id = Guid.NewGuid().ToString() } };
                }

                // Initialize the step as a process.
                var scopedProcessId = this.ScopedActorId(new ActorId(processStep.State.Id!));
                var processActor = this.ProxyFactory.CreateActorProxy<IProcess>(scopedProcessId, nameof(ProcessActor));
                await processActor.InitializeProcessAsync(processStep, this.Id.GetId(), eventProxyStepId).ConfigureAwait(false);
                stepActor = this.ProxyFactory.CreateActorProxy<IStep>(scopedProcessId, nameof(ProcessActor));
            }
            else if (step is DaprMapInfo mapStep)
            {
                // Initialize the step as a map.
                ActorId scopedMapId = this.ScopedActorId(new ActorId(mapStep.State.Id!));
                IMap mapActor = this.ProxyFactory.CreateActorProxy<IMap>(scopedMapId, nameof(MapActor));
                await mapActor.InitializeMapAsync(mapStep, this.Id.GetId()).ConfigureAwait(false);
                stepActor = this.ProxyFactory.CreateActorProxy<IStep>(scopedMapId, nameof(MapActor));
            }
            else if (step is DaprProxyInfo proxyStep)
            {
                // Initialize the step as a proxy
                ActorId scopedProxyId = this.ScopedActorId(new ActorId(proxyStep.State.Id!));
                IProxy proxyActor = this.ProxyFactory.CreateActorProxy<IProxy>(scopedProxyId, nameof(ProxyActor));
                await proxyActor.InitializeProxyAsync(proxyStep, this.Id.GetId()).ConfigureAwait(false);
                stepActor = this.ProxyFactory.CreateActorProxy<IStep>(scopedProxyId, nameof(ProxyActor));
            }
            else
            {
                // The current step should already have an Id.
                Verify.NotNull(step.State?.Id);

                var scopedStepId = this.ScopedActorId(new ActorId(step.State.Id!));
                stepActor = this.ProxyFactory.CreateActorProxy<IStep>(scopedStepId, nameof(StepActor));
                await stepActor.InitializeStepAsync(step, this.Id.GetId(), eventProxyStepId).ConfigureAwait(false);
            }

            this._steps.Add(stepActor);
        }

        this._isInitialized = true;
    }

    private async Task Internal_ExecuteAsync(int maxSupersteps = 100, bool keepAlive = true, CancellationToken cancellationToken = default)
    {
        try
        {
            // Run the Pregel algorithm until there are no more messages being sent.
            for (int superstep = 0; superstep < maxSupersteps; superstep++)
            {
                // Check for EndStep messages. If there are any then cancel the process.
                if (await this.IsEndMessageSentAsync().ConfigureAwait(false))
                {
                    this._processCancelSource?.Cancel();
                    break;
                }

                // Translate any global error events into an message that targets the appropriate step, when one exists.
                await this.HandleGlobalErrorMessageAsync().ConfigureAwait(false);

                // Check for external events
                await this.EnqueueExternalMessagesAsync().ConfigureAwait(false);

                // Reach out to all of the steps in the process and instruct them to retrieve their pending messages from their associated queues.
                var stepPreparationTasks = this._steps.Select(step => step.PrepareIncomingMessagesAsync()).ToArray();
                var messageCounts = await Task.WhenAll(stepPreparationTasks).ConfigureAwait(false);

                // If there are no messages to process, wait for an external event or finish.
                if (messageCounts.Sum() == 0)
                {
                    if (!keepAlive || !await this._externalEventChannel.Reader.WaitToReadAsync(cancellationToken).ConfigureAwait(false))
                    {
                        this._processCancelSource?.Cancel();
                        break;
                    }
                }

                // Process the incoming messages for each step.
                var stepProcessingTasks = this._steps.Select(step => step.ProcessIncomingMessagesAsync()).ToArray();
                await Task.WhenAll(stepProcessingTasks).ConfigureAwait(false);

                // Handle public events that need to be bubbled out of the process.
                await this.SendOutgoingPublicEventsAsync().ConfigureAwait(false);
            }
        }
        catch (Exception ex)
        {
            this._logger?.LogError(ex, "An error occurred while running the process: {ErrorMessage}.", ex.Message);
            throw;
        }
        finally
        {
            if (this._processCancelSource?.IsCancellationRequested ?? false)
            {
                this._processCancelSource.Cancel();
            }

            this._processCancelSource?.Dispose();
        }

        return;
    }

    /// <summary>
    /// Processes external events that have been sent to the process, translates them to <see cref="ProcessMessage"/>s, and enqueues
    /// them to the provided message channel so that they can be processed in the next superstep.
    /// </summary>
    private async Task EnqueueExternalMessagesAsync()
    {
        IExternalEventBuffer externalEventQueue = this.ProxyFactory.CreateActorProxy<IExternalEventBuffer>(new ActorId(this.Id.GetId()), nameof(ExternalEventBufferActor));
        IList<string> dequeuedEvents = await externalEventQueue.DequeueAllAsync().ConfigureAwait(false);
        IList<KernelProcessEvent> externalEvents = dequeuedEvents.ToKernelProcessEvents();

        foreach (KernelProcessEvent externalEvent in externalEvents)
        {
            if (this._outputEdges!.TryGetValue(externalEvent.Id!, out List<KernelProcessEdge>? edges) && edges is not null)
            {
                foreach (KernelProcessEdge edge in edges)
                {
                    if (edge.OutputTarget is not KernelProcessFunctionTarget functionTarget)
                    {
                        throw new KernelException("The target for the edge is not a function target.").Log(this._logger);
                    }

                    ProcessMessage message = ProcessMessageFactory.CreateFromEdge(edge, externalEvent.Id, externalEvent.Data);
                    var scopedMessageBufferId = this.ScopedActorId(new ActorId(functionTarget.StepId));
                    var messageQueue = this.ProxyFactory.CreateActorProxy<IMessageBuffer>(scopedMessageBufferId, nameof(MessageBufferActor));
                    await messageQueue.EnqueueAsync(message.ToJson()).ConfigureAwait(false);
                }
            }
        }
    }

    /// <summary>
    /// Check for the presence of an global-error event and any edges defined for processing it.
    /// When both exist, the error event is processed and sent to the appropriate targets.
    /// </summary>
    private async Task HandleGlobalErrorMessageAsync()
    {
        var errorEventQueue = this.ProxyFactory.CreateActorProxy<IEventBuffer>(ProcessActor.GetScopedGlobalErrorEventBufferId(this.Id.GetId()), nameof(EventBufferActor));

        IList<string> errorEvents = await errorEventQueue.DequeueAllAsync().ConfigureAwait(false);
        if (errorEvents.Count == 0)
        {
            // No error events in queue.
            return;
        }

        var errorEdges = this.GetEdgeForEvent(ProcessConstants.GlobalErrorEventId).ToArray();
        if (errorEdges.Length == 0)
        {
            // No further action is required when there are no targetes defined for processing the error.
            return;
        }

        IList<ProcessEvent> processErrorEvents = errorEvents.ToProcessEvents();
        foreach (var errorEdge in errorEdges)
        {
            foreach (ProcessEvent errorEvent in processErrorEvents)
            {
                if (errorEdge.OutputTarget is not KernelProcessFunctionTarget functionTarget)
                {
                    throw new KernelException("The target for the edge is not a function target.").Log(this._logger);
                }
                var errorMessage = ProcessMessageFactory.CreateFromEdge(errorEdge, errorEvent.SourceId, errorEvent.Data);
                var scopedErrorMessageBufferId = this.ScopedActorId(new ActorId(functionTarget.StepId));
                var errorStepQueue = this.ProxyFactory.CreateActorProxy<IMessageBuffer>(scopedErrorMessageBufferId, nameof(MessageBufferActor));
                await errorStepQueue.EnqueueAsync(errorMessage.ToJson()).ConfigureAwait(false);
            }
        }
    }

    /// <summary>
    /// Public events that are produced inside of this process need to be sent to the parent process. This method reads
    /// all of the public events from the event buffer and sends them to the targeted step in the parent process.
    /// </summary>
    private async Task SendOutgoingPublicEventsAsync()
    {
        // Loop through all steps that are processes and call a function requesting their outgoing events, then queue them up.
        if (!string.IsNullOrWhiteSpace(this.ParentProcessId))
        {
            // Handle public events that need to be bubbled out of the process.
            IEventBuffer eventQueue = this.ProxyFactory.CreateActorProxy<IEventBuffer>(new ActorId(this.Id.GetId()), nameof(EventBufferActor));
            IList<string> allEvents = await eventQueue.DequeueAllAsync().ConfigureAwait(false);
            IList<ProcessEvent> processEvents = allEvents.ToProcessEvents();

            foreach (ProcessEvent processEvent in processEvents)
            {
                ProcessEvent scopedEvent = this.ScopedEvent(processEvent);
                if (this._outputEdges!.TryGetValue(scopedEvent.QualifiedId, out List<KernelProcessEdge>? edges) && edges is not null)
                {
                    foreach (var edge in edges)
                    {
                        if (edge.OutputTarget is not KernelProcessFunctionTarget functionTarget)
                        {
                            throw new KernelException("The target for the edge is not a function target.").Log(this._logger);
                        }

                        ProcessMessage message = ProcessMessageFactory.CreateFromEdge(edge, scopedEvent.SourceId, scopedEvent.Data);
                        var scopedMessageBufferId = this.ScopedActorId(new ActorId(functionTarget.StepId), scopeToParent: true);
                        var messageQueue = this.ProxyFactory.CreateActorProxy<IMessageBuffer>(scopedMessageBufferId, nameof(MessageBufferActor));
                        await messageQueue.EnqueueAsync(message.ToJson()).ConfigureAwait(false);
                    }
                }
            }
        }
    }

    /// <summary>
    /// Determines is the end message has been sent to the process.
    /// </summary>
    /// <returns>True if the end message has been sent, otherwise false.</returns>
    private async Task<bool> IsEndMessageSentAsync()
    {
        var scopedMessageBufferId = this.ScopedActorId(new ActorId(ProcessConstants.EndStepName));
        var endMessageQueue = this.ProxyFactory.CreateActorProxy<IMessageBuffer>(scopedMessageBufferId, nameof(MessageBufferActor));
        var messages = await endMessageQueue.DequeueAllAsync().ConfigureAwait(false);
        return messages.Count > 0;
    }

    /// <summary>
    /// Builds a <see cref="DaprProcessInfo"/> from the current <see cref="ProcessActor"/>.
    /// </summary>
    /// <returns>An instance of <see cref="DaprProcessInfo"/></returns>
    /// <exception cref="InvalidOperationException"></exception>
    private async Task<DaprProcessInfo> ToDaprProcessInfoAsync()
    {
        var processState = new KernelProcessState(this.Name, this._process!.State.Version, this.Id.GetId());
        var stepTasks = this._steps.Select(step => step.ToDaprStepInfoAsync()).ToList();
        var steps = await Task.WhenAll(stepTasks).ConfigureAwait(false);
        return new DaprProcessInfo { InnerStepDotnetType = this._process!.InnerStepDotnetType, Edges = this._process!.Edges, State = processState, Steps = [.. steps] };
    }

    /// <summary>
    /// Scopes the Id of a step within the process to the process.
    /// </summary>
    /// <param name="actorId">The actor Id to scope.</param>
    /// <param name="scopeToParent">Indicates if the Id should be scoped to the parent process.</param>
    /// <returns>A new <see cref="ActorId"/> which is scoped to the process.</returns>
    private ActorId ScopedActorId(ActorId actorId, bool scopeToParent = false)
    {
        if (scopeToParent && string.IsNullOrWhiteSpace(this.ParentProcessId))
        {
            throw new InvalidOperationException("The parent process Id must be set before scoping to the parent process.");
        }

        string id = scopeToParent ? this.ParentProcessId! : this.Id.GetId();
        return new ActorId($"{id}.{actorId.GetId()}");
    }

    /// <summary>
    /// Generates a scoped event for the step.
    /// </summary>
    /// <param name="daprEvent">The event.</param>
    /// <returns>A <see cref="ProcessEvent"/> with the correctly scoped namespace.</returns>
    private ProcessEvent ScopedEvent(ProcessEvent daprEvent)
    {
        Verify.NotNull(daprEvent);
        return daprEvent with { Namespace = $"{this.Name}_{this._process!.State.Id}" };
    }

    #endregion

    public void Dispose()
    {
        this._externalEventChannel.Writer.Complete();
        this._joinableTaskContext.Dispose();
        this._joinableTaskContext.Dispose();
        this._processCancelSource?.Dispose();
    }
}


===== Process.Runtime.Dapr\Actors\ProxyActor.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Dapr.Actors;
using Dapr.Actors.Runtime;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.SemanticKernel.Process;
using Microsoft.SemanticKernel.Process.Internal;
using Microsoft.SemanticKernel.Process.Runtime;

namespace Microsoft.SemanticKernel;

internal sealed class ProxyActor : StepActor, IProxy
{
    private readonly ILogger? _logger;

    internal DaprProxyInfo? _daprProxyInfo;

    /// <summary>
    /// Initializes a new instance of the <see cref="ProxyActor"/> class.
    /// </summary>
    /// <param name="host">The Dapr host actor</param>
    /// <param name="kernel">An instance of <see cref="Kernel"/></param>
    public ProxyActor(ActorHost host, Kernel kernel)
        : base(host, kernel)
    {
        this._logger = this._kernel.LoggerFactory?.CreateLogger(typeof(KernelProxyStep)) ?? new NullLogger<ProxyActor>();
    }

    internal override void AssignStepFunctionParameterValues(ProcessMessage message)
    {
        if (this._functions is null || this._inputs is null || this._initialInputs is null)
        {
            throw new KernelException("The step has not been initialized.").Log(this._logger);
        }

        if (message.Values.Count != 1)
        {
            throw new KernelException("The proxy step can only handle 1 parameter object").Log(this._logger);
        }

        // Add the message values to the inputs for the function
        var kvp = message.Values.Single();
        if (this._inputs.TryGetValue(message.FunctionName, out Dictionary<string, object?>? functionName) && functionName != null && functionName.TryGetValue(kvp.Key, out object? parameterName) && parameterName != null)
        {
            this._logger?.LogWarning("Step {StepName} already has input for {FunctionName}.{Key}, it is being overwritten with a message from Step named '{SourceId}'.", this.Name, message.FunctionName, kvp.Key, message.SourceId);
        }

        if (!this._inputs.TryGetValue(message.FunctionName, out Dictionary<string, object?>? functionParameters))
        {
            this._inputs[message.FunctionName] = [];
            functionParameters = this._inputs[message.FunctionName];
        }

        if (this._daprProxyInfo?.ProxyMetadata != null && message.SourceEventId != null && this._daprProxyInfo.ProxyMetadata.EventMetadata.TryGetValue(message.SourceEventId, out var metadata) && metadata != null)
        {
            functionParameters![kvp.Key] = KernelProcessProxyMessageFactory.CreateProxyMessage(this.ParentProcessId!, message.SourceEventId, metadata.TopicName, kvp.Value);
        }
    }

    internal override Dictionary<string, Dictionary<string, object?>?> GenerateInitialInputs()
    {
        // Creating external process channel actor to be used for only by proxy step actor
        IExternalKernelProcessMessageChannel? externalMessageChannelActor = null;
        var scopedExternalMessageBufferId = this.ScopedActorId(new ActorId(this.Id.GetId()));
        IExternalMessageBuffer actor = this.ProxyFactory.CreateActorProxy<IExternalMessageBuffer>(scopedExternalMessageBufferId, nameof(ExternalMessageBufferActor));
        externalMessageChannelActor = new ExternalMessageBufferActorWrapper(actor);

        return this.FindInputChannels(this._functions, this._logger, externalMessageChannelActor);
    }

    public async Task InitializeProxyAsync(DaprProxyInfo proxyInfo, string? parentProcessId)
    {
        this._daprProxyInfo = proxyInfo;

        await base.InitializeStepAsync(proxyInfo, parentProcessId).ConfigureAwait(false);
    }
}


===== Process.Runtime.Dapr\Actors\StepActor.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text.Json;
using System.Threading.Tasks;
using Dapr.Actors;
using Dapr.Actors.Runtime;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.SemanticKernel.Process.Internal;
using Microsoft.SemanticKernel.Process.Runtime;
using Microsoft.SemanticKernel.Process.Serialization;

namespace Microsoft.SemanticKernel;

internal class StepActor : Actor, IStep, IKernelProcessMessageChannel
{
    private readonly Lazy<ValueTask> _activateTask;

    private DaprStepInfo? _stepInfo;
    private ILogger? _logger;
    private Type? _innerStepType;

    private bool _isInitialized;

    protected readonly Kernel _kernel;
    protected string? _eventNamespace;

    internal Queue<ProcessMessage> _incomingMessages = new();
    internal KernelProcessStepState? _stepState;
    internal Type? _stepStateType;
    internal Dictionary<string, List<KernelProcessEdge>>? _outputEdges;
    internal readonly Dictionary<string, KernelFunction> _functions = [];
    internal Dictionary<string, Dictionary<string, object?>?>? _inputs = [];
    internal Dictionary<string, Dictionary<string, object?>?>? _initialInputs = [];

    internal string? ParentProcessId;
    internal ActorId? EventProxyStepId;

    /// <summary>
    /// Represents a step in a process that is running in-process.
    /// </summary>
    /// <param name="host">The host.</param>
    /// <param name="kernel">Required. An instance of <see cref="Kernel"/>.</param>
    public StepActor(ActorHost host, Kernel kernel)
        : base(host)
    {
        this._kernel = kernel;
        this._activateTask = new Lazy<ValueTask>(this.ActivateStepAsync);
    }

    #region Public Actor Methods

    /// <summary>
    /// Initializes the step with the provided step information.
    /// </summary>
    /// <param name="stepInfo">The <see cref="KernelProcessStepInfo"/> instance describing the step.</param>
    /// <param name="parentProcessId">The Id of the parent process if one exists.</param>
    /// <param name="eventProxyStepId">An optional identifier of an actor requesting to proxy events.</param>
    /// <returns>A <see cref="ValueTask"/></returns>
    public async Task InitializeStepAsync(DaprStepInfo stepInfo, string? parentProcessId, string? eventProxyStepId = null)
    {
        Verify.NotNull(stepInfo, nameof(stepInfo));

        // Only initialize once. This check is required as the actor can be re-activated from persisted state and
        // this should not result in multiple initializations.
        if (this._isInitialized)
        {
            return;
        }

        this.InitializeStep(stepInfo, parentProcessId, eventProxyStepId);

        // Save initial state
        await this.StateManager.AddStateAsync(ActorStateKeys.StepInfoState, stepInfo).ConfigureAwait(false);
        await this.StateManager.AddStateAsync(ActorStateKeys.StepParentProcessId, parentProcessId).ConfigureAwait(false);
        if (!string.IsNullOrWhiteSpace(eventProxyStepId))
        {
            await this.StateManager.AddStateAsync(ActorStateKeys.EventProxyStepId, eventProxyStepId).ConfigureAwait(false);
        }
        await this.StateManager.SaveStateAsync().ConfigureAwait(false);
    }

    /// <summary>
    /// Initializes the step with the provided step information.
    /// </summary>
    /// <param name="stepInfo">The <see cref="KernelProcessStepInfo"/> instance describing the step.</param>
    /// <param name="parentProcessId">The Id of the parent process if one exists.</param>
    /// <param name="eventProxyStepId">An optional identifier of an actor requesting to proxy events.</param>
    private void InitializeStep(DaprStepInfo stepInfo, string? parentProcessId, string? eventProxyStepId = null)
    {
        Verify.NotNull(stepInfo, nameof(stepInfo));

        // Attempt to load the inner step type
        this._innerStepType = Type.GetType(stepInfo.InnerStepDotnetType);
        if (this._innerStepType is null)
        {
            throw new KernelException($"Could not load the inner step type '{stepInfo.InnerStepDotnetType}'.").Log(this._logger);
        }

        this.ParentProcessId = parentProcessId;
        this._stepInfo = stepInfo;
        this._stepState = this._stepInfo.State;
        this._logger = this._kernel.LoggerFactory?.CreateLogger(this._innerStepType) ?? new NullLogger<StepActor>();
        this._outputEdges = this._stepInfo.Edges.ToDictionary(kvp => kvp.Key, kvp => kvp.Value.ToList());
        this._eventNamespace = $"{this._stepInfo.State.Name}_{this._stepInfo.State.Id}";

        if (!string.IsNullOrWhiteSpace(eventProxyStepId))
        {
            this.EventProxyStepId = new ActorId(eventProxyStepId);
        }

        this._isInitialized = true;
    }

    /// <summary>
    /// Triggers the step to dequeue all pending messages and prepare for processing.
    /// </summary>
    /// <returns>A <see cref="Task{Task}"/> where T is an <see cref="int"/> indicating the number of messages that are prepared for processing.</returns>
    public async Task<int> PrepareIncomingMessagesAsync()
    {
        IMessageBuffer messageQueue = this.ProxyFactory.CreateActorProxy<IMessageBuffer>(new ActorId(this.Id.GetId()), nameof(MessageBufferActor));
        IList<string> incoming = await messageQueue.DequeueAllAsync().ConfigureAwait(false);
        IList<ProcessMessage> messages = incoming.ToProcessMessages();

        foreach (ProcessMessage message in messages)
        {
            this._incomingMessages.Enqueue(message);
        }

        // Save the incoming messages to state
        await this.StateManager.SetStateAsync(ActorStateKeys.StepIncomingMessagesState, this._incomingMessages).ConfigureAwait(false);
        await this.StateManager.SaveStateAsync().ConfigureAwait(false);

        return this._incomingMessages.Count;
    }

    /// <summary>
    /// Triggers the step to process all prepared messages.
    /// </summary>
    /// <returns>A <see cref="Task"/></returns>
    public async Task ProcessIncomingMessagesAsync()
    {
        // Handle all the incoming messages one at a time
        while (this._incomingMessages.Count > 0)
        {
            var message = this._incomingMessages.Dequeue();
            await this.HandleMessageAsync(message).ConfigureAwait(false);

            // Save the incoming messages to state
            await this.StateManager.SetStateAsync(ActorStateKeys.StepIncomingMessagesState, this._incomingMessages).ConfigureAwait(false);
            await this.StateManager.SaveStateAsync().ConfigureAwait(false);
        }
    }

    /// <summary>
    /// Extracts the current state of the step and returns it as a <see cref="DaprStepInfo"/>.
    /// </summary>
    /// <returns>An instance of <see cref="DaprStepInfo"/></returns>
    public virtual async Task<DaprStepInfo> ToDaprStepInfoAsync()
    {
        // Lazy one-time initialization of the step before extracting state information.
        // This allows state information to be extracted even if the step has not been activated.
        await this._activateTask.Value.ConfigureAwait(false);

        var stepInfo = new DaprStepInfo { InnerStepDotnetType = this._stepInfo!.InnerStepDotnetType!, State = this._stepInfo.State, Edges = this._stepInfo.Edges! };
        return stepInfo;
    }

    /// <summary>
    /// Overrides the base method to initialize the step from persisted state.
    /// </summary>
    /// <returns>A <see cref="Task"/></returns>
    protected override async Task OnActivateAsync()
    {
        var existingStepInfo = await this.StateManager.TryGetStateAsync<DaprStepInfo>(ActorStateKeys.StepInfoState).ConfigureAwait(false);
        if (existingStepInfo.HasValue)
        {
            // Initialize the step from persisted state
            string? parentProcessId = await this.StateManager.GetStateAsync<string>(ActorStateKeys.StepParentProcessId).ConfigureAwait(false);
            string? eventProxyStepId = null;
            if (await this.StateManager.ContainsStateAsync(ActorStateKeys.EventProxyStepId).ConfigureAwait(false))
            {
                eventProxyStepId = await this.StateManager.GetStateAsync<string>(ActorStateKeys.EventProxyStepId).ConfigureAwait(false);
            }
            this.InitializeStep(existingStepInfo.Value, parentProcessId, eventProxyStepId);

            // Load the persisted incoming messages
            var incomingMessages = await this.StateManager.TryGetStateAsync<Queue<ProcessMessage>>(ActorStateKeys.StepIncomingMessagesState).ConfigureAwait(false);
            if (incomingMessages.HasValue)
            {
                this._incomingMessages = incomingMessages.Value;
            }
        }
    }

    #endregion

    /// <summary>
    /// The name of the step.
    /// </summary>
    protected virtual string Name => this._stepInfo?.State.Name ?? throw new KernelException("The Step must be initialized before accessing the Name property.").Log(this._logger);

    /// <summary>
    /// Emits an event from the step.
    /// </summary>
    /// <param name="processEvent">The event to emit.</param>
    /// <returns>A <see cref="ValueTask"/></returns>
    public ValueTask EmitEventAsync(KernelProcessEvent processEvent) => this.EmitEventAsync(ProcessEvent.Create(processEvent, this._eventNamespace!));

    // TODO: this can be moved to shared runtime code, looks almost/same to localRuntime implementation
    internal virtual void AssignStepFunctionParameterValues(ProcessMessage message)
    {
        if (this._functions is null || this._inputs is null || this._initialInputs is null)
        {
            throw new KernelException("The step has not been initialized.").Log(this._logger);
        }

        // Add the message values to the inputs for the function
        foreach (var kvp in message.Values)
        {
            if (this._inputs.TryGetValue(message.FunctionName, out Dictionary<string, object?>? functionName) && functionName != null && functionName.TryGetValue(kvp.Key, out object? parameterName) && parameterName != null)
            {
                this._logger?.LogWarning("Step {StepName} already has input for {FunctionName}.{Key}, it is being overwritten with a message from Step named '{SourceId}'.", this.Name, message.FunctionName, kvp.Key, message.SourceId);
            }

            if (!this._inputs.TryGetValue(message.FunctionName, out Dictionary<string, object?>? functionParameters))
            {
                this._inputs[message.FunctionName] = [];
                functionParameters = this._inputs[message.FunctionName];
            }

            if (kvp.Value is KernelProcessEventData proxyData)
            {
                functionParameters![kvp.Key] = proxyData.ToObject();
            }
            else
            {
                functionParameters![kvp.Key] = kvp.Value;
            }
        }
    }

    /// <summary>
    /// Handles a <see cref="ProcessMessage"/> that has been sent to the step.
    /// </summary>
    /// <param name="message">The message to process.</param>
    /// <returns>A <see cref="Task"/></returns>
    /// <exception cref="KernelException"></exception>
    internal virtual async Task HandleMessageAsync(ProcessMessage message)
    {
        Verify.NotNull(message, nameof(message));

        // Lazy one-time initialization of the step before processing a message
        await this._activateTask.Value.ConfigureAwait(false);

        if (this._functions is null || this._inputs is null || this._initialInputs is null)
        {
            throw new KernelException("The step has not been initialized.").Log(this._logger);
        }

        string messageLogParameters = string.Join(", ", message.Values.Select(kvp => $"{kvp.Key}: {kvp.Value}"));
        this._logger?.LogDebug("Received message from '{SourceId}' targeting function '{FunctionName}' and parameters '{Parameters}'.", message.SourceId, message.FunctionName, messageLogParameters);

        // Add the message values to the inputs for the function
        this.AssignStepFunctionParameterValues(message);

        // If we're still waiting for inputs on all of our functions then don't do anything.
        List<string> invocableFunctions = this._inputs.Where(i => i.Value != null && i.Value.All(v => v.Value != null)).Select(i => i.Key).ToList();
        var missingKeys = this._inputs.Where(i => i.Value is null || i.Value.Any(v => v.Value is null));

        if (invocableFunctions.Count == 0)
        {
            string missingKeysLog() => string.Join(", ", missingKeys.Select(k => $"{k.Key}: {string.Join(", ", k.Value?.Where(v => v.Value == null).Select(v => v.Key) ?? [])}"));
            this._logger?.LogInformation("No invocable functions, missing keys: {MissingKeys}", missingKeysLog());
            return;
        }

        // A message can only target one function and should not result in a different function being invoked.
        var targetFunction = invocableFunctions.FirstOrDefault((name) => name == message.FunctionName) ??
            throw new InvalidOperationException($"A message targeting function '{message.FunctionName}' has resulted in a function named '{invocableFunctions.First()}' becoming invocable. Are the function names configured correctly?").Log(this._logger);

        this._logger?.LogInformation("Step with Id `{StepId}` received all required input for function [{TargetFunction}] and is executing.", this.Name, targetFunction);

        // Concat all the inputs and run the function
        KernelArguments arguments = new(this._inputs[targetFunction]!);
        if (!this._functions.TryGetValue(targetFunction, out KernelFunction? function) || function == null)
        {
            throw new InvalidOperationException($"Function {targetFunction} not found in plugin {this.Name}").Log(this._logger);
        }

        // Invoke the function, catching all exceptions that it may throw, and then post the appropriate event.
#pragma warning disable CA1031 // Do not catch general exception types
        try
        {
            this?._logger?.LogInformation("Invoking function {FunctionName} with arguments {Arguments}", targetFunction, arguments);
            FunctionResult invokeResult = await this.InvokeFunction(function, this._kernel, arguments).ConfigureAwait(false);

            this?.Logger?.LogInformation("Function {FunctionName} returned {Result}", targetFunction, invokeResult);

            // Persist the state after the function has been executed
            var stateJson = JsonSerializer.Serialize(this._stepState, this._stepStateType!);
            await this.StateManager.SetStateAsync(ActorStateKeys.StepStateJson, stateJson).ConfigureAwait(false);
            await this.StateManager.SaveStateAsync().ConfigureAwait(false);

            await this.EmitEventAsync(
                ProcessEvent.Create(
                    invokeResult.GetValue<object>(),
                    this._eventNamespace!,
                    sourceId: $"{targetFunction}.OnResult",
                    eventVisibility: KernelProcessEventVisibility.Public)).ConfigureAwait(false);
        }
        catch (Exception ex)
        {
            this._logger?.LogError(ex, "Error in Step {StepName}: {ErrorMessage}", this.Name, ex.Message);
            await this.EmitEventAsync(
                ProcessEvent.Create(
                    KernelProcessError.FromException(ex),
                    this._eventNamespace!,
                    sourceId: $"{targetFunction}.OnError",
                    eventVisibility: KernelProcessEventVisibility.Public,
                    isError: true)).ConfigureAwait(false);
        }
        finally
        {
            // Reset the inputs for the function that was just executed
            this._inputs[targetFunction] = new(this._initialInputs[targetFunction] ?? []);
        }
#pragma warning restore CA1031 // Do not catch general exception types
    }

    internal virtual Dictionary<string, Dictionary<string, object?>?> GenerateInitialInputs()
    {
        return this.FindInputChannels(this._functions, this._logger);
    }

    /// <summary>
    /// Initializes the step with the provided step information.
    /// </summary>
    /// <returns>A <see cref="ValueTask"/></returns>
    /// <exception cref="KernelException"></exception>
    protected virtual async ValueTask ActivateStepAsync()
    {
        if (this._stepInfo is null)
        {
            throw new KernelException("A step cannot be activated before it has been initialized.").Log(this._logger);
        }

        // Instantiate an instance of the inner step object
        KernelProcessStep stepInstance = (KernelProcessStep)ActivatorUtilities.CreateInstance(this._kernel.Services, this._innerStepType!);
        var kernelPlugin = KernelPluginFactory.CreateFromObject(stepInstance, pluginName: this._stepInfo.State.Name);

        // Load the kernel functions
        foreach (KernelFunction f in kernelPlugin)
        {
            this._functions.Add(f.Name, f);
        }

        // Initialize the input channels
        this._initialInputs = this.GenerateInitialInputs();
        this._inputs = this._initialInputs.ToDictionary(kvp => kvp.Key, kvp => kvp.Value?.ToDictionary(kvp => kvp.Key, kvp => kvp.Value));

        // Activate the step with user-defined state if needed
        KernelProcessStepState? stateObject = null;
        Type? stateType = null;

        // Check if the state has already been persisted
        var stepStateType = await this.StateManager.TryGetStateAsync<string>(ActorStateKeys.StepStateType).ConfigureAwait(false);
        if (stepStateType.HasValue)
        {
            stateType = Type.GetType(stepStateType.Value);
            var stateObjectJson = await this.StateManager.GetStateAsync<string>(ActorStateKeys.StepStateJson).ConfigureAwait(false);
            stateObject = JsonSerializer.Deserialize(stateObjectJson, stateType!) as KernelProcessStepState;
        }
        else
        {
            stateType = this._innerStepType.ExtractStateType(out Type? userStateType, this._logger);
            stateObject = this._stepInfo.State;

            // Persist the state type and type object.
            await this.StateManager.AddStateAsync(ActorStateKeys.StepStateType, stateType.AssemblyQualifiedName).ConfigureAwait(false);
            await this.StateManager.AddStateAsync(ActorStateKeys.StepStateJson, JsonSerializer.Serialize(stateObject)).ConfigureAwait(false);
            await this.StateManager.SaveStateAsync().ConfigureAwait(false);
        }

        if (stateType is null || stateObject is null)
        {
            throw new KernelException("The state object for the KernelProcessStep could not be created.").Log(this._logger);
        }

        MethodInfo? methodInfo =
            this._innerStepType!.GetMethod(nameof(KernelProcessStep.ActivateAsync), [stateType]) ??
            throw new KernelException("The ActivateAsync method for the KernelProcessStep could not be found.").Log(this._logger);

        this._stepState = stateObject;
        this._stepStateType = stateType;

        ValueTask activateTask =
            (ValueTask?)methodInfo.Invoke(stepInstance, [stateObject]) ??
            throw new KernelException("The ActivateAsync method failed to complete.").Log(this._logger);

        await stepInstance.ActivateAsync(stateObject).ConfigureAwait(false);
        await activateTask.ConfigureAwait(false);
    }

    /// <summary>
    /// Invokes the provides function with the provided kernel and arguments.
    /// </summary>
    /// <param name="function">The function to invoke.</param>
    /// <param name="kernel">The kernel to use for invocation.</param>
    /// <param name="arguments">The arguments to invoke with.</param>
    /// <returns>A <see cref="Task"/> containing the result of the function invocation.</returns>
    private Task<FunctionResult> InvokeFunction(KernelFunction function, Kernel kernel, KernelArguments arguments)
    {
        return kernel.InvokeAsync(function, arguments: arguments);
    }

    /// <summary>
    /// Emits an event from the step.
    /// </summary>
    /// <param name="daprEvent">The event to emit.</param>
    internal async ValueTask EmitEventAsync(ProcessEvent daprEvent)
    {
        // Emit the event out of the process (this one) if it's visibility is public.
        if (daprEvent.Visibility == KernelProcessEventVisibility.Public)
        {
            if (this.ParentProcessId is not null)
            {
                // Emit the event to the parent process
                IEventBuffer parentProcess = this.ProxyFactory.CreateActorProxy<IEventBuffer>(new ActorId(this.ParentProcessId), nameof(EventBufferActor));
                await parentProcess.EnqueueAsync(daprEvent.ToJson()).ConfigureAwait(false);
            }
        }

        if (this.EventProxyStepId != null)
        {
            IEventBuffer proxyBuffer = this.ProxyFactory.CreateActorProxy<IEventBuffer>(this.EventProxyStepId, nameof(EventBufferActor));
            await proxyBuffer.EnqueueAsync(daprEvent.ToJson()).ConfigureAwait(false);
        }

        // Get the edges for the event and queue up the messages to be sent to the next steps.
        bool foundEdge = false;
        foreach (KernelProcessEdge edge in this.GetEdgeForEvent(daprEvent.QualifiedId))
        {
            if (edge.OutputTarget is not KernelProcessFunctionTarget functionTarget)
            {
                throw new KernelException("The target for the edge is not a function target.").Log(this._logger);
            }
            ProcessMessage message = ProcessMessageFactory.CreateFromEdge(edge, daprEvent.SourceId, daprEvent.Data);
            ActorId scopedStepId = this.ScopedActorId(new ActorId(functionTarget.StepId));
            IMessageBuffer targetStep = this.ProxyFactory.CreateActorProxy<IMessageBuffer>(scopedStepId, nameof(MessageBufferActor));
            await targetStep.EnqueueAsync(message.ToJson()).ConfigureAwait(false);
            foundEdge = true;
        }

        // Error event was raised with no edge to handle it, send it to the global error event buffer.
        if (!foundEdge && daprEvent.IsError && this.ParentProcessId != null)
        {
            IEventBuffer parentProcess1 = this.ProxyFactory.CreateActorProxy<IEventBuffer>(ProcessActor.GetScopedGlobalErrorEventBufferId(this.ParentProcessId), nameof(EventBufferActor));
            await parentProcess1.EnqueueAsync(daprEvent.ToJson()).ConfigureAwait(false);
        }
    }

    /// <summary>
    /// Scopes the Id of a step within the process to the process.
    /// </summary>
    /// <param name="actorId">The actor Id to scope.</param>
    /// <returns>A new <see cref="ActorId"/> which is scoped to the process.</returns>
    internal ActorId ScopedActorId(ActorId actorId)
    {
        return new ActorId($"{this.ParentProcessId}.{actorId.GetId()}");
    }

    /// <summary>
    /// Retrieves all edges that are associated with the provided event Id.
    /// </summary>
    /// <param name="eventId">The event Id of interest.</param>
    /// <returns>A <see cref="IEnumerable{T}"/> where T is <see cref="KernelProcessEdge"/></returns>
    internal IEnumerable<KernelProcessEdge> GetEdgeForEvent(string eventId)
    {
        if (this._outputEdges is null)
        {
            return [];
        }

        if (this._outputEdges.TryGetValue(eventId, out List<KernelProcessEdge>? edges) && edges is not null)
        {
            return edges;
        }

        return [];
    }
}


===== Process.Runtime.Dapr\AssemblyInfo.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Diagnostics.CodeAnalysis;

// This assembly is currently experimental.
[assembly: Experimental("SKEXP0080")]


===== Process.Runtime.Dapr\DaprKernelProcessContext.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Threading.Tasks;
using Dapr.Actors;
using Dapr.Actors.Client;
using Microsoft.SemanticKernel.Process;
using Microsoft.SemanticKernel.Process.Serialization;

namespace Microsoft.SemanticKernel;

/// <summary>
/// A context for a Dapr kernel process.
/// </summary>
public class DaprKernelProcessContext : KernelProcessContext
{
    private readonly IProcess _daprProcess;
    private readonly KernelProcess _process;

    internal DaprKernelProcessContext(KernelProcess process, IActorProxyFactory? actorProxyFactory = null)
    {
        Verify.NotNull(process);
        Verify.NotNullOrWhiteSpace(process.State?.Name);

        if (string.IsNullOrWhiteSpace(process.State.Id))
        {
            process = process with { State = process.State with { Id = Guid.NewGuid().ToString() } };
        }

        this._process = process;
        var processId = new ActorId(process.State.Id);

        // For a non-dependency-injected application, the static methods on ActorProxy are used.
        // Since the ActorProxy methods are error prone, try to avoid using them when using
        // dependency-injected applications
        if (actorProxyFactory != null)
        {
            this._daprProcess = actorProxyFactory.CreateActorProxy<IProcess>(processId, nameof(ProcessActor));
        }
        else
        {
            this._daprProcess = ActorProxy.Create<IProcess>(processId, nameof(ProcessActor));
        }
    }

    /// <summary>
    /// Starts the process with an initial event.
    /// </summary>
    /// <param name="initialEvent">The initial event.</param>
    /// <param name="eventProxyStepId">An optional identifier of an actor requesting to proxy events.</param>
    internal async Task StartWithEventAsync(KernelProcessEvent initialEvent, ActorId? eventProxyStepId = null)
    {
        var daprProcess = DaprProcessInfo.FromKernelProcess(this._process);
        await this._daprProcess.InitializeProcessAsync(daprProcess, null, eventProxyStepId?.GetId()).ConfigureAwait(false);
        await this._daprProcess.RunOnceAsync(initialEvent.ToJson()).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a message to the process.
    /// </summary>
    /// <param name="processEvent">The event to sent to the process.</param>
    /// <returns>A <see cref="Task"/></returns>
    public override async Task SendEventAsync(KernelProcessEvent processEvent) =>
        await this._daprProcess.SendMessageAsync(processEvent.ToJson()).ConfigureAwait(false);

    /// <summary>
    /// Stops the process.
    /// </summary>
    /// <returns>A <see cref="Task"/></returns>
    public override async Task StopAsync() => await this._daprProcess.StopAsync().ConfigureAwait(false);

    /// <summary>
    /// Gets a snapshot of the current state of the process.
    /// </summary>
    /// <returns>A <see cref="Task{T}"/> where T is <see cref="KernelProcess"/></returns>
    public override async Task<KernelProcess> GetStateAsync()
    {
        var daprProcessInfo = await this._daprProcess.GetProcessInfoAsync().ConfigureAwait(false);
        return daprProcessInfo.ToKernelProcess();
    }

    /// <inheritdoc/>
    public override Task<IExternalKernelProcessMessageChannel?> GetExternalMessageChannelAsync()
    {
        throw new NotImplementedException();
    }

    /// <inheritdoc/>
    public override async Task<string> GetProcessIdAsync()
    {
        var processInfo = await this._daprProcess.GetProcessInfoAsync().ConfigureAwait(false);
        return processInfo.State.Id!;
    }
}


===== Process.Runtime.Dapr\DaprKernelProcessFactory.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Threading.Tasks;
using Dapr.Actors.Client;

namespace Microsoft.SemanticKernel;
/// <summary>
/// A class that can run a process locally or in-process.
/// </summary>
public static class DaprKernelProcessFactory
{
    /// <summary>
    /// Starts the specified process.
    /// </summary>
    /// <param name="process">Required: The <see cref="KernelProcess"/> to start running.</param>
    /// <param name="initialEvent">Required: The initial event to start the process.</param>
    /// <param name="processId">Optional: Used to specify the unique Id of the process. If the process already has an Id, it will not be overwritten and this parameter has no effect.</param>
    /// <param name="actorProxyFactory">Optional: when using in application with dependency injection it is recommended to pass the <see cref="IActorProxyFactory"/></param>
    /// <returns>An instance of <see cref="KernelProcess"/> that can be used to interrogate or stop the running process.</returns>
    public static async Task<DaprKernelProcessContext> StartAsync(this KernelProcess process, KernelProcessEvent initialEvent, string? processId = null, IActorProxyFactory? actorProxyFactory = null)
    {
        Verify.NotNull(process);
        Verify.NotNullOrWhiteSpace(process.State?.Name);
        Verify.NotNull(initialEvent);

        // Assign the process Id if one is provided and the processes does not already have an Id.
        if (!string.IsNullOrWhiteSpace(processId) && string.IsNullOrWhiteSpace(process.State.Id))
        {
            process = process with { State = process.State with { Id = processId } };
        }

        DaprKernelProcessContext processContext = new(process, actorProxyFactory);
        await processContext.StartWithEventAsync(initialEvent).ConfigureAwait(false);
        return processContext;
    }
}


===== Process.Runtime.Dapr\DaprMapInfo.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Runtime.Serialization;

namespace Microsoft.SemanticKernel;

/// <summary>
/// A serializable representation of a Dapr Map.
/// </summary>
[KnownType(typeof(KernelProcessEdge))]
[KnownType(typeof(KernelProcessMapState))]
[KnownType(typeof(KernelProcessStepState))]
[KnownType(typeof(KernelProcessStepState<>))]
public sealed record DaprMapInfo : DaprStepInfo
{
    /// <summary>
    /// The map operation
    /// </summary>
    public required DaprStepInfo Operation { get; init; }

    /// <summary>
    /// Initializes a new instance of the <see cref="KernelProcessMap"/> class from this instance of <see cref="DaprMapInfo"/>.
    /// </summary>
    /// <returns>An instance of <see cref="KernelProcessMap"/></returns>
    /// <exception cref="KernelException"></exception>
    public KernelProcessMap ToKernelProcessMap()
    {
        KernelProcessStepInfo processStepInfo = this.ToKernelProcessStepInfo();
        if (this.State is not KernelProcessMapState state)
        {
            throw new KernelException($"Unable to read state from map with name '{this.State.Name}' and Id '{this.State.Id}'.");
        }

        KernelProcessStepInfo operationStep =
            this.Operation is DaprProcessInfo processInfo
                ? processInfo.ToKernelProcess()
                : this.Operation.ToKernelProcessStepInfo();

        return new KernelProcessMap(state, operationStep, this.Edges);
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="DaprMapInfo"/> class from an instance of <see cref="KernelProcessMap"/>.
    /// </summary>
    /// <param name="processMap">The <see cref="KernelProcessMap"/> used to build the <see cref="DaprMapInfo"/></param>
    /// <returns>An instance of <see cref="DaprProcessInfo"/></returns>
    public static DaprMapInfo FromKernelProcessMap(KernelProcessMap processMap)
    {
        Verify.NotNull(processMap);

        DaprStepInfo operationInfo =
            processMap.Operation is KernelProcess processOperation
                ? DaprProcessInfo.FromKernelProcess(processOperation)
                : DaprStepInfo.FromKernelStepInfo(processMap.Operation);
        DaprStepInfo mapStepInfo = DaprStepInfo.FromKernelStepInfo(processMap);

        return new DaprMapInfo
        {
            InnerStepDotnetType = mapStepInfo.InnerStepDotnetType,
            State = mapStepInfo.State,
            Edges = mapStepInfo.Edges,
            Operation = operationInfo,
        };
    }
}


===== Process.Runtime.Dapr\DaprProcessInfo.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Runtime.Serialization;

namespace Microsoft.SemanticKernel;

/// <summary>
/// A serializable representation of a Dapr Process.
/// </summary>
[KnownType(typeof(KernelProcessEdge))]
[KnownType(typeof(KernelProcessState))]
[KnownType(typeof(KernelProcessMapState))]
[KnownType(typeof(KernelProcessStepState))]
[KnownType(typeof(KernelProcessStepState<>))]
public sealed record DaprProcessInfo : DaprStepInfo
{
    /// <summary>
    /// The collection of Steps in the Process.
    /// </summary>
    public required IList<DaprStepInfo> Steps { get; init; }

    /// <summary>
    /// Initializes a new instance of the <see cref="KernelProcess"/> class from this instance of <see cref="DaprProcessInfo"/>.
    /// </summary>
    /// <returns>An instance of <see cref="KernelProcess"/></returns>
    /// <exception cref="KernelException"></exception>
    public KernelProcess ToKernelProcess()
    {
        var processStepInfo = this.ToKernelProcessStepInfo();
        if (this.State is not KernelProcessState state)
        {
            throw new KernelException($"Unable to read state from process with name '{this.State.Name}' and Id '{this.State.Id}'.");
        }

        List<KernelProcessStepInfo> steps = [];
        foreach (var step in this.Steps)
        {
            if (step is DaprProcessInfo processStep)
            {
                steps.Add(processStep.ToKernelProcess());
            }
            else if (step is DaprMapInfo mapStep)
            {
                steps.Add(mapStep.ToKernelProcessMap());
            }
            else if (step is DaprProxyInfo proxyStep)
            {
                steps.Add(proxyStep.ToKernelProcessProxy());
            }
            else
            {
                steps.Add(step.ToKernelProcessStepInfo());
            }
        }

        return new KernelProcess(state, steps, this.Edges);
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="DaprProcessInfo"/> class from an instance of <see cref="KernelProcess"/>.
    /// </summary>
    /// <param name="kernelProcess">The <see cref="KernelProcess"/> used to build the <see cref="DaprProcessInfo"/></param>
    /// <returns>An instance of <see cref="DaprProcessInfo"/></returns>
    public static DaprProcessInfo FromKernelProcess(KernelProcess kernelProcess)
    {
        Verify.NotNull(kernelProcess);

        DaprStepInfo daprStepInfo = DaprStepInfo.FromKernelStepInfo(kernelProcess);
        List<DaprStepInfo> daprSteps = [];

        foreach (var step in kernelProcess.Steps)
        {
            if (step is KernelProcess processStep)
            {
                daprSteps.Add(DaprProcessInfo.FromKernelProcess(processStep));
            }
            else if (step is KernelProcessMap mapStep)
            {
                daprSteps.Add(DaprMapInfo.FromKernelProcessMap(mapStep));
            }
            else if (step is KernelProcessProxy proxyStep)
            {
                daprSteps.Add(DaprProxyInfo.FromKernelProxyInfo(proxyStep));
            }
            else
            {
                daprSteps.Add(DaprStepInfo.FromKernelStepInfo(step));
            }
        }

        return new DaprProcessInfo
        {
            InnerStepDotnetType = daprStepInfo.InnerStepDotnetType,
            State = daprStepInfo.State,
            Edges = daprStepInfo.Edges,
            Steps = daprSteps,
        };
    }
}


===== Process.Runtime.Dapr\DaprProxyInfo.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Runtime.Serialization;
using Microsoft.SemanticKernel.Process.Models;

namespace Microsoft.SemanticKernel;

/// <summary>
/// A serializable representation of a Dapr Proxy.
/// </summary>
[KnownType(typeof(KernelProcessEdge))]
[KnownType(typeof(KernelProcessStepState))]
[KnownType(typeof(KernelProcessStepState<>))]
public sealed record DaprProxyInfo : DaprStepInfo
{
    /// <summary>
    /// Proxy related data to be able to emit the events externally
    /// </summary>
    public required KernelProcessProxyStateMetadata? ProxyMetadata { get; init; }

    /// <summary>
    /// Initializes a new instance of the <see cref="KernelProcessMap"/> class from this instance of <see cref="DaprMapInfo"/>.
    /// </summary>
    /// <returns>An instance of <see cref="KernelProcessMap"/></returns>
    /// <exception cref="KernelException"></exception>
    public KernelProcessProxy ToKernelProcessProxy()
    {
        KernelProcessStepInfo processStepInfo = this.ToKernelProcessStepInfo();
        if (this.State is not KernelProcessStepState state)
        {
            throw new KernelException($"Unable to read state from proxy with name '{this.State.Name}', Id '{this.State.Id}' and type {this.State.GetType()}.");
        }

        return new KernelProcessProxy(state, this.Edges)
        {
            ProxyMetadata = this.ProxyMetadata,
        };
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="DaprProxyInfo"/> class from an instance of <see cref="KernelProcessProxy"/>.
    /// </summary>
    /// <param name="kernelProxyInfo">The <see cref="KernelProcessProxy"/> used to build the <see cref="DaprProxyInfo"/></param>
    /// <returns></returns>
    public static DaprProxyInfo FromKernelProxyInfo(KernelProcessProxy kernelProxyInfo)
    {
        Verify.NotNull(kernelProxyInfo, nameof(kernelProxyInfo));

        DaprStepInfo proxyStepInfo = DaprStepInfo.FromKernelStepInfo(kernelProxyInfo);

        return new DaprProxyInfo
        {
            InnerStepDotnetType = proxyStepInfo.InnerStepDotnetType,
            State = proxyStepInfo.State,
            Edges = proxyStepInfo.Edges,
            ProxyMetadata = kernelProxyInfo.ProxyMetadata,
        };
    }
}


===== Process.Runtime.Dapr\DaprStepInfo.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.Serialization;
using System.Text.Json.Serialization;

namespace Microsoft.SemanticKernel;

/// <summary>
/// Contains information about a Step in a Dapr Process including it's state and edges.
/// </summary>
[KnownType(typeof(KernelProcessEdge))]
[KnownType(typeof(KernelProcessStepState))]
[KnownType(typeof(KernelProcessProxyMessage))]
[KnownType(typeof(DaprProcessInfo))]
[KnownType(typeof(DaprMapInfo))]
[KnownType(typeof(DaprProxyInfo))]
[JsonDerivedType(typeof(DaprProcessInfo))]
[JsonDerivedType(typeof(DaprMapInfo))]
[JsonDerivedType(typeof(DaprProxyInfo))]
public record DaprStepInfo
{
    /// <summary>
    /// The .Net type of the inner step.
    /// </summary>
    public required string InnerStepDotnetType { get; init; }

    /// <summary>
    /// The state of the Step.
    /// </summary>
    public required KernelProcessStepState State { get; init; }

    /// <summary>
    /// A read-only dictionary of output edges from the Step.
    /// </summary>
    public required Dictionary<string, List<KernelProcessEdge>> Edges { get; init; }

    /// <summary>
    /// Builds an instance of <see cref="KernelProcessStepInfo"/> from the current object.
    /// </summary>
    /// <returns>An instance of <see cref="KernelProcessStepInfo"/></returns>
    /// <exception cref="KernelException"></exception>
    public KernelProcessStepInfo ToKernelProcessStepInfo()
    {
        Type? innerStepType = Type.GetType(this.InnerStepDotnetType);
        if (innerStepType is null)
        {
            throw new KernelException($"Unable to create inner step type from assembly qualified name `{this.InnerStepDotnetType}`");
        }

        return new KernelProcessStepInfo(innerStepType, this.State, this.Edges);
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="DaprStepInfo"/> class from an instance of <see cref="KernelProcessStepInfo"/>.
    /// </summary>
    /// <returns>An instance of <see cref="DaprStepInfo"/></returns>
    public static DaprStepInfo FromKernelStepInfo(KernelProcessStepInfo kernelStepInfo)
    {
        Verify.NotNull(kernelStepInfo, nameof(kernelStepInfo));

        return new DaprStepInfo
        {
            InnerStepDotnetType = kernelStepInfo.InnerStepType.AssemblyQualifiedName!,
            State = kernelStepInfo.State,
            Edges = kernelStepInfo.Edges.ToDictionary(kvp => kvp.Key, kvp => new List<KernelProcessEdge>(kvp.Value)),
        };
    }
}


===== Process.Runtime.Dapr\Interfaces\IEventBuffer.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Threading.Tasks;
using Dapr.Actors;
using Microsoft.SemanticKernel.Process.Runtime;

namespace Microsoft.SemanticKernel;

/// <summary>
/// An interface for a buffer of <see cref="ProcessEvent"/>s.
/// </summary>
public interface IEventBuffer : IActor
{
    /// <summary>
    /// Enqueues an external event.
    /// </summary>
    /// <param name="stepEvent">The event to enqueue as JSON.</param>
    /// <returns>A <see cref="Task"/></returns>
    Task EnqueueAsync(string stepEvent);

    /// <summary>
    /// Dequeues all external events.
    /// </summary>
    /// <returns>A <see cref="IList{T}"/> where T is the JSON representation of a <see cref="ProcessEvent"/></returns>
    Task<IList<string>> DequeueAllAsync();
}


===== Process.Runtime.Dapr\Interfaces\IExternalEventBuffer.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Threading.Tasks;
using Dapr.Actors;

namespace Microsoft.SemanticKernel;

/// <summary>
/// An interface for a buffer of <see cref="KernelProcessEvent"/>s.
/// </summary>
public interface IExternalEventBuffer : IActor
{
    /// <summary>
    /// Enqueues an external event.
    /// </summary>
    /// <param name="externalEvent">The external event to enqueue as JSON.</param>
    /// <returns>A <see cref="Task"/></returns>
    Task EnqueueAsync(string externalEvent);

    /// <summary>
    /// Dequeues all external events.
    /// </summary>
    /// <returns>A <see cref="IList{T}"/> where T is the JSON representation of a <see cref="KernelProcessEvent"/></returns>
    Task<IList<string>> DequeueAllAsync();
}


===== Process.Runtime.Dapr\Interfaces\IExternalMessageBuffer.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Threading.Tasks;
using Dapr.Actors;

namespace Microsoft.SemanticKernel;

// estenori-note:
// for some reason dapr doesn't like if instead public interface IExternalMessageBuffer : IActor, IExternalKernelProcessMessageChannelBase
// instead defining the interface component is necessary. To make it compatible with shared components a "casting" to IExternalKernelProcessMessageChannelEmitter
// is added in StepActor logic to make use of FindInputChannels

/// <summary>
/// An interface for <see cref="IExternalKernelProcessMessageChannel"/>
/// </summary>
public interface IExternalMessageBuffer : IActor
{
    /// <summary>
    /// Emits external events outside of the SK process
    /// </summary>
    /// <param name="externalTopicEvent"></param>
    /// <param name="eventData"></param>
    /// <returns></returns>
    abstract Task EmitExternalEventAsync(string externalTopicEvent, KernelProcessProxyMessage eventData);
}


===== Process.Runtime.Dapr\Interfaces\IMap.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Threading.Tasks;
using Dapr.Actors;

namespace Microsoft.SemanticKernel;

/// <summary>
/// An interface that represents a step in a process.
/// </summary>
public interface IMap : IActor
{
    /// <summary>
    /// Initializes the step with the provided step information.
    /// </summary>
    /// <returns>A <see cref="Task"/></returns>
    /// <exception cref="KernelException"></exception>
    Task InitializeMapAsync(DaprMapInfo mapInfo, string? parentProcessId);
}


===== Process.Runtime.Dapr\Interfaces\IMessageBuffer.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Threading.Tasks;
using Dapr.Actors;
using Microsoft.SemanticKernel.Process.Runtime;

namespace Microsoft.SemanticKernel;

/// <summary>
/// An interface for a buffer of <see cref="ProcessMessage"/>s.
/// </summary>
public interface IMessageBuffer : IActor
{
    /// <summary>
    /// Enqueues an external event.
    /// </summary>
    /// <param name="message">The message to enqueue as JSON.</param>
    /// <returns>A <see cref="Task"/></returns>
    Task EnqueueAsync(string message);

    /// <summary>
    /// Dequeues all external events.
    /// </summary>
    /// <returns>A <see cref="IList{T}"/> where T is the JSON representation of a <see cref="ProcessMessage"/></returns>
    Task<IList<string>> DequeueAllAsync();
}


===== Process.Runtime.Dapr\Interfaces\IProcess.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Threading.Tasks;
using Dapr.Actors;

namespace Microsoft.SemanticKernel;

/// <summary>
/// An interface that represents a process.
/// </summary>
public interface IProcess : IActor, IStep
{
    /// <summary>
    /// Initializes the process with the specified instance of <see cref="DaprProcessInfo"/>.
    /// </summary>
    /// <param name="processInfo">Used to initialize the process.</param>
    /// <param name="parentProcessId">The parent Id of the process if one exists.</param>
    /// <param name="eventProxyStepId">An optional identifier of an actor requesting to proxy events.</param>
    /// <returns>A<see cref="Task"/></returns>
    Task InitializeProcessAsync(DaprProcessInfo processInfo, string? parentProcessId, string? eventProxyStepId);

    /// <summary>
    /// Starts an initialized process.
    /// </summary>
    /// <param name="keepAlive">Indicates if the process should wait for external events after it's finished processing.</param>
    /// <returns></returns>
    Task StartAsync(bool keepAlive);

    /// <summary>
    /// Starts the process with an initial event and then waits for the process to finish. In this case the process will not
    /// keep alive waiting for external events after the internal messages have stopped.
    /// </summary>
    /// <param name="processEvent">Required. The <see cref="KernelProcessEvent"/> to start the process with.</param>
    /// <returns>A <see cref="Task"/></returns>
    Task RunOnceAsync(string processEvent);

    /// <summary>
    /// Stops a running process. This will cancel the process and wait for it to complete before returning.
    /// </summary>
    /// <returns>A <see cref="Task"/></returns>
    Task StopAsync();

    /// <summary>
    /// Sends a message to the process. This does not start the process if it's not already running, in
    /// this case the message will remain queued until the process is started.
    /// </summary>
    /// <param name="processEvent">Required. The <see cref="KernelProcessEvent"/> to start the process with.</param>
    /// <returns>A <see cref="Task"/></returns>
    Task SendMessageAsync(string processEvent);

    /// <summary>
    /// Gets the process information.
    /// </summary>
    /// <returns>An instance of <see cref="KernelProcess"/></returns>
    Task<DaprProcessInfo> GetProcessInfoAsync();
}


===== Process.Runtime.Dapr\Interfaces\IProxy.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Threading.Tasks;
using Dapr.Actors;

namespace Microsoft.SemanticKernel;

/// <summary>
/// An interface that represents a step in a process.
/// </summary>
public interface IProxy : IActor
{
    /// <summary>
    /// Initializes the step with the provided step information.
    /// </summary>
    /// <returns>A <see cref="Task"/></returns>
    /// <exception cref="KernelException"></exception>
    Task InitializeProxyAsync(DaprProxyInfo proxyInfo, string? parentProcessId);
}


===== Process.Runtime.Dapr\Interfaces\IStep.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Threading.Tasks;
using Dapr.Actors;

namespace Microsoft.SemanticKernel;

/// <summary>
/// An interface that represents a step in a process.
/// </summary>
public interface IStep : IActor
{
    /// <summary>
    /// Initializes the step with the provided step information.
    /// </summary>
    /// <returns>A <see cref="Task"/></returns>
    /// <exception cref="KernelException"></exception>
    Task InitializeStepAsync(DaprStepInfo stepInfo, string? parentProcessId, string? eventProxyStepId);

    /// <summary>
    /// Triggers the step to dequeue all pending messages and prepare for processing.
    /// </summary>
    /// <returns>A <see cref="Task{Task}"/> where T is an <see cref="int"/> indicating the number of messages that are prepared for processing.</returns>
    Task<int> PrepareIncomingMessagesAsync();

    /// <summary>
    /// Triggers the step to process all prepared messages.
    /// </summary>
    /// <returns>A <see cref="Task"/></returns>
    Task ProcessIncomingMessagesAsync();

    /// <summary>
    /// Builds the current state of the step into a <see cref="DaprStepInfo"/>.
    /// </summary>
    /// <returns>An instance of <see cref="DaprStepInfo"/></returns>
    Task<DaprStepInfo> ToDaprStepInfoAsync();
}


===== Process.Runtime.Dapr\KernelProcessDaprExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using Dapr.Actors.Runtime;

namespace Microsoft.SemanticKernel;

/// <summary>
/// Extension methods for configuring Dapr actors for the process runtime.
/// </summary>
public static class KernelProcessDaprExtensions
{
    /// <summary>
    /// Adds the process runtime actors to the actor runtime options.
    /// </summary>
    /// <param name="actorOptions">The instance of <see cref="ActorRuntimeOptions"/></param>
    public static void AddProcessActors(this ActorRuntimeOptions actorOptions)
    {
        // Register actor types and configure actor settings
        actorOptions.Actors.RegisterActor<ProcessActor>();
        actorOptions.Actors.RegisterActor<StepActor>();
        actorOptions.Actors.RegisterActor<MapActor>();
        actorOptions.Actors.RegisterActor<ProxyActor>();
        actorOptions.Actors.RegisterActor<EventBufferActor>();
        actorOptions.Actors.RegisterActor<MessageBufferActor>();
        actorOptions.Actors.RegisterActor<ExternalEventBufferActor>();
        actorOptions.Actors.RegisterActor<ExternalMessageBufferActor>();
    }
}


===== Process.Runtime.Dapr\Serialization\KernelProcessEventSerializer.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Collections.Generic;
using System.Linq;
using System.Text.Json;

namespace Microsoft.SemanticKernel.Process.Serialization;

/// <summary>
/// Serializer for <see cref="KernelProcessEvent"/> objects.
/// </summary>
/// <remarks>
/// Includes type info for <see cref="KernelProcessEvent.Data"/>.
/// </remarks>
internal static class KernelProcessEventSerializer
{
    /// <summary>
    /// Serialize <see cref="KernelProcessEvent"/> to JSON with type information.
    /// </summary>
    public static string ToJson(this KernelProcessEvent processEvent)
    {
        EventContainer<KernelProcessEvent> containedEvents = new(TypeInfo.GetAssemblyQualifiedType(processEvent.Data), processEvent);
        return JsonSerializer.Serialize(containedEvents);
    }

    /// <summary>
    /// Deserialize a list of JSON events into a list of <see cref="KernelProcessEvent"/> objects.
    /// </summary>
    /// <exception cref="KernelException">If any event fails deserialization</exception>
    public static IList<KernelProcessEvent> ToKernelProcessEvents(this IEnumerable<string> jsonEvents)
    {
        return Deserialize().ToArray();

        IEnumerable<KernelProcessEvent> Deserialize()
        {
            foreach (string json in jsonEvents)
            {
                yield return json.ToKernelProcessEvent();
            }
        }
    }

    /// <summary>
    /// Deserialize a list of JSON events into a list of <see cref="KernelProcessEvent"/> objects.
    /// </summary>
    /// <exception cref="KernelException">If any event fails deserialization</exception>
    public static KernelProcessEvent ToKernelProcessEvent(this string jsonEvent)
    {
        EventContainer<KernelProcessEvent> eventContainer =
            JsonSerializer.Deserialize<EventContainer<KernelProcessEvent>>(jsonEvent) ??
            throw new KernelException($"Unable to deserialize {nameof(KernelProcessEvent)} queue.");
        return eventContainer.Payload with { Data = TypeInfo.ConvertValue(eventContainer.DataTypeName, eventContainer.Payload.Data) };
    }
}


===== Process.Runtime.Dapr\Serialization\ProcessEventSerializer.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Collections.Generic;
using System.Linq;
using System.Text.Json;
using Microsoft.SemanticKernel.Process.Runtime;

namespace Microsoft.SemanticKernel.Process.Serialization;

/// <summary>
/// Serializer for <see cref="ProcessEvent"/> objects.
/// </summary>
/// <remarks>
/// Includes type info for <see cref="ProcessEvent.Data"/>.
/// </remarks>
internal static class ProcessEventSerializer
{
    /// <summary>
    /// Serialize <see cref="ProcessEvent"/> to JSON with type information.
    /// </summary>
    public static string ToJson(this ProcessEvent processEvent)
    {
        EventContainer<ProcessEvent> containedEvent = new(TypeInfo.GetAssemblyQualifiedType(processEvent.Data), processEvent);
        return JsonSerializer.Serialize(containedEvent);
    }

    /// <summary>
    /// Deserialize a list of JSON events into a list of <see cref="ProcessEvent"/> objects.
    /// </summary>
    /// <exception cref="KernelException">If any event fails deserialization</exception>
    public static IList<ProcessEvent> ToProcessEvents(this IEnumerable<string> jsonEvents)
    {
        return Deserialize().ToArray();

        IEnumerable<ProcessEvent> Deserialize()
        {
            foreach (string json in jsonEvents)
            {
                EventContainer<ProcessEvent> eventContainer =
                    JsonSerializer.Deserialize<EventContainer<ProcessEvent>>(json) ??
                    throw new KernelException($"Unable to deserialize {nameof(ProcessEvent)} queue.");
                yield return eventContainer.Payload with { Data = TypeInfo.ConvertValue(eventContainer.DataTypeName, eventContainer.Payload.Data) };
            }
        }
    }
}


===== Process.Runtime.Dapr\Serialization\ProcessMessageSerializer.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Collections.Generic;
using System.Linq;
using System.Text.Json;
using Microsoft.SemanticKernel.Process.Runtime;

namespace Microsoft.SemanticKernel.Process.Serialization;

/// <summary>
/// Serializer for <see cref="ProcessMessage"/> objects.
/// </summary>
/// <remarks>
/// Includes type info for <see cref="ProcessMessage.TargetEventData"/> and <see cref="ProcessMessage.Values"/>.
/// </remarks>
internal static class ProcessMessageSerializer
{
    /// <summary>
    /// Serialize <see cref="ProcessMessage"/> to JSON with type information.
    /// </summary>
    public static string ToJson(this ProcessMessage processMessage)
    {
        Dictionary<string, string?> typeMap = processMessage.Values.ToDictionary(kvp => kvp.Key, kvp => TypeInfo.GetAssemblyQualifiedType(kvp.Value));
        MessageContainer containedMessage = new(TypeInfo.GetAssemblyQualifiedType(processMessage.TargetEventData), typeMap, processMessage);
        return JsonSerializer.Serialize(containedMessage);
    }

    /// <summary>
    /// Deserialize a list of JSON messages into a list of <see cref="ProcessMessage"/> objects.
    /// </summary>
    /// <exception cref="KernelException">If any message fails deserialization</exception>
    public static IList<ProcessMessage> ToProcessMessages(this IEnumerable<string> jsonMessages)
    {
        return Deserialize().ToArray();

        IEnumerable<ProcessMessage> Deserialize()
        {
            foreach (string json in jsonMessages)
            {
                MessageContainer containedMessage =
                    JsonSerializer.Deserialize<MessageContainer>(json) ??
                    throw new KernelException($"Unable to deserialize {nameof(ProcessMessage)} queue.");

                yield return Process(containedMessage);
            }
        }
    }

    private static ProcessMessage Process(MessageContainer messageContainer)
    {
        ProcessMessage processMessage = messageContainer.Message;

        if (processMessage.Values.Count == 0)
        {
            return processMessage;
        }

        processMessage =
            processMessage with
            {
                TargetEventData = TypeInfo.ConvertValue(messageContainer.DataTypeName, processMessage.TargetEventData),
                Values = messageContainer.ValueTypeNames.ToDictionary(kvp => kvp.Key, kvp => TypeInfo.ConvertValue(kvp.Value, processMessage.Values[kvp.Key]))
            };

        return processMessage;
    }
}


===== Process.Runtime.Dapr\Serialization\TypeContainers.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Collections.Generic;
using Microsoft.SemanticKernel.Process.Runtime;

namespace Microsoft.SemanticKernel.Process.Serialization;

/// <summary>
/// Container for an event with type information.
/// </summary>
/// <typeparam name="TValue">The type of event</typeparam>
/// <param name="DataTypeName">The typeof the Data property</param>
/// <param name="Payload">The source event</param>
internal sealed record EventContainer<TValue>(string? DataTypeName, TValue Payload);

/// <summary>
/// Container for an message with type information.
/// </summary>
/// <param name="DataTypeName">The type of <see cref="ProcessMessage.TargetEventData"/>.</param>
/// <param name="ValueTypeNames">A type map for <see cref="ProcessMessage.Values"/>.</param>
/// <param name="Message">The source message</param>
internal sealed record MessageContainer(string? DataTypeName, Dictionary<string, string?> ValueTypeNames, ProcessMessage Message);


===== Process.Runtime.Dapr\Serialization\TypeInfo.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.Text.Json;

namespace Microsoft.SemanticKernel.Process.Serialization;

/// <summary>
/// Extension methods for capturing and restoring an object's type.
/// </summary>
internal static class TypeInfo
{
    /// <summary>
    /// Retrieves the assembly qualified type-name of the provided value (null when null).
    /// </summary>
    public static string? GetAssemblyQualifiedType(object? value)
    {
        if (value == null)
        {
            return null;
        }

        return value.GetType().AssemblyQualifiedName;
    }

    /// <summary>
    /// Restore the object's type from the provided assembly qualified type-name, but
    /// only if it is a <see cref="JsonElement"/>. Otherwise, return the original value.
    /// </summary>
    public static object? ConvertValue(string? assemblyQualifiedTypeName, object? value)
    {
        if (value == null || value.GetType() != typeof(JsonElement))
        {
            return value;
        }

        if (assemblyQualifiedTypeName == null)
        {
            throw new KernelException("Data persisted without type information.");
        }

        Type? valueType = Type.GetType(assemblyQualifiedTypeName);
        return ((JsonElement)value).Deserialize(valueType!);
    }
}


===== Process.UnitTests\Core\ProcessBuilderTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using Xunit;

namespace Microsoft.SemanticKernel.Process.Core.UnitTests;

/// <summary>
/// Unit tests for the ProcessBuilder class.
/// </summary>
public class ProcessBuilderTests
{
    private const string ProcessName = "TestProcess";
    private const string StepName = "TestStep";
    private const string EventId = "TestEvent";
    private const string SubProcessName = "SubProcess";

    /// <summary>
    /// Tests the initialization of the ProcessBuilder.
    /// </summary>
    [Fact]
    public void ProcessBuilderInitialization()
    {
        // Arrange & Act
        var processBuilder = new ProcessBuilder(ProcessName);

        // Assert
        Assert.Equal(ProcessName, processBuilder.Name);
        Assert.Empty(processBuilder.Steps);
    }

    /// <summary>
    /// Tests the AddStepFromType method to ensure it adds a step correctly.
    /// </summary>
    [Fact]
    public void AddStepFromTypeAddsStep()
    {
        // Arrange
        var processBuilder = new ProcessBuilder(ProcessName);

        // Act
        var stepBuilder = processBuilder.AddStepFromType<TestStep>(StepName);

        // Assert
        Assert.Single(processBuilder.Steps);
        Assert.Equal(StepName, stepBuilder.Name);
    }

    /// <summary>
    /// Tests that ensures when adding steps to builder, step names are not duplicated.<br/>
    /// For state persistence step names must be unique to ensure they can be mapped correctly when restoring from save state.
    /// </summary>
    [Fact]
    public void InvalidOperationExceptionOnAddStepWithSameStepName()
    {
        // Arrange
        var processBuilder = new ProcessBuilder(ProcessName);
        processBuilder.AddStepFromType<TestStep>(StepName);

        // Act
        try
        {
            processBuilder.AddStepFromType<TestStep>(StepName);
        }
        catch (InvalidOperationException ex)
        {
            // Assert
            Assert.Equal($"Step name {StepName} is already used, assign a different name for step", ex.Message);
        }
    }

    /// <summary>
    /// Tests the AddStepFromProcess method to ensure it adds a sub-process correctly.
    /// </summary>
    [Fact]
    public void AddStepFromProcessAddsSubProcess()
    {
        // Arrange
        var processBuilder = new ProcessBuilder(ProcessName);
        var subProcessBuilder = new ProcessBuilder(SubProcessName);

        // Act
        var stepBuilder = processBuilder.AddStepFromProcess(subProcessBuilder);

        // Assert
        Assert.Single(processBuilder.Steps);
        Assert.Equal(SubProcessName, stepBuilder.Name);
    }

    /// <summary>
    /// Tests that ensures when adding process steps to builder, step names are not duplicated.<br/>
    /// For state persistence step names must be unique to ensure they can be mapped correctly when restoring from save state.
    /// </summary>
    [Fact]
    public void InvalidOperationExceptionOnAddSubprocessWithSameStepName()
    {
        // Arrange
        var processBuilder = new ProcessBuilder(ProcessName);
        var subProcessBuilder = new ProcessBuilder(StepName);

        processBuilder.AddStepFromType<TestStep>(StepName);
        // Act
        try
        {
            processBuilder.AddStepFromProcess(subProcessBuilder);
        }
        catch (InvalidOperationException ex)
        {
            // Assert
            Assert.Equal($"Step name {StepName} is already used, assign a different name for step", ex.Message);
        }
    }

    /// <summary>
    /// Tests the OnExternalEvent method to ensure it creates an edge builder correctly.
    /// </summary>
    [Fact]
    public void OnExternalEventCreatesEdgeBuilder()
    {
        // Arrange
        var processBuilder = new ProcessBuilder(ProcessName);

        // Act
        var edgeBuilder = processBuilder.OnInputEvent(EventId);

        // Assert
        Assert.NotNull(edgeBuilder);
        Assert.Equal(EventId, edgeBuilder.EventData.EventId);
    }

    /// <summary>
    /// Tests the Build method to ensure it creates a KernelProcess correctly.
    /// </summary>
    [Fact]
    public void BuildCreatesKernelProcess()
    {
        // Arrange
        var processBuilder = new ProcessBuilder(ProcessName);
        processBuilder.AddStepFromType<TestStep>(StepName);

        // Act
        var kernelProcess = processBuilder.Build();

        // Assert
        Assert.NotNull(kernelProcess);
        Assert.Equal(ProcessName, kernelProcess.State.Name);
        Assert.Single(kernelProcess.Steps);
    }

    /// <summary>
    /// Verify that the <see cref="ProcessStepBuilder.OnFunctionResult(string)"/> method returns a <see cref="ProcessStepEdgeBuilder"/>.
    /// </summary>
    [Fact]
    public void OnFunctionErrorCreatesEdgeBuilder()
    {
        // Arrange
        var processBuilder = new ProcessBuilder(ProcessName);
        var errorStep = processBuilder.AddStepFromType<ErrorStep>();
        var edgeBuilder = processBuilder.OnError().SendEventTo(new ProcessFunctionTargetBuilder(errorStep));
        processBuilder.AddStepFromType<TestStep>();

        // Act
        var kernelProcess = processBuilder.Build();

        // Assert
        Assert.NotNull(edgeBuilder);
        Assert.EndsWith("Global.OnError", edgeBuilder.EventData.EventId);
    }

    /// <summary>
    /// A class that represents a step for testing.
    /// </summary>
    private sealed class TestStep : KernelProcessStep<TestState>
    {
        /// <summary>
        /// The name of the step.
        /// </summary>
        public static string Name => "TestStep";

        /// <summary>
        /// A method that represents a function for testing.
        /// </summary>
        [KernelFunction]
        public void TestFunction()
        {
        }
    }

    /// <summary>
    /// A class that represents a step for testing.
    /// </summary>
    private sealed class ErrorStep : KernelProcessStep
    {
        /// <summary>
        /// A method for unhandling failures at the process level.
        /// </summary>
        [KernelFunction]
        public void GlobalErrorHandler(Exception exception)
        {
        }
    }

    /// <summary>
    /// A class that represents a state for testing.
    /// </summary>
    private sealed class TestState
    {
    }
}


===== Process.UnitTests\Core\ProcessEdgeBuilderTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using Xunit;

namespace Microsoft.SemanticKernel.Process.Core.UnitTests;

/// <summary>
/// Unit testing of <see cref="ProcessEdgeBuilder"/>.
/// </summary>
public class ProcessEdgeBuilderTests
{
    /// <summary>
    /// Verify initialization of <see cref="ProcessEdgeBuilder"/>.
    /// </summary>
    [Fact]
    public void ProcessEdgeBuilderInitialization()
    {
        // Arrange
        var processBuilder = new ProcessBuilder("TestProcess");

        // Act
        var edgeBuilder = new ProcessEdgeBuilder(processBuilder, "TestEvent");

        // Assert
        Assert.StrictEqual(processBuilder, edgeBuilder.Source);
        Assert.Equal("TestEvent", edgeBuilder.EventData.EventId);
    }

    /// <summary>
    /// Verify initialization of <see cref="ProcessEdgeBuilder"/>.
    /// </summary>
    [Fact]
    public void SendEventToShouldSetOutputTarget()
    {
        // Arrange
        var processBuilder = new ProcessBuilder("TestProcess");
        var source = new ProcessStepBuilder<TestStep>("TestStep");
        var outputTarget = new ProcessFunctionTargetBuilder(source, "TestFunction");

        // Act
        var edgeBuilder = new ProcessEdgeBuilder(processBuilder, "TestEvent");
        edgeBuilder.SendEventTo(outputTarget);

        // Assert
        Assert.Equal(outputTarget, edgeBuilder.Target);
    }

    /// <summary>
    /// Verify initialization of <see cref="ProcessEdgeBuilder"/>.
    /// </summary>
    [Fact]
    public void SendEventToShouldSetMultipleOutputTargets()
    {
        // Arrange
        var processBuilder = new ProcessBuilder("TestProcess");
        var outputTargetA = new ProcessFunctionTargetBuilder(new ProcessStepBuilder<TestStep>("TestStep1"), "TestFunction");
        var outputTargetB = new ProcessFunctionTargetBuilder(new ProcessStepBuilder<TestStep>("TestStep2"), "TestFunction");

        // Act
        var edgeBuilder = new ProcessEdgeBuilder(processBuilder, "TestEvent");
        var edgeBuilder2 = edgeBuilder.SendEventTo(outputTargetA);
        edgeBuilder2.SendEventTo(outputTargetB);

        // Assert
        Assert.Equal(outputTargetA, edgeBuilder.Target);
        Assert.Equal(outputTargetB, edgeBuilder2.Target);
    }

    /// <summary>
    /// A class that represents a step for testing.
    /// </summary>
    private sealed class TestStep : KernelProcessStep
    {
        /// <summary>
        /// The name of the step.
        /// </summary>
        public static string Name => "TestStep";

        /// <summary>
        /// A method that represents a function for testing.
        /// </summary>
        [KernelFunction]
        public void TestFunction()
        {
        }
    }
}


===== Process.UnitTests\Core\ProcessMapBuilderTests.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.Linq;
using System.Threading.Tasks;
using Xunit;

namespace Microsoft.SemanticKernel.Process.Core.UnitTests;

/// <summary>
/// Unit tests for <see cref="ProcessMapBuilder"/>.
/// </summary>
public class ProcessMapBuilderTests
{
    /// <summary>
    /// Verify initialization based on <see cref="ProcessStepBuilder"/>.
    /// </summary>
    [Fact]
    public void ProcessMapBuilderFromStep()
    {
        // Arrange
        ProcessStepBuilder<SimpleTestStep> step = new($"One{nameof(SimpleTestStep)}", null);

        // Act
        ProcessMapBuilder map = new(step);

        // Assert
        Assert.NotNull(map.Id);
        Assert.NotNull(map.Name);
        Assert.Contains(nameof(SimpleTestStep), map.Name);
        Assert.NotNull(map.MapOperation);
        Assert.Equal(step, map.MapOperation);
    }

    /// <summary>
    /// Verify cannot be a function target.
    /// </summary>
    [Fact]
    public void ProcessMapBuilderFromMap()
    {
        // Arrange
        ProcessStepBuilder<SimpleTestStep> step = new($"One{nameof(SimpleTestStep)}", null);
        ProcessMapBuilder map1 = new(step);
        ProcessMapBuilder map2 = new(step);

        // Act & Assert
        Assert.Throws<ArgumentException>(() => map1.OnEvent("any").SendEventTo(new ProcessFunctionTargetBuilder(map2)));
    }

    /// <summary>
    /// Verify initialization based on <see cref="ProcessBuilder"/>.
    /// </summary>
    [Fact]
    public void ProcessMapBuilderFromProcess()
    {
        // Arrange
        ProcessBuilder process = new("MapOperation", null);
        ProcessStepBuilder step = process.AddStepFromType<SimpleTestStep>($"One{nameof(SimpleTestStep)}");
        process.OnInputEvent("ComputeMapValue").SendEventTo(new ProcessFunctionTargetBuilder(step));

        // Act
        ProcessMapBuilder map = new(process);

        // Assert
        Assert.NotNull(map.Id);
        Assert.NotNull(map.Name);
        Assert.Contains(process.Name, map.Name);
        Assert.NotNull(map.MapOperation);
        Assert.Equal(process, map.MapOperation);
    }

    /// <summary>
    /// Verify <see cref="ProcessMapBuilder"/> is able to define targets / output edges.
    /// </summary>
    [Fact]
    public void ProcessMapBuilderCanDefineTarget()
    {
        // Arrange
        ProcessStepBuilder<SimpleTestStep> step = new($"One{nameof(SimpleTestStep)}", null);
        ProcessMapBuilder map = new(step);

        // Act
        ProcessStepBuilder<SimpleTestStep> step2 = new($"Two{nameof(SimpleTestStep)}", null);
        map.OnEvent("Any").SendEventTo(new ProcessFunctionTargetBuilder(step2));

        // Assert
        Assert.Single(map.Edges);
        Assert.Single(map.Edges.Single().Value);
        Assert.NotNull(map.Edges.Single().Value[0].Target);
        Assert.Equal(step2, (map.Edges.Single().Value[0].Target as ProcessFunctionTargetBuilder)!.Step);

        // Act
        KernelProcessStepInfo processMap = map.BuildStep(new ProcessBuilder("Test", null));

        // Assert
        Assert.NotNull(processMap);
        Assert.Equal(processMap.Edges.Count, map.Edges.Count);
        Assert.Equal(processMap.Edges.Single().Value.Count, map.Edges.First().Value.Count);
        Assert.Equal((processMap.Edges.Single().Value.Single().OutputTarget as KernelProcessFunctionTarget)!.StepId, (map.Edges.Single().Value[0].Target as ProcessFunctionTargetBuilder)!.Step.Id);
    }

    /// <summary>
    /// Verify <see cref="ProcessMapBuilder.GetFunctionMetadataMap"/> always throws.
    /// </summary>
    [Fact]
    public void ProcessMapBuilderGetFunctionMetadataMapThrows()
    {
        // Arrange
        ProcessStepBuilder<SimpleTestStep> step = new($"One{nameof(SimpleTestStep)}", null);
        ProcessMapBuilder map = new(step);

        // Act
        Assert.Throws<NotImplementedException>(() => map.GetFunctionMetadataMap());
    }

    /// <summary>
    /// Verify <see cref="ProcessMapBuilder.BuildStep"/> produces the
    /// expected <see cref="KernelProcessMap"/>.
    /// </summary>
    [Fact]
    public void ProcessMapBuilderWillBuild()
    {
        // Arrange
        ProcessStepBuilder<SimpleTestStep> step = new($"One{nameof(SimpleTestStep)}", null);
        ProcessMapBuilder map = new(step);

        // Act
        KernelProcessStepInfo processMap = map.BuildStep(new ProcessBuilder("Test", null));

        // Assert
        Assert.NotNull(processMap);
        Assert.IsType<KernelProcessMap>(processMap);
        Assert.Equal(map.Name, processMap.State.Name);
        Assert.Equal(map.Id, processMap.State.Id);
    }

    /// <summary>
    /// Verify <see cref="ProcessMapBuilder.BuildStep"/> throws an exception
    /// if the target is a <see cref="ProcessBuilder"/>> without the having
    /// <see cref="ProcessFunctionTargetBuilder.TargetEventId"/> defined.
    /// While this state should not be achievable by external callers, the
    /// underlying state contracts do permit this permutation.
    /// </summary>
    [Fact]
    public void ProcessMapBuilderFailsBuildForMapTarget()
    {
        // Arrange
        ProcessBuilder process = new(nameof(InvalidTestStep), null);
        ProcessStepBuilder step = process.AddStepFromType<SimpleTestStep>();
        ProcessFunctionTargetBuilder invalidTarget = new(new ProcessMapBuilder(step));

        // Act & Assert
        Assert.Throws<ArgumentException>(() => new ProcessMapBuilder(step).OnEvent("Test").SendEventTo(invalidTarget));
    }

    /// <summary>
    /// Verify <see cref="ProcessMapBuilder.BuildStep"/> throws an exception
    /// if the target is a <see cref="ProcessBuilder"/>> without the having
    /// <see cref="ProcessFunctionTargetBuilder.TargetEventId"/> defined.
    /// While this state should not be achievable by external callers, the
    /// underlying state contracts do permit this permutation.
    /// </summary>
    [Fact]
    public void ProcessMapBuilderFailsBuildForInvalidTarget()
    {
        // Arrange
        ProcessBuilder process = new(nameof(InvalidTestStep), null);
        ProcessStepBuilder step = process.AddStepFromType<SimpleTestStep>();

        // Act & Assert
        Assert.Throws<KernelException>(() => step.OnEvent("Test").SendEventTo(new ProcessFunctionTargetBuilder(new ProcessMapBuilder(step), "missing")));
    }

    private sealed class SimpleTestStep : KernelProcessStep<TestState>
    {
        private TestState? _state;

        public override ValueTask ActivateAsync(KernelProcessStepState<TestState> state)
        {
            this._state = state.State;

            return ValueTask.CompletedTask;
        }

        [KernelFunction]
        public void TestFunction(Guid value)
        {
            Assert.NotNull(this._state);
        }
    }

    private sealed class InvalidTestStep : KernelProcessStep<TestState>
    {
        private TestState? _state;

        public override ValueTask ActivateAsync(KernelProcessStepState<TestState> state)
        {
            this._state = state.State;

            return ValueTask.CompletedTask;
        }

        [KernelFunction]
        public void TestFunction()
        {
            Assert.NotNull(this._state);
        }
    }

    private sealed class ComplexTestStep : KernelProcessStep<TestState>
    {
        private TestState? _state;

        public override ValueTask ActivateAsync(KernelProcessStepState<TestState> state)
        {
            this._state = state.State;

            return ValueTask.CompletedTask;
        }

        [KernelFunction]
        public void TestFunctionA(Guid value)
        {
            Assert.NotNull(this._state);
        }

        [KernelFunction]
        public void TestFunctionB(Guid value)
        {
            Assert.NotNull(this._state);
        }
    }

    private sealed class TestState
    {
        public Guid Value { get; set; }
    }
}


===== Process.UnitTests\Core\ProcessProxyBuilderTests.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.Collections.Generic;
using Xunit;

namespace Microsoft.SemanticKernel.Process.Core.UnitTests;

/// <summary>
/// Unit tests for <see cref="ProcessProxyBuilder"/>.
/// </summary>
public class ProcessProxyBuilderTests
{
    private readonly string _testProcessName = "testProcess";
    private readonly string _proxyName = "proxyTestName";
    private readonly string _topicName1 = "testTopic1";
    private readonly string _topicName2 = "testTopic2";
    private readonly string _topicName3 = "testTopic3";

    /// <summary>
    /// Verify initialization based on <see cref="ProcessStepBuilder"/>.
    /// </summary>
    [Fact]
    public void ProcessProxyBuilderInitialization()
    {
        // Arrange & Act
        ProcessProxyBuilder proxy = new([this._topicName1, this._topicName2, this._topicName3], this._proxyName, null);

        // Assert
        Assert.NotNull(proxy.Id);
        Assert.NotNull(proxy.Name);
        Assert.Equal(this._proxyName, proxy.Name);
        Assert.True(proxy._externalTopicUsage.Count > 0);
    }

    /// <summary>
    /// Verify registered topics are different
    /// </summary>
    [Fact]
    public void ProcessProxyBuilderInitializationEmptyTopicsThrows()
    {
        // Arrange
        List<string> repeatedTopics = [];

        // Act & Assert
        Assert.Throws<ArgumentException>(() => new ProcessProxyBuilder(repeatedTopics, this._proxyName, null));
    }

    /// <summary>
    /// Verify registered topics are different
    /// </summary>
    [Fact]
    public void ProcessProxyBuilderInitializationRepeatedTopicsThrows()
    {
        // Arrange
        List<string> repeatedTopics = [this._topicName1, this._topicName1];

        // Act & Assert
        Assert.Throws<ArgumentException>(() => new ProcessProxyBuilder(repeatedTopics, this._proxyName, null));
    }

    /// <summary>
    /// Verify <see cref="ProcessProxyBuilder.BuildStep"/> produces the
    /// expected <see cref="KernelProcessProxy"/>.
    /// </summary>
    [Fact]
    public void ProcessProxyBuilderWillBuild()
    {
        // Arrange
        ProcessProxyBuilder proxy = new([this._topicName1], this._proxyName, null);

        ProcessBuilder process = new(this._testProcessName, null);
        ProcessStepBuilder stepSource = process.AddStepFromType<SimpleTestStep>();
        stepSource.OnFunctionResult().EmitExternalEvent(proxy, this._topicName1);

        // Act
        var proxyInfo = proxy.BuildStep(new ProcessBuilder("Test", null));

        // Assert
        Assert.NotNull(proxyInfo);
        Assert.IsType<KernelProcessProxy>(proxyInfo);
        Assert.Equal(proxy.Name, proxyInfo.State.Name);
        Assert.Equal(proxy.Id, proxyInfo.State.Id);
        var processProxy = (KernelProcessProxy)proxyInfo;
        Assert.NotNull(processProxy?.ProxyMetadata);
        Assert.Equal(proxy._eventMetadata, processProxy.ProxyMetadata.EventMetadata);
    }

    /// <summary>
    /// Verify <see cref="ProcessProxyBuilder.BuildStep"/> fails building
    /// when is registered topics are not linked properly
    /// </summary>
    [Fact]
    public void ProcessProxyBuilderWillNotLinkDueMultipleLinkingToSameTopicThrows()
    {
        // Arrange
        ProcessProxyBuilder proxy = new([this._topicName1], this._proxyName, null);

        ProcessBuilder process = new(this._testProcessName, null);
        ProcessStepBuilder stepSource1 = process.AddStepFromType<SimpleTestStep>("step1");
        ProcessStepBuilder stepSource2 = process.AddStepFromType<SimpleTestStep>("step2");
        stepSource1.OnFunctionResult().EmitExternalEvent(proxy, this._topicName1);

        // Act & Assert
        Assert.Throws<InvalidOperationException>(() => stepSource2.OnFunctionResult().EmitExternalEvent(proxy, this._topicName1));
    }

    /// <summary>
    /// Verify <see cref="ProcessProxyBuilder.BuildStep"/> fails building
    /// when is registered topics are not linked properly
    /// </summary>
    [Fact]
    public void ProcessProxyBuilderWillNotBuildDueMissingLinking()
    {
        // Arrange
        ProcessProxyBuilder proxy = new([this._topicName1], this._proxyName, null);

        // Act & Assert
        Assert.Throws<InvalidOperationException>(() => proxy.BuildStep(new ProcessBuilder("Test", null)));
    }

    private sealed class SimpleTestStep : KernelProcessStep
    {
        [KernelFunction]
        public string TestFunction()
        {
            return "Test function message";
        }
    }
}


===== Process.UnitTests\Core\ProcessStepBuilderTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using Microsoft.SemanticKernel.Process.Models;
using Xunit;

namespace Microsoft.SemanticKernel.Process.Core.UnitTests;

/// <summary>
/// Unit tests for the <see cref="ProcessStepBuilder"/> class.
/// </summary>
public class ProcessStepBuilderTests
{
    /// <summary>
    /// Verify the constructor initializes properties.
    /// </summary>
    [Fact]
    public void ConstructorShouldInitializeProperties()
    {
        // Arrange
        var name = "TestStep";

        // Act
        var stepBuilder = new TestProcessStepBuilder(name);

        // Assert
        Assert.Equal(name, stepBuilder.Name);
        Assert.NotNull(stepBuilder.Id);
        Assert.NotNull(stepBuilder.FunctionsDict);
        Assert.NotNull(stepBuilder.Edges);
    }

    /// <summary>
    /// Verify that the <see cref="ProcessStepBuilder.OnEvent(string)"/> method returns a <see cref="ProcessStepEdgeBuilder"/>.
    /// </summary>
    [Fact]
    public void OnEventShouldReturnProcessStepEdgeBuilder()
    {
        // Arrange
        var stepBuilder = new TestProcessStepBuilder("TestStep");

        // Act
        var edgeBuilder = stepBuilder.OnEvent("TestEvent");

        // Assert
        Assert.NotNull(edgeBuilder);
        Assert.IsType<ProcessStepEdgeBuilder>(edgeBuilder);
        Assert.EndsWith("TestEvent", edgeBuilder.EventData.EventId);
    }

    /// <summary>
    /// Verify that the <see cref="ProcessStepBuilder.OnFunctionResult(string)"/> method returns a <see cref="ProcessStepEdgeBuilder"/>.
    /// </summary>
    [Fact]
    public void OnFunctionResultShouldReturnProcessStepEdgeBuilder()
    {
        // Arrange
        var stepBuilder = new TestProcessStepBuilder("TestStep");

        // Act
        var edgeBuilder = stepBuilder.OnFunctionResult("TestFunction");

        // Assert
        Assert.NotNull(edgeBuilder);
        Assert.IsType<ProcessStepEdgeBuilder>(edgeBuilder);
        Assert.EndsWith("TestFunction.OnResult", edgeBuilder.EventData.EventId);
    }

    /// <summary>
    /// Verify that the <see cref="ProcessStepBuilder.OnFunctionResult(string)"/> method returns a <see cref="ProcessStepEdgeBuilder"/>.
    /// </summary>
    [Fact]
    public void OnFunctionErrorShouldReturnProcessStepEdgeBuilder()
    {
        // Arrange
        var stepBuilder = new TestProcessStepBuilder("TestStep");

        // Act
        var edgeBuilder = stepBuilder.OnFunctionError("TestFunction");

        // Assert
        Assert.NotNull(edgeBuilder);
        Assert.EndsWith("TestFunction.OnError", edgeBuilder.EventData.EventId);
    }

    /// <summary>
    /// Verify that the <see cref="ProcessStepBuilder.LinkTo(string, ProcessStepEdgeBuilder)"/> method adds an edge.
    /// </summary>
    [Fact]
    public void LinkToShouldAddEdge()
    {
        // Arrange
        var stepBuilder = new TestProcessStepBuilder("TestStep");
        var edgeBuilder = new ProcessStepEdgeBuilder(stepBuilder, "TestEvent", "TestEvent");

        // Act
        stepBuilder.LinkTo("TestEvent", edgeBuilder);

        // Assert
        Assert.True(stepBuilder.Edges.ContainsKey("TestEvent"));
        Assert.Contains(edgeBuilder, stepBuilder.Edges["TestEvent"]);
    }

    /// <summary>
    /// Verify that the <see cref="ProcessStepBuilder.ResolveFunctionTarget(string, string)"/> method throws an exception when no functions exist.
    /// </summary>
    [Fact]
    public void ResolveFunctionTargetShouldThrowExceptionWhenNoFunctionsExist()
    {
        // Arrange
        var stepBuilder = new TestProcessStepBuilder("TestStep");

        // Act & Assert
        Assert.Throws<KernelException>(() => stepBuilder.ResolveFunctionTarget(null, null));
    }

    /// <summary>
    /// Verify that the <see cref="ProcessStepBuilder.ResolveFunctionTarget(string, string)"/> method correctly resolves a function target.
    /// In this case, the function name is provided and the parameter name is not. The target function has no parameters.
    /// </summary>
    [Fact]
    public void ResolveFunctionTargetWithoutParameterShouldReturnFunctionTargetWhenNoneExist()
    {
        // Arrange
        var stepBuilder = new TestProcessStepBuilder("TestStep");
        stepBuilder.FunctionsDict["TestFunction"] = new KernelFunctionMetadata(name: "TestFunction")
        {
            Description = "Test function description",
            Parameters = new List<KernelParameterMetadata>()
        };

        // Act
        var target = stepBuilder.ResolveFunctionTarget("TestFunction", null);

        // Assert
        Assert.NotNull(target);
        Assert.Equal("TestFunction", target.FunctionName);
    }

    /// <summary>
    /// Verify that the <see cref="ProcessStepBuilder.ResolveFunctionTarget(string, string)"/> method correctly resolves a function target.
    /// In this case, the function name is provided and the parameter name is not. The target function has one parameters.
    /// </summary>
    [Fact]
    public void ResolveFunctionTargetWithoutParameterShouldReturnFunctionTargetWhenOnlyOneParameterExists()
    {
        // Arrange
        var stepBuilder = new TestProcessStepBuilder("TestStep");
        stepBuilder.FunctionsDict["TestFunction"] = new KernelFunctionMetadata(name: "TestFunction")
        {
            Description = "Test function description",
            Parameters = [new KernelParameterMetadata("param1")]
        };

        // Act
        var target = stepBuilder.ResolveFunctionTarget("TestFunction", null);

        // Assert
        Assert.NotNull(target);
        Assert.Equal("TestFunction", target.FunctionName);
        Assert.Equal("param1", target.ParameterName);
    }

    /// <summary>
    /// Verify that the <see cref="ProcessStepBuilder.ResolveFunctionTarget(string, string)"/> method throws when it cannot resolve.
    /// In this case, the function name is provided and the parameter name is not. The target function has more than one parameters.
    /// </summary>
    [Fact(Skip = "Working on removing function parameter targets.")]
    public void ResolveFunctionTargetWithoutParameterShouldThrowWhenCannotResolveParameter()
    {
        // Arrange
        var stepBuilder = new TestProcessStepBuilder("TestStep");
        stepBuilder.FunctionsDict["TestFunction"] = new KernelFunctionMetadata(name: "TestFunction")
        {
            Description = "Test function description",
            Parameters = [new KernelParameterMetadata("param1"), new KernelParameterMetadata("param2")]
        };

        // Act & Assert
        Assert.Throws<KernelException>(() => stepBuilder.ResolveFunctionTarget("TestFunction", null));
    }

    /// <summary>
    /// Verify that the <see cref="ProcessStepBuilder.ResolveFunctionTarget(string, string)"/> method correctly resolves a function target.
    /// In this case, the function name is not provided, nor is the parameter name. The target function has one function with one parameter.
    /// </summary>
    [Fact]
    public void ResolveFunctionTargetWithoutParameterShouldReturnFunctionTargetWhenOnlyOneFunctionExists()
    {
        // Arrange
        var stepBuilder = new TestProcessStepBuilder("TestStep");
        stepBuilder.FunctionsDict["TestFunction"] = new KernelFunctionMetadata(name: "TestFunction")
        {
            Description = "Test function description",
            Parameters = [new KernelParameterMetadata("param1")]
        };

        // Act
        var target = stepBuilder.ResolveFunctionTarget(null, null);

        // Assert
        Assert.NotNull(target);
        Assert.Equal("TestFunction", target.FunctionName);
        Assert.Equal("param1", target.ParameterName);
    }

    /// <summary>
    /// Verify that the <see cref="ProcessStepBuilder.ResolveFunctionTarget(string, string)"/> method throws when it cannot resolve.
    /// In this case, the function name is provided as is the parameter name. The target has more than one function.
    /// </summary>
    [Fact]
    public void ResolveFunctionTargetWithoutParameterShouldThrowWhenCannotResolveFunction()
    {
        // Arrange
        var stepBuilder = new TestProcessStepBuilder("TestStep");
        stepBuilder.FunctionsDict["TestFunction1"] = new KernelFunctionMetadata(name: "TestFunction1")
        {
            Description = "Test function description",
            Parameters = [new KernelParameterMetadata("param1")]
        };
        stepBuilder.FunctionsDict["TestFunction2"] = new KernelFunctionMetadata(name: "TestFunction2")
        {
            Description = "Test function description",
            Parameters = [new KernelParameterMetadata("param1")]
        };

        // Act & Assert
        Assert.Throws<KernelException>(() => stepBuilder.ResolveFunctionTarget(null, null));
    }

    /// <summary>
    /// A test implementation of <see cref="ProcessStepBuilder"/> for testing purposes.
    /// </summary>
    private sealed class TestProcessStepBuilder : ProcessStepBuilder
    {
        public TestProcessStepBuilder(string name) : base(name, null) { }

        internal override KernelProcessStepInfo BuildStep(ProcessBuilder processBuilder, KernelProcessStepStateMetadata? stateMetadata = null)
        {
            return new KernelProcessStepInfo(typeof(TestProcessStepBuilder), new KernelProcessStepState(this.Name, version: "v1", id: this.Id), []);
        }

        internal override Dictionary<string, KernelFunctionMetadata> GetFunctionMetadataMap()
        {
            return new Dictionary<string, KernelFunctionMetadata>();
        }
    }
}


===== Process.UnitTests\Core\ProcessStepEdgeBuilderTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using Xunit;

namespace Microsoft.SemanticKernel.Process.Core.UnitTests;

/// <summary>
/// Unit tests for the <see cref="ProcessStepEdgeBuilder"/> class.
/// </summary>
public class ProcessStepEdgeBuilderTests
{
    /// <summary>
    /// Verify the constructor initializes properties.
    /// </summary>
    [Fact]
    public void ConstructorShouldInitializeProperties()
    {
        // Arrange
        var source = new ProcessStepBuilder<TestStep>(TestStep.Name);
        var eventType = "Event1";

        // Act
        var builder = new ProcessStepEdgeBuilder(source, eventType, eventType);

        // Assert
        Assert.Equal(source, builder.Source);
        Assert.Equal(eventType, builder.EventData.EventId);
        Assert.Equal(eventType, builder.EventData.EventName);
    }

    /// <summary>
    /// Verify that the <see cref="ProcessStepEdgeBuilder.SendEventTo_Internal(ProcessTargetBuilder)"/> method sets the output target.
    /// </summary>
    [Fact]
    public void SendEventToShouldSetOutputTarget()
    {
        // Arrange
        var source = new ProcessStepBuilder<TestStep>(TestStep.Name);
        var builder = new ProcessStepEdgeBuilder(source, "Event1", "Event1");
        var outputTarget = new ProcessFunctionTargetBuilder(new ProcessStepBuilder<TestStep>("OutputStep"));

        // Act
        builder.SendEventTo(outputTarget);

        // Assert
        Assert.Equal(outputTarget, builder.Target); // Assuming GetOutputTarget() is a method to access _outputTarget
    }

    /// <summary>
    /// Verify that the <see cref="ProcessStepEdgeBuilder.SendEventTo_Internal(ProcessTargetBuilder)"/> method sets chained output targets.
    /// </summary>
    [Fact]
    public void SendEventToShouldSetMultipleOutputTargets()
    {
        // Arrange
        var source = new ProcessStepBuilder<TestStep>(TestStep.Name);
        var builder = new ProcessStepEdgeBuilder(source, "Event1", "Event1");
        var outputTargetA = new ProcessFunctionTargetBuilder(new ProcessStepBuilder<TestStep>("StepA"));
        var outputTargetB = new ProcessFunctionTargetBuilder(new ProcessStepBuilder<TestStep>("StepB"));

        // Act
        var builder2 = builder.SendEventTo(outputTargetA);
        builder2.SendEventTo(outputTargetB);

        // Assert
        Assert.Equal(outputTargetA, builder.Target); // Assuming GetOutputTarget() is a method to access _outputTarget
        Assert.Equal(outputTargetB, builder2.Target); // Assuming GetOutputTarget() is a method to access _outputTarget
    }

    /// <summary>
    /// Verify that the <see cref="ProcessStepEdgeBuilder.SendEventTo_Internal(ProcessTargetBuilder)"/> method throws if the output target is already set.
    /// </summary>
    [Fact]
    public void SendEventToShouldThrowIfOutputTargetAlreadySet()
    {
        // Arrange
        var source = new ProcessStepBuilder<TestStep>(TestStep.Name);
        var builder = new ProcessStepEdgeBuilder(source, "Event1", "Event1");
        var outputTarget1 = new ProcessFunctionTargetBuilder(source);
        var outputTarget2 = new ProcessFunctionTargetBuilder(source);

        // Act
        builder.SendEventTo(outputTarget1);

        // Assert
        Assert.Throws<InvalidOperationException>(() => builder.SendEventTo(outputTarget2));
    }

    /// <summary>
    /// Verify that the <see cref="ProcessStepEdgeBuilder.StopProcess"/> method sets the output target to the end step.
    /// </summary>
    [Fact]
    public void StopProcessShouldSetOutputTargetToEndStep()
    {
        // Arrange
        var source = new ProcessStepBuilder<TestStep>(TestStep.Name);
        var builder = new ProcessStepEdgeBuilder(source, "Event1", "Event1");

        // Act
        builder.StopProcess();

        // Assert
        Assert.Equal(EndStep.Instance, (builder.Target as ProcessFunctionTargetBuilder)?.Step);
    }

    /// <summary>
    /// Verify that the <see cref="ProcessStepEdgeBuilder.StopProcess"/> method throws if the output target is already set.
    /// </summary>
    [Fact]
    public void StopProcessShouldThrowIfOutputTargetAlreadySet()
    {
        // Arrange
        var source = new ProcessStepBuilder<TestStep>(TestStep.Name);
        var builder = new ProcessStepEdgeBuilder(source, "Event1", "Event1");
        var outputTarget = new ProcessFunctionTargetBuilder(source);

        // Act
        builder.SendEventTo(outputTarget);

        // Assert
        Assert.Throws<InvalidOperationException>(() => builder.StopProcess());
    }

    /// <summary>
    /// Verify that the <see cref="ProcessStepEdgeBuilder.Build"/> method returns a <see cref="KernelProcessEdge"/>.
    /// </summary>
    [Fact]
    public void BuildShouldReturnKernelProcessEdge()
    {
        // Arrange
        var source = new ProcessStepBuilder<TestStep>(TestStep.Name);
        var builder = new ProcessStepEdgeBuilder(source, "Event1", "Event1");
        var outputTarget = new ProcessFunctionTargetBuilder(source);
        builder.SendEventTo(outputTarget);

        // Act
        var edge = builder.Build();

        // Assert
        Assert.NotNull(edge);
        Assert.Equal(source.Id, edge.SourceStepId);
    }

    /// <summary>
    /// A class that represents a step for testing.
    /// </summary>
    private sealed class TestStep : KernelProcessStep<TestState>
    {
        /// <summary>
        /// The name of the step.
        /// </summary>
        public static string Name => "TestStep";

        /// <summary>
        /// A method that represents a function for testing.
        /// </summary>
        [KernelFunction]
        public void TestFunction()
        {
        }
    }

    /// <summary>
    /// A class that represents a state for testing.
    /// </summary>
    private sealed class TestState
    {
    }
}


===== Process.UnitTests\KernelProcessMapTests.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using Xunit;

namespace Microsoft.SemanticKernel.Process.UnitTests;

/// <summary>
/// Unit testing of <see cref="KernelProcessMap"/>.
/// </summary>
public class KernelProcessMapTests
{
    /// <summary>
    /// Verify initialization.
    /// </summary>
    [Fact]
    public void KernelProcessMapStateInitialization()
    {
        // Arrange
        KernelProcessState processState = new("Operation", "vTest");
        KernelProcess process = new(processState, [], []);
        KernelProcessMapState state = new(nameof(KernelProcessMapStateInitialization), "vTest", Guid.NewGuid().ToString());

        // Act
        KernelProcessMap map = new(state, process, []);

        // Assert
        Assert.Equal(state, map.State);
        Assert.Equivalent(process, map.Operation);
        Assert.Empty(map.Edges);
    }

    /// <summary>
    /// Verify <see cref="KernelProcessMapState"/> requires a name and id
    /// </summary>
    [Fact]
    public void KernelProcessMapStateRequiredProperties()
    {
        // Act & Assert
        Assert.Throws<ArgumentNullException>(() => new KernelProcessMapState(name: null!, "vTest", "testid"));
        Assert.Throws<ArgumentNullException>(() => new KernelProcessMapState(name: "testname", null!, "testid"));
        Assert.Throws<ArgumentNullException>(() => new KernelProcessMapState("testname", "vTest", null!));
    }
}


===== Process.UnitTests\KernelProcessProxyTests.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using Xunit;

namespace Microsoft.SemanticKernel.Process.UnitTests;

/// <summary>
/// Unit testing of <see cref="KernelProcessProxy"/>.
/// </summary>
public class KernelProcessProxyTests
{
    /// <summary>
    /// Verify initialization.
    /// </summary>
    [Fact]
    public void KernelProcessProxyStateInitialization()
    {
        // Arrange
        KernelProcessStepState state = new(nameof(KernelProcessProxyStateInitialization), "vTest", Guid.NewGuid().ToString());

        // Act
        KernelProcessProxy proxy = new(state, []);

        // Assert
        Assert.Equal(state, proxy.State);
        Assert.Empty(proxy.Edges);
    }

    /// <summary>
    /// Verify <see cref="KernelProcessStepState"/> requires a name and id
    /// </summary>
    [Fact]
    public void KernelProcessProxyStateRequiredProperties()
    {
        // Act & Assert
        Assert.Throws<ArgumentNullException>(() => new KernelProcessStepState(name: null!, "vTest", "testid"));
        Assert.Throws<ArgumentNullException>(() => new KernelProcessStepState(name: "testname", null!, "testid"));
        Assert.Throws<ArgumentNullException>(() => new KernelProcessProxy(new KernelProcessStepState("testname", "vTest", null!), []));
    }
}


===== Process.UnitTests\KernelProcessSerializationTests.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Threading.Tasks;
using Microsoft.SemanticKernel.Process.Models;
using Xunit;

namespace Microsoft.SemanticKernel.Process.UnitTests;

/// <summary>
/// Unit testing of <see cref="Microsoft.SemanticKernel.Process.Models"/>
/// and associated operations.
/// </summary>
public class KernelProcessSerializationTests
{
    private static readonly JsonSerializerOptions s_serializerOptions = new() { WriteIndented = true };

    /// <summary>
    /// Verify serialization of process with step.
    /// </summary>
    [Fact]
    public void KernelProcessSerialization()
    {
        // Arrange
        ProcessBuilder processBuilder = new(nameof(KernelProcessSerialization));
        processBuilder.AddStepFromType<SimpleStep>("SimpleStep");
        processBuilder.AddStepFromType<StatefulStep, StepState>(new StepState { Id = Guid.NewGuid() }, "StatefulStep");
        KernelProcess process = processBuilder.Build();

        // Act
        KernelProcessStateMetadata processState = process.ToProcessStateMetadata();

        // Assert
        AssertProcessState(process, processState);

        // Act
        string json = JsonSerializer.Serialize(processState, s_serializerOptions);
        KernelProcessStateMetadata? copyState = JsonSerializer.Deserialize<KernelProcessStateMetadata>(json);

        // Assert
        Assert.NotNull(copyState);
        AssertProcessState(process, copyState);

        // Arrange
        ProcessBuilder anotherBuilder = new(nameof(KernelProcessSerialization));
        anotherBuilder.AddStepFromType<SimpleStep>("SimpleStep");
        anotherBuilder.AddStepFromType<StatefulStep>("StatefulStep");
        KernelProcess another = anotherBuilder.Build(copyState);

        AssertProcess(process, another);
    }

    /// <summary>
    /// Verify serialization of process with subprocess.
    /// </summary>
    [Fact]
    public void KernelSubProcessSerialization()
    {
        // Arrange
        ProcessBuilder processBuilder = new(nameof(KernelProcessSerialization));
        ProcessBuilder subProcessBuilder = new("subprocess");
        subProcessBuilder.AddStepFromType<SimpleStep>("SimpleStep");
        subProcessBuilder.AddStepFromType<StatefulStep, StepState>(new StepState { Id = Guid.NewGuid() }, "StatefulStep");
        processBuilder.AddStepFromProcess(subProcessBuilder);
        KernelProcess process = processBuilder.Build();

        // Act
        KernelProcessStateMetadata processState = process.ToProcessStateMetadata();

        // Assert
        AssertProcessState(process, processState);

        // Act
        string json = JsonSerializer.Serialize(processState, s_serializerOptions);
        KernelProcessStateMetadata? copyState = JsonSerializer.Deserialize<KernelProcessStateMetadata>(json);

        // Assert
        Assert.NotNull(copyState);
        AssertProcessState(process, copyState);

        // Arrange
        ProcessBuilder anotherBuilder = new(nameof(KernelProcessSerialization));
        ProcessBuilder anotherSubBuilder = new("subprocess");
        anotherSubBuilder.AddStepFromType<SimpleStep>("SimpleStep");
        anotherSubBuilder.AddStepFromType<StatefulStep>("StatefulStep");
        anotherBuilder.AddStepFromProcess(anotherSubBuilder);
        KernelProcess another = anotherBuilder.Build(copyState);

        AssertProcess(process, another);
    }

    /// <summary>
    /// Verify serialization of process with map-step.
    /// </summary>
    [Fact]
    public void KernelProcessMapSerialization()
    {
        ProcessBuilder processBuilder = new(nameof(KernelProcessSerialization));
        processBuilder.AddMapStepFromType<StatefulStep, StepState>(new StepState { Id = Guid.NewGuid() }, "StatefulStep");
        KernelProcess process = processBuilder.Build();

        // Act
        KernelProcessStateMetadata processState = process.ToProcessStateMetadata();

        // Assert
        AssertProcessState(process, processState);

        // Act
        string json = JsonSerializer.Serialize(processState, s_serializerOptions);
        KernelProcessStateMetadata? copyState = JsonSerializer.Deserialize<KernelProcessStateMetadata>(json);

        // Assert
        Assert.NotNull(copyState);
        AssertProcessState(process, copyState);

        // Arrange
        ProcessBuilder anotherBuilder = new(nameof(KernelProcessSerialization));
        anotherBuilder.AddMapStepFromType<StatefulStep>("StatefulStep");
        KernelProcess another = anotherBuilder.Build(copyState);

        AssertProcess(process, another);
    }

    private static void AssertProcess(KernelProcess expectedProcess, KernelProcess anotherProcess)
    {
        Assert.Equal(expectedProcess.State.Name, anotherProcess.State.Name);
        Assert.Equal(expectedProcess.State.Version, anotherProcess.State.Version);
        Assert.Equal(expectedProcess.Steps.Count, anotherProcess.Steps.Count);

        for (int index = 0; index < expectedProcess.Steps.Count; ++index)
        {
            AssertStep(expectedProcess.Steps[index], anotherProcess.Steps[index]);
        }
    }

    private static void AssertStep(KernelProcessStepInfo expectedStep, KernelProcessStepInfo actualStep)
    {
        Assert.Equal(expectedStep.InnerStepType, actualStep.InnerStepType);
        Assert.Equal(expectedStep.State.Name, actualStep.State.Name);
        Assert.Equal(expectedStep.State.Version, actualStep.State.Version);

        if (expectedStep is KernelProcessMap mapStep)
        {
            Assert.IsType<KernelProcessMap>(actualStep);
            AssertStep(mapStep.Operation, ((KernelProcessMap)actualStep).Operation);
        }
        else if (expectedStep is KernelProcess subProcess)
        {
            Assert.IsType<KernelProcess>(actualStep);
            AssertProcess(subProcess, (KernelProcess)actualStep);
        }
        else if (expectedStep.State is KernelProcessStepState<StepState> stepState)
        {
            Assert.IsType<KernelProcessStepState<StepState>>(actualStep.State);
            KernelProcessStepState<StepState> actualState = (KernelProcessStepState<StepState>)actualStep.State;
            Assert.NotNull(stepState.State);
            Assert.NotNull(actualState.State);
            Assert.Equal(stepState.State.Id, actualState.State.Id);
        }
    }

    private static void AssertProcessState(KernelProcess process, KernelProcessStateMetadata? savedProcess)
    {
        Assert.NotNull(savedProcess);
        Assert.Equal(process.State.Id, savedProcess.Id);
        Assert.Equal(process.State.Name, savedProcess.Name);
        Assert.Equal(process.State.Version, savedProcess.VersionInfo);
        Assert.NotNull(savedProcess.StepsState);
        Assert.Equal(process.Steps.Count, savedProcess.StepsState.Count);

        foreach (KernelProcessStepInfo step in process.Steps)
        {
            AssertStepState(step, savedProcess.StepsState);
        }
    }

    private static void AssertStepState(KernelProcessStepInfo step, Dictionary<string, KernelProcessStepStateMetadata> savedSteps)
    {
        Assert.True(savedSteps.ContainsKey(step.State.Name));
        KernelProcessStepStateMetadata savedStep = savedSteps[step.State.Name];
        Assert.Equal(step.State.Id, savedStep.Id);
        Assert.Equal(step.State.Name, savedStep.Name);
        Assert.Equal(step.State.Version, savedStep.VersionInfo);

        if (step is KernelProcessMap mapStep)
        {
            Assert.IsType<KernelProcessMapStateMetadata>(savedStep);
            KernelProcessMapStateMetadata mapState = (KernelProcessMapStateMetadata)savedStep;
            Assert.NotNull(mapState.OperationState);
            Assert.NotNull(mapState.OperationState.Name);
            AssertStepState(mapStep.Operation, new() { { mapState.OperationState.Name, mapState.OperationState } });
        }
        else if (step is KernelProcess subProcess)
        {
            Assert.IsType<KernelProcessStateMetadata>(savedStep);
            AssertProcessState(subProcess, (KernelProcessStateMetadata)savedStep);
        }
        else if (step.State is KernelProcessStepState<StepState> stepState)
        {
            Assert.NotNull(savedStep.State);
            if (savedStep.State is JsonElement jsonState)
            {
                StepState? savedState = jsonState.Deserialize<StepState>();
                Assert.NotNull(savedState);
                Assert.NotNull(stepState.State);
                Assert.Equal(stepState.State.Id, savedState.Id);
            }
            else
            {
                Assert.Equal(stepState.State, (StepState)savedStep.State);
            }
        }
    }

    private sealed class SimpleStep : KernelProcessStep
    {
        [KernelFunction]
        public void RunSimple()
        {
        }
    }

    private sealed class StepState
    {
        public Guid Id { get; set; } = Guid.Empty;
    }

    private sealed class StatefulStep : KernelProcessStep<StepState>
    {
        private StepState? _state;

        public override ValueTask ActivateAsync(KernelProcessStepState<StepState> state)
        {
            this._state = state.State;
            return default;
        }

        [KernelFunction]
        public void RunStateful()
        {
        }
    }
}


===== Process.UnitTests\KernelProcessStateTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using Xunit;

namespace Microsoft.SemanticKernel.Process.UnitTests;

/// <summary>
/// Unit testing of <see cref="KernelProcessState"/>.
/// </summary>
public class KernelProcessStateTests
{
    /// <summary>
    /// Verify initialization of <see cref="KernelProcessState"/>.
    /// </summary>
    [Fact]
    public void KernelProcessStateInitializationSetsPropertiesCorrectly()
    {
        // Arrange
        string name = "TestProcess";
        string id = "123";

        // Act
        KernelProcessState state = new(name, "v1", id);

        // Assert
        Assert.Equal(name, state.Name);
        Assert.Equal(id, state.Id);
    }

    /// <summary>
    /// Verify initialization of <see cref="KernelProcessState"/> with null id.
    /// </summary>
    [Fact]
    public void KernelProcessStateInitializationWithNullIdSucceeds()
    {
        // Arrange
        string name = "TestProcess";

        // Act
        KernelProcessState state = new(name, version: "v1");

        // Assert
        Assert.Equal(name, state.Name);
        Assert.Null(state.Id);
    }

    /// <summary>
    /// Verify initialization of <see cref="KernelProcessState"/> with null name throws.
    /// </summary>
    [Fact]
    public void KernelProcessStateInitializationWithNullNameThrows()
    {
        // Act & Assert
        var ex = Assert.Throws<ArgumentNullException>(() => new KernelProcessState(name: null!, version: "v1"));
    }

    /// <summary>
    /// Verify initialization of <see cref="KernelProcessState"/> with null version throws.
    /// </summary>
    [Fact]
    public void KernelProcessStateInitializationWithNullVersionThrows()
    {
        // Act & Assert
        var ex = Assert.Throws<ArgumentNullException>(() => new KernelProcessState(name: "stateName", version: null!));
    }
}


===== Process.UnitTests\Runtime.Local\LocalMapTests.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using SemanticKernel.Process.TestsShared.Services;
using SemanticKernel.Process.TestsShared.Setup;
using SemanticKernel.Process.TestsShared.Steps;
using Xunit;

namespace Microsoft.SemanticKernel.Process.Runtime.Local.UnitTests;

/// <summary>
/// Unit tests for the <see cref="LocalMap"/> class.
/// </summary>
public class LocalMapTests
{
    /// <summary>
    /// Validates the <see cref="LocalMap"/> result as the first step in the process
    /// and with a step as the map operation.
    /// </summary>
    [Fact]
    public async Task ProcessMapResultAsFirstAsync()
    {
        // Arrange
        ProcessBuilder process = new(nameof(ProcessMapResultAsFirstAsync));

        ProcessMapBuilder mapStep = process.AddMapStepFromType<ComputeStep>();
        process
            .OnInputEvent("Start")
            .SendEventTo(new ProcessFunctionTargetBuilder(mapStep));

        ProcessStepBuilder unionStep = process.AddStepFromType<UnionStep>("Union");
        mapStep
            .OnEvent(ComputeStep.SquareEventId)
            .SendEventTo(new ProcessFunctionTargetBuilder(unionStep, UnionStep.SumSquareFunction));

        KernelProcess processInstance = process.Build();
        Kernel kernel = new();

        // Act
        await using LocalKernelProcessContext processContext = await this.RunProcessAsync(kernel, processInstance, new int[] { 1, 2, 3, 4, 5 }, "Start");

        // Assert
        UnionState unionState = await GetUnionStateAsync(processContext);
        Assert.Equal(55L, unionState.SquareResult);
    }

    /// <summary>
    /// Validates the <see cref="LocalMap"/> filtering on a specific event (cubic, not square).
    /// </summary>
    [Fact]
    public async Task ProcessMapResultFilterEventAsync()
    {
        // Arrange
        ProcessBuilder process = new(nameof(ProcessMapResultFilterEventAsync));

        ProcessMapBuilder mapStep = process.AddMapStepFromType<ComputeStep>();
        process
            .OnInputEvent("Start")
            .SendEventTo(new ProcessFunctionTargetBuilder(mapStep));

        ProcessStepBuilder unionStep = process.AddStepFromType<UnionStep>("Union");
        mapStep
            .OnEvent(ComputeStep.CubicEventId)
            .SendEventTo(new ProcessFunctionTargetBuilder(unionStep, UnionStep.SumSquareFunction));

        KernelProcess processInstance = process.Build();
        Kernel kernel = new();

        // Act
        await using LocalKernelProcessContext processContext = await this.RunProcessAsync(kernel, processInstance, new int[] { 1, 2, 3, 4, 5 }, "Start");

        // Assert
        UnionState unionState = await GetUnionStateAsync(processContext);
        Assert.Equal(225L, unionState.SquareResult);
    }

    /// <summary>
    /// Validates the <see cref="LocalMap"/> result as the first step in the process
    /// and with a step as the map operation.
    /// </summary>
    [Fact]
    public async Task ProcessMapResultWithTransformAsync()
    {
        // Arrange
        ProcessBuilder process = new(nameof(ProcessMapResultWithTransformAsync));

        ProcessMapBuilder mapStep = process.AddMapStepFromType<FormatStep>();
        process
            .OnInputEvent("Start")
            .SendEventTo(new ProcessFunctionTargetBuilder(mapStep));

        ProcessStepBuilder unionStep = process.AddStepFromType<UnionStep>("Union");
        mapStep
            .OnEvent(FormatStep.EventId)
            .SendEventTo(new ProcessFunctionTargetBuilder(unionStep, UnionStep.FormatFunction));

        KernelProcess processInstance = process.Build();
        Kernel kernel = new();

        // Act
        await using LocalKernelProcessContext processContext = await this.RunProcessAsync(kernel, processInstance, new int[] { 1, 2, 3, 4, 5 }, "Start");

        // Assert
        UnionState unionState = await GetUnionStateAsync(processContext);
        Assert.Equal("[1]/[2]/[3]/[4]/[5]", unionState.FormatResult);
    }

    /// <summary>
    /// Validates the <see cref="LocalMap"/> result when the operation step
    /// contains multiple function targets.
    /// </summary>
    [Fact]
    public async Task ProcessMapResultOperationTargetAsync()
    {
        // Arrange
        ProcessBuilder process = new(nameof(ProcessMapResultOperationTargetAsync));

        ProcessMapBuilder mapStep = process.AddMapStepFromType<ComplexStep>();
        process
            .OnInputEvent("Start")
            .SendEventTo(new ProcessFunctionTargetBuilder(mapStep, ComplexStep.ComputeFunction));

        ProcessStepBuilder unionStep = process.AddStepFromType<UnionStep>("Union");
        mapStep
            .OnEvent(ComplexStep.ComputeEventId)
            .SendEventTo(new ProcessFunctionTargetBuilder(unionStep, UnionStep.SumSquareFunction));

        KernelProcess processInstance = process.Build();
        Kernel kernel = new();

        // Act
        await using LocalKernelProcessContext processContext = await this.RunProcessAsync(kernel, processInstance, new int[] { 1, 2, 3, 4, 5 }, "Start");

        // Assert
        UnionState unionState = await GetUnionStateAsync(processContext);
        Assert.Equal(55L, unionState.SquareResult);
    }

    /// <summary>
    /// Validates the <see cref="LocalMap"/> result as the second step in the process
    /// and with a step as the map operation.
    /// </summary>
    [Fact]
    public async Task ProcessMapResultAsTargetAsync()
    {
        // Arrange
        ProcessBuilder process = new(nameof(ProcessMapResultOperationTargetAsync));

        ProcessStepBuilder initStep = process.AddStepFromType<InitialStep>();
        process
            .OnInputEvent("Start")
            .SendEventTo(new ProcessFunctionTargetBuilder(initStep));

        ProcessMapBuilder mapStep = process.AddMapStepFromType<ComputeStep>();
        initStep
            .OnEvent(InitialStep.EventId)
            .SendEventTo(new ProcessFunctionTargetBuilder(mapStep));

        ProcessStepBuilder unionStep = process.AddStepFromType<UnionStep>("Union");
        mapStep
            .OnEvent(ComputeStep.SquareEventId)
            .SendEventTo(new ProcessFunctionTargetBuilder(unionStep, UnionStep.SumSquareFunction));

        KernelProcess processInstance = process.Build();
        Kernel kernel = new();

        // Act
        await using LocalKernelProcessContext processContext = await this.RunProcessAsync(kernel, processInstance, new int[] { 1, 2, 3, 4, 5 }, "Start");

        // Assert
        UnionState unionState = await GetUnionStateAsync(processContext);
        Assert.Equal(55L, unionState.SquareResult);
    }

    /// <summary>
    /// Validates the <see cref="LocalMap"/> result responding to multiple events
    /// from a step as the map operation.
    /// </summary>
    [Fact]
    public async Task ProcessMapResultMultiEventAsync()
    {
        // Arrange
        ProcessBuilder process = new(nameof(ProcessMapResultMultiEventAsync));

        ProcessMapBuilder mapStep = process.AddMapStepFromType<ComputeStep>();
        process
            .OnInputEvent("Start")
            .SendEventTo(new ProcessFunctionTargetBuilder(mapStep));

        ProcessStepBuilder unionStep = process.AddStepFromType<UnionStep>("Union");
        mapStep
            .OnEvent(ComputeStep.SquareEventId)
            .SendEventTo(new ProcessFunctionTargetBuilder(unionStep, UnionStep.SumSquareFunction));
        mapStep
            .OnEvent(ComputeStep.CubicEventId)
            .SendEventTo(new ProcessFunctionTargetBuilder(unionStep, UnionStep.SumCubicFunction));

        KernelProcess processInstance = process.Build();
        Kernel kernel = new();

        // Act
        await using LocalKernelProcessContext processContext = await this.RunProcessAsync(kernel, processInstance, new int[] { 1, 2, 3, 4, 5 }, "Start");

        // Assert
        UnionState unionState = await GetUnionStateAsync(processContext);
        Assert.Equal(55L, unionState.SquareResult);
        Assert.Equal(225L, unionState.CubicResult);
    }

    /// <summary>
    /// Validates the <see cref="LocalMap"/> result with a sub-process as the map operation.
    /// </summary>
    [Fact]
    public async Task ProcessMapResultProcessOperationAsync()
    {
        // Arrange
        ProcessBuilder process = new(nameof(ProcessMapResultProcessOperationAsync));

        ProcessBuilder mapProcess = new("MapOperation");
        ProcessStepBuilder computeStep = mapProcess.AddStepFromType<ComputeStep>();
        mapProcess
            .OnInputEvent("Anything")
            .SendEventTo(new ProcessFunctionTargetBuilder(computeStep));

        ProcessMapBuilder mapStep = process.AddMapStepFromProcess(mapProcess);

        process
            .OnInputEvent("Start")
            .SendEventTo(mapStep.WhereInputEventIs("Anything"));

        ProcessStepBuilder unionStep = process.AddStepFromType<UnionStep>("Union");
        mapStep
            .OnEvent(ComputeStep.SquareEventId)
            .SendEventTo(new ProcessFunctionTargetBuilder(unionStep, UnionStep.SumSquareFunction));

        KernelProcess processInstance = process.Build();
        Kernel kernel = new();

        // Act
        await using LocalKernelProcessContext processContext = await this.RunProcessAsync(kernel, processInstance, new int[] { 1, 2, 3, 4, 5 }, "Start");

        // Assert
        UnionState unionState = await GetUnionStateAsync(processContext);
        Assert.Equal(55L, unionState.SquareResult);
    }

    /// <summary>
    /// Validates the <see cref="LocalMap"/> result even when an invalid edge is
    /// introduced to the map-operation.
    /// </summary>
    [Fact]
    public async Task ProcessMapResultWithTargetInvalidAsync()
    {
        // Arrange
        ProcessBuilder process = new(nameof(ProcessMapResultWithTargetInvalidAsync));

        ProcessMapBuilder mapStep = process.AddMapStepFromType<ComputeStep>();
        process
            .OnInputEvent("Start")
            .SendEventTo(new ProcessFunctionTargetBuilder(mapStep));

        // CountStep is not part of the map operation, rather it has been defined on the "outer" process.
        ProcessStepBuilder countStep = process.AddStepFromType<CommonSteps.CountStep>(id: nameof(ProcessMapResultWithTargetInvalidAsync));
        mapStep.MapOperation
            .OnEvent(ComputeStep.SquareEventId)
            .SendEventTo(new ProcessFunctionTargetBuilder(countStep));

        ProcessStepBuilder unionStep = process.AddStepFromType<UnionStep>("Union");
        mapStep
            .OnEvent(ComputeStep.SquareEventId)
            .SendEventTo(new ProcessFunctionTargetBuilder(unionStep, UnionStep.SumSquareFunction));

        KernelProcess processInstance = process.Build();
        Kernel kernel = new();

        // Act & Assert
        await Assert.ThrowsAsync<InvalidOperationException>(() => this.RunProcessAsync(kernel, processInstance, new int[] { 1, 2, 3, 4, 5 }, "Start"));
    }

    /// <summary>
    /// Validates the <see cref="LocalMap"/> result an extra edge is
    /// introduced to the map-operation.
    /// </summary>
    [Fact]
    public async Task ProcessMapResultWithTargetExtraAsync()
    {
        // Arrange
        ProcessBuilder process = new(nameof(ProcessMapResultProcessOperationAsync));

        ProcessBuilder mapProcess = new("MapOperation");
        ProcessStepBuilder computeStep = mapProcess.AddStepFromType<ComputeStep>();
        mapProcess
            .OnInputEvent("Anything")
            .SendEventTo(new ProcessFunctionTargetBuilder(computeStep));

        const string CounterName = nameof(ProcessMapResultWithTargetExtraAsync);
        ProcessStepBuilder countStep = mapProcess.AddStepFromType<CommonSteps.CountStep>(id: CounterName);
        computeStep
            .OnEvent(ComputeStep.SquareEventId)
            .SendEventTo(new ProcessFunctionTargetBuilder(countStep));

        ProcessMapBuilder mapStep = process.AddMapStepFromProcess(mapProcess);
        process
            .OnInputEvent("Start")
            .SendEventTo(mapStep.WhereInputEventIs("Anything"));

        ProcessStepBuilder unionStep = process.AddStepFromType<UnionStep>("Union");
        mapStep
            .OnEvent(ComputeStep.SquareEventId)
            .SendEventTo(new ProcessFunctionTargetBuilder(unionStep, UnionStep.SumSquareFunction));

        KernelProcess processInstance = process.Build();
        CounterService counterService = new();
        Kernel kernel = KernelSetup.SetupKernelWithCounterService(counterService);

        // Act
        await using LocalKernelProcessContext processContext = await this.RunProcessAsync(kernel, processInstance, new int[] { 1, 2, 3, 4, 5 }, "Start");

        // Assert
        UnionState unionState = await GetUnionStateAsync(processContext);
        Assert.Equal(55L, unionState.SquareResult);
        Assert.Equal(5, counterService.GetCount());
    }

    /// <summary>
    /// Validates the <see cref="LocalMap"/> result as for a nested map operation.
    /// </summary>
    [Fact]
    public async Task ProcessMapResultForNestedMapAsync()
    {
        // Arrange
        ProcessBuilder process = new(nameof(ProcessMapResultForNestedMapAsync));

        ProcessBuilder mapProcess = new("MapOperation");
        ProcessMapBuilder mapStepInner = mapProcess.AddMapStepFromType<ComputeStep>();
        ProcessStepBuilder unionStepInner = mapProcess.AddStepFromType<UnionStep>();
        mapStepInner
            .OnEvent(ComputeStep.SquareEventId)
            .SendEventTo(new ProcessFunctionTargetBuilder(unionStepInner, UnionStep.SumSquareFunction));

        mapProcess
            .OnInputEvent("Anything")
            .SendEventTo(new ProcessFunctionTargetBuilder(mapStepInner));

        ProcessMapBuilder mapStepOuter = process.AddMapStepFromProcess(mapProcess);
        ProcessStepBuilder unionStepOuter = process.AddStepFromType<UnionStep>("Union");
        mapStepOuter
            .OnEvent(UnionStep.EventId)
            .SendEventTo(new ProcessFunctionTargetBuilder(unionStepOuter, UnionStep.SumSquareFunction));

        process
            .OnInputEvent("Start")
            .SendEventTo(mapStepOuter.WhereInputEventIs("Anything"));

        KernelProcess processInstance = process.Build();
        Kernel kernel = new();

        // Act
        int[][] input =
        [
            [1, 2, 3, 4, 5],
            [1, 2, 3, 4, 5],
            [1, 2, 3, 4, 5],
        ];
        await using LocalKernelProcessContext processContext = await this.RunProcessAsync(kernel, processInstance, input, "Start");

        // Assert
        UnionState unionState = await GetUnionStateAsync(processContext);
        Assert.Equal(165L, unionState.SquareResult);
    }

    private async Task<LocalKernelProcessContext> RunProcessAsync(Kernel kernel, KernelProcess process, object? input, string inputEvent)
    {
        return
            await process.StartAsync(
                kernel,
                new KernelProcessEvent
                {
                    Id = inputEvent,
                    Data = input,
                });
    }

    private static async Task<UnionState> GetUnionStateAsync(LocalKernelProcessContext processContext)
    {
        KernelProcess processState = await processContext.GetStateAsync();
        KernelProcessStepState<UnionState> unionState = (KernelProcessStepState<UnionState>)processState.Steps.Single(s => s.State.Name == "Union").State;
        Assert.NotNull(unionState);
        Assert.NotNull(unionState.State);
        return unionState.State;
    }

    /// <summary>
    /// A filler step used that emits the provided value as its output.
    /// </summary>
    private sealed class IncrementStep : KernelProcessStep
    {
        public const string EventId = "Bump";
        public const string IncrementFunction = "Increment";

        [KernelFunction(IncrementFunction)]
        public async ValueTask IncrementAsync(KernelProcessStepContext context, int count)
        {
            await context.EmitEventAsync(new() { Id = EventId, Data = count + 1, Visibility = KernelProcessEventVisibility.Public });
        }
    }

    /// <summary>
    /// A filler step used that emits the provided value as its output.
    /// </summary>
    private sealed class InitialStep : KernelProcessStep
    {
        public const string EventId = "Init";
        public const string InitFunction = "MapInit";

        [KernelFunction(InitFunction)]
        public async ValueTask InitAsync(KernelProcessStepContext context, object values)
        {
            await context.EmitEventAsync(new() { Id = EventId, Data = values, Visibility = KernelProcessEventVisibility.Public });
        }
    }

    /// <summary>
    /// A step that contains a map operation that emits two events.
    /// </summary>
    private sealed class ComputeStep : KernelProcessStep
    {
        public const string SquareEventId = "SquareResult";
        public const string CubicEventId = "CubicResult";
        public const string ComputeFunction = "MapCompute";

        [KernelFunction(ComputeFunction)]
        public async ValueTask ComputeAsync(KernelProcessStepContext context, long value)
        {
            long square = value * value;
            await context.EmitEventAsync(new() { Id = SquareEventId, Data = square, Visibility = KernelProcessEventVisibility.Public });
            await context.EmitEventAsync(new() { Id = CubicEventId, Data = square * value, Visibility = KernelProcessEventVisibility.Public });
        }
    }

    /// <summary>
    /// A step that contains multiple functions, one of which is a map operation.
    /// </summary>
    private sealed class ComplexStep : KernelProcessStep
    {
        public const string ComputeEventId = "SquareResult";
        public const string ComputeFunction = "MapCompute";

        public const string OtherEventId = "CubicResult";
        public const string OtherFunction = "Other";

        [KernelFunction(ComputeFunction)]
        public async ValueTask ComputeAsync(KernelProcessStepContext context, long value)
        {
            long square = value * value;
            await context.EmitEventAsync(new() { Id = ComputeEventId, Data = square });
        }

        [KernelFunction(OtherFunction)]
        public async ValueTask OtherAsync(KernelProcessStepContext context)
        {
            await context.EmitEventAsync(new() { Id = OtherEventId });
        }
    }

    /// <summary>
    /// A map operation that formats the input as a string.
    /// </summary>
    private sealed class FormatStep : KernelProcessStep
    {
        public const string EventId = "FormatResult";
        public const string FormatFunction = "MapCompute";

        [KernelFunction(FormatFunction)]
        public async ValueTask FormatAsync(KernelProcessStepContext context, object value)
        {
            await context.EmitEventAsync(new() { Id = EventId, Data = $"[{value}]" });
        }
    }

    private sealed record UnionState
    {
        public long SquareResult { get; set; }
        public long CubicResult { get; set; }
        public string FormatResult { get; set; } = string.Empty;
    };

    /// <summary>
    /// The step that combines the results of the map operation.
    /// </summary>
    private sealed class UnionStep : KernelProcessStep<UnionState>
    {
        public const string EventId = "MapUnion";
        public const string SumSquareFunction = "UnionSquare";
        public const string SumCubicFunction = "UnionCubic";
        public const string FormatFunction = "UnionFormat";

        private UnionState _state = new();

        public override ValueTask ActivateAsync(KernelProcessStepState<UnionState> state)
        {
            this._state = state.State ?? throw new InvalidDataException();

            return ValueTask.CompletedTask;
        }

        [KernelFunction(SumSquareFunction)]
        public async ValueTask SumSquareAsync(KernelProcessStepContext context, IList<long> values)
        {
            this._state.SquareResult = values.Sum();
            await context.EmitEventAsync(new() { Id = EventId, Data = this._state.SquareResult });
        }

        [KernelFunction(SumCubicFunction)]
        public async ValueTask SumCubicAsync(KernelProcessStepContext context, IList<long> values)
        {
            this._state.CubicResult = values.Sum();
            await context.EmitEventAsync(new() { Id = EventId, Data = this._state.CubicResult });
        }

        [KernelFunction(FormatFunction)]
        public void FormatValues(IList<string> values)
        {
            this._state.FormatResult = string.Join("/", values);
        }
    }
}


===== Process.UnitTests\Runtime.Local\LocalProcessTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Threading.Tasks;
using Xunit;

namespace Microsoft.SemanticKernel.Process.Runtime.Local.UnitTests;

/// <summary>
/// Unit tests for the <see cref="LocalProcess"/> class.
/// </summary>
public class LocalProcessTests
{
    /// <summary>
    /// Validates that the <see cref="LocalProcess"/> constructor initializes the steps correctly.
    /// </summary>
    [Fact]
    public async Task ExecuteAsyncInitializesCorrectlyAsync()
    {
        // Arrange
        var processState = new KernelProcessState(name: "TestProcess", version: "v1", id: "123");
        var mockKernelProcess = new KernelProcess(processState,
        [
            new(typeof(TestStep), new KernelProcessState(name: "Step1", version: "v1", id: "1"), []),
            new(typeof(TestStep), new KernelProcessState(name: "Step2", version: "v1", id: "2"), [])
        ], []);

        var mockKernel = new Kernel();
        await using var localProcess = new LocalProcess(mockKernelProcess, mockKernel);
        // Act
        await localProcess.StartAsync();

        // Assert
        Assert.Equal(2, localProcess._steps.Count);
        Assert.Contains(localProcess._steps, s => s.Name == "Step1");
        Assert.Contains(localProcess._steps, s => s.Name == "Step2");
    }

    /// <summary>
    /// Validates that the <see cref="LocalProcess"/> assigns and Id to the process if one is not already set.
    /// </summary>
    [Fact]
    public async Task ProcessWithMissingIdIsAssignedAnIdAsync()
    {
        // Arrange
        var mockKernel = new Kernel();
        var processState = new KernelProcessState(name: "TestProcess", version: "v1");
        var mockKernelProcess = new KernelProcess(processState,
        [
            new(typeof(TestStep), new KernelProcessState(name: "Step1", version: "v1", id: "1"), []),
            new(typeof(TestStep), new KernelProcessState(name: "Step2", version: "v1", id: "2"), [])
        ], []);

        // Act
        await using var localProcess = new LocalProcess(mockKernelProcess, mockKernel);

        // Assert
        Assert.NotEmpty(localProcess.Id);
    }

    /// <summary>
    /// Validates that the <see cref="LocalProcess"/> assigns and Id to the process if one is not already set.
    /// </summary>
    [Fact]
    public async Task ProcessWithAssignedIdIsNotOverwrittenIdAsync()
    {
        // Arrange
        var mockKernel = new Kernel();
        var processState = new KernelProcessState(name: "TestProcess", version: "v1", id: "AlreadySet");
        var mockKernelProcess = new KernelProcess(processState,
        [
            new(typeof(TestStep), new KernelProcessState(name: "Step1", version: "v1", id: "1"), []),
            new(typeof(TestStep), new KernelProcessState(name: "Step2", version: "v1", id: "2"), [])
        ], []);

        // Act
        await using var localProcess = new LocalProcess(mockKernelProcess, mockKernel);

        // Assert
        Assert.NotEmpty(localProcess.Id);
        Assert.Equal("AlreadySet", localProcess.Id);
    }

    /// <summary>
    /// Verify that the function  level error handler is called when a function fails.
    /// </summary>
    [Fact]
    public async Task ProcessFunctionErrorHandledAsync()
    {
        // Arrange
        ProcessBuilder process = new(nameof(ProcessFunctionErrorHandledAsync));

        ProcessStepBuilder testStep = process.AddStepFromType<FailedStep>();
        process.OnInputEvent("Start").SendEventTo(new ProcessFunctionTargetBuilder(testStep));

        ProcessStepBuilder errorStep = process.AddStepFromType<ErrorStep>();
        testStep.OnFunctionError(nameof(FailedStep.TestFailure)).SendEventTo(new ProcessFunctionTargetBuilder(errorStep, nameof(ErrorStep.FunctionErrorHandler)));

        KernelProcess processInstance = process.Build();
        Kernel kernel = new();

        // Act
        await using LocalKernelProcessContext runningProcess = await processInstance.StartAsync(kernel, new KernelProcessEvent() { Id = "Start" });

        // Assert
        Assert.True(kernel.Data.ContainsKey("error-function"));
        Assert.IsType<KernelProcessError>(kernel.Data["error-function"]);
    }

    /// <summary>
    /// Verify that the process level error handler is called when a function fails.
    /// </summary>
    [Fact]
    public async Task ProcessGlobalErrorHandledAsync()
    {
        // Arrange
        ProcessBuilder process = new(nameof(ProcessFunctionErrorHandledAsync));

        ProcessStepBuilder testStep = process.AddStepFromType<FailedStep>();
        process.OnInputEvent("Start").SendEventTo(new ProcessFunctionTargetBuilder(testStep));

        ProcessStepBuilder errorStep = process.AddStepFromType<ErrorStep>();
        process.OnError().SendEventTo(new ProcessFunctionTargetBuilder(errorStep, nameof(ErrorStep.GlobalErrorHandler)));

        KernelProcess processInstance = process.Build();
        Kernel kernel = new();

        // Act
        await using LocalKernelProcessContext runningProcess = await processInstance.StartAsync(kernel, new KernelProcessEvent() { Id = "Start" });

        // Assert
        Assert.True(kernel.Data.ContainsKey("error-global"));
        Assert.IsType<KernelProcessError>(kernel.Data["error-global"]);
    }

    /// <summary>
    /// Verify that the function level error handler has precedence over the process level error handler.
    /// </summary>
    [Fact]
    public async Task FunctionErrorHandlerTakesPrecedenceAsync()
    {
        // Arrange
        ProcessBuilder process = new(nameof(ProcessFunctionErrorHandledAsync));

        ProcessStepBuilder testStep = process.AddStepFromType<FailedStep>();
        process.OnInputEvent("Start").SendEventTo(new ProcessFunctionTargetBuilder(testStep));

        ProcessStepBuilder errorStep = process.AddStepFromType<ErrorStep>();
        testStep.OnFunctionError(nameof(FailedStep.TestFailure)).SendEventTo(new ProcessFunctionTargetBuilder(errorStep, nameof(ErrorStep.FunctionErrorHandler)));
        process.OnError().SendEventTo(new ProcessFunctionTargetBuilder(errorStep, nameof(ErrorStep.GlobalErrorHandler)));

        KernelProcess processInstance = process.Build();
        Kernel kernel = new();

        // Act
        await using LocalKernelProcessContext runningProcess = await processInstance.StartAsync(kernel, new KernelProcessEvent() { Id = "Start" });

        // Assert
        Assert.False(kernel.Data.ContainsKey("error-global"));
        Assert.True(kernel.Data.ContainsKey("error-function"));
        Assert.IsType<KernelProcessError>(kernel.Data["error-function"]);
    }

    /// <summary>
    /// A class that represents a step for testing.
    /// </summary>
    [Fact]
    public void ProcessWithSubprocessAndInvalidTargetThrows()
    {
        // Arrange
        ProcessBuilder process = new(nameof(ProcessWithSubprocessAndInvalidTargetThrows));

        ProcessBuilder subProcess = new("SubProcess");
        ProcessStepBuilder innerStep = subProcess.AddStepFromType<TestStep>("InnerStep");
        subProcess
            .OnInputEvent("Go")
            .SendEventTo(new ProcessFunctionTargetBuilder(innerStep));
        process
            .OnInputEvent("Start")
            .SendEventTo(subProcess.WhereInputEventIs("Go"));

        ProcessStepBuilder outerStep = process.AddStepFromType<TestStep>("OuterStep");
        innerStep
            .OnEvent(TestStep.EventId)
            .SendEventTo(new ProcessFunctionTargetBuilder(outerStep));

        KernelProcess processInstance = process.Build();
        Kernel kernel = new();
    }

    /// <summary>
    /// A class that represents a step for testing.
    /// </summary>
    private sealed class FailedStep : KernelProcessStep
    {
        /// <summary>
        /// A method that represents a function for testing.
        /// </summary>
        [KernelFunction]
        public void TestFailure()
        {
            throw new InvalidOperationException("I failed!");
        }
    }

    /// <summary>
    /// A class that represents a step for testing.
    /// </summary>
    private sealed class ErrorStep : KernelProcessStep
    {
        /// <summary>
        /// A method for unhandling failures at the process level.
        /// </summary>
        [KernelFunction]
        public void GlobalErrorHandler(KernelProcessError exception, Kernel kernel)
        {
            kernel.Data.Add("error-global", exception);
        }

        /// <summary>
        /// A method for unhandling failures at the function level.
        /// </summary>
        [KernelFunction]
        public void FunctionErrorHandler(KernelProcessError exception, Kernel kernel)
        {
            kernel.Data.Add("error-function", exception);
        }
    }

    /// <summary>
    /// A class that represents a step for testing.
    /// </summary>
    private sealed class TestStep : KernelProcessStep
    {
        public const string EventId = "Next";
        public const string Name = nameof(TestStep);

        [KernelFunction]
        public async Task TestFunctionAsync(KernelProcessStepContext context)
        {
            await context.EmitEventAsync(new() { Id = EventId });
        }
    }
}


===== Process.UnitTests\Runtime.Local\LocalProxyTests.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.Threading.Tasks;
using SemanticKernel.Process.TestsShared.CloudEvents;
using SemanticKernel.Process.TestsShared.Services;
using SemanticKernel.Process.TestsShared.Setup;
using SemanticKernel.Process.TestsShared.Steps;
using Xunit;

namespace Microsoft.SemanticKernel.Process.Runtime.Local.UnitTests;

/// <summary>
/// Unit tests for the <see cref="LocalProxy"/> class.
/// </summary>
public class LocalProxyTests
{
    private readonly string _topic1 = "myTopic1";
    private readonly string _topic2 = "MyTopic2";

    private readonly string _startProcessEvent = "startProcess";

    /// <summary>
    /// Validates the <see cref="LocalProxy"/> result called once and then after process stops
    /// </summary>
    [Fact]
    public async Task ProcessWithProxyWithSingleTopicCalledTwiceAsync()
    {
        // Arrange
        var mockProxyClient = new MockCloudEventClient();
        ProcessBuilder process = new(nameof(ProcessWithProxyWithSingleTopicCalledTwiceAsync));

        var counterStep = process.AddStepFromType<CommonSteps.CountStep>(id: nameof(ProcessWithProxyWithSingleTopicCalledTwiceAsync));
        var proxyStep = process.AddProxyStep(id: "proxy", [this._topic1, this._topic2]);

        process.OnInputEvent(this._startProcessEvent).SendEventTo(new(counterStep));
        counterStep.OnFunctionResult().EmitExternalEvent(proxyStep, this._topic1);

        KernelProcess processInstance = process.Build();
        CounterService counterService = new();
        Kernel kernel = KernelSetup.SetupKernelWithCounterService(counterService);

        // Act
        await using (LocalKernelProcessContext processContext = await this.RunProcessAsync(kernel, processInstance, null, this._startProcessEvent, externalMessageChannel: mockProxyClient))
        {
            // Assert
            var runningProcessId = await processContext.GetProcessIdAsync();

            Assert.NotNull(mockProxyClient);
            Assert.Equal(1, mockProxyClient.InitializationCounter);
            Assert.Equal(0, mockProxyClient.UninitializationCounter);
            Assert.Single(mockProxyClient.CloudEvents);
            Assert.Equal(this._topic1, mockProxyClient.CloudEvents[0].ExternalTopicName);
            Assert.Equal(runningProcessId, mockProxyClient.CloudEvents[0].ProcessId);
            Assert.Equal("1", mockProxyClient.CloudEvents[0].EventData?.ToObject());

            // Act
            await processContext.SendEventAsync(new() { Id = this._startProcessEvent, Data = null });

            // Assert
            Assert.NotNull(mockProxyClient);
            Assert.Equal(1, mockProxyClient.InitializationCounter);
            Assert.Equal(0, mockProxyClient.UninitializationCounter);
            Assert.Equal(2, mockProxyClient.CloudEvents.Count);
            Assert.Equal(this._topic1, mockProxyClient.CloudEvents[1].ExternalTopicName);
            Assert.Equal(runningProcessId, mockProxyClient.CloudEvents[0].ProcessId);
            Assert.Equal("2", mockProxyClient.CloudEvents[1].EventData?.ToObject());
        }
        Assert.Equal(1, mockProxyClient.UninitializationCounter);
    }

    /// <summary>
    /// Validates the <see cref="LocalProxy"/> fails when using unregistered topic
    /// </summary>
    [Fact]
    public void ProcessWithProxyFailsToCreateDueMissingTopicRegistration()
    {
        // Arrange
        var mockProxyClient = new MockCloudEventClient();
        ProcessBuilder process = new(nameof(ProcessWithProxyFailsToCreateDueMissingTopicRegistration));

        var counterStep = process.AddStepFromType<CommonSteps.CountStep>(id: nameof(ProcessWithProxyFailsToCreateDueMissingTopicRegistration));
        var proxyStep = process.AddProxyStep(id: "proxy", [this._topic1]);

        process.OnInputEvent(this._startProcessEvent).SendEventTo(new(counterStep));

        // Act & Assert
        Assert.Throws<InvalidOperationException>(() => counterStep.OnFunctionResult().EmitExternalEvent(proxyStep, this._topic2));
    }

    /// <summary>
    /// Validates the <see cref="LocalProxy"/> emits different topics from
    /// different steps
    /// </summary>
    [Fact]
    public async Task ProcessWithCyclesAndProxyWithTwoTopicsAsync()
    {
        // Arrange
        var mockProxyClient = new MockCloudEventClient();
        ProcessBuilder process = this.GetSampleProcessWithProxyEmittingTwoTopics(nameof(ProcessWithCyclesAndProxyWithTwoTopicsAsync), counterName: nameof(ProcessWithCyclesAndProxyWithTwoTopicsAsync));
        KernelProcess processInstance = process.Build();
        CounterService counterService = new();
        Kernel kernel = KernelSetup.SetupKernelWithCounterService(counterService);

        // Act
        await using (LocalKernelProcessContext processContext = await this.RunProcessAsync(kernel, processInstance, null, this._startProcessEvent, externalMessageChannel: mockProxyClient))
        {
            // Assert
            var runningProcessId = await processContext.GetProcessIdAsync();

            Assert.NotNull(mockProxyClient);
            Assert.True(0 < mockProxyClient.InitializationCounter);
            Assert.Equal(0, mockProxyClient.UninitializationCounter);
            Assert.Equal(3, mockProxyClient.CloudEvents.Count);
            Assert.Equal(this._topic1, mockProxyClient.CloudEvents[0].ExternalTopicName);
            Assert.Equal(runningProcessId, mockProxyClient.CloudEvents[0].ProcessId);
            Assert.Equal("1", mockProxyClient.CloudEvents[0].EventData?.ToObject());
            Assert.Equal(this._topic1, mockProxyClient.CloudEvents[1].ExternalTopicName);
            Assert.Equal("2", mockProxyClient.CloudEvents[1].EventData?.ToObject());
            Assert.Equal(this._topic2, mockProxyClient.CloudEvents[2].ExternalTopicName);
            Assert.Equal("2", mockProxyClient.CloudEvents[2].EventData?.ToObject());
        }

        // Assert
        Assert.Equal(1, mockProxyClient.UninitializationCounter);
    }

    /// <summary>
    /// Validates the <see cref="LocalProxy"/> emits different topics from
    /// different steps from a nested process
    /// </summary>
    [Fact]
    public async Task ProcessWithProxyIn2LevelsNestedProcessEmitsTwoTopicsAsync()
    {
        // Arrange
        var mockProxyClient = new MockCloudEventClient();
        ProcessBuilder process = new(nameof(ProcessWithProxyIn2LevelsNestedProcessEmitsTwoTopicsAsync));
        var innerProcess = process.AddStepFromProcess(this.GetSampleProcessWithProxyEmittingTwoTopics(
            $"Inner-{nameof(ProcessWithProxyIn2LevelsNestedProcessEmitsTwoTopicsAsync)}", counterName: nameof(ProcessWithProxyIn2LevelsNestedProcessEmitsTwoTopicsAsync)));

        process
            .OnInputEvent(this._startProcessEvent)
            .SendEventTo(innerProcess.WhereInputEventIs(this._startProcessEvent));

        KernelProcess processInstance = process.Build();
        CounterService counterService = new();
        Kernel kernel = KernelSetup.SetupKernelWithCounterService(counterService);

        // Act
        await using (LocalKernelProcessContext processContext = await this.RunProcessAsync(kernel, processInstance, null, this._startProcessEvent, externalMessageChannel: mockProxyClient))
        {
            // Assert
            var runningProcessId = await processContext.GetProcessIdAsync();

            Assert.NotNull(mockProxyClient);
            Assert.True(0 < mockProxyClient.InitializationCounter);
            Assert.Equal(0, mockProxyClient.UninitializationCounter);
            Assert.Equal(3, mockProxyClient.CloudEvents.Count);
            Assert.Equal(this._topic1, mockProxyClient.CloudEvents[0].ExternalTopicName);
            Assert.Equal(runningProcessId, mockProxyClient.CloudEvents[0].ProcessId);
            Assert.Equal("1", mockProxyClient.CloudEvents[0].EventData?.ToObject());
            Assert.Equal(this._topic1, mockProxyClient.CloudEvents[1].ExternalTopicName);
            Assert.Equal("2", mockProxyClient.CloudEvents[1].EventData?.ToObject());
            Assert.Equal(this._topic2, mockProxyClient.CloudEvents[2].ExternalTopicName);
            Assert.Equal("2", mockProxyClient.CloudEvents[2].EventData?.ToObject());
        }

        // Assert
        Assert.Equal(1, mockProxyClient.UninitializationCounter);
    }

    /// <summary>
    /// Validates the <see cref="LocalProxy"/> emits different topics from
    /// different steps from a deep nested process
    /// </summary>
    [Fact]
    public async Task ProcessWithProxyIn4LevelsNestedProcessEmitsTwoTopicsAsync()
    {
        // Arrange
        var mockProxyClient = new MockCloudEventClient();
        ProcessBuilder process = new(nameof(ProcessWithProxyIn4LevelsNestedProcessEmitsTwoTopicsAsync));
        var innerProcess = process.AddStepFromProcess(
            this.GetNestedProcess(
                processName: $"Inner1-{nameof(ProcessWithProxyIn4LevelsNestedProcessEmitsTwoTopicsAsync)}",
                internalProcess: this.GetSampleProcessWithProxyEmittingTwoTopics(
                    $"Inner2-{nameof(ProcessWithProxyIn4LevelsNestedProcessEmitsTwoTopicsAsync)}",
                    $"Inner2_{nameof(ProcessWithProxyIn4LevelsNestedProcessEmitsTwoTopicsAsync)}"),
                inputEventName: this._startProcessEvent,
                counterName: $"Inner1_{nameof(ProcessWithProxyIn4LevelsNestedProcessEmitsTwoTopicsAsync)}"));

        process
            .OnInputEvent(this._startProcessEvent)
            .SendEventTo(innerProcess.WhereInputEventIs(this._startProcessEvent));

        KernelProcess processInstance = process.Build();
        CounterService counterService = new();
        Kernel kernel = KernelSetup.SetupKernelWithCounterService(counterService);

        // Act
        await using (LocalKernelProcessContext processContext = await this.RunProcessAsync(kernel, processInstance, null, this._startProcessEvent, externalMessageChannel: mockProxyClient))
        {
            // Assert
            var runningProcessId = await processContext.GetProcessIdAsync();

            Assert.NotNull(mockProxyClient);
            Assert.True(0 < mockProxyClient.InitializationCounter);
            Assert.Equal(0, mockProxyClient.UninitializationCounter);
            Assert.Equal(3, mockProxyClient.CloudEvents.Count);
            Assert.Equal(this._topic1, mockProxyClient.CloudEvents[0].ExternalTopicName);
            Assert.Equal(runningProcessId, mockProxyClient.CloudEvents[0].ProcessId);
            Assert.Equal("1", mockProxyClient.CloudEvents[0].EventData?.ToObject());
            Assert.Equal(this._topic1, mockProxyClient.CloudEvents[1].ExternalTopicName);
            Assert.Equal("2", mockProxyClient.CloudEvents[1].EventData?.ToObject());
            Assert.Equal(this._topic2, mockProxyClient.CloudEvents[2].ExternalTopicName);
            Assert.Equal("2", mockProxyClient.CloudEvents[2].EventData?.ToObject());
        }

        // Assert
        Assert.Equal(1, mockProxyClient.UninitializationCounter);
    }

    private ProcessBuilder GetNestedProcess(string processName, ProcessBuilder internalProcess, string inputEventName, string counterName)
    {
        ProcessBuilder process = new(processName);
        var innerProcess = process.AddStepFromProcess(this.GetSampleProcessWithProxyEmittingTwoTopics($"Inner-{processName}", counterName));

        process
            .OnInputEvent(inputEventName)
            .SendEventTo(innerProcess.WhereInputEventIs(inputEventName));

        return process;
    }

    private ProcessBuilder GetSampleProcessWithProxyEmittingTwoTopics(string processName, string counterName)
    {
        ProcessBuilder process = new(processName);

        var counterStep = process.AddStepFromType<CommonSteps.CountStep>(id: counterName);
        var evenNumberStep = process.AddStepFromType<CommonSteps.EvenNumberDetectorStep>();
        var proxyStep = process.AddProxyStep(id: "proxy", [this._topic1, this._topic2]);

        process
            .OnInputEvent(this._startProcessEvent)
            .SendEventTo(new(counterStep));

        counterStep
            .OnFunctionResult()
            .EmitExternalEvent(proxyStep, this._topic1)
            .SendEventTo(new ProcessFunctionTargetBuilder(evenNumberStep));

        // request another number if number is odd
        evenNumberStep
            .OnEvent(CommonSteps.EvenNumberDetectorStep.OutputEvents.OddNumber)
            .SendEventTo(new ProcessFunctionTargetBuilder(counterStep));

        evenNumberStep
            .OnEvent(CommonSteps.EvenNumberDetectorStep.OutputEvents.EvenNumber)
            .EmitExternalEvent(proxyStep, this._topic2);

        return process;
    }

    private async Task<LocalKernelProcessContext> RunProcessAsync(Kernel kernel, KernelProcess process, object? input, string inputEvent, IExternalKernelProcessMessageChannel? externalMessageChannel)
    {
        return
            await process.StartAsync(
                kernel,
                new KernelProcessEvent
                {
                    Id = inputEvent,
                    Data = input,
                },
                externalMessageChannel);
    }
}


===== Process.UnitTests\Steps\AStep.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Threading.Tasks;

namespace Microsoft.SemanticKernel.Process.UnitTests.Steps;

/// <summary>
/// A step in the process.
/// </summary>
public sealed class AStep : KernelProcessStep
{
    [KernelFunction]
    public async ValueTask DoItAsync(KernelProcessStepContext context)
    {
        Console.WriteLine("##### AStep ran.");
        await Task.Delay(TimeSpan.FromSeconds(1));
        await context.EmitEventAsync(CommonEvents.AStepDone, "I did A");
    }
}


===== Process.UnitTests\Steps\BStep.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Threading.Tasks;

namespace Microsoft.SemanticKernel.Process.UnitTests.Steps;

/// <summary>
/// A step in the process.
/// </summary>
public sealed class BStep : KernelProcessStep
{
    [KernelFunction]
    public async ValueTask DoItAsync(KernelProcessStepContext context)
    {
        Console.WriteLine("##### BStep ran.");
        await Task.Delay(TimeSpan.FromSeconds(2));
        await context.EmitEventAsync(new() { Id = CommonEvents.BStepDone, Data = "I did B" });
    }
}


===== Process.UnitTests\Steps\CommonEvents.cs =====

// Copyright (c) Microsoft. All rights reserved.

namespace Microsoft.SemanticKernel.Process.UnitTests.Steps;

/// <summary>
/// Common Events used in the process.
/// </summary>
public static class CommonEvents
{
    public const string UserInputReceived = nameof(UserInputReceived);
    public const string CompletionResponseGenerated = nameof(CompletionResponseGenerated);
    public const string WelcomeDone = nameof(WelcomeDone);
    public const string AStepDone = nameof(AStepDone);
    public const string BStepDone = nameof(BStepDone);
    public const string CStepDone = nameof(CStepDone);
    public const string StartARequested = nameof(StartARequested);
    public const string StartBRequested = nameof(StartBRequested);
    public const string ExitRequested = nameof(ExitRequested);
    public const string StartProcess = nameof(StartProcess);
}


===== Process.UnitTests\Steps\CStep.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Runtime.Serialization;
using System.Threading.Tasks;

namespace Microsoft.SemanticKernel.Process.UnitTests.Steps;

/// <summary>
/// A stateful step in the process. This step uses <see cref="CStepState"/> as the persisted
/// state object and overrides the ActivateAsync method to initialize the state when activated.
/// </summary>
public sealed class CStep : KernelProcessStep<CStep.CStepState>
{
    private CStepState? _state;

    // ################ Using persisted state #################
    // CStep has state that we want to be persisted in the process. To ensure that the step always
    // starts with the previously persisted or configured state, we need to override the ActivateAsync
    // method and use the state object it provides.
    public override ValueTask ActivateAsync(KernelProcessStepState<CStepState> state)
    {
        this._state = state.State!;
        Console.WriteLine($"##### CStep activated with Cycle = '{state.State?.CurrentCycle}'.");
        return base.ActivateAsync(state);
    }

    [KernelFunction]
    public async ValueTask DoItAsync(KernelProcessStepContext context, string astepdata, string bstepdata)
    {
        // ########### This method will restart the process in a loop until CurrentCycle >= 3 ###########
        this._state!.CurrentCycle++;
        if (this._state.CurrentCycle >= 3)
        {
            // Exit the processes
            Console.WriteLine("##### CStep run cycle 3 - exiting.");
            await context.EmitEventAsync(new() { Id = CommonEvents.ExitRequested });
            return;
        }

        // Cycle back to the start
        Console.WriteLine($"##### CStep run cycle {this._state.CurrentCycle}.");
        await context.EmitEventAsync(new() { Id = CommonEvents.CStepDone });
    }

    /// <summary>
    /// A state object for the CStep.
    /// </summary>
    [DataContract]
    public sealed record CStepState
    {
        [DataMember]
        public int CurrentCycle { get; set; }
    }
}


===== Process.UnitTests\Steps\KickoffStep.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Threading.Tasks;

namespace Microsoft.SemanticKernel.Process.UnitTests.Steps;

/// <summary>
/// Kick off step for the process.
/// </summary>
public sealed class KickoffStep : KernelProcessStep
{
    public static class ProcessFunctions
    {
        public const string KickOff = nameof(KickOff);
    }

    [KernelFunction(ProcessFunctions.KickOff)]
    public async ValueTask PrintWelcomeMessageAsync(KernelProcessStepContext context)
    {
        Console.WriteLine("##### Kickoff ran.");
        await context.EmitEventAsync(new() { Id = CommonEvents.StartARequested, Data = "Get Going" });
    }
}


===== Process.UnitTests\Steps\ProductInfoProvider.cs =====

// Copyright (c) Microsoft. All rights reserved.

using Microsoft.SemanticKernel;

namespace SemanticKernel.Process.UnitTests.Steps;

public class ProductInfoProvider : KernelProcessStep
{
    [KernelFunction]
    public string GetProductInfo()
    {
        return
            """
            Product Description:
            GlowBrew is a revolutionary AI driven coffee machine with industry leading number of LEDs and programmable light shows. The machine is also capable of brewing coffee and has a built in grinder.

            Product Features:
            1. **Luminous Brew Technology**: Customize your morning ambiance with programmable LED lights that sync with your brewing process.
            2. **AI Taste Assistant**: Learns your taste preferences over time and suggests new brew combinations to explore.
            3. **Gourmet Aroma Diffusion**: Built-in aroma diffusers enhance your coffee's scent profile, energizing your senses before the first sip.

            Troubleshooting:
            - **Issue**: LED Lights Malfunctioning
                - **Solution**: Reset the lighting settings via the app. Ensure the LED connections inside the GlowBrew are secure. Perform a factory reset if necessary.
            """;
    }
}


===== Process.Utilities.UnitTests\CloneTests.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Process.Internal;
using Xunit;

namespace SemanticKernel.Process.Utilities.UnitTests;

/// <summary>
/// Unit tests for the ability to clone:
/// - <see cref="KernelProcessStepState"/>.
/// - <see cref="KernelProcessStepInfo"/>.
/// - <see cref="KernelProcess"/>.
/// </summary>
public class CloneTests
{
    /// <summary>
    /// Verify result of cloning <see cref="KernelProcessStepState"/>.
    /// </summary>
    [Fact]
    public void VerifyCloneStepStateTest()
    {
        // Arrange
        KernelProcessStepState state = new(nameof(VerifyCloneStepStateTest), "v1", "test");

        // Act
        KernelProcessStepState copy = state.Clone(typeof(KernelProcessStepState), null, NullLogger.Instance);

        // Assert
        Assert.Equal(state, copy);
    }

    /// <summary>
    /// Verify result of cloning <see cref="KernelProcessStepState{TState}"/>.
    /// </summary>
    [Fact]
    public void VerifyCloneTypedStepStateTest()
    {
        // Arrange
        KernelProcessStepState<TestState> state = new(nameof(VerifyCloneTypedStepStateTest), "v1", "test") { State = new TestState() };

        // Act
        KernelProcessStepState copy = state.Clone(state.GetType(), typeof(TestState), NullLogger.Instance);

        // Assert
        Assert.Equal(state, copy);
    }

    /// <summary>
    /// Verify result of cloning a simple <see cref="KernelProcessStepInfo"/>.
    /// </summary>
    [Fact]
    public void VerifyCloneSimpleStepTest()
    {
        // Arrange
        KernelProcessStepInfo source = new(typeof(KernelProcessStep), new(nameof(VerifyCloneSimpleStepTest), "v1", "test"), []);

        // Act
        KernelProcessStepInfo copy = source.Clone(NullLogger.Instance);

        // Assert
        Assert.Equivalent(source, copy);
    }

    /// <summary>
    /// Verify result of cloning a <see cref="KernelProcessStepInfo"/> with typed state and edges.
    /// </summary>
    [Fact]
    public void VerifyCloneRealStepTest()
    {
        // Arrange
        KernelProcessStepState<TestState> state = new(nameof(VerifyCloneRealStepTest), "v1", "test") { State = new TestState() };
        KernelProcessStepInfo source = new(typeof(KernelProcessStep<TestState>), state, CreateTestEdges());

        // Act
        KernelProcessStepInfo copy = source.Clone(NullLogger.Instance);

        // Assert
        Assert.Equivalent(source, copy);
    }

    /// <summary>
    /// Verify result of cloning a <see cref="KernelProcess"/>.
    /// </summary>
    [Fact]
    public void VerifyCloneSingleProcessTest()
    {
        // Arrange
        KernelProcessStepInfo step = new(typeof(KernelProcessStep), new(nameof(VerifyCloneSingleProcessTest), "v1", "teststep"), []);
        KernelProcessState processState = new(nameof(VerifyCloneSingleProcessTest), "v1", "test");
        KernelProcess source = new(processState, [step], CreateTestEdges());

        // Act
        KernelProcess copy = source.CloneProcess(NullLogger.Instance);

        // Assert
        VerifyProcess(source, copy);
    }

    /// <summary>
    /// Verify result of cloning a <see cref="KernelProcess"/> with a subprocess.
    /// </summary>
    [Fact]
    public void VerifyCloneNestedProcessTest()
    {
        // Arrange
        KernelProcessStepInfo step = new(typeof(KernelProcessStep), new(nameof(VerifyCloneNestedProcessTest), "teststep"), []);
        KernelProcess subProcess = new(new(nameof(VerifyCloneNestedProcessTest), "v2", "inner"), [step], CreateTestEdges());
        KernelProcess source = new(new(nameof(VerifyCloneNestedProcessTest), "v1", "outer"), [subProcess], []);

        // Act
        KernelProcess copy = source.CloneProcess(NullLogger.Instance);

        // Assert
        VerifyProcess(source, copy);
    }

    /// <summary>
    /// Verify result of cloning a <see cref="KernelProcess"/> with a <see cref="KernelProcessMap"/>.
    /// </summary>
    [Fact]
    public void VerifyCloneMapStepTest()
    {
        // Arrange
        KernelProcessStepInfo step = new(typeof(KernelProcessStep), new(nameof(VerifyCloneNestedProcessTest), "v1", "teststep"), []);
        KernelProcess mapOperation = new(new(nameof(VerifyCloneNestedProcessTest), "v1", "operation"), [step], CreateTestEdges());
        KernelProcessMap mapStep = new(new(nameof(VerifyCloneNestedProcessTest), "v1", "map"), mapOperation, CreateTestEdges());
        KernelProcess source = new(new(nameof(VerifyCloneNestedProcessTest), "v1", "outer"), [mapStep], []);

        // Act
        KernelProcess copy = source.CloneProcess(NullLogger.Instance);

        // Assert
        VerifyProcess(source, copy);
    }

    private static void VerifyProcess(KernelProcess expected, KernelProcess actual)
    {
        Assert.Equal(expected.State.Id, actual.State.Id);
        Assert.Equal(expected.State.Name, actual.State.Name);
        Assert.Equal(expected.State.Version, actual.State.Version);
        Assert.Equal(expected.InnerStepType, actual.InnerStepType);
        Assert.Equivalent(expected.Edges, actual.Edges);
        foreach (var (expectedStep, actualStep) in expected.Steps.Zip(actual.Steps))
        {
            if (expectedStep is KernelProcess subProcess)
            {
                Assert.IsType<KernelProcess>(subProcess);
                VerifyProcess(subProcess, (KernelProcess)actualStep);
            }
            else
            {
                Assert.Equivalent(expectedStep, actualStep);
            }
        }
    }

    private static Dictionary<string, List<KernelProcessEdge>> CreateTestEdges() =>
        new()
        {
            {
                "sourceId",
                [
                    new KernelProcessEdge("sourceId", new KernelProcessFunctionTarget("sourceId", "targetFunction", "targetParameter", "targetEventId")),
                ]
            }
        };

    private sealed record TestState
    {
        public Guid Value { get; set; }
    };
}


===== Process.Utilities.UnitTests\ProcessTypeExtensionsTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Process.Internal;
using Xunit;

namespace SemanticKernel.Process.Utilities.UnitTests;

/// <summary>
/// Unit tests for the <see cref="KernelProcessStepExtensions"/> class.
/// </summary>
public class ProcessTypeExtensionsTests
{
    private sealed class TestState { }
    private class TestStep : KernelProcessStep<TestState> { }
    private sealed class DerivedTestStep : TestStep { }
    private sealed class NonStep { }
    private sealed class NonGenericStep : KernelProcessStep { }

    /// <summary>
    /// Verify that TryGetSubtypeOfStatefulStep returns true and the correct type when the type is a direct subtype of KernelProcessStep.
    /// </summary>
    [Fact]
    public void TryGetSubtypeOfStatefulStepDirectSubtypeReturnsTrue()
    {
        // Arrange
        Type type = typeof(TestStep);

        // Act
        bool result = type.TryGetSubtypeOfStatefulStep(out Type? genericStateType);

        // Assert
        Assert.True(result);
        Assert.NotNull(genericStateType);
        Assert.Equal(typeof(KernelProcessStep<TestState>), genericStateType);
    }

    /// <summary>
    /// Verify that TryGetSubtypeOfStatefulStep returns true and the correct type when the type is a subtype of a subtype of KernelProcessStep.
    /// </summary>
    [Fact]
    public void TryGetSubtypeOfStatefulStepInheritedSubtypeReturnsTrue()
    {
        // Arrange
        Type type = typeof(DerivedTestStep);

        // Act
        bool result = type.TryGetSubtypeOfStatefulStep(out Type? genericStateType);

        // Assert
        Assert.True(result);
        Assert.NotNull(genericStateType);
        Assert.Equal(typeof(KernelProcessStep<TestState>), genericStateType);
    }

    /// <summary>
    /// Verify that TryGetSubtypeOfStatefulStep returns false when the type is not a subtype of KernelProcessStep.
    /// </summary>
    [Fact]
    public void TryGetSubtypeOfStatefulStepNotASubtypeReturnsFalse()
    {
        // Arrange
        Type type = typeof(NonStep);

        // Act
        bool result = type.TryGetSubtypeOfStatefulStep(out Type? genericStateType);

        // Assert
        Assert.False(result);
        Assert.Null(genericStateType);
    }

    /// <summary>
    /// Verify that TryGetSubtypeOfStatefulStep returns false when the type is not a subtype of KernelProcessStep.
    /// </summary>
    [Fact]
    public void TryGetSubtypeOfStatefulStepNotAGenericSubtypeReturnsFalse()
    {
        // Arrange
        Type type = typeof(NonGenericStep);

        // Act
        bool result = type.TryGetSubtypeOfStatefulStep(out Type? genericStateType);

        // Assert
        Assert.False(result);
        Assert.Null(genericStateType);
    }

    /// <summary>
    /// Verify that TryGetSubtypeOfStatefulStep returns false when the type is null.
    /// </summary>
    [Fact]
    public void TryGetSubtypeOfStatefulStepNullTypeReturnsFalse()
    {
        // Arrange
        Type? type = null;

        // Act
        bool result = type.TryGetSubtypeOfStatefulStep(out Type? genericStateType);

        // Assert
        Assert.False(result);
        Assert.Null(genericStateType);
    }
}


