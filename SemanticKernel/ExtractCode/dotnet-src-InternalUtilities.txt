
===== agents\Extensions\AgentExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Diagnostics.CodeAnalysis;

namespace Microsoft.SemanticKernel.Agents.Extensions;

/// <summary>
/// Extension methods for <see cref="Agent"/>.
/// </summary>
[ExcludeFromCodeCoverage]
internal static class AgentExtensions
{
    /// <summary>
    /// Provides a name for the agent, even if it's the identifier.
    /// (since <see cref="Agent.Name"/> allows null)
    /// </summary>
    /// <param name="agent">The target agent</param>
    /// <returns>The agent name as a non-empty string</returns>
    public static string GetName(this Agent agent) => agent.Name ?? agent.Id;

    /// <summary>
    /// Provides the display name of the agent.
    /// </summary>
    /// <param name="agent">The target agent</param>
    /// <remarks>
    /// Currently, it's intended for telemetry purposes only.
    /// </remarks>
    public static string GetDisplayName(this Agent agent) => !string.IsNullOrWhiteSpace(agent.Name) ? agent.Name! : "UnnamedAgent";

    /// <summary>
    /// Gets the kernel scoped to the current invocation.
    /// </summary>
    /// <param name="agent">The <see cref="Agent"/> whose kernel is used as a fallback if <paramref name="options"/> does not specify one.</param>
    /// <param name="options">The <see cref="AgentInvokeOptions"/> instance containing invocation-specific options. May be <c>null</c>.</param>
    /// <returns>
    /// The <see cref="Kernel"/> instance to use for the current invocation. Returns the kernel from <paramref name="options"/> if specified; otherwise, returns the kernel from <paramref name="agent"/>.
    /// </returns>
    public static Kernel GetKernel(this Agent agent, AgentInvokeOptions? options) => options?.Kernel ?? agent.Kernel;
}


===== agents\Extensions\KernelFunctionMetadataExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.Collections.Generic;

namespace Microsoft.SemanticKernel.Agents;

internal static class KernelFunctionMetadataExtensions
{
    /// <summary>
    /// Transform the function parameter metadata into a binary parameter spec.
    /// </summary>
    /// <param name="metadata">The function meta-data</param>
    /// <returns>The parameter spec as <see cref="BinaryData"/></returns>
    internal static BinaryData CreateParameterSpec(this KernelFunctionMetadata metadata)
    {
        JsonSchemaFunctionParameters parameterSpec = new();
        List<string> required = new(metadata.Parameters.Count);

        foreach (var parameter in metadata.Parameters)
        {
            if (parameter.IsRequired)
            {
                parameterSpec.Required.Add(parameter.Name);
            }

            if (parameter.Schema is null)
            {
                throw new KernelException($"Unsupported function parameter: {metadata.PluginName ?? "*"}.{metadata.Name}.{parameter.Name}");
            }

            parameterSpec.Properties.Add(parameter.Name, parameter.Schema);
        }

        return BinaryData.FromObjectAsJson(parameterSpec);
    }
}


===== arguments\Extensions\KernelArgumentsExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Linq;

namespace Microsoft.SemanticKernel.Arguments.Extensions;

/// <summary>
/// Extensions for <see cref="KernelArguments"/>
/// </summary>
internal static class KernelArgumentsExtensions
{
    private static readonly Dictionary<string, PromptExecutionSettings> s_emptySettings = [];

    /// <summary>
    /// Provides a merged instance of <see cref="KernelArguments"/> with precedence for override arguments.
    /// </summary>
    /// <param name="primaryArguments">Primary arguments to merge. This is the base set of arguments.</param>
    /// <param name="overrideArguments">The override arguments.</param>
    /// <remarks>
    /// This merge preserves original <see cref="PromptExecutionSettings"/> and <see cref="KernelArguments"/> parameters.
    /// It allows for incremental addition or replacement of specific parameters while also preserving the ability
    /// to override the execution settings.
    /// </remarks>
    internal static KernelArguments Merge(this KernelArguments? primaryArguments, KernelArguments? overrideArguments)
    {
        // Avoid merge when override arguments are not set.
        if (overrideArguments is null)
        {
            return primaryArguments ?? [];
        }

        // Avoid merge when the Agent arguments are not set.
        if (primaryArguments is null)
        {
            return overrideArguments ?? [];
        }

        // Both instances are not null, merge with precedence for override arguments.

        // Merge execution settings with precedence for override arguments.
        Dictionary<string, PromptExecutionSettings>? settings =
            (overrideArguments.ExecutionSettings ?? s_emptySettings)
                .Concat(primaryArguments.ExecutionSettings ?? s_emptySettings)
                .GroupBy(entry => entry.Key)
                .ToDictionary(entry => entry.Key, entry => entry.First().Value);

        // Merge parameters with precedence for override arguments.
        Dictionary<string, object?>? parameters =
            overrideArguments
                .Concat(primaryArguments)
                .GroupBy(entry => entry.Key)
                .ToDictionary(entry => entry.Key, entry => entry.First().Value);

        return new KernelArguments(parameters, settings);
    }
}


===== azure\Policies\GeneratedActionPipelinePolicy.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Diagnostics.CodeAnalysis;
using System.Threading.Tasks;
using Azure.Core;
using Azure.Core.Pipeline;

/// <summary>
/// Generic action pipeline policy for processing messages.
/// </summary>
[ExcludeFromCodeCoverage]
internal sealed class GenericActionPipelinePolicy : HttpPipelinePolicy
{
    private readonly Action<HttpMessage> _processMessageAction;

    internal GenericActionPipelinePolicy(Action<HttpMessage> processMessageAction)
    {
        this._processMessageAction = processMessageAction;
    }

    public override void Process(HttpMessage message, ReadOnlyMemory<HttpPipelinePolicy> pipeline)
    {
        this._processMessageAction(message);
    }

    public override ValueTask ProcessAsync(HttpMessage message, ReadOnlyMemory<HttpPipelinePolicy> pipeline)
    {
        this._processMessageAction(message);
        return new ValueTask(Task.CompletedTask); // .NET STD 2.0 compatibility
    }
}


===== azure\workflow\ClientOptions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Threading.Tasks;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Microsoft.SemanticKernel.Agents.AzureAI;

/// <summary>
/// RoutingPolicy for managing Foundry Workflows.
/// </summary>
public class HttpPipelineRoutingPolicy : HttpPipelinePolicy
{
    private readonly Uri _endpoint;
    private readonly string _apiVersion;

    /// <summary>
    /// Initializes a new instance of the <see cref="HttpPipelineRoutingPolicy"/> class.
    /// </summary>
    /// <param name="endpoint">The endpoint URI.</param>
    /// <param name="apiVersion">The API version.</param>
    public HttpPipelineRoutingPolicy(Uri endpoint, string apiVersion)
    {
        this._endpoint = endpoint ?? throw new ArgumentNullException(nameof(endpoint));
        this._apiVersion = apiVersion ?? throw new ArgumentNullException(nameof(apiVersion));
    }

    /// <summary>
    /// Processes the HTTP message and routes it as needed.
    /// </summary>
    /// <param name="message">The HTTP message.</param>
    /// <param name="pipeline">The pipeline policies.</param>
    public override void Process(HttpMessage message, ReadOnlyMemory<HttpPipelinePolicy> pipeline)
    {
        this.Process(message);

        ProcessNext(message, pipeline);
    }

    /// <summary>
    /// Asynchronously processes the HTTP message and routes it as needed.
    /// </summary>
    /// <param name="message">The HTTP message.</param>
    /// <param name="pipeline">The pipeline policies.</param>
    /// <returns>A <see cref="ValueTask"/> representing the asynchronous operation.</returns>
    public override ValueTask ProcessAsync(HttpMessage message, ReadOnlyMemory<HttpPipelinePolicy> pipeline)
    {
        this.Process(message);

        return ProcessNextAsync(message, pipeline);
    }

    /// <summary>
    /// Processes the HTTP message and updates its URI for routing.
    /// </summary>
    /// <param name="message">The HTTP message.</param>
    public void Process(HttpMessage message)
    {
        if (message.Request.Uri is null)
        {
            throw new ArgumentException(nameof(message.Request.Uri));
        }
        else if (message.Request.Uri.ToUri().IsLoopback)
        {
            message.Request.Uri.Reset(new Uri(string.Format($"{this._endpoint.ToString().TrimEnd('/')}/{message.Request.Uri.ToUri().AbsolutePath.TrimStart('/')}?api-version={this._apiVersion}")));
        }

        message.Request.Uri.Reset(message.Request.Uri.ToUri().Reroute(apiVersion: this._apiVersion, isWorkflow: message.Request.Content!.IsWorkflow()));
    }
}

/// <summary>
/// Pipeline policy for routing requests in the Foundry pipeline.
/// </summary>
public class PipelineRoutingPolicy : PipelinePolicy
{
    private readonly Uri _endpoint;
    private readonly string _apiVersion;

    /// <summary>
    /// Initializes a new instance of the <see cref="PipelineRoutingPolicy"/> class.
    /// </summary>
    /// <param name="endpoint">The endpoint URI.</param>
    /// <param name="apiVersion">The API version.</param>
    public PipelineRoutingPolicy(Uri endpoint, string apiVersion)
    {
        this._endpoint = endpoint ?? throw new ArgumentNullException(nameof(endpoint));
        this._apiVersion = apiVersion ?? throw new ArgumentNullException(nameof(apiVersion));
    }

    /// <summary>
    /// Processes the pipeline message and routes it as needed.
    /// </summary>
    /// <param name="message">The pipeline message.</param>
    /// <param name="pipeline">The pipeline policies.</param>
    /// <param name="currentIndex">The current index in the pipeline.</param>
    public override void Process(PipelineMessage message, IReadOnlyList<PipelinePolicy> pipeline, int currentIndex)
    {
        this.ProcessRequest(message.Request);
        ProcessNext(message, pipeline, currentIndex);
    }

    /// <summary>
    /// Asynchronously processes the pipeline message and routes it as needed.
    /// </summary>
    /// <param name="message">The pipeline message.</param>
    /// <param name="pipeline">The pipeline policies.</param>
    /// <param name="currentIndex">The current index in the pipeline.</param>
    /// <returns>A <see cref="ValueTask"/> representing the asynchronous operation.</returns>
    public override async ValueTask ProcessAsync(PipelineMessage message, IReadOnlyList<PipelinePolicy> pipeline, int currentIndex)
    {
        this.ProcessRequest(message.Request);
        await ProcessNextAsync(message, pipeline, currentIndex).ConfigureAwait(false);
    }

    private void ProcessRequest(PipelineRequest request)
    {
        if (request.Uri is null)
        {
            throw new InvalidOperationException($"{nameof(request.Uri)} cannot be null");
        }
        else if (request.Uri.IsLoopback)
        {
            request.Uri = new Uri(string.Format($"{this._endpoint.ToString().TrimEnd('/')}/{request.Uri.AbsolutePath.TrimStart('/')}?api-version={this._apiVersion}"));
        }

        request.Uri = request.Uri.Reroute(apiVersion: this._apiVersion, isWorkflow: request.Content!.IsWorkflow());
    }
}


===== azure\workflow\UriExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using Azure.Core;

namespace Microsoft.SemanticKernel.Agents.AzureAI;

/// <summary>
/// Extensions for rerouting URIs for Azure AI Agents and Workflows.
/// </summary>
internal static class FoundryWorkflowHelperExtensions
{
    /// <summary>
    /// Reroutes the specified URI for workflow or agent endpoints, updating the API version and path as needed.
    /// </summary>
    /// <param name="uri">The original URI.</param>
    /// <param name="apiVersion">The API version to use.</param>
    /// <param name="isWorkflow">Indicates if the URI should be rewritten for a workflow.</param>
    /// <returns>The rerouted <see cref="Uri"/>.</returns>
    public static Uri Reroute(this Uri uri, string apiVersion, bool isWorkflow)
    {
        UriBuilder uriBuilder = new(uri);

        // Check if URI contains "run" and body contains assistant_id starting with "wf_"
        bool isRunOrAgentPath =
           uri.ToString().Contains("runs", StringComparison.OrdinalIgnoreCase) ||
           uri.AbsolutePath.EndsWith("/agents", StringComparison.OrdinalIgnoreCase);

        bool isWorkflowInstance =
            uri.AbsolutePath.Contains("/wf_agent");

        bool shouldRewriteToWorkflow =
            (isRunOrAgentPath && isWorkflow) || isWorkflowInstance;

        if (shouldRewriteToWorkflow)
        {
            // 1RP
            if (uriBuilder.Host.EndsWith("services.ai.azure.com", StringComparison.OrdinalIgnoreCase))
            {
                var items = new ArrayList(uriBuilder.Path.Split(['/'], options: StringSplitOptions.RemoveEmptyEntries));
                if (items.Count > 3)
                {
                    items.Insert(3, "workflows");
                }

                uriBuilder.Path = string.Join("/", items.ToArray());
            }
            else
            {
                // Non-1RP (Machine Learning RP)
                uriBuilder.Path = Regex.Replace(uriBuilder.Path, "/agents/v1.0", "/workflows/v1.0", RegexOptions.IgnoreCase);
            }
        }

        // Remove the "/openai" request URI infix, if present
        uriBuilder.Path = Regex.Replace(uriBuilder.Path, "/openai", string.Empty);

        // Substitute the Azure AI Agents api-version where the default AOAI one is
        uriBuilder.Query = Regex.Replace(uriBuilder.Query, "api-version=[^&]*", $"api-version={apiVersion}");

        // Ensure file search citation result content is always requested on run steps
        if (!uriBuilder.Query.Contains("include[]"))
        {
            uriBuilder.Query += "&include[]=step_details.tool_calls[*].file_search.results[*].content";
        }

        return uriBuilder.Uri;
    }

    /// <summary>
    /// Determines whether the <see cref="RequestContent"/> contains a workflow pattern.
    /// </summary>
    /// <param name="content">The request content.</param>
    /// <returns><c>true</c> if the content contains a workflow pattern; otherwise, <c>false</c>.</returns>
    public static bool IsWorkflow(this RequestContent content)
    {
        return IsWorkflowInternal(content, (c, s) => c?.WriteTo(s, default));
    }

    /// <summary>
    /// Determines whether the <see cref="System.ClientModel.BinaryContent"/> contains a workflow pattern.
    /// </summary>
    /// <param name="content">The binary content.</param>
    /// <returns><c>true</c> if the content contains a workflow pattern; otherwise, <c>false</c>.</returns>
    public static bool IsWorkflow(this System.ClientModel.BinaryContent content)
    {
        return IsWorkflowInternal(content, (c, s) => c?.WriteTo(s, default));
    }

    private static bool IsWorkflowInternal<T>(T content, Action<T, Stream> writeToStream)
    {
#pragma warning disable CA1031 // Do not catch general exception types
        try
        {
            using var stream = new MemoryStream();
            writeToStream(content, stream);
            return StreamContainsWorkflowPattern(stream, @"""assistant_id"":""wf_", @"""workflow_version");
        }
        catch
        {
            // ignore
        }
#pragma warning restore CA1031 // Do not catch general exception types
        return false;
    }

    private static bool StreamContainsWorkflowPattern(Stream stream, params string[] bodies)
    {
        var patterns = bodies.Select(b => Encoding.UTF8.GetBytes(b)).ToArray();
        stream.Position = 0;
        int b;
        var matchIndexes = new int[patterns.Length];
        while ((b = stream.ReadByte()) != -1)
        {
            for (int i = 0; i < patterns.Length; i++)
            {
                if (b == patterns[i][matchIndexes[i]])
                {
                    matchIndexes[i]++;
                    if (matchIndexes[i] == patterns[i].Length)
                    {
                        return true;
                    }
                }
                else
                {
                    matchIndexes[i] = (b == patterns[i][0]) ? 1 : 0;
                }
            }
        }
        return false;
    }

    private static bool Contains(this string source, string value, StringComparison comparison)
    {
#if NETCOREAPP3_0_OR_GREATER
        return source.Contains(value, comparison);
#else
        return source.IndexOf(value, comparison) >= 0;
#endif
    }
}


===== connectors\AI\FunctionCalling\FunctionCallsProcessor.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Text.Encodings.Web;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.SemanticKernel.ChatCompletion;

namespace Microsoft.SemanticKernel.Connectors.FunctionCalling;

/// <summary>
/// Class responsible for providing function calling configuration and processing AI function calls. As part of the processing, it will:
/// 1. Iterate over <see cref="FunctionCallContent"/> items representing AI model function calls in the <see cref="ChatMessageContent.Items"/> collection.
/// 2. Look up each function in the <see cref="Kernel"/>.
/// 3. Invoke the auto function invocation filter, if registered, for each function.
/// 4. Invoke each function and add the function result to the <see cref="ChatHistory"/>.
/// </summary>
[ExcludeFromCodeCoverage]
internal sealed class FunctionCallsProcessor
{
    /// <summary>
    /// The maximum number of auto-invokes that can be in-flight at any given time as part of the current
    /// asynchronous chain of execution.
    /// </summary>
    /// <remarks>
    /// This is a fail-safe mechanism. If someone accidentally manages to set up execution settings in such a way that
    /// auto-invocation is invoked recursively, and in particular where a prompt function is able to auto-invoke itself,
    /// we could end up in an infinite loop. This const is a backstop against that happening. We should never come close
    /// to this limit, but if we do, auto-invoke will be disabled for the current flow in order to prevent runaway execution.
    /// With the current setup, the way this could possibly happen is if a prompt function is configured with built-in
    /// execution settings that opt-in to auto-invocation of everything in the kernel, in which case the invocation of that
    /// prompt function could advertize itself as a candidate for auto-invocation. We don't want to outright block that,
    /// if that's something a developer has asked to do (e.g. it might be invoked with different arguments than its parent
    /// was invoked with), but we do want to limit it. This limit is arbitrary and can be tweaked in the future and/or made
    /// configurable should need arise.
    /// </remarks>
    private const int MaxInflightAutoInvokes = 128;

    /// <summary>
    /// The maximum number of function auto-invokes that can be made in a single user request.
    /// </summary>
    /// <remarks>
    /// After this number of iterations as part of a single user request is reached, auto-invocation
    /// will be disabled. This is a safeguard against possible runaway execution if the model routinely re-requests
    /// the same function over and over.
    /// </remarks>
    internal const int MaximumAutoInvokeAttempts = 128;

    /// <summary>Tracking <see cref="AsyncLocal{Int32}"/> for <see cref="MaxInflightAutoInvokes"/>.</summary>
    /// <remarks>
    /// It is temporarily made internal to allow code that uses the old function model to read it and decide whether to continue auto-invocation or not.
    /// It should be made private when the old model is deprecated.
    /// Despite the field being static, its value is unique per execution flow. So if thousands of requests hit it in parallel, each request will see its unique value.
    /// </remarks>
    internal static readonly AsyncLocal<int> s_inflightAutoInvokes = new();

    /// <summary>
    /// The logger.
    /// </summary>
    private readonly ILogger _logger;

    /// <summary>
    /// Initializes a new instance of the <see cref="FunctionCallsProcessor"/> class.
    /// </summary>
    /// <param name="logger">The logger.</param>
    public FunctionCallsProcessor(ILogger? logger = null)
    {
        this._logger = logger ?? NullLogger.Instance;
    }

    /// <summary>
    /// Retrieves the configuration of the specified <see cref="FunctionChoiceBehavior"/>.
    /// </summary>
    /// <param name="behavior">The function choice behavior.</param>
    /// <param name="chatHistory">The chat history.</param>
    /// <param name="requestIndex">Request sequence index.</param>
    /// <param name="kernel">The <see cref="Kernel"/>.</param>
    /// <returns>The configuration of the specified <see cref="FunctionChoiceBehavior"/>.</returns>
    public FunctionChoiceBehaviorConfiguration? GetConfiguration(FunctionChoiceBehavior? behavior, ChatHistory chatHistory, int requestIndex, Kernel? kernel)
    {
        // If no behavior is specified, return null.
        if (behavior is null)
        {
            return null;
        }

        var configuration = behavior.GetConfiguration(new(chatHistory) { Kernel = kernel, RequestSequenceIndex = requestIndex });

        this._logger.LogFunctionChoiceBehaviorConfiguration(configuration);

        // Disable auto invocation if no kernel is provided.
        configuration.AutoInvoke = kernel is not null && configuration.AutoInvoke;

        // Disable auto invocation if we've exceeded the allowed auto-invoke limit.
        int maximumAutoInvokeAttempts = configuration.AutoInvoke ? MaximumAutoInvokeAttempts : 0;
        if (requestIndex >= maximumAutoInvokeAttempts)
        {
            configuration.AutoInvoke = false;
            this._logger.LogMaximumNumberOfAutoInvocationsPerUserRequestReached(maximumAutoInvokeAttempts);
        }
        // Disable auto invocation if we've exceeded the allowed limit of in-flight auto-invokes. See XML comment for the "MaxInflightAutoInvokes" const for more details.
        else if (s_inflightAutoInvokes.Value >= MaxInflightAutoInvokes)
        {
            configuration.AutoInvoke = false;
            this._logger.LogMaximumNumberOfInFlightAutoInvocationsReached(MaxInflightAutoInvokes);
        }

        return configuration;
    }

    /// <summary>
    /// Processes AI function calls by iterating over the function calls, invoking them and adding the results to the chat history.
    /// </summary>
    /// <param name="chatMessageContent">The chat message content representing AI model response and containing function calls.</param>
    /// <param name="executionSettings">The prompt execution settings.</param>
    /// <param name="chatHistory">The chat history to add function invocation results to.</param>
    /// <param name="requestIndex">AI model function(s) call request sequence index.</param>
    /// <param name="checkIfFunctionAdvertised">Callback to check if a function was advertised to AI model or not.</param>
    /// <param name="options">Function choice behavior options.</param>
    /// <param name="kernel">The <see cref="Kernel"/>.</param>
    /// <param name="isStreaming">Boolean flag which indicates whether an operation is invoked within streaming or non-streaming mode.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests.</param>
    /// <returns>Last chat history message if function invocation filter requested processing termination, otherwise null.</returns>
    public async Task<ChatMessageContent?> ProcessFunctionCallsAsync(
        ChatMessageContent chatMessageContent,
        PromptExecutionSettings? executionSettings,
        ChatHistory chatHistory,
        int requestIndex,
        Func<FunctionCallContent, bool> checkIfFunctionAdvertised,
        FunctionChoiceBehaviorOptions options,
        Kernel? kernel,
        bool isStreaming,
        CancellationToken cancellationToken)
    {
        // Add the result message to the caller's chat history;
        // this is required for AI model to understand the function results.
        chatHistory.Add(chatMessageContent);

        FunctionCallContent[] functionCalls = FunctionCallContent.GetFunctionCalls(chatMessageContent).ToArray();

        this._logger.LogFunctionCalls(functionCalls);

        List<Task<FunctionResultContext>>? functionTasks =
            options.AllowConcurrentInvocation && functionCalls.Length > 1 ?
                new(functionCalls.Length) :
                null;

        // We must send back a result for every function call, regardless of whether we successfully executed it or not.
        // If we successfully execute it, we'll add the result. If we don't, we'll add an error.
        for (int functionCallIndex = 0; functionCallIndex < functionCalls.Length; functionCallIndex++)
        {
            FunctionCallContent functionCall = functionCalls[functionCallIndex];

            // Check if the function call is valid to execute.
            if (!TryValidateFunctionCall(functionCall, checkIfFunctionAdvertised, kernel, out KernelFunction? function, out string? errorMessage))
            {
                this.AddFunctionCallErrorToChatHistory(chatHistory, functionCall, errorMessage);
                continue;
            }

            // Prepare context for the auto function invocation filter and invoke it.
            AutoFunctionInvocationContext invocationContext =
                new(kernel!,  // Kernel cannot be null if function-call is valid
                    function,
                    result: new(function) { Culture = kernel!.Culture },
                    chatHistory,
                    chatMessageContent)
                {
                    Arguments = functionCall.Arguments,
                    RequestSequenceIndex = requestIndex,
                    FunctionSequenceIndex = functionCallIndex,
                    FunctionCount = functionCalls.Length,
                    CancellationToken = cancellationToken,
                    IsStreaming = isStreaming,
                    ToolCallId = functionCall.Id,
                    ExecutionSettings = executionSettings
                };

            s_inflightAutoInvokes.Value++;

            Task<FunctionResultContext> functionTask = this.ExecuteFunctionCallAsync(invocationContext, functionCall, function, kernel, cancellationToken);

            // If concurrent invocation is enabled, add the task to the list for later waiting. Otherwise, join with it now.
            if (functionTasks is not null)
            {
                functionTasks.Add(functionTask);
            }
            else
            {
                FunctionResultContext functionResult = await functionTask.ConfigureAwait(false);
                this.AddFunctionCallResultToChatHistory(chatHistory, functionResult);

                // If filter requested termination, return last chat history message.
                if (functionResult.Context.Terminate)
                {
                    this._logger.LogAutoFunctionInvocationProcessTermination(functionResult.Context);
                    return chatHistory.Last();
                }
            }
        }

        // If concurrent invocation is enabled, join with all the tasks now.
        if (functionTasks is not null)
        {
            bool terminationRequested = false;

            // Wait for all the function invocations to complete, then add the results to the chat, but stop when we hit a
            // function for which termination was requested.
            FunctionResultContext[] resultContexts = await Task.WhenAll(functionTasks).ConfigureAwait(false);
            foreach (FunctionResultContext resultContext in resultContexts)
            {
                this.AddFunctionCallResultToChatHistory(chatHistory, resultContext);

                if (resultContext.Context.Terminate)
                {
                    this._logger.LogAutoFunctionInvocationProcessTermination(resultContext.Context);
                    terminationRequested = true;
                }
            }

            // If filter requested termination, return last chat history message.
            if (terminationRequested)
            {
                return chatHistory.Last();
            }
        }

        return null;
    }

    /// <summary>
    /// Processes function calls specifically for Open AI Assistant API.  In this context, the chat-history is not
    /// present in local memory.
    /// </summary>
    /// <param name="chatMessageContent">The chat message content representing AI model response and containing function calls.</param>
    /// <param name="checkIfFunctionAdvertised">Callback to check if a function was advertised to AI model or not.</param>
    /// <param name="options">Function choice behavior options.</param>
    /// <param name="kernel">The <see cref="Kernel"/>.</param>
    /// <param name="isStreaming">Boolean flag which indicates whether an operation is invoked within streaming or non-streaming mode.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests.</param>
    /// <returns>Last chat history message if function invocation filter requested processing termination, otherwise null.</returns>
    public async ValueTask<FunctionResultContent[]> InvokeFunctionCallsAsync(
        ChatMessageContent chatMessageContent,
        Func<FunctionCallContent, bool> checkIfFunctionAdvertised,
        FunctionChoiceBehaviorOptions options,
        Kernel kernel,
        bool isStreaming,
        CancellationToken cancellationToken)
    {
        FunctionCallContent[] functionCalls = FunctionCallContent.GetFunctionCalls(chatMessageContent).ToArray();
        ChatHistory history = [chatMessageContent];
        List<FunctionResultContent> results = [];

        this._logger.LogFunctionCalls(functionCalls);

        List<Task<FunctionResultContext>> functionTasks = new(functionCalls.Length);

        // We must send back a result for every function call, regardless of whether we successfully executed it or not.
        // If we successfully execute it, we'll add the result. If we don't, we'll add an error.
        for (int functionCallIndex = 0; functionCallIndex < functionCalls.Length; functionCallIndex++)
        {
            FunctionCallContent functionCall = functionCalls[functionCallIndex];

            // Check if the function call is valid to execute.
            if (!TryValidateFunctionCall(functionCall, checkIfFunctionAdvertised, kernel, out KernelFunction? function, out string? errorMessage))
            {
                results.Add(this.GenerateResultContent(functionCall, result: null, errorMessage));
                continue;
            }

            // Prepare context for the auto function invocation filter and invoke it.
            AutoFunctionInvocationContext invocationContext =
                new(kernel!,  // Kernel cannot be null if function-call is valid
                    function,
                    result: new(function) { Culture = kernel!.Culture },
                    history,
                    chatMessageContent)
                {
                    Arguments = functionCall.Arguments,
                    FunctionSequenceIndex = functionCallIndex,
                    FunctionCount = functionCalls.Length,
                    CancellationToken = cancellationToken,
                    IsStreaming = isStreaming,
                    ToolCallId = functionCall.Id
                };

            s_inflightAutoInvokes.Value++;

            functionTasks.Add(this.ExecuteFunctionCallAsync(invocationContext, functionCall, function, kernel, cancellationToken));
        }

        // Wait for all of the function invocations to complete, then add the results to the chat, but stop when we hit a
        // function for which termination was requested.
        FunctionResultContext[] resultContexts = await Task.WhenAll(functionTasks).ConfigureAwait(false);
        foreach (var context in resultContexts)
        {
            results.Add(this.GenerateResultContent(context));
        }

        return [.. results];
    }

    private static bool TryValidateFunctionCall(
            FunctionCallContent functionCall,
            Func<FunctionCallContent, bool> checkIfFunctionAdvertised,
            Kernel? kernel,
            [NotNullWhen(true)] out KernelFunction? function,
            out string? errorMessage)
    {
        function = null;

        // Check if the function call has an exception.
        if (functionCall.Exception is not null)
        {
            errorMessage = $"Error: Function call processing failed. Correct yourself. {functionCall.Exception.Message}";
            return false;
        }

        // Make sure the requested function is one of the functions that was advertised to the AI model.
        if (!checkIfFunctionAdvertised(functionCall))
        {
            errorMessage = "Error: Function call request for a function that wasn't defined. Correct yourself.";
            return false;
        }

        // Look up the function in the kernel
        if (kernel?.Plugins.TryGetFunction(functionCall.PluginName, functionCall.FunctionName, out function) ?? false)
        {
            errorMessage = null;
            return true;
        }

        errorMessage = "Error: Requested function could not be found. Correct yourself.";
        return false;
    }

    private record struct FunctionResultContext(AutoFunctionInvocationContext Context, FunctionCallContent FunctionCall, string? Result, string? ErrorMessage);

    private async Task<FunctionResultContext> ExecuteFunctionCallAsync(
            AutoFunctionInvocationContext invocationContext,
            FunctionCallContent functionCall,
            KernelFunction function,
            Kernel kernel,
            CancellationToken cancellationToken)
    {
        try
        {
            invocationContext =
                await this.OnAutoFunctionInvocationAsync(
                    kernel,
                    invocationContext,
                    async (context) =>
                    {
                        // Check if filter requested termination.
                        if (context.Terminate)
                        {
                            return;
                        }

                        // Note that we explicitly do not use executionSettings here; those pertain to the all-up operation and not necessarily to any
                        // further calls made as part of this function invocation. In particular, we must not use function calling settings naively here,
                        // as the called function could in turn telling the model about itself as a possible candidate for invocation.
                        context.Result = await function.InvokeAsync(kernel, invocationContext.Arguments, cancellationToken: cancellationToken).ConfigureAwait(false);
                    }).ConfigureAwait(false);
        }
#pragma warning disable CA1031 // Do not catch general exception types
        catch (Exception e)
#pragma warning restore CA1031 // Do not catch general exception types
        {
            return new FunctionResultContext(invocationContext, functionCall, null, $"Error: Exception while invoking function. {e.Message}");
        }

        // Apply any changes from the auto function invocation filters context to final result.
        string stringResult = ProcessFunctionResult(invocationContext.Result.GetValue<object>() ?? string.Empty);
        return new FunctionResultContext(invocationContext, functionCall, stringResult, null);
    }

    /// <summary>
    /// Adds the function call result or error message to the chat history.
    /// </summary>
    /// <param name="chatHistory">The chat history to add the function call result to.</param>
    /// <param name="resultContext">The function result context.</param>
    private void AddFunctionCallResultToChatHistory(ChatHistory chatHistory, FunctionResultContext resultContext)
    {
        var message = new ChatMessageContent(role: AuthorRole.Tool, content: resultContext.Result);
        message.Items.Add(this.GenerateResultContent(resultContext));
        chatHistory.Add(message);
    }

    /// <summary>
    /// Adds the function call result or error message to the chat history.
    /// </summary>
    /// <param name="chatHistory">The chat history to add the function call result to.</param>
    /// <param name="functionCall">The function call content.</param>
    /// <param name="errorMessage">An error message.</param>
    private void AddFunctionCallErrorToChatHistory(ChatHistory chatHistory, FunctionCallContent functionCall, string? errorMessage)
    {
        var message = new ChatMessageContent(role: AuthorRole.Tool, content: errorMessage);
        message.Items.Add(this.GenerateResultContent(functionCall, result: null, errorMessage));
        chatHistory.Add(message);
    }

    /// <summary>
    /// Creates a <see cref="FunctionResultContent"/> instance.
    /// </summary>
    /// <param name="resultContext">The function result context.</param>
    private FunctionResultContent GenerateResultContent(FunctionResultContext resultContext)
    {
        return this.GenerateResultContent(resultContext.FunctionCall, resultContext.Result, resultContext.ErrorMessage);
    }

    /// <summary>
    /// Creates a <see cref="FunctionResultContent"/> instance.
    /// </summary>
    /// <param name="functionCall">The function call content.</param>
    /// <param name="result">The function result, if available</param>
    /// <param name="errorMessage">An error message.</param>
    private FunctionResultContent GenerateResultContent(FunctionCallContent functionCall, string? result, string? errorMessage)
    {
        // Log any error
        if (errorMessage is not null)
        {
            this._logger.LogFunctionCallRequestFailure(functionCall, errorMessage);
        }

        return new FunctionResultContent(functionCall.FunctionName, functionCall.PluginName, functionCall.Id, result ?? errorMessage ?? string.Empty);
    }

    /// <summary>
    /// Invokes the auto function invocation filters.
    /// </summary>
    /// <param name="kernel">The <see cref="Kernel"/>.</param>
    /// <param name="context">The auto function invocation context.</param>
    /// <param name="functionCallCallback">The function to call after the filters.</param>
    /// <returns>The auto function invocation context.</returns>
    private async Task<AutoFunctionInvocationContext> OnAutoFunctionInvocationAsync(
        Kernel kernel,
        AutoFunctionInvocationContext context,
        Func<AutoFunctionInvocationContext, Task> functionCallCallback)
    {
        await this.InvokeFilterOrFunctionAsync(kernel.AutoFunctionInvocationFilters, functionCallCallback, context).ConfigureAwait(false);

        return context;
    }

    /// <summary>
    /// This method will execute auto function invocation filters and function recursively.
    /// If there are no registered filters, just function will be executed.
    /// If there are registered filters, filter on <paramref name="index"/> position will be executed.
    /// Second parameter of filter is callback. It can be either filter on <paramref name="index"/> + 1 position or function if there are no remaining filters to execute.
    /// Function will be always executed as last step after all filters.
    /// </summary>
    private async Task InvokeFilterOrFunctionAsync(
        IList<IAutoFunctionInvocationFilter>? autoFunctionInvocationFilters,
        Func<AutoFunctionInvocationContext, Task> functionCallCallback,
        AutoFunctionInvocationContext context,
        int index = 0)
    {
        if (autoFunctionInvocationFilters is { Count: > 0 } && index < autoFunctionInvocationFilters.Count)
        {
            this._logger.LogAutoFunctionInvocationFilterContext(context);

            await autoFunctionInvocationFilters[index].OnAutoFunctionInvocationAsync(
                context,
                (context) => this.InvokeFilterOrFunctionAsync(autoFunctionInvocationFilters, functionCallCallback, context, index + 1)
            ).ConfigureAwait(false);
        }
        else
        {
            await functionCallCallback(context).ConfigureAwait(false);
        }
    }

    /// <summary>
    /// Processes the function result.
    /// </summary>
    /// <param name="functionResult">The result of the function call.</param>
    /// <returns>A string representation of the function result.</returns>
    public static string ProcessFunctionResult(object functionResult)
    {
        if (functionResult is string stringResult)
        {
            return stringResult;
        }

        // This is an optimization to use ChatMessageContent content directly
        // without unnecessary serialization of the whole message content class.
        if (functionResult is ChatMessageContent chatMessageContent)
        {
            return chatMessageContent.ToString();
        }

        // Same optimization but for a enumerable of ChatMessageContent
        if (functionResult is IEnumerable<ChatMessageContent> chatMessageContents)
        {
            return string.Join(",", chatMessageContents.Select(c => c.ToString()));
        }

        return JsonSerializer.Serialize(functionResult, s_functionResultSerializerOptions);
    }

    /// <summary>
    /// The <see cref="JsonSerializerOptions" /> which will be used in <see cref="ProcessFunctionResult(object)"/>.
    /// </summary>
    /// <remarks>
    /// <see cref="JsonSerializer.Serialize{TValue}(TValue, JsonSerializerOptions?)"/> is very likely to escape characters and generates LLM unfriendly results by default.
    /// </remarks>
    private static readonly JsonSerializerOptions s_functionResultSerializerOptions = new()
    {
        Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping,
    };
}


===== connectors\AI\FunctionCalling\FunctionCallsProcessorLoggerExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using Microsoft.Extensions.Logging;

namespace Microsoft.SemanticKernel.Connectors.FunctionCalling;

[ExcludeFromCodeCoverage]
internal static partial class FunctionCallsProcessorLoggingExtensions
{
    /// <summary>
    /// Action to log the <see cref="FunctionChoiceBehaviorConfiguration"/>.
    /// </summary>
    private static readonly Action<ILogger, string, bool, bool, bool?, string, Exception?> s_logFunctionChoiceBehaviorConfiguration =
        LoggerMessage.Define<string, bool, bool, bool?, string>(
            logLevel: LogLevel.Debug,
            eventId: 0,
            "Function choice behavior configuration: Choice:{Choice}, AutoInvoke:{AutoInvoke}, AllowConcurrentInvocation:{AllowConcurrentInvocation}, AllowParallelCalls:{AllowParallelCalls} Functions:{Functions}");

    /// <summary>
    /// Action to log function calls.
    /// </summary>
    private static readonly Action<ILogger, string, Exception?> s_logFunctionCalls =
        LoggerMessage.Define<string>(
            logLevel: LogLevel.Debug,
            eventId: 0,
            "Function calls: {Calls}");

    /// <summary>
    /// Action to log auto function invocation filter context.
    /// </summary>
    private static readonly Action<ILogger, string, string?, bool, int, int, int, Exception?> s_logAutoFunctionInvocationFilterContext =
        LoggerMessage.Define<string, string?, bool, int, int, int>(
            logLevel: LogLevel.Debug,
            eventId: 0,
            "Auto function invocation filter context: Name:{Name}, Id:{Id}, IsStreaming:{IsStreaming} FunctionSequenceIndex:{FunctionSequenceIndex}, RequestSequenceIndex:{RequestSequenceIndex}, FunctionCount:{FunctionCount}");

    /// <summary>
    /// Action to log auto function invocation filter termination.
    /// </summary>
    private static readonly Action<ILogger, string, string?, Exception?> s_logAutoFunctionInvocationFilterTermination =
        LoggerMessage.Define<string, string?>(
            logLevel: LogLevel.Debug,
            eventId: 0,
            "Auto function invocation filter requested termination: Name:{Name}, Id:{Id}");

    /// <summary>
    /// Logs <see cref="FunctionChoiceBehaviorConfiguration"/>.
    /// </summary>
    public static void LogFunctionChoiceBehaviorConfiguration(this ILogger logger, FunctionChoiceBehaviorConfiguration configuration)
    {
        if (logger.IsEnabled(LogLevel.Debug))
        {
            var functionsLog = (configuration.Functions != null && configuration.Functions.Any())
                ? string.Join(", ", configuration.Functions.Select(f => FunctionName.ToFullyQualifiedName(f.Name, f.PluginName)))
                : "None (Function calling is disabled)";

            s_logFunctionChoiceBehaviorConfiguration(
                logger,
                configuration.Choice.Label,
                configuration.AutoInvoke,
                configuration.Options.AllowConcurrentInvocation,
                configuration.Options.AllowParallelCalls,
                functionsLog,
                null);
        }
    }

    /// <summary>
    /// Logs function calls.
    /// </summary>
    public static void LogFunctionCalls(this ILogger logger, FunctionCallContent[] functionCalls)
    {
        if (logger.IsEnabled(LogLevel.Debug))
        {
            s_logFunctionCalls(
                logger,
                string.Join(", ", functionCalls.Select(call => $"{FunctionName.ToFullyQualifiedName(call.FunctionName, call.PluginName)} [Id: {call.Id}]")),
                null
            );
        }
    }

    /// <summary>
    /// Logs the <see cref="AutoFunctionInvocationContext"/>.
    /// </summary>
    public static void LogAutoFunctionInvocationFilterContext(this ILogger logger, AutoFunctionInvocationContext context)
    {
        if (logger.IsEnabled(LogLevel.Debug))
        {
            var fqn = FunctionName.ToFullyQualifiedName(context.Function.Name, context.Function.PluginName);

            s_logAutoFunctionInvocationFilterContext(
                    logger,
                    fqn,
                    context.ToolCallId,
                    context.IsStreaming,
                    context.FunctionSequenceIndex,
                    context.RequestSequenceIndex,
                    context.FunctionCount,
                    null);
        }
    }

    /// <summary>
    /// Logs the auto function invocation process termination.
    /// </summary>
    public static void LogAutoFunctionInvocationProcessTermination(this ILogger logger, AutoFunctionInvocationContext context)
    {
        if (logger.IsEnabled(LogLevel.Debug))
        {
            var fqn = FunctionName.ToFullyQualifiedName(context.Function.Name, context.Function.PluginName);

            s_logAutoFunctionInvocationFilterTermination(logger, fqn, context.ToolCallId, null);
        }
    }

    /// <summary>
    /// Logs function call request failure.
    /// </summary>
    public static void LogFunctionCallRequestFailure(this ILogger logger, FunctionCallContent functionCall, string error)
    {
        if (logger.IsEnabled(LogLevel.Debug))
        {
            var fqn = FunctionName.ToFullyQualifiedName(functionCall.FunctionName, functionCall.PluginName);

            logger.LogDebug("Function call request failed: Name:{Name}, Id:{Id}", fqn, functionCall.Id);
        }

        // Log error at trace level only because it may contain sensitive information.
        if (logger.IsEnabled(LogLevel.Trace))
        {
            var fqn = FunctionName.ToFullyQualifiedName(functionCall.FunctionName, functionCall.PluginName);

            logger.LogTrace("Function call request failed: Name:{Name}, Id:{Id}, Error:{Error}", fqn, functionCall.Id, error);
        }
    }

    [LoggerMessage(EventId = 0, Level = LogLevel.Debug, Message = "The maximum limit of {MaxNumberOfAutoInvocations} auto invocations per user request has been reached. Auto invocation is now disabled.")]
    public static partial void LogMaximumNumberOfAutoInvocationsPerUserRequestReached(this ILogger logger, int maxNumberOfAutoInvocations);

    [LoggerMessage(EventId = 0, Level = LogLevel.Debug, Message = "The maximum limit of {MaxNumberOfInflightAutoInvocations} in-flight auto invocations has been reached. Auto invocation is now disabled.")]
    public static partial void LogMaximumNumberOfInFlightAutoInvocationsReached(this ILogger logger, int maxNumberOfInflightAutoInvocations);
}


===== connectors\Memory\MongoDB\ErrorHandlingAsyncCursor.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.VectorData;
using MongoDB.Driver;

namespace Microsoft.SemanticKernel.Connectors.MongoDB;

/// <summary>
/// A decorator for <see cref="IAsyncCursor{T}"/> that handles errors on move next.
/// </summary>
/// <typeparam name="T">The type that the cursor returns.</typeparam>
internal class ErrorHandlingAsyncCursor<T> : IAsyncCursor<T>
{
    private readonly IAsyncCursor<T> _cursor;
    private readonly string _operationName;
    private readonly VectorStoreCollectionMetadata _collectionMetadata;

    public ErrorHandlingAsyncCursor(IAsyncCursor<T> cursor, VectorStoreCollectionMetadata collectionMetadata, string operationName)
    {
        this._cursor = cursor;
        this._operationName = operationName;
        this._collectionMetadata = collectionMetadata;
    }

    public ErrorHandlingAsyncCursor(IAsyncCursor<T> cursor, VectorStoreMetadata metadata, string operationName)
    {
        this._cursor = cursor;
        this._operationName = operationName;
        this._collectionMetadata = new VectorStoreCollectionMetadata()
        {
            CollectionName = null,
            VectorStoreName = metadata.VectorStoreName,
            VectorStoreSystemName = metadata.VectorStoreSystemName,
        };
    }

    public IEnumerable<T> Current => this._cursor.Current;

    public void Dispose()
    {
        this._cursor.Dispose();
    }

    public bool MoveNext(CancellationToken cancellationToken = default)
    {
        return VectorStoreErrorHandler.RunOperation<bool, MongoException>(
            this._collectionMetadata,
            this._operationName,
            () => this._cursor.MoveNext(cancellationToken));
    }

    public Task<bool> MoveNextAsync(CancellationToken cancellationToken = default)
    {
        return VectorStoreErrorHandler.RunOperationAsync<bool, MongoException>(
            this._collectionMetadata,
            this._operationName,
            () => this._cursor.MoveNextAsync(cancellationToken));
    }
}


===== connectors\Memory\MongoDB\IMongoMapper.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using Microsoft.Extensions.AI;
using MongoDB.Bson;

namespace Microsoft.SemanticKernel.Connectors.MongoDB;

internal interface IMongoMapper<TRecord>
{
    /// <summary>
    /// Maps from the consumer record data model to the storage model.
    /// </summary>
    BsonDocument MapFromDataToStorageModel(TRecord dataModel, int recordIndex, IReadOnlyList<Embedding>?[]? generatedEmbeddings);

    /// <summary>
    /// Maps from the storage model to the consumer record data model.
    /// </summary>
    TRecord MapFromStorageToDataModel(BsonDocument storageModel, bool includeVectors);
}


===== connectors\Memory\MongoDB\MongoConstants.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using Microsoft.Extensions.VectorData;

namespace Microsoft.SemanticKernel.Connectors.MongoDB;

/// <summary>
/// Constants for MongoDB vector store implementation.
/// </summary>
[ExcludeFromCodeCoverage]
internal static class MongoConstants
{
    internal const string VectorStoreSystemName = "mongodb";

    /// <summary>Default ratio of number of nearest neighbors to number of documents to return.</summary>
    internal const int DefaultNumCandidatesRatio = 10;

    /// <summary>Default vector index name.</summary>
    internal const string DefaultVectorIndexName = "vector_index";

    /// <summary>Default full text search index name.</summary>
    internal const string DefaultFullTextSearchIndexName = "full_text_search_index";

    /// <summary>Default index kind for vector search.</summary>
    internal const string DefaultIndexKind = IndexKind.IvfFlat;

    /// <summary>Default distance function for vector search.</summary>
    internal const string DefaultDistanceFunction = DistanceFunction.CosineDistance;

    /// <summary>Reserved key property name in MongoDB.</summary>
    internal const string MongoReservedKeyPropertyName = "_id";

    /// <summary>Reserved key property name in data model.</summary>
    internal const string DataModelReservedKeyPropertyName = "Id";

    /// <summary>A <see cref="HashSet{Type}"/> containing the supported key types.</summary>
    internal static readonly HashSet<Type> SupportedKeyTypes =
    [
        typeof(string)
    ];

    /// <summary>A <see cref="HashSet{Type}"/> containing the supported data property types.</summary>
    internal static readonly HashSet<Type> SupportedDataTypes =
    [
        typeof(bool),
        typeof(string),
        typeof(int),
        typeof(long),
        typeof(float),
        typeof(double),
        typeof(decimal),
        typeof(DateTime),
    ];

    /// <summary>A <see cref="HashSet{Type}"/> containing the supported vector types.</summary>
    internal static readonly HashSet<Type> SupportedVectorTypes =
    [
        typeof(ReadOnlyMemory<float>),
        typeof(ReadOnlyMemory<float>?)
    ];
}


===== connectors\Memory\MongoDB\MongoDynamicMapper.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Runtime.InteropServices;
using Microsoft.Extensions.AI;
using Microsoft.Extensions.VectorData.ProviderServices;
using MongoDB.Bson;

namespace Microsoft.SemanticKernel.Connectors.MongoDB;

/// <summary>
/// A mapper that maps between the dynamic data model and the model that the data is stored under, within MongoDB.
/// </summary>
[ExcludeFromCodeCoverage]
internal sealed class MongoDynamicMapper(CollectionModel model) : IMongoMapper<Dictionary<string, object?>>
{
    /// <inheritdoc />
    public BsonDocument MapFromDataToStorageModel(Dictionary<string, object?> dataModel, int recordIndex, IReadOnlyList<Embedding>?[]? generatedEmbeddings)
    {
        Verify.NotNull(dataModel);

        var document = new BsonDocument();

        document[MongoConstants.MongoReservedKeyPropertyName] = !dataModel.TryGetValue(model.KeyProperty.ModelName, out var keyValue)
            ? throw new InvalidOperationException($"Missing value for key property '{model.KeyProperty.ModelName}")
            : keyValue switch
            {
                string s => s,
                Guid g => BsonValue.Create(g),
                ObjectId o => o,
                long i => i,
                int i => i,

                null => throw new InvalidOperationException($"Key property '{model.KeyProperty.ModelName}' is null."),
                _ => throw new InvalidCastException($"Key property '{model.KeyProperty.ModelName}' must be a string.")
            };

        foreach (var property in model.DataProperties)
        {
            if (dataModel.TryGetValue(property.ModelName, out var dataValue))
            {
                document[property.StorageName] = BsonValue.Create(dataValue);
            }
        }

        for (var i = 0; i < model.VectorProperties.Count; i++)
        {
            var property = model.VectorProperties[i];

            // Don't create a property if it doesn't exist in the dictionary
            if (dataModel.TryGetValue(property.ModelName, out var vectorValue))
            {
                var vector = generatedEmbeddings?[i]?[recordIndex] is Embedding ge
                    ? ge
                    : vectorValue;

                document[property.StorageName] = BsonArray.Create(
                    vector switch
                    {
                        ReadOnlyMemory<float> m
                            => MemoryMarshal.TryGetArray(m, out ArraySegment<float> segment) && segment.Count == segment.Array!.Length ? segment.Array : m.ToArray(),
                        Embedding<float> e
                            => MemoryMarshal.TryGetArray(e.Vector, out ArraySegment<float> segment) && segment.Count == segment.Array!.Length ? segment.Array : e.Vector.ToArray(),
                        float[] a => a,

                        null => Array.Empty<object>(),

                        _ => throw new UnreachableException()
                    });
            }
        }

        return document;
    }

    /// <inheritdoc />
    public Dictionary<string, object?> MapFromStorageToDataModel(BsonDocument storageModel, bool includeVectors)
    {
        Verify.NotNull(storageModel);

        var result = new Dictionary<string, object?>();

        // Loop through all known properties and map each from the storage model to the data model.
        foreach (var property in model.Properties)
        {
            switch (property)
            {
                case KeyPropertyModel keyProperty:
                    if (!storageModel.TryGetValue(MongoConstants.MongoReservedKeyPropertyName, out var keyValue))
                    {
                        throw new InvalidOperationException("No key property was found in the record retrieved from storage.");
                    }

                    result[keyProperty.ModelName] = keyProperty.Type switch
                    {
                        var t when t == typeof(string) => keyValue.AsString,
                        var t when t == typeof(Guid) => keyValue.AsGuid,
                        var t when t == typeof(ObjectId) => keyValue.AsObjectId,
                        var t when t == typeof(long) => keyValue.AsInt64,
                        var t when t == typeof(int) => keyValue.AsInt32,

                        _ => throw new UnreachableException()
                    };

                    continue;

                case DataPropertyModel dataProperty:
                    if (storageModel.TryGetValue(dataProperty.StorageName, out var dataValue))
                    {
                        result.Add(dataProperty.ModelName, GetDataPropertyValue(property.ModelName, property.Type, dataValue));
                    }
                    continue;

                case VectorPropertyModel vectorProperty:
                    if (includeVectors && storageModel.TryGetValue(vectorProperty.StorageName, out var vectorValue))
                    {
                        result.Add(
                            vectorProperty.ModelName,
                            vectorValue.IsBsonNull
                                ? null
                                : (Nullable.GetUnderlyingType(property.Type) ?? property.Type) switch
                                {
                                    Type t when t == typeof(ReadOnlyMemory<float>) => new ReadOnlyMemory<float>(vectorValue.AsBsonArray.Select(item => (float)item.AsDouble).ToArray()),
                                    Type t when t == typeof(Embedding<float>) => new Embedding<float>(vectorValue.AsBsonArray.Select(item => (float)item.AsDouble).ToArray()),
                                    Type t when t == typeof(float[]) => vectorValue.AsBsonArray.Select(item => (float)item.AsDouble).ToArray(),

                                    _ => throw new UnreachableException()
                                });
                    }
                    continue;

                default:
                    throw new UnreachableException();
            }
        }

        return result;
    }

    #region private

    private static object? GetDataPropertyValue(string propertyName, Type propertyType, BsonValue value)
    {
        if (value.IsBsonNull)
        {
            return null;
        }

        var result = propertyType switch
        {
            Type t when t == typeof(bool) => value.AsBoolean,
            Type t when t == typeof(bool?) => value.AsNullableBoolean,
            Type t when t == typeof(string) => value.AsString,
            Type t when t == typeof(int) => value.AsInt32,
            Type t when t == typeof(int?) => value.AsNullableInt32,
            Type t when t == typeof(long) => value.AsInt64,
            Type t when t == typeof(long?) => value.AsNullableInt64,
            Type t when t == typeof(float) => ((float)value.AsDouble),
            Type t when t == typeof(float?) => ((float?)value.AsNullableDouble),
            Type t when t == typeof(double) => value.AsDouble,
            Type t when t == typeof(double?) => value.AsNullableDouble,
            Type t when t == typeof(decimal) => value.AsDecimal,
            Type t when t == typeof(decimal?) => value.AsNullableDecimal,
            Type t when t == typeof(DateTime) => value.ToUniversalTime(),
            Type t when t == typeof(DateTime?) => value.ToNullableUniversalTime(),

            _ => (object?)null
        };

        if (result is not null)
        {
            return result;
        }

        if (propertyType.IsArray)
        {
            return propertyType switch
            {
                Type t when t == typeof(bool[]) => value.AsBsonArray.Select(x => x.AsBoolean).ToArray(),
                Type t when t == typeof(bool?[]) => value.AsBsonArray.Select(x => x.AsNullableBoolean).ToArray(),
                Type t when t == typeof(string[]) => value.AsBsonArray.Select(x => x.AsString).ToArray(),
                Type t when t == typeof(int[]) => value.AsBsonArray.Select(x => x.AsInt32).ToArray(),
                Type t when t == typeof(int?[]) => value.AsBsonArray.Select(x => x.AsNullableInt32).ToArray(),
                Type t when t == typeof(long[]) => value.AsBsonArray.Select(x => x.AsInt64).ToArray(),
                Type t when t == typeof(long?[]) => value.AsBsonArray.Select(x => x.AsNullableInt64).ToArray(),
                Type t when t == typeof(float[]) => value.AsBsonArray.Select(x => (float)x.AsDouble).ToArray(),
                Type t when t == typeof(float?[]) => value.AsBsonArray.Select(x => (float?)x.AsNullableDouble).ToArray(),
                Type t when t == typeof(double[]) => value.AsBsonArray.Select(x => x.AsDouble).ToArray(),
                Type t when t == typeof(double?[]) => value.AsBsonArray.Select(x => x.AsNullableDouble).ToArray(),
                Type t when t == typeof(decimal[]) => value.AsBsonArray.Select(x => x.AsDecimal).ToArray(),
                Type t when t == typeof(decimal?[]) => value.AsBsonArray.Select(x => x.AsNullableDecimal).ToArray(),
                Type t when t == typeof(DateTime[]) => value.AsBsonArray.Select(x => x.ToUniversalTime()).ToArray(),
                Type t when t == typeof(DateTime?[]) => value.AsBsonArray.Select(x => x.ToNullableUniversalTime()).ToArray(),

                _ => (object?)null
            };
        }

        if (propertyType.IsGenericType && propertyType.GetGenericTypeDefinition() == typeof(List<>))
        {
            return propertyType switch
            {
                Type t when t == typeof(List<bool>) => value.AsBsonArray.Select(x => x.AsBoolean).ToList(),
                Type t when t == typeof(List<bool?>) => value.AsBsonArray.Select(x => x.AsNullableBoolean).ToList(),
                Type t when t == typeof(List<string>) => value.AsBsonArray.Select(x => x.AsString).ToList(),
                Type t when t == typeof(List<int>) => value.AsBsonArray.Select(x => x.AsInt32).ToList(),
                Type t when t == typeof(List<int?>) => value.AsBsonArray.Select(x => x.AsNullableInt32).ToList(),
                Type t when t == typeof(List<long>) => value.AsBsonArray.Select(x => x.AsInt64).ToList(),
                Type t when t == typeof(List<long?>) => value.AsBsonArray.Select(x => x.AsNullableInt64).ToList(),
                Type t when t == typeof(List<float>) => value.AsBsonArray.Select(x => (float)x.AsDouble).ToList(),
                Type t when t == typeof(List<float?>) => value.AsBsonArray.Select(x => (float?)x.AsNullableDouble).ToList(),
                Type t when t == typeof(List<double>) => value.AsBsonArray.Select(x => x.AsDouble).ToList(),
                Type t when t == typeof(List<double?>) => value.AsBsonArray.Select(x => x.AsNullableDouble).ToList(),
                Type t when t == typeof(List<decimal>) => value.AsBsonArray.Select(x => x.AsDecimal).ToList(),
                Type t when t == typeof(List<decimal?>) => value.AsBsonArray.Select(x => x.AsNullableDecimal).ToList(),
                Type t when t == typeof(List<DateTime>) => value.AsBsonArray.Select(x => x.ToUniversalTime()).ToList(),
                Type t when t == typeof(List<DateTime?>) => value.AsBsonArray.Select(x => x.ToNullableUniversalTime()).ToList(),

                _ => (object?)null
            };
        }

        throw new NotSupportedException($"Mapping for property {propertyName} with type {propertyType.FullName} is not supported in dynamic data model.");
    }

    #endregion
}


===== connectors\Memory\MongoDB\MongoMapper.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using Microsoft.Extensions.AI;
using Microsoft.Extensions.VectorData.ProviderServices;
using MongoDB.Bson;
using MongoDB.Bson.Serialization;
using MongoDB.Bson.Serialization.Attributes;
using MongoDB.Bson.Serialization.Conventions;

namespace Microsoft.SemanticKernel.Connectors.MongoDB;

[ExcludeFromCodeCoverage]
internal sealed class MongoMapper<TRecord> : IMongoMapper<TRecord>
    where TRecord : class
{
    private readonly CollectionModel _model;

    /// <summary>A key property info of the data model.</summary>
    private readonly PropertyInfo? _keyClrProperty;

    /// <summary>A key property name of the data model.</summary>
    private readonly string _keyPropertyModelName;

    /// <summary>
    /// Initializes a new instance of the <see cref="MongoMapper{TRecord}"/> class.
    /// </summary>
    /// <param name="model">The model.</param>
    public MongoMapper(CollectionModel model)
    {
        this._model = model;

        var keyProperty = model.KeyProperty;
        this._keyPropertyModelName = keyProperty.ModelName;
        this._keyClrProperty = keyProperty.PropertyInfo;

        var conventionPack = new ConventionPack
        {
            new IgnoreExtraElementsConvention(ignoreExtraElements: true)
        };

        ConventionRegistry.Register(
            nameof(MongoMapper<TRecord>),
            conventionPack,
            type => type == typeof(TRecord));
    }

    public BsonDocument MapFromDataToStorageModel(TRecord dataModel, int recordIndex, IReadOnlyList<Embedding>?[]? generatedEmbeddings)
    {
        var document = dataModel.ToBsonDocument();

        // Handle key property mapping due to reserved key name in Mongo.
        if (!document.Contains(MongoConstants.MongoReservedKeyPropertyName))
        {
            var value = document[this._keyPropertyModelName];

            document.Remove(this._keyPropertyModelName);

            document[MongoConstants.MongoReservedKeyPropertyName] = value;
        }

        // Go over the vector properties; those which have an embedding generator configured on them will have embedding generators, overwrite
        // the value in the JSON object with that.
        for (var i = 0; i < this._model.VectorProperties.Count; i++)
        {
            var property = this._model.VectorProperties[i];

            Embedding<float>? embedding = generatedEmbeddings?[i]?[recordIndex] is Embedding e ? (Embedding<float>)e : null;

            if (embedding is null)
            {
                switch (Nullable.GetUnderlyingType(property.Type) ?? property.Type)
                {
                    case var t when t == typeof(ReadOnlyMemory<float>):
                    case var t2 when t2 == typeof(float[]):
                        // The .NET vector property is a ReadOnlyMemory<float> or float[] (not an Embedding<float>), which means that ToBsonDocument()
                        // already serialized it correctly above.
                        // In addition, there's no generated embedding (which would be an Embedding<float> which we'd need to handle manually).
                        // So there's nothing for us to do.
                        continue;

                    case var t when t == typeof(Embedding<float>):
                        embedding = (Embedding<float>)property.GetValueAsObject(dataModel)!;
                        break;

                    default:
                        throw new UnreachableException();
                }
            }

            document[property.StorageName] = BsonArray.Create(embedding.Vector.ToArray());
        }

        return document;
    }

    public TRecord MapFromStorageToDataModel(BsonDocument storageModel, bool includeVectors)
    {
        // Handle key property mapping due to reserved key name in Mongo.
        if (!this._keyPropertyModelName.Equals(MongoConstants.DataModelReservedKeyPropertyName, StringComparison.OrdinalIgnoreCase) &&
            this._keyClrProperty?.GetCustomAttribute<BsonIdAttribute>() is null)
        {
            var value = storageModel[MongoConstants.MongoReservedKeyPropertyName];

            storageModel.Remove(MongoConstants.MongoReservedKeyPropertyName);

            storageModel[this._keyPropertyModelName] = value;
        }

        if (includeVectors)
        {
            foreach (var vectorProperty in this._model.VectorProperties)
            {
                // If the vector property .NET type is Embedding<float>, we need to create the BSON structure for it
                // (BSON array embedded inside an object representing the embedding), so that the deserialization below
                // works correctly.
                if (vectorProperty.Type == typeof(Embedding<float>))
                {
                    storageModel[vectorProperty.StorageName] = new BsonDocument
                    {
                        [nameof(Embedding<float>.Vector)] = BsonArray.Create(storageModel[vectorProperty.StorageName])
                    };
                }
            }
        }
        else
        {
            // If includeVectors is false, remove the values; this allows us to not project them out of Mongo in the future
            // (more efficient) without introducing a breaking change.
            foreach (var vectorProperty in this._model.VectorProperties)
            {
                storageModel.Remove(vectorProperty.StorageName);
            }
        }

        return BsonSerializer.Deserialize<TRecord>(storageModel);
    }
}


===== connectors\Memory\MongoDB\MongoModelBuilder.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using Microsoft.Extensions.AI;
using Microsoft.Extensions.VectorData;
using Microsoft.Extensions.VectorData.ProviderServices;
using MongoDB.Bson;
using MongoDB.Bson.Serialization.Attributes;

namespace Microsoft.SemanticKernel.Connectors.MongoDB;

/// <summary>
/// Customized MongoDB model builder that adds specialized configuration of property storage names
/// (Mongo's reserve key property name and [BsonElement]).
/// </summary>
internal class MongoModelBuilder() : CollectionModelBuilder(s_validationOptions)
{
    internal const string SupportedVectorTypes = "ReadOnlyMemory<float>, Embedding<float>, float[]";

    private static readonly CollectionModelBuildingOptions s_validationOptions = new()
    {
        RequiresAtLeastOneVector = false,
        SupportsMultipleKeys = false,
        SupportsMultipleVectors = true,
        UsesExternalSerializer = true,
    };

    [RequiresUnreferencedCode("Traverses the CLR type's properties with reflection, so not compatible with trimming")]
    protected override void ProcessTypeProperties(Type type, VectorStoreCollectionDefinition? definition)
    {
        base.ProcessTypeProperties(type, definition);

        foreach (var property in this.Properties)
        {
            if (property.PropertyInfo?.GetCustomAttribute<BsonElementAttribute>() is { } bsonElementAttribute)
            {
                property.StorageName = bsonElementAttribute.ElementName;
            }
        }
    }

    protected override bool IsKeyPropertyTypeValid(Type type, [NotNullWhen(false)] out string? supportedTypes)
    {
        supportedTypes = "string, int, long, Guid, ObjectId";

        return type == typeof(string) || type == typeof(int) || type == typeof(long) || type == typeof(Guid) || type == typeof(ObjectId);
    }

    protected override bool IsDataPropertyTypeValid(Type type, [NotNullWhen(false)] out string? supportedTypes)
    {
        supportedTypes = "string, int, long, double, float, bool, DateTimeOffset, or arrays/lists of these types";

        if (Nullable.GetUnderlyingType(type) is Type underlyingType)
        {
            type = underlyingType;
        }

        return IsValid(type)
            || (type.IsArray && IsValid(type.GetElementType()!))
            || (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(List<>) && IsValid(type.GenericTypeArguments[0]));

        static bool IsValid(Type type)
            => type == typeof(bool) ||
                type == typeof(string) ||
                type == typeof(int) ||
                type == typeof(long) ||
                type == typeof(float) ||
                type == typeof(double) ||
                type == typeof(decimal) ||
                type == typeof(DateTime);
    }

    protected override bool IsVectorPropertyTypeValid(Type type, [NotNullWhen(false)] out string? supportedTypes)
        => IsVectorPropertyTypeValidCore(type, out supportedTypes);

    internal static bool IsVectorPropertyTypeValidCore(Type type, [NotNullWhen(false)] out string? supportedTypes)
    {
        supportedTypes = SupportedVectorTypes;

        return type == typeof(ReadOnlyMemory<float>)
            || type == typeof(ReadOnlyMemory<float>?)
            || type == typeof(Embedding<float>)
            || type == typeof(float[]);
    }
}


===== meai\Extensions\ChatMessageExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.ChatCompletion;

namespace Microsoft.Extensions.AI;

[ExcludeFromCodeCoverage]
internal static class ChatMessageExtensions
{
    /// <summary>Converts a <see cref="ChatMessage"/> to a <see cref="ChatMessageContent"/>.</summary>
    internal static ChatMessageContent ToChatMessageContent(this ChatMessage message, Microsoft.Extensions.AI.ChatResponse? response = null)
    {
        ChatMessageContent result = new()
        {
            ModelId = response?.ModelId,
            AuthorName = message.AuthorName,
            InnerContent = response?.RawRepresentation ?? message.RawRepresentation,
            Metadata = new AdditionalPropertiesDictionary(message.AdditionalProperties ?? []) { ["Usage"] = response?.Usage },
            Role = new AuthorRole(message.Role.Value),
        };

        foreach (AIContent content in message.Contents)
        {
#pragma warning disable SKEXP0001 // Type is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.
            KernelContent? resultContent = content switch
            {
                Microsoft.Extensions.AI.TextContent tc => new Microsoft.SemanticKernel.TextContent(tc.Text),
                Microsoft.Extensions.AI.DataContent dc when dc.HasTopLevelMediaType("image") => new Microsoft.SemanticKernel.ImageContent(dc.Uri),
                Microsoft.Extensions.AI.UriContent uc when uc.HasTopLevelMediaType("image") => new Microsoft.SemanticKernel.ImageContent(uc.Uri),
                Microsoft.Extensions.AI.DataContent dc when dc.HasTopLevelMediaType("audio") => new Microsoft.SemanticKernel.AudioContent(dc.Uri),
                Microsoft.Extensions.AI.UriContent uc when uc.HasTopLevelMediaType("audio") => new Microsoft.SemanticKernel.AudioContent(uc.Uri),
                Microsoft.Extensions.AI.DataContent dc => new Microsoft.SemanticKernel.BinaryContent(dc.Uri),
                Microsoft.Extensions.AI.UriContent uc => new Microsoft.SemanticKernel.BinaryContent(uc.Uri),
                Microsoft.Extensions.AI.FunctionCallContent fcc => new Microsoft.SemanticKernel.FunctionCallContent(
                    functionName: fcc.Name,
                    id: fcc.CallId,
                    arguments: fcc.Arguments is not null ? new(fcc.Arguments) : null),
                Microsoft.Extensions.AI.FunctionResultContent frc => new Microsoft.SemanticKernel.FunctionResultContent(
                    functionName: GetFunctionCallContent(frc.CallId)?.Name,
                    callId: frc.CallId,
                    result: frc.Result),
                _ => null
            };
#pragma warning restore SKEXP0001 // Type is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.

            if (resultContent is not null)
            {
                resultContent.Metadata = content.AdditionalProperties;
                resultContent.InnerContent = content.RawRepresentation;
                resultContent.ModelId = response?.ModelId;
                result.Items.Add(resultContent);
            }
        }

        return result;

        Microsoft.Extensions.AI.FunctionCallContent? GetFunctionCallContent(string callId)
            => response?.Messages
                .Select(m => m.Contents
                .FirstOrDefault(c => c is Microsoft.Extensions.AI.FunctionCallContent fcc && fcc.CallId == callId) as Microsoft.Extensions.AI.FunctionCallContent)
                    .FirstOrDefault(fcc => fcc is not null);
    }

    /// <summary>Converts a list of <see cref="ChatMessage"/> to a <see cref="ChatHistory"/>.</summary>
    internal static ChatHistory ToChatHistory(this IEnumerable<ChatMessage> chatMessages)
    {
        ChatHistory chatHistory = [];
        foreach (var message in chatMessages)
        {
            chatHistory.Add(message.ToChatMessageContent());
        }
        return chatHistory;
    }
}


===== openai\Extensions\ClientResultExceptionExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.ClientModel;
using System.Diagnostics.CodeAnalysis;
using System.Net;
using Microsoft.SemanticKernel;

/// <summary>
/// Provides extension methods for the <see cref="ClientResultException"/> class.
/// </summary>
[ExcludeFromCodeCoverage]
internal static class ClientResultExceptionExtensions
{
    /// <summary>
    /// Converts a <see cref="ClientResultException"/> to an <see cref="HttpOperationException"/>.
    /// </summary>
    /// <param name="exception">The original <see cref="ClientResultException"/>.</param>
    /// <returns>An <see cref="HttpOperationException"/> instance.</returns>
    public static HttpOperationException ToHttpOperationException(this ClientResultException exception)
    {
        const int NoResponseReceived = 0;

        string? responseContent = null;

        try
        {
            responseContent = exception.GetRawResponse()?.Content.ToString();
        }
#pragma warning disable CA1031 // Do not catch general exception types
        catch { } // We want to suppress any exceptions that occur while reading the content, ensuring that an HttpOperationException is thrown instead.
#pragma warning restore CA1031

        return new HttpOperationException(
            exception.Status == NoResponseReceived ? null : (HttpStatusCode?)exception.Status,
            responseContent,
            exception.Message,
            exception);
    }
}


===== openai\Policies\GeneratedActionPipelinePolicy.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Threading.Tasks;

/// <summary>
/// Generic action pipeline policy for processing messages.
/// </summary>
[ExcludeFromCodeCoverage]
internal sealed class GenericActionPipelinePolicy : PipelinePolicy
{
    private readonly Action<PipelineMessage> _processMessageAction;

    internal GenericActionPipelinePolicy(Action<PipelineMessage> processMessageAction)
    {
        this._processMessageAction = processMessageAction;
    }

    public override void Process(PipelineMessage message, IReadOnlyList<PipelinePolicy> pipeline, int currentIndex)
    {
        this._processMessageAction(message);
        if (currentIndex < pipeline.Count - 1)
        {
            pipeline[currentIndex + 1].Process(message, pipeline, currentIndex + 1);
        }
    }

    public override async ValueTask ProcessAsync(PipelineMessage message, IReadOnlyList<PipelinePolicy> pipeline, int currentIndex)
    {
        this._processMessageAction(message);
        if (currentIndex < pipeline.Count - 1)
        {
            await pipeline[currentIndex + 1].ProcessAsync(message, pipeline, currentIndex + 1).ConfigureAwait(false);
        }
    }
}


===== planning\Exceptions\PlanCreationException.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;

namespace Microsoft.SemanticKernel.Planning;

/// <summary>
/// Exception thrown when a plan cannot be created.
/// </summary>
public sealed class PlanCreationException : KernelException
{
    /// <summary>
    /// Gets the prompt template used to generate the plan.
    /// </summary>
    public string? CreatePlanPrompt { get; set; } = null;

    /// <summary>
    /// Completion results from the model; generally, this is the proposed plan.
    /// </summary>
    public ChatMessageContent? ModelResults { get; set; } = null;

    /// <summary>
    /// Initializes a new instance of the <see cref="PlanCreationException"/> class.
    /// </summary>
    public PlanCreationException()
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="PlanCreationException"/> class with a specified error message.
    /// </summary>
    /// <param name="message">The error message that explains the reason for the exception.</param>
    public PlanCreationException(string? message) : base(message)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="PlanCreationException"/> class with a specified error message and a reference to the inner exception that is the cause of this exception.
    /// </summary>
    /// <param name="message">The error message that explains the reason for the exception.</param>
    /// <param name="innerException">The exception that is the cause of the current exception, or a null reference if no inner exception is specified.</param>
    public PlanCreationException(string? message, Exception? innerException) : base(message, innerException)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="PlanCreationException"/> class.
    /// Exception thrown when a plan cannot be created containing the prompt and model results.
    /// </summary>
    /// <param name="message">The error message that explains the reason for the exception.</param>
    /// <param name="createPlanPrompt">The prompt template used to generate the plan.</param>
    /// <param name="modelResults">Completion results from the model; generally, this is the proposed plan.</param>
    /// <param name="innerException">The exception that is the cause of the current exception, or a null reference if no inner exception is specified.</param>
    public PlanCreationException(string? message, string? createPlanPrompt, ChatMessageContent? modelResults, Exception? innerException = null) : base(message, innerException)
    {
        this.CreatePlanPrompt = createPlanPrompt;
        this.ModelResults = modelResults;
    }
}


===== planning\Extensions\ChatHistoryExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Linq;
using Microsoft.SemanticKernel.ChatCompletion;
using Microsoft.SemanticKernel.Text;

namespace Microsoft.SemanticKernel.Planning;

/// <summary>
/// Extension methods for <see cref="ChatHistory"/> class.
/// </summary>
internal static class ChatHistoryExtensions
{
    /// <summary>
    /// Returns the number of tokens in the chat history.
    /// </summary>
    /// <param name="chatHistory">The chat history.</param>
    /// <param name="additionalMessage">An additional message to include in the token count.</param>
    /// <param name="skipStart">The index to start skipping messages.</param>
    /// <param name="skipCount">The number of messages to skip.</param>
    /// <param name="tokenCounter">The token counter to use.</param>
    internal static int GetTokenCount(this ChatHistory chatHistory, string? additionalMessage = null, int skipStart = 0, int skipCount = 0, TextChunker.TokenCounter? tokenCounter = null)
    {
        return tokenCounter is null ?
            Default(chatHistory, additionalMessage, skipStart, skipCount) :
            Custom(chatHistory, additionalMessage, skipStart, skipCount, tokenCounter);

        static int Default(ChatHistory chatHistory, string? additionalMessage, int skipStart, int skipCount)
        {
            int chars = 0;
            bool prevMsg = false;
            for (int i = 0; i < chatHistory.Count; i++)
            {
                if (i >= skipStart && i < skipStart + skipCount)
                {
                    continue;
                }

                chars += chatHistory[i].Content?.Length ?? 0;

                // +1 for "\n" if there was a previous message
                if (prevMsg)
                {
                    chars++;
                }
                prevMsg = true;
            }

            if (additionalMessage is not null)
            {
                chars += 1 + additionalMessage.Length; // +1 for "\n"
            }

            return chars / 4; // same as TextChunker's default token counter
        }

        static int Custom(ChatHistory chatHistory, string? additionalMessage, int skipStart, int skipCount, TextChunker.TokenCounter tokenCounter)
        {
            var messages = string.Join("\n", chatHistory.Where((m, i) => i < skipStart || i >= skipStart + skipCount).Select(m => m.Content));

            if (!string.IsNullOrEmpty(additionalMessage))
            {
                messages = $"{messages}\n{additionalMessage}";
            }

            var tokenCount = tokenCounter(messages);
            return tokenCount;
        }
    }
}


===== planning\Extensions\KernelFunctionMetadataExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Linq;

namespace Microsoft.SemanticKernel.Planning;

/// <summary>
/// Provides extension methods for the <see cref="KernelFunctionMetadata"/> class.
/// </summary>
internal static class KernelFunctionMetadataExtensions
{
    private const string SuccessfulResponseCode = "200";
    private const string SuccessfulResponseDescription = "Success";

    /// <summary>
    /// Creates a <see cref="JsonSchemaFunctionView"/> for a function.
    /// </summary>
    /// <param name="function">The function.</param>
    /// <param name="includeOutputSchema">Indicates if the schema should include information about the output or return type of the function.</param>
    /// <param name="nameDelimiter">The delimiter to use between the plugin name and the function name.</param>
    /// <returns>An instance of <see cref="JsonSchemaFunctionView"/></returns>
    public static JsonSchemaFunctionView ToJsonSchemaFunctionView(this KernelFunctionMetadata function, bool includeOutputSchema = true, string nameDelimiter = "-")
    {
        var functionView = new JsonSchemaFunctionView
        {
            Name = $"{function.PluginName}{nameDelimiter}{function.Name}",
            Description = function.Description,
        };

        var requiredProperties = new List<string>();
        foreach (var parameter in function.Parameters)
        {
            var schema = parameter.Schema;
            if (schema is not null)
            {
                functionView.Parameters.Properties.Add(parameter.Name, schema);
            }
            if (parameter.IsRequired)
            {
                requiredProperties.Add(parameter.Name);
            }
        }

        if (includeOutputSchema)
        {
            var functionResponse = new JsonSchemaFunctionResponse
            {
                Description = SuccessfulResponseDescription
            };

            functionResponse.Content.JsonResponse.Schema = function.ReturnParameter.Schema;

            functionView.FunctionResponses.Add(SuccessfulResponseCode, functionResponse);
        }

        functionView.Parameters.Required = requiredProperties;
        return functionView;
    }

    /// <summary>
    /// Create a manual-friendly string for a function.
    /// </summary>
    /// <param name="function">The function to create a manual-friendly string for.</param>
    /// <returns>A manual-friendly string for a function.</returns>
    internal static string ToManualString(this KernelFunctionMetadata function)
    {
        var inputs = string.Join("\n", function.Parameters.Select(parameter =>
        {
            var defaultValueString = InternalTypeConverter.ConvertToString(parameter.DefaultValue);
            defaultValueString = string.IsNullOrEmpty(defaultValueString) ? string.Empty : $" (default value: {defaultValueString})";
            return $"    - {parameter.Name}: {parameter.Description}{defaultValueString}";
        }));

        // description and inputs are indented by 2 spaces
        // While each parameter in inputs is indented by 4 spaces
        return $"{function.ToFullyQualifiedName()}:  description: {function.Description}  inputs:{inputs}";
    }

    /// <summary>
    /// Create a fully qualified name for a function.
    /// </summary>
    /// <param name="function">The function to create a fully qualified name for.</param>
    /// <returns>A fully qualified name for a function.</returns>
    internal static string ToFullyQualifiedName(this KernelFunctionMetadata function)
    {
        return $"{function.PluginName}.{function.Name}";
    }

    /// <summary>
    /// Create a string for generating an embedding for a function.
    /// </summary>
    /// <param name="function">The function to create a string for generating an embedding for.</param>
    /// <returns>A string for generating an embedding for a function.</returns>
    internal static string ToEmbeddingString(this KernelFunctionMetadata function)
    {
        var inputs = string.Join("\n", function.Parameters.Select(p => $"    - {p.Name}: {p.Description}"));
        return $"{function.Name}:\n  description: {function.Description}\n  inputs:\n{inputs}";
    }
}


===== planning\Extensions\ReadOnlyFunctionCollectionPlannerExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.SemanticKernel.Memory;

namespace Microsoft.SemanticKernel.Planning;

/// <summary>
/// Provides extension methods for the <see cref="IReadOnlyKernelPluginCollection"/> implementations for planners.
/// </summary>
internal static class ReadOnlyPluginCollectionPlannerExtensions
{
    internal const string PlannerMemoryCollectionName = "Planning.KernelFunctionsManual";

    /// <summary>
    /// Returns a function callback that can be used to retrieve a function from the function provider.
    /// </summary>
    /// <param name="plugins">The plugins.</param>
    /// <returns>A function callback that can be used to retrieve a function from the function provider.</returns>
    internal static Func<string, string, KernelFunction?> GetFunctionCallback(this IReadOnlyKernelPluginCollection plugins)
    {
        return (pluginName, functionName) =>
        {
            plugins.TryGetFunction(pluginName, functionName, out var pluginFunction);
            return pluginFunction;
        };
    }

    /// <summary>
    /// Returns a string containing the manual for all available functions.
    /// </summary>
    /// <param name="plugins">The plugins.</param>
    /// <param name="plannerOptions">The planner options.</param>
    /// <param name="semanticQuery">The semantic query for finding relevant registered functions</param>
    /// <param name="logger">The logger to use for logging.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>A string containing the manual for all available functions.</returns>
    internal static async Task<string> GetFunctionsManualAsync(
        this IReadOnlyKernelPluginCollection plugins,
        PlannerOptions plannerOptions,
        string? semanticQuery = null,
        ILogger? logger = null,
        CancellationToken cancellationToken = default)
    {
        IEnumerable<KernelFunctionMetadata> availableFunctions = await plugins.GetFunctionsAsync(plannerOptions, semanticQuery, logger, cancellationToken).ConfigureAwait(false);

        return string.Join("\n\n", availableFunctions.Select(x => x.ToManualString()));
    }

    /// <summary>
    /// Returns a string containing the manual for all available functions in a JSON Schema format.
    /// </summary>
    /// <param name="plugins">The plugins.</param>
    /// <param name="plannerOptions">The planner options.</param>
    /// <param name="semanticQuery">The semantic query for finding relevant registered functions</param>
    /// <param name="logger">The logger to use for logging.</param>
    /// <param name="includeOutputSchema">Indicates if the output or return type of the function should be included in the schema.</param>
    /// <param name="nameDelimiter">The delimiter to use between the plugin name and the function name.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>A string containing the manual for all available functions.</returns>
    internal static async Task<string> GetJsonSchemaFunctionsManualAsync(
        this IReadOnlyKernelPluginCollection plugins,
        PlannerOptions plannerOptions,
        string? semanticQuery = null,
        ILogger? logger = null,
        bool includeOutputSchema = true,
        string nameDelimiter = "-",
        CancellationToken cancellationToken = default)
    {
        IEnumerable<KernelFunctionMetadata> availableFunctions = await plugins.GetFunctionsAsync(plannerOptions, semanticQuery, logger, cancellationToken).ConfigureAwait(false);
        var manuals = availableFunctions.Select(x => x.ToJsonSchemaFunctionView(includeOutputSchema));
        return JsonSerializer.Serialize(manuals);
    }

    /// <summary>
    /// Returns a list of functions that are available to the user based on the semantic query and the excluded plugins and functions.
    /// </summary>
    /// <param name="plugins">The function provider.</param>
    /// <param name="plannerOptions">The planner options.</param>
    /// <param name="semanticQuery">The semantic query for finding relevant registered functions</param>
    /// <param name="logger">The logger to use for logging.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>A list of functions that are available to the user based on the semantic query and the excluded plugins and functions.</returns>
    internal static async Task<IEnumerable<KernelFunctionMetadata>> GetFunctionsAsync(
        this IReadOnlyKernelPluginCollection plugins,
        PlannerOptions plannerOptions,
        string? semanticQuery,
        ILogger? logger,
        CancellationToken cancellationToken)
    {
        return plannerOptions.GetAvailableFunctionsAsync is null ?
            await plugins.GetAvailableFunctionsAsync(plannerOptions, semanticQuery, logger, cancellationToken).ConfigureAwait(false) :
            await plannerOptions.GetAvailableFunctionsAsync(plannerOptions, semanticQuery, cancellationToken).ConfigureAwait(false);
    }

    /// <summary>
    /// Returns a list of functions that are available to the user based on the semantic query and the excluded plugins and functions.
    /// </summary>
    /// <param name="plugins">The function provider.</param>
    /// <param name="plannerOptions">The planner options.</param>
    /// <param name="semanticQuery">The semantic query for finding relevant registered functions</param>
    /// <param name="logger">The logger to use for logging.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>A list of functions that are available to the user based on the semantic query and the excluded plugins and functions.</returns>
    internal static async Task<IEnumerable<KernelFunctionMetadata>> GetAvailableFunctionsAsync(
        this IReadOnlyKernelPluginCollection plugins,
        PlannerOptions plannerOptions,
        string? semanticQuery = null,
        ILogger? logger = null,
        CancellationToken cancellationToken = default)
    {
        var functionsView = plugins.GetFunctionsMetadata();

        var availableFunctions = functionsView
            .Where(s => !plannerOptions.ExcludedPlugins.Contains(s.PluginName, StringComparer.OrdinalIgnoreCase)
                && !plannerOptions.ExcludedFunctions.Contains(s.Name, StringComparer.OrdinalIgnoreCase))
            .ToList();

        List<KernelFunctionMetadata>? result = null;
        var semanticMemoryConfig = plannerOptions.SemanticMemoryConfig;
        if (string.IsNullOrEmpty(semanticQuery) || semanticMemoryConfig is null || semanticMemoryConfig.Memory is NullMemory)
        {
            // If no semantic query is provided, return all available functions.
            // If a Memory provider has not been registered, return all available functions.
            result = availableFunctions;
        }
        else
        {
            result = [];

            // Remember functions in memory so that they can be searched.
            await RememberFunctionsAsync(semanticMemoryConfig.Memory, availableFunctions, cancellationToken).ConfigureAwait(false);

            // Search for functions that match the semantic query.
            var memories = semanticMemoryConfig.Memory.SearchAsync(
                PlannerMemoryCollectionName,
                semanticQuery!,
                semanticMemoryConfig.MaxRelevantFunctions,
                semanticMemoryConfig.RelevancyThreshold ?? 0.0,
                cancellationToken: cancellationToken);

            // Add functions that were found in the search results.
            result.AddRange(await GetRelevantFunctionsAsync(availableFunctions, memories, logger ?? NullLogger.Instance, cancellationToken).ConfigureAwait(false));

            // Add any missing functions that were included but not found in the search results.
            var missingFunctions = semanticMemoryConfig.IncludedFunctions
                .Except(result.Select(x => (x.PluginName, x.Name))!)
                .Join(availableFunctions, f => f, af => (af.PluginName, af.Name), (_, af) => af);

            result.AddRange(missingFunctions);
        }

        return result
            .OrderBy(x => x.PluginName)
            .ThenBy(x => x.Name);
    }

    private static async Task<IEnumerable<KernelFunctionMetadata>> GetRelevantFunctionsAsync(
        IEnumerable<KernelFunctionMetadata> availableFunctions,
        IAsyncEnumerable<MemoryQueryResult> memories,
        ILogger logger,
        CancellationToken cancellationToken = default)
    {
        var relevantFunctions = new List<KernelFunctionMetadata>();
        await foreach (var memoryEntry in memories.WithCancellation(cancellationToken).ConfigureAwait(false))
        {
            var function = availableFunctions.FirstOrDefault(x => x.ToFullyQualifiedName() == memoryEntry.Metadata.Id);
            if (function is not null)
            {
                if (logger.IsEnabled(LogLevel.Debug))
                {
                    logger.LogDebug("Found relevant function. Relevance Score: {0}, Function: {1}", memoryEntry.Relevance, function.ToFullyQualifiedName());
                }

                relevantFunctions.Add(function);
            }
        }

        return relevantFunctions;
    }

    /// <summary>
    /// Saves all available functions to memory.
    /// </summary>
    /// <param name="memory">The memory provided to store the functions to.</param>
    /// <param name="availableFunctions">The available functions to save.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    private static async Task RememberFunctionsAsync(
        ISemanticTextMemory memory,
        List<KernelFunctionMetadata> availableFunctions,
        CancellationToken cancellationToken = default)
    {
        foreach (var function in availableFunctions)
        {
            var functionName = function.ToFullyQualifiedName();
            var key = functionName;
            var description = string.IsNullOrEmpty(function.Description) ? functionName : function.Description;
            var textToEmbed = function.ToEmbeddingString();

            // It'd be nice if there were a saveIfNotExists method on the memory interface
            var memoryEntry = await memory.GetAsync(collection: PlannerMemoryCollectionName, key: key, withEmbedding: false,
                cancellationToken: cancellationToken).ConfigureAwait(false);
            if (memoryEntry is null)
            {
                // TODO It'd be nice if the minRelevanceScore could be a parameter for each item that was saved to memory
                // As folks may want to tune their functions to be more or less relevant.
                // Memory now supports these such strategies.
                await memory.SaveInformationAsync(collection: PlannerMemoryCollectionName, text: textToEmbed, id: key, description: description,
                    additionalMetadata: string.Empty, cancellationToken: cancellationToken).ConfigureAwait(false);
            }
        }
    }
}


===== planning\PlannerInstrumentation.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Diagnostics;
using System.Diagnostics.Metrics;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.SemanticKernel.Diagnostics;

namespace Microsoft.SemanticKernel.Planning;

/// <summary>Surrounds the invocation of a planner with logging and metrics.</summary>
internal static partial class PlannerInstrumentation
{
    /// <summary><see cref="ActivitySource"/> for planning-related activities.</summary>
    private static readonly ActivitySource s_activitySource = new("Microsoft.SemanticKernel.Planning");

    /// <summary><see cref="Meter"/> for planner-related metrics.</summary>
    private static readonly Meter s_meter = new("Microsoft.SemanticKernel.Planning");

    /// <summary><see cref="Histogram{T}"/> to record plan creation duration.</summary>
    private static readonly Histogram<double> s_createPlanDuration = s_meter.CreateHistogram<double>(
        name: "semantic_kernel.planning.create_plan.duration",
        unit: "s",
        description: "Duration time of plan creation.");

    /// <summary><see cref="Histogram{T}"/> to record plan execution duration.</summary>
    private static readonly Histogram<double> s_planExecutionDuration = s_meter.CreateHistogram<double>(
        name: "semantic_kernel.planning.invoke_plan.duration",
        unit: "s",
        description: "Duration time of plan execution.");

    /// <summary>Invokes the supplied <paramref name="createPlanAsync"/> delegate, surrounded by logging and metrics.</summary>
    public static async Task<TPlan> CreatePlanAsync<TPlanner, TPlan>(
        Func<TPlanner, Kernel, string, KernelArguments?, CancellationToken, Task<TPlan>> createPlanAsync,
        TPlanner planner, Kernel kernel, string goal, KernelArguments? arguments, ILogger logger, CancellationToken cancellationToken)
        where TPlanner : class
        where TPlan : class
    {
        string plannerName = planner.GetType().FullName!;

        using var activity = s_activitySource.StartActivity(plannerName);

        logger.LogCreatePlanStarted();
        logger.LogGoal(goal);

        TagList tags = new() { { "semantic_kernel.planner.name", plannerName } };
        long startingTimestamp = Stopwatch.GetTimestamp();
        try
        {
            var plan = await createPlanAsync(planner, kernel, goal, arguments, cancellationToken).ConfigureAwait(false);
            logger.LogPlanCreated();
            logger.LogPlan(plan);

            return plan;
        }
        catch (Exception ex)
        {
            tags.Add("error.type", ex.GetType().FullName);
            activity?.SetError(ex);
            logger.LogCreatePlanError(ex, ex.Message);
            throw;
        }
        finally
        {
            TimeSpan duration = new((long)((Stopwatch.GetTimestamp() - startingTimestamp) * (10_000_000.0 / Stopwatch.Frequency)));
            logger.LogCreatePlanDuration(duration.TotalSeconds);
            s_createPlanDuration.Record(duration.TotalSeconds, in tags);
        }
    }

    // <summary>Invokes the supplied <paramref name="InvokePlanAsync"/> delegate, surrounded by logging and metrics.</summary>
    public static async Task<TPlanResult> InvokePlanAsync<TPlan, TPlanInput, TPlanResult>(
        Func<TPlan, Kernel, TPlanInput?, CancellationToken, Task<TPlanResult>> InvokePlanAsync,
        TPlan plan, Kernel kernel, TPlanInput? input, ILogger logger, CancellationToken cancellationToken)
        where TPlan : class
        where TPlanInput : class
        where TPlanResult : class
    {
        string planName = plan.GetType().FullName!;
        using var activity = s_activitySource.StartActivity(planName);

        logger.LogInvokePlanStarted();

        TagList tags = new() { { "semantic_kernel.plan.name", planName } };
        long startingTimestamp = Stopwatch.GetTimestamp();
        try
        {
            TPlanResult planResult = await InvokePlanAsync(plan, kernel, input, cancellationToken).ConfigureAwait(false);

            logger.LogInvokePlanSuccess();
            logger.LogPlanResult(planResult);

            return planResult;
        }
        catch (Exception ex)
        {
            tags.Add("error.type", ex.GetType().FullName);
            activity?.SetError(ex);
            logger.LogInvokePlanError(ex, ex.Message);
            throw;
        }
        finally
        {
            TimeSpan duration = new((long)((Stopwatch.GetTimestamp() - startingTimestamp) * (10_000_000.0 / Stopwatch.Frequency)));
            logger.LogInvokePlanDuration(duration.TotalSeconds);
            s_planExecutionDuration.Record(duration.TotalSeconds, in tags);
        }
    }

    #region CreatePlan Logging helpers
#pragma warning disable SYSLIB1006 // Multiple logging methods cannot use the same event id within a class
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Information,
        Message = "Plan creation started.")]
    static partial void LogCreatePlanStarted(this ILogger logger);

    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Trace, // Sensitive data, logging as trace, disabled by default
        Message = "Goal: {Goal}")]
    static partial void LogGoal(this ILogger logger, string goal);

    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Information,
        Message = "Plan created.")]
    static partial void LogPlanCreated(this ILogger logger);

    private static readonly Action<ILogger, string, Exception?> s_logPlan =
        LoggerMessage.Define<string>(
            logLevel: LogLevel.Trace,   // Sensitive data, logging as trace, disabled by default
            eventId: 0,
            "Plan:\n{Plan}");
    private static void LogPlan(this ILogger logger, object plan)
    {
        if (logger.IsEnabled(LogLevel.Trace))
        {
            try
            {
                var jsonString = JsonSerializer.Serialize(plan);
                s_logPlan(logger, jsonString, null);
            }
            catch (NotSupportedException ex)
            {
                s_logPlan(logger, "Failed to serialize plan to Json", ex);
            }
        }
    }

    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Error,
        Message = "Plan creation failed. Error: {Message}")]
    static partial void LogCreatePlanError(this ILogger logger, Exception exception, string message);

    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Information,
        Message = "Plan creation duration: {Duration}s.")]
    static partial void LogCreatePlanDuration(this ILogger logger, double duration);

    #endregion

    #region InvokePlan Logging helpers
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Information,
        Message = "Plan execution started.")]
    static partial void LogInvokePlanStarted(this ILogger logger);

    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Information,
        Message = "Plan executed successfully.")]
    static partial void LogInvokePlanSuccess(this ILogger logger);

    private static readonly Action<ILogger, string, Exception?> s_logPlanResult =
        LoggerMessage.Define<string>(
            logLevel: LogLevel.Trace,   // Sensitive data, logging as trace, disabled by default
            eventId: 0,
            "Plan result: {Result}");

    private static void LogPlanResult(this ILogger logger, object planResult)
    {
        if (logger.IsEnabled(LogLevel.Trace))
        {
            try
            {
                var jsonString = planResult.GetType() == typeof(string)
                    ? planResult.ToString()
                    : JsonSerializer.Serialize(planResult);
                s_logPlanResult(logger, jsonString ?? string.Empty, null);
            }
            catch (NotSupportedException ex)
            {
                s_logPlanResult(logger, "Failed to serialize plan result to Json", ex);
            }
        }
    }

    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Error,
        Message = "Plan execution failed. Error: {Message}")]
    static partial void LogInvokePlanError(this ILogger logger, Exception exception, string message);

    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Information,
        Message = "Plan execution duration: {Duration}s.")]
    static partial void LogInvokePlanDuration(this ILogger logger, double duration);

#pragma warning restore SYSLIB1006 // Multiple logging methods cannot use the same event id within a class
    #endregion
}


===== planning\PlannerOptions.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;

namespace Microsoft.SemanticKernel.Planning;

/// <summary>
/// Planner config with semantic memory
/// </summary>
public abstract class PlannerOptions
{
    /// <summary>
    /// A list of plugins to exclude from the plan creation request.
    /// </summary>
    public HashSet<string> ExcludedPlugins { get; } = [];

    /// <summary>
    /// A list of functions to exclude from the plan creation request.
    /// </summary>
    public HashSet<string> ExcludedFunctions { get; } = [];

    /// <summary>
    /// Callback to get the available functions for planning (optional).
    /// Use if you want to override the default function lookup behavior.
    /// If set, this function takes precedence over <see cref="Memory"/>.
    /// Setting <see cref="ExcludedPlugins"/>, <see cref="ExcludedFunctions"/> will be used to filter the results.
    /// </summary>
    public Func<PlannerOptions, string?, CancellationToken, Task<IEnumerable<KernelFunctionMetadata>>>? GetAvailableFunctionsAsync { get; set; }

    /// <summary>
    /// Semantic Memory configuration, used to enable function filtering during plan creation.
    /// </summary>
    /// <remarks>
    /// This configuration will be ignored if GetAvailableFunctionsAsync is set.
    /// </remarks>
    public SemanticMemoryConfig SemanticMemoryConfig { get; set; } = new();
}


===== planning\Schema\JsonSchemaFunctionContent.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Text.Json.Serialization;

namespace Microsoft.SemanticKernel;

/// <summary>
/// A class to describe the content of a response/return type from an KernelFunctionFactory, in a JSON Schema friendly way.
/// </summary>
internal sealed class JsonSchemaFunctionContent
{
    /// <summary>
    /// The JSON Schema for applivation/json responses.
    /// </summary>
    [JsonPropertyName("application/json")]
    public JsonSchemaResponse JsonResponse { get; } = new JsonSchemaResponse();
}


===== planning\Schema\JsonSchemaFunctionParameters.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Text.Json.Serialization;

namespace Microsoft.SemanticKernel;

/// <summary>
/// A class to describe the parameters of an KernelFunctionFactory in a JSON Schema friendly way.
/// </summary>
internal sealed class JsonSchemaFunctionParameters
{
    /// <summary>
    /// The type of schema which is always "object" when describing function parameters.
    /// </summary>
    [JsonPropertyName("type")]
    public string Type => "object";

    /// <summary>
    /// The list of required properties.
    /// </summary>
    [JsonPropertyName("required")]
    public List<string> Required { get; set; } = [];

    /// <summary>
    /// A dictionary of properties name => JSON Schema.
    /// </summary>
    [JsonPropertyName("properties")]
    public Dictionary<string, KernelJsonSchema> Properties { get; set; } = [];
}


===== planning\Schema\JsonSchemaFunctionResponse.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Text.Json.Serialization;

namespace Microsoft.SemanticKernel;

/// <summary>
/// A class for describing the reponse/return type of an KernelFunctionFactory in a JSON Schema friendly way.
/// </summary>
internal sealed class JsonSchemaFunctionResponse
{
    /// <summary>
    /// The response description.
    /// </summary>
    [JsonPropertyName("description")]
    public string Description { get; set; } = string.Empty;

    /// <summary>
    /// The response content.
    /// </summary>
    [JsonPropertyName("content")]
    public JsonSchemaFunctionContent Content { get; set; } = new JsonSchemaFunctionContent();
}


===== planning\Schema\JsonSchemaFunctionView.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Text.Json.Serialization;

namespace Microsoft.SemanticKernel;

/// <summary>
/// A class to describe an KernelFunctionFactory in a JSON Schema friendly way.
/// </summary>
internal sealed class JsonSchemaFunctionView
{
    /// <summary>
    /// The function name.
    /// </summary>
    [JsonPropertyName("name")]
    public string Name { get; set; } = string.Empty;

    /// <summary>
    /// The function description.
    /// </summary>
    [JsonPropertyName("description")]
    public string Description { get; set; } = string.Empty;

    /// <summary>
    /// The function parameters.
    /// </summary>
    [JsonPropertyName("parameters")]
    public JsonSchemaFunctionParameters Parameters { get; set; } = new JsonSchemaFunctionParameters();

    /// <summary>
    /// The function response.
    /// </summary>
    [JsonPropertyName("responses")]
    public Dictionary<string, JsonSchemaFunctionResponse> FunctionResponses { get; set; } = [];
}


===== planning\Schema\JsonSchemaResponse.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Text.Json.Serialization;

namespace Microsoft.SemanticKernel;

/// <summary>
/// A class to describe the content schma of a response/return type from an KernelFunctionFactory, in a JSON Schema friendly way.
/// </summary>
internal sealed class JsonSchemaResponse
{
    /// <summary>
    /// The JSON Schema
    /// </summary>
    [JsonPropertyName("schema")]
    public KernelJsonSchema? Schema { get; set; }
}


===== planning\SemanticMemoryConfig.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using Microsoft.SemanticKernel.Memory;

namespace Microsoft.SemanticKernel.Planning;

/// <summary>
/// Semantic memory configuration.
/// </summary>
public class SemanticMemoryConfig
{
    /// <summary>
    /// A list of functions to be included regardless of relevancy.
    /// </summary>
    public HashSet<(string PluginName, string FunctionName)> IncludedFunctions { get; } = [];

    /// <summary>
    /// Semantic memory to use for filtering function lookup during plan creation.
    /// </summary>
    public ISemanticTextMemory Memory { get; set; } = NullMemory.Instance;

    /// <summary>
    /// The maximum number of relevant functions to search for.
    /// </summary>
    /// <remarks>
    /// Limits the number of relevant functions as result of semantic
    /// search included in the plan creation request.
    /// <see cref="IncludedFunctions"/> will be included
    /// in the plan regardless of this limit.
    /// </remarks>
    public int MaxRelevantFunctions { get; set; } = 100;

    /// <summary>
    /// The minimum relevancy score for a function to be considered.
    /// </summary>
    /// <remarks>
    /// Depending on the embeddings engine used, the user ask, the step goal
    /// and the functions available, this value may need to be adjusted.
    /// For default, this is set to null which will return the top
    /// <see cref="MaxRelevantFunctions"/> sorted by relevancy.
    /// </remarks>
    public double? RelevancyThreshold { get; set; }
}


===== process\Abstractions\DeclarativeConditionEvaluation.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.IO;
using System.Text.Json;
using DevLab.JmesPath;

namespace Microsoft.SemanticKernel.Process.Internal;

internal static class JMESPathConditionEvaluator
{
    public static bool EvaluateCondition(object? data, string jmesPathExpression)
    {
        if (data == null || string.IsNullOrEmpty(jmesPathExpression))
        {
            return false;
        }

        JmesPath _jmesPath = new();
#pragma warning disable CA1031 // Do not catch general exception types
        try
        {
            // Convert your state object to a JSON string
            string jsonState = JsonSerializer.Serialize(data);

            // Evaluate the JMESPath expression
            string result = _jmesPath.Transform(jsonState, jmesPathExpression);

            // Parse the result
            if (string.IsNullOrEmpty(result) || result == "null")
            {
                return false;
            }

            // Handle different result types
            if (result == "true" || result == "\"true\"")
            {
                return true;
            }

            if (result == "false" || result == "\"false\"")
            {
                return false;
            }

            // If the result is a number, check if it's non-zero
            if (double.TryParse(result.Trim('"'), out double numericResult))
            {
                return numericResult != 0;
            }

            // If it's a non-empty array or object, consider it true
            using JsonDocument doc = JsonDocument.Parse(result);
            JsonElement root = doc.RootElement;

            switch (root.ValueKind)
            {
                case JsonValueKind.Array:
                    return root.GetArrayLength() > 0;
                case JsonValueKind.Object:
                    // Check if object has any properties
                    using (var enumerator = root.EnumerateObject())
                    {
                        return enumerator.MoveNext(); // True if there's at least one property
                    }
                case JsonValueKind.String:
                    return !string.IsNullOrEmpty(root.GetString());
                default:
                    return true; // Any other non-null value is considered true
            }
        }
        catch (Exception ex)
        {
            // Log the exception if needed
            Console.WriteLine($"Error evaluating JMESPath expression: {ex.Message}");
            return false;
        }
#pragma warning restore CA1031 // Do not catch general exception types
    }

    /// <summary>
    /// Evaluates a JMESPath expression on a state object and returns the result as a string.
    /// </summary>
    /// <param name="data">The state object to evaluate against</param>
    /// <param name="jmesPathExpression">The JMESPath expression</param>
    /// <returns>The string result, or null if the result is null or cannot be converted to a string</returns>
    public static string? EvaluateToString(object data, string jmesPathExpression)
    {
        if (data == null || string.IsNullOrEmpty(jmesPathExpression))
        {
            return null;
        }

        JmesPath _jmesPath = new();

#pragma warning disable CA1031 // Do not catch general exception types
        try
        {
            // Convert your state object to a JSON string
            string jsonState = JsonSerializer.Serialize(data);

            // Evaluate the JMESPath expression
            string result = _jmesPath.Transform(jsonState, jmesPathExpression);

            // Handle different result scenarios
            if (string.IsNullOrEmpty(result) || result == "null")
            {
                return null;
            }

            // Parse the result to handle string escape sequences properly
            using JsonDocument doc = JsonDocument.Parse(result);
            JsonElement root = doc.RootElement;

            // Check if the result is a JSON string
            if (root.ValueKind == JsonValueKind.String)
            {
                // Return the string value without quotes
                return root.GetString();
            }
            // For non-string results, convert to string representation
            return root.ToString();
        }
        catch (Exception ex)
        {
            // Log the exception if needed
            Console.WriteLine($"Error evaluating JMESPath expression: {ex.Message}");
            return null;
        }
#pragma warning restore CA1031 // Do not catch general exception types
    }
}

internal static class ConditionEvaluator
{
    public static bool EvaluateCondition(object? data, ConditionExpression expression)
    {
        if (data == null || expression == null)
        {
            return false;
        }

        // Get the property value using reflection
        var propertyValue = GetPropertyValue(data, expression.Path);

        // If property doesn't exist, the condition is false
        if (propertyValue == null)
        {
            return false;
        }

        // Convert the target value to the same type as the property
        var typedValue = ConvertValue(expression.Value, propertyValue.GetType());

        // Evaluate based on the operator
        return EvaluateWithOperator(propertyValue, expression.Operator, typedValue);
    }

    private static object? GetPropertyValue(object data, string path)
    {
        // Handle nested properties with dot notation (e.g., "User.Address.City")
        var properties = path.Split('.');
        object? current = data;

        foreach (var property in properties)
        {
            if (current == null)
            {
                return null;
            }

            // Get property info using reflection
            var propertyInfo = current.GetType().GetProperty(property);
            if (propertyInfo == null)
            {
                return null;
            }

            // Get the value
            current = propertyInfo.GetValue(current);
        }

        return current;
    }

    private static object? ConvertValue(object value, Type targetType)
    {
        if (value == null)
        {
            return null;
        }

        // Handle numeric conversions which are common in comparison operations
        if (targetType.IsNumeric() && value is IConvertible)
        {
            return Convert.ChangeType(value, targetType);
        }

        return value;
    }

    private static bool EvaluateWithOperator(object left, ConditionOperator op, object? right)
    {
        // Special case for null values
        if (left == null && right == null)
        {
            return op == ConditionOperator.Equal;
        }

        if (left == null || right == null)
        {
            return op == ConditionOperator.NotEqual;
        }

        // If both values are comparable
        if (left is IComparable comparable)
        {
            int comparisonResult = comparable.CompareTo(right);

            switch (op)
            {
                case ConditionOperator.Equal: return comparisonResult == 0;
                case ConditionOperator.NotEqual: return comparisonResult != 0;
                case ConditionOperator.GreaterThan: return comparisonResult > 0;
                case ConditionOperator.GreaterThanOrEqual: return comparisonResult >= 0;
                case ConditionOperator.LessThan: return comparisonResult < 0;
                case ConditionOperator.LessThanOrEqual: return comparisonResult <= 0;
                default: throw new NotSupportedException($"Operator {op} is not supported.");
            }
        }

        // Fallback to simple equality
        return left.Equals(right);
    }
}

// Extension method to check if a type is numeric
internal static class TypeExtensions
{
    public static bool IsNumeric(this Type type)
    {
        if (type == null)
        {
            return false;
        }

        switch (Type.GetTypeCode(type))
        {
            case TypeCode.Byte:
            case TypeCode.Decimal:
            case TypeCode.Double:
            case TypeCode.Int16:
            case TypeCode.Int32:
            case TypeCode.Int64:
            case TypeCode.SByte:
            case TypeCode.Single:
            case TypeCode.UInt16:
            case TypeCode.UInt32:
            case TypeCode.UInt64:
                return true;
            default:
                return false;
        }
    }
}

internal static class JMESUpdate
{
    public static JsonDocument UpdateState(JsonDocument document, string path, StateUpdateOperations operation, object? value = null)
    {
        if (document == null)
        {
            throw new ArgumentNullException(nameof(document));
        }

        if (string.IsNullOrEmpty(path))
        {
            throw new ArgumentException("Path cannot be null or empty", nameof(path));
        }

        try
        {
            // Clone the document for immutability
            using var memoryStream = new MemoryStream();
            using (var jsonWriter = new Utf8JsonWriter(memoryStream))
            {
                UpdateJsonElement(document.RootElement, jsonWriter, path.Split('.'), 0, operation, value);
                jsonWriter.Flush();
            }

            memoryStream.Position = 0;
            return JsonDocument.Parse(memoryStream);
        }
        catch (JsonException ex)
        {
            throw new InvalidOperationException($"JSON processing error: {ex.Message}", ex);
        }
        catch (IOException ex)
        {
            throw new InvalidOperationException($"I/O error during JSON update: {ex.Message}", ex);
        }
        catch (ArgumentOutOfRangeException ex)
        {
            throw new ArgumentException($"Invalid path: {ex.Message}", ex);
        }
    }

    private static void UpdateJsonElement(JsonElement element, Utf8JsonWriter writer, string[] pathParts, int depth, StateUpdateOperations operation, object? value)
    {
        // If we're at the target element
        if (depth == pathParts.Length)
        {
            PerformOperation(element, writer, operation, value);
            return;
        }

        // If we're at an intermediate level
        switch (element.ValueKind)
        {
            case JsonValueKind.Object:
                writer.WriteStartObject();

                foreach (var property in element.EnumerateObject())
                {
                    if (property.Name == pathParts[depth])
                    {
                        writer.WritePropertyName(property.Name);
                        UpdateJsonElement(property.Value, writer, pathParts, depth + 1, operation, value);
                    }
                    else
                    {
                        property.WriteTo(writer);
                    }
                }

                writer.WriteEndObject();
                break;

            case JsonValueKind.Array:
                writer.WriteStartArray();

                // Check if the path part is a valid array index
                if (int.TryParse(pathParts[depth], out int index) && index < element.GetArrayLength())
                {
                    int i = 0;
                    foreach (var item in element.EnumerateArray())
                    {
                        if (i == index)
                        {
                            UpdateJsonElement(item, writer, pathParts, depth + 1, operation, value);
                        }
                        else
                        {
                            item.WriteTo(writer);
                        }
                        i++;
                    }
                }
                else
                {
                    // If the index is invalid, just copy the array unchanged
                    foreach (var item in element.EnumerateArray())
                    {
                        item.WriteTo(writer);
                    }
                }

                writer.WriteEndArray();
                break;

            default:
                // We've reached a leaf node before the full path was traversed
                // Just write the current value and return
                element.WriteTo(writer);
                break;
        }
    }

    private static void PerformOperation(JsonElement element, Utf8JsonWriter writer, StateUpdateOperations operation, object? value)
    {
        try
        {
            switch (operation)
            {
                case StateUpdateOperations.Set:
                    WriteValue(writer, value);
                    break;

                case StateUpdateOperations.Increment:
                    if (element.ValueKind != JsonValueKind.Number)
                    {
                        throw new InvalidOperationException("Cannot increment non-numeric value at the specified path");
                    }

                    if (element.TryGetInt32(out int intValue))
                    {
                        int incrementBy = value != null ? Convert.ToInt32(value) : 1;
                        writer.WriteNumberValue(intValue + incrementBy);
                    }
                    else if (element.TryGetDouble(out double doubleValue))
                    {
                        double incrementBy = value != null ? Convert.ToDouble(value) : 1.0;
                        writer.WriteNumberValue(doubleValue + incrementBy);
                    }
                    break;

                case StateUpdateOperations.Decrement:
                    if (element.ValueKind != JsonValueKind.Number)
                    {
                        throw new InvalidOperationException("Cannot decrement non-numeric value at the specified path");
                    }

                    if (element.TryGetInt32(out int intVal))
                    {
                        int decrementBy = value != null ? Convert.ToInt32(value) : 1;
                        writer.WriteNumberValue(intVal - decrementBy);
                    }
                    else if (element.TryGetDouble(out double doubleVal))
                    {
                        double decrementBy = value != null ? Convert.ToDouble(value) : 1.0;
                        writer.WriteNumberValue(doubleVal - decrementBy);
                    }
                    break;

                default:
                    throw new NotSupportedException($"Operation {operation} is not supported");
            }
        }
        catch (FormatException ex)
        {
            throw new ArgumentException($"Value format error: {ex.Message}", ex);
        }
        catch (OverflowException ex)
        {
            throw new ArgumentException($"Numeric overflow during operation: {ex.Message}", ex);
        }
    }

    private static void WriteValue(Utf8JsonWriter writer, object? value)
    {
        if (value == null)
        {
            writer.WriteNullValue();
            return;
        }

        switch (value)
        {
            case string strValue:
                writer.WriteStringValue(strValue);
                break;
            case int intValue:
                writer.WriteNumberValue(intValue);
                break;
            case long longValue:
                writer.WriteNumberValue(longValue);
                break;
            case double doubleValue:
                writer.WriteNumberValue(doubleValue);
                break;
            case decimal decimalValue:
                writer.WriteNumberValue(decimalValue);
                break;
            case bool boolValue:
                writer.WriteBooleanValue(boolValue);
                break;
            case DateTime dateTimeValue:
                writer.WriteStringValue(dateTimeValue);
                break;
            default:
                // For complex objects, serialize them to JSON
                var json = JsonSerializer.Serialize(value);
                using (var doc = JsonDocument.Parse(json))
                {
                    doc.RootElement.WriteTo(writer);
                }
                break;
        }
    }
}


===== process\Abstractions\ExceptionExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using Microsoft.Extensions.Logging;

namespace Microsoft.SemanticKernel.Process.Internal;

internal static class ExceptionExtensions
{
    public static Exception Log(this Exception exception, ILogger? logger)
    {
        logger?.LogError(exception, "{ErrorMessage}", exception.Message);
        return exception;
    }
}


===== process\Abstractions\KernelProcessStateMetadataFactory.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using Microsoft.SemanticKernel.Process.Models;

namespace Microsoft.SemanticKernel.Process.Internal;

internal static class ProcessStateMetadataFactory
{
    /// <summary>
    /// Captures Kernel Process State into <see cref="KernelProcessStateMetadata"/>
    /// </summary>
    /// <returns><see cref="KernelProcessStateMetadata"/></returns>
    public static KernelProcessStateMetadata KernelProcessToProcessStateMetadata(KernelProcess kernelProcess)
    {
        KernelProcessStateMetadata metadata = new()
        {
            Name = kernelProcess.State.Name,
            Id = kernelProcess.State.Id,
            VersionInfo = kernelProcess.State.Version,
            StepsState = [],
        };

        foreach (KernelProcessStepInfo step in kernelProcess.Steps)
        {
            metadata.StepsState.Add(step.State.Name, step.ToProcessStateMetadata());
        }

        return metadata;
    }

    public static KernelProcessStepStateMetadata ToProcessStateMetadata(this KernelProcessStepInfo stepInfo)
    {
        if (stepInfo is KernelProcess subprocess)
        {
            return KernelProcessToProcessStateMetadata(subprocess);
        }
        else if (stepInfo is KernelProcessMap stepMap)
        {
            return KernelProcessMapToProcessStateMetadata(stepMap);
        }
        else if (stepInfo is KernelProcessProxy stepProxy)
        {
            return KernelProcessProxyToProcessStateMetadata(stepProxy);
        }

        return StepInfoToProcessStateMetadata(stepInfo);
    }

    private static KernelProcessMapStateMetadata KernelProcessMapToProcessStateMetadata(KernelProcessMap stepMap)
    {
        return
            new()
            {
                Name = stepMap.State.Name,
                Id = stepMap.State.Id,
                VersionInfo = stepMap.State.Version,
                OperationState = ToProcessStateMetadata(stepMap.Operation),
            };
    }

    private static KernelProcessProxyStateMetadata KernelProcessProxyToProcessStateMetadata(KernelProcessProxy stepProxy)
    {
        return new()
        {
            Name = stepProxy.State.Name,
            Id = stepProxy.State.Id,
            VersionInfo = stepProxy.State.Version,
            PublishTopics = stepProxy.ProxyMetadata?.PublishTopics ?? [],
            EventMetadata = stepProxy.ProxyMetadata?.EventMetadata ?? [],
        };
    }

    /// <summary>
    /// Captures Kernel Process Step State into <see cref="KernelProcessStateMetadata"/>
    /// </summary>
    /// <returns><see cref="KernelProcessStateMetadata"/></returns>
    private static KernelProcessStepStateMetadata StepInfoToProcessStateMetadata(KernelProcessStepInfo stepInfo)
    {
        KernelProcessStepStateMetadata metadata = new()
        {
            Name = stepInfo.State.Name,
            Id = stepInfo.State.Id,
            VersionInfo = stepInfo.State.Version
        };

        if (stepInfo.InnerStepType.TryGetSubtypeOfStatefulStep(out Type? genericStateType) && genericStateType != null)
        {
            Type userStateType = genericStateType.GetGenericArguments()[0];
            Type stateOriginalType = typeof(KernelProcessStepState<>).MakeGenericType(userStateType);

            object? innerState = stateOriginalType.GetProperty(nameof(KernelProcessStepState<object>.State))?.GetValue(stepInfo.State);
            if (innerState != null)
            {
                metadata.State = innerState;
            }
        }

        return metadata;
    }
}


===== process\Abstractions\KernelProcessStepExtension.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;

namespace Microsoft.SemanticKernel.Process.Internal;

internal static class KernelProcessStepExtensions
{
    /// <summary>
    /// The generic state type for a process step.
    /// </summary>
    private static readonly Type s_genericStepType = typeof(KernelProcessStep<>);

    /// <summary>
    /// Attempts to find an instance of <![CDATA['KernelProcessStep<>']]> within the provided types hierarchy.
    /// </summary>
    /// <param name="type">The type to examine.</param>
    /// <param name="genericStateType">The matching type if found, otherwise null.</param>
    /// <returns>True if a match is found, false otherwise.</returns>
    public static bool TryGetSubtypeOfStatefulStep(this Type? type, out Type? genericStateType)
    {
        while (type != null && type != typeof(object))
        {
            if (type.IsGenericType && type.GetGenericTypeDefinition() == s_genericStepType)
            {
                genericStateType = type;
                return true;
            }

            type = type.BaseType;
        }

        genericStateType = null;

        return false;
    }
}


===== process\Abstractions\MapExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Linq;
using Microsoft.Extensions.Logging;

namespace Microsoft.SemanticKernel.Process.Internal;

internal static class MapExtensions
{
    public static KernelProcessMap CloneMap(this KernelProcessMap map, ILogger logger)
    {
        KernelProcessMapState newState = new(map.State.Name, map.State.Version, map.State.Id!);

        KernelProcessMap copy =
            new(
                newState,
                map.Operation.Clone(logger),
                map.Edges.ToDictionary(kvp => kvp.Key, kvp => kvp.Value.ToList()));

        return copy;
    }
}


===== process\Abstractions\ProcessConstants.cs =====

// Copyright (c) Microsoft. All rights reserved.
namespace Microsoft.SemanticKernel.Process.Internal;

internal static class ProcessConstants
{
    /// <summary>
    /// Event raised internally for errors not handled at the step level.
    /// </summary>
    public const string GlobalErrorEventId = "Microsoft.SemanticKernel.Process.Global.OnError";

    /// <summary>
    /// Qualified name of the end step.
    /// </summary>
    public const string EndStepName = "Microsoft.SemanticKernel.Process.EndStep";

    /// <summary>
    /// Separator for qualified event ids.
    /// </summary>
    internal const char EventIdSeparator = '.';

    /// <summary>
    /// Version for state of internal steps
    /// </summary>
    public const string InternalStepsVersion = "v0";

    /// <summary>
    /// EventId used internally as the input event for <see cref="KernelProcessMap.Operation"/>.
    /// </summary>
    public const string MapEventId = "StartMap";

    public static class Declarative
    {
        public const string VariablePrefix = "_variables_";

        public const string DefaultCondition = "_default_";

        public const string OnEnterEvent = "_on_enter_";

        public const string OnCompleteEvent = "_on_complete_";

        public const string OnExitEvent = "_on_exit_";

        public const string OnErrorEvent = "_on_error_";
    }

    /// <summary>
    /// Enum containing the name of internal components.
    /// Used for serialization purposes.
    /// </summary>
    public enum SupportedComponents
    {
        Step,
        Process,
        Map,
        Proxy,
        AgentStep,
    }
}


===== process\Abstractions\ProcessExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Linq;
using Microsoft.Extensions.Logging;

namespace Microsoft.SemanticKernel.Process.Internal;

internal static class ProcessExtensions
{
    public static KernelProcess CloneProcess(this KernelProcess process, ILogger logger)
    {
        KernelProcess copy =
            new(
                new KernelProcessState(process.State.Name, process.State.Version, process.State.Id),
                process.Steps.Select(s => s.Clone(logger)).ToArray(),
                process.Edges.ToDictionary(kvp => kvp.Key, kvp => kvp.Value.ToList()));

        return copy;
    }
}


===== process\Abstractions\ProcessStateManager.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Text.Json;
using System.Threading.Tasks;

namespace Microsoft.SemanticKernel;
internal sealed class ProcessStateManager
{
    private readonly Type? _stateType;
    private object? _instance;

    public ProcessStateManager(Type? stateType, object? initialState = null)
    {
        this._stateType = stateType;
        this._instance = initialState;

        if (initialState is null && stateType is not null)
        {
            // Create an instance of the state type if not provided
            this._instance = Activator.CreateInstance(stateType);
        }
    }

    public async Task ReduceAsync(Func<Type, object?, Task<object?>> func)
    {
        Verify.NotNull(func);
        if (this._stateType is null)
        {
            throw new KernelException("State type is not defined.");
        }

        this._instance = await func(this._stateType, this._instance).ConfigureAwait(false);
    }

    public object? GetState()
    {
        if (this._stateType is null)
        {
            return null;
        }

        // return a deep copy of the state
        var json = JsonSerializer.Serialize(this._instance, this._stateType);
        return JsonSerializer.Deserialize(json, this._stateType);
    }
}


===== process\Abstractions\StepExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.Extensions.Logging;
using Microsoft.SemanticKernel.Agents;

namespace Microsoft.SemanticKernel.Process.Internal;

internal static class StepExtensions
{
    public static KernelProcessStepInfo Clone(this KernelProcessStepInfo step, ILogger logger)
    {
        if (step is KernelProcess subProcess)
        {
            return subProcess.CloneProcess(logger);
        }

        if (step is KernelProcessMap mapStep)
        {
            return mapStep.CloneMap(logger);
        }

        Type stateType = step.InnerStepType.ExtractStateType(out Type? userStateType, logger);

        KernelProcessStepState newState = step.State.Clone(stateType, userStateType, logger);

        KernelProcessStepInfo copy =
            new(
                step.InnerStepType,
                newState,
                step.Edges.ToDictionary(kvp => kvp.Key, kvp => kvp.Value.ToList()));

        return copy;
    }

    // Exposed for testing
    public static KernelProcessStepState Clone(this KernelProcessStepState sourceState, Type stateType, Type? userStateType, ILogger logger)
    {
        KernelProcessStepState? newState = (KernelProcessStepState?)Activator.CreateInstance(stateType, sourceState.Name, sourceState.Version, sourceState.Id);
        if (newState == null)
        {
            throw new KernelException($"Failed to instantiate state: {stateType.Name} [{sourceState.Id}].").Log(logger);
        }

        if (userStateType != null)
        {
            newState.InitializeUserState(stateType, userStateType);
        }

        return newState;
    }

    public static Type ExtractStateType(this Type? innerStepType, out Type? userStateType, ILogger? logger)
    {
        Type stateType;

        if (innerStepType.TryGetSubtypeOfStatefulStep(out Type? genericStepType) && genericStepType is not null)
        {
            // The step is a subclass of KernelProcessStep<>, so we need to extract the generic type argument
            // and create an instance of the corresponding KernelProcessStepState<>.
            userStateType = genericStepType.GetGenericArguments()[0];
            if (userStateType is null)
            {
                throw new KernelException("The generic type argument for the KernelProcessStep subclass could not be determined.").Log(logger);
            }

            stateType = typeof(KernelProcessStepState<>).MakeGenericType(userStateType);
            if (stateType is null)
            {
                throw new KernelException("The generic type argument for the KernelProcessStep subclass could not be determined.").Log(logger);
            }
        }
        else
        {
            // The step is a KernelProcessStep with no use`-defined state, so we can use the base KernelProcessStepState.
            stateType = typeof(KernelProcessStepState);
            userStateType = null;
        }

        return stateType;
    }

    public static void InitializeUserState(this KernelProcessStepState stateObject, Type stateType, Type? userStateType)
    {
        if (stateType.IsGenericType && userStateType != null)
        {
            var userState = stateType.GetProperty(nameof(KernelProcessStepState<object>.State))?.GetValue(stateObject);
            if (userState is null)
            {
                stateType.GetProperty(nameof(KernelProcessStepState<object>.State))?.SetValue(stateObject, Activator.CreateInstance(userStateType));
            }
        }
    }

    /// <summary>
    /// Examines the KernelFunction for the step and creates a dictionary of input channels.
    /// Some types such as KernelProcessStepContext are special and need to be injected into
    /// the function parameter. Those objects are instantiated at this point.
    /// </summary>
    /// <param name="channel">The source channel to evaluate</param>
    /// <param name="functions">A dictionary of KernelFunction instances.</param>
    /// <param name="logger">An instance of <see cref="ILogger"/>.</param>
    /// <param name="externalMessageChannel">An instance of <see cref="IExternalKernelProcessMessageChannel"/></param>
    /// <param name="agentDefinition">An instance of <see cref="AgentDefinition"/></param>
    /// <returns><see cref="Dictionary{TKey, TValue}"/></returns>
    /// <exception cref="InvalidOperationException"></exception>
    public static Dictionary<string, Dictionary<string, object?>?> FindInputChannels(
        this IKernelProcessMessageChannel channel,
        Dictionary<string, KernelFunction> functions,
        ILogger? logger,
        IExternalKernelProcessMessageChannel? externalMessageChannel = null,
        AgentDefinition? agentDefinition = null)
    {
        if (functions is null)
        {
            throw new KernelException("Internal Error: The step has not been initialized.").Log(logger);
        }

        Dictionary<string, Dictionary<string, object?>?> inputs = new();
        foreach (var kvp in functions)
        {
            inputs[kvp.Key] = new();
            foreach (var param in kvp.Value.Metadata.Parameters)
            {
                // Optional parameters are should not be added to the input dictionary.
                if (!param.IsRequired)
                {
                    continue;
                }

                // Parameters of type KernelProcessStepContext are injected by the process
                // and are instantiated here.
                if (param.ParameterType == typeof(KernelProcessStepContext))
                {
                    inputs[kvp.Key]![param.Name] = new KernelProcessStepContext(channel);
                }
                else if (param.ParameterType == typeof(KernelProcessStepExternalContext))
                {
                    inputs[kvp.Key]![param.Name] = new KernelProcessStepExternalContext(externalMessageChannel);
                }
                else if (param.ParameterType == typeof(AgentDefinition))
                {
                    inputs[kvp.Key]![param.Name] = agentDefinition;
                }
                else
                {
                    inputs[kvp.Key]![param.Name] = null;
                }
            }
        }

        return inputs;
    }
}


===== process\Runtime\AgentFactoryFactory.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.Agents.AzureAI;
using Microsoft.SemanticKernel.Agents.OpenAI;

namespace Microsoft.SemanticKernel.Process.Internal;

/// <summary>
/// A factory for creating agent threads.
/// </summary>
public static class ProcessAgentFactory
{
    /// <summary>
    /// Processes the agent definition and creates the correct derived type of <see cref="AgentFactory"/>."/>
    /// </summary>
    /// <param name="agentDefinition">An instance of <see cref="AgentDefinition"/>.</param>
    public static AgentFactory CreateAgentFactory(this AgentDefinition agentDefinition)
    {
        return agentDefinition.Type switch
        {
            AzureAIAgentFactory.AzureAIAgentType => new AzureAIAgentFactory(),
            OpenAIAssistantAgentFactory.OpenAIAssistantAgentType => new OpenAIAssistantAgentFactory(),
            ChatCompletionAgentFactory.ChatCompletionAgentType => new ChatCompletionAgentFactory(),
            _ => throw new NotSupportedException($"Agent type {agentDefinition.Type} is not supported."),
        };
    }
}


===== process\Runtime\AgentThreadFactory.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Threading.Tasks;
using Azure;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.Agents.AzureAI;

namespace Microsoft.SemanticKernel.Process.Internal;

/// <summary>
/// A factory for creating agent threads.
/// </summary>
public static class AgentThreadFactory
{
    /// <summary>
    /// Processes the thread definition and creates an underlying thread if needed.
    /// </summary>
    /// <param name="threadDefinition"></param>
    /// <param name="kernel"></param>
    /// <returns></returns>
    /// <exception cref="KernelException"></exception>
    public static async Task<AgentThread> CreateAgentThreadAsync(this KernelProcessAgentThread threadDefinition, Kernel kernel)
    {
        switch (threadDefinition.ThreadType)
        {
            case KernelProcessThreadType.AzureAI:
                return await CreateAzureAIThreadAsync(threadDefinition.ThreadId, kernel).ConfigureAwait(false);
            case KernelProcessThreadType.ChatCompletion:
                return new ChatHistoryAgentThread([]);

            default:
                throw new KernelException($"Thread type {threadDefinition.ThreadType} is not supported.");

        }
    }

    private static async Task<AgentThread> CreateAzureAIThreadAsync(string? id, Kernel kernel)
    {
        const string ErrorMessage = "The thread could not be created due to an error response from the service.";
        var client = kernel.Services.GetService<Azure.AI.Agents.Persistent.PersistentAgentsClient>() ?? throw new KernelException("The AzureAI thread type requires an AgentsClient to be registered in the kernel.");

        if (string.IsNullOrWhiteSpace(id))
        {
            try
            {
                var threadResponse = await client.Threads.CreateThreadAsync().ConfigureAwait(false);
                id = threadResponse.Value.Id;
            }
            catch (RequestFailedException ex)
            {
                throw new KernelException(ErrorMessage, ex);
            }
            catch (AggregateException ex)
            {
                throw new KernelException(ErrorMessage, ex);
            }
        }

        return new AzureAIAgentThread(client, id);
    }
}


===== process\Runtime\KernelProcessAgentExecutor_Internal.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Text.Json;
using System.Threading.Tasks;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.Process.Internal;

namespace Microsoft.SemanticKernel;

/// <summary>
/// Represents a step in a process that executes an agent.
/// </summary>
internal sealed class KernelProcessAgentExecutorInternal : KernelProcessStep<KernelProcessAgentExecutorState>
{
    private readonly KernelProcessAgentStep _agentStep;
    private readonly KernelProcessAgentThread _processThread;
    private readonly ProcessStateManager _stateManager;

    internal KernelProcessAgentExecutorState _state = new();

    /// <summary>
    /// Constructor used by parent process passing specific agent factory
    /// </summary>
    /// <param name="agentStep"></param>
    /// <param name="processThread"></param>
    /// <param name="stateManager"></param>
    public KernelProcessAgentExecutorInternal(KernelProcessAgentStep agentStep, KernelProcessAgentThread processThread, ProcessStateManager stateManager)
    {
        Verify.NotNull(agentStep);
        Verify.NotNull(agentStep.AgentDefinition);

        this._agentStep = agentStep;
        this._processThread = processThread;
        this._stateManager = stateManager;
    }

    /// <inheritdoc/>
    public override ValueTask ActivateAsync(KernelProcessStepState<KernelProcessAgentExecutorState> state)
    {
        this._state = state.State!;

        return base.ActivateAsync(state);
    }

    /// <summary>
    /// Invokes the agent with the provided definition.
    /// </summary>
    /// <param name="kernel">instance of <see cref="Kernel"/></param>
    /// <param name="message">incoming message to be processed by agent</param>
    /// <param name="writtenToThread"> <see langword="true"/> if the message has already been written to the thread</param>
    /// <returns></returns>
    [KernelFunction]
    public async Task<AgentInvokeOutputWrapper?> InvokeAsync(Kernel kernel, object? message = null, bool writtenToThread = false)
    {
        ChatMessageContent? inputMessageContent = null;
        try
        {
            // TODO: Update agent inputs to include messages_in, thread, user_messages, etc.
            // TODO: copy messages_in to the thread

            if (!writtenToThread)
            {
                inputMessageContent = null;
                if (message is ChatMessageContent chatMessage)
                {
                    // if receiving a chat message content, passing as is
                    inputMessageContent = chatMessage;
                }
                else
                {
                    // else wrapping it up assuming it is serializable
                    // todo: add try catch and use shared serialization logic
                    inputMessageContent = new ChatMessageContent(
                        ChatCompletion.AuthorRole.User,
                        JsonSerializer.Serialize(message)
                    );
                }
            }

            if (this._agentStep.AgentIdResolver is not null)
            {
                var state = this._stateManager.GetState();
                this._agentStep.AgentDefinition.Id = await this._agentStep.AgentIdResolver(state).ConfigureAwait(false);
                if (string.IsNullOrWhiteSpace(this._agentStep.AgentDefinition.Id))
                {
                    throw new KernelException("AgentIdResolver returned an empty agent ID");
                }
            }

            List<ChatMessageContent> agentResponses = [];
            AgentFactory agentFactory = ProcessAgentFactory.CreateAgentFactory(this._agentStep.AgentDefinition);
            Agent agent = await agentFactory.CreateAsync(kernel, this._agentStep.AgentDefinition).ConfigureAwait(false);
            this._state!.AgentId = agent.Id;

            var threadDefinition = this._processThread with { ThreadId = this._state.ThreadId };
            var agentThread = await this._processThread.CreateAgentThreadAsync(kernel).ConfigureAwait(false);
            this._state.ThreadId = agentThread.Id;

            if (inputMessageContent is null)
            {
                await foreach (var response in agent.InvokeAsync(agentThread).ConfigureAwait(false))
                {
                    agentThread = response.Thread;
                    agentResponses.Add(response.Message);
                }
            }
            else
            {
                await foreach (var response in agent.InvokeAsync(inputMessageContent, agentThread).ConfigureAwait(false))
                {
                    agentThread = response.Thread;
                    agentResponses.Add(response.Message);
                }
            }

            var outputWrapper = new AgentInvokeOutputWrapper
            {
                MessagesOut = agentResponses,
                // TODO: Events
            };

            return outputWrapper;
        }
        catch (System.Exception)
        {
            throw;
        }
    }
}

/// <summary>
/// State used by <see cref="KernelProcessAgentExecutor"/> to persist agent and thread details
/// </summary>
public sealed class KernelProcessAgentExecutorState
{
    /// <summary>
    /// Id of agent so it is reused if the same process is invoked again
    /// </summary>
    public string? AgentId { get; set; }

    /// <summary>
    /// Thread related information used for checking thread details by the specific agent
    /// </summary>
    public string? ThreadId { get; set; }
}

/// <summary>
/// Output wrapper for agent invocation.
/// </summary>
public sealed class AgentInvokeOutputWrapper
{
    /// <summary>
    /// Collection of output messages produced by agent.
    /// </summary>
    public List<ChatMessageContent> MessagesOut { get; set; } = [];

    /// <summary>
    /// Collection of events produced by agent.
    /// </summary>
    public Dictionary<string, object?>? Events { get; set; } = [];
}


===== process\Runtime\KernelProcessProxyMessageFactory.cs =====

// Copyright (c) Microsoft. All rights reserved.

namespace Microsoft.SemanticKernel.Process.Internal;

/// <summary>
/// Factory that helps create <see cref="KernelProcessProxyMessage"/>
/// </summary>
internal static class KernelProcessProxyMessageFactory
{
    /// <summary>
    /// Captures SK process event data into <see cref="KernelProcessProxyMessage"/>
    /// </summary>
    /// <param name="processId">id of the running process where the event is emitted from</param>
    /// <param name="triggerEventName">SK event name triggered inside the process</param>
    /// <param name="publishTopic">name to be used for publishing the event outside of the SK process</param>
    /// <param name="data">data contained from SK event to be emitted externally</param>
    /// <returns><see cref="KernelProcessProxyMessage"/></returns>
    internal static KernelProcessProxyMessage CreateProxyMessage(string processId, string triggerEventName, string publishTopic, object? data)
    {
        KernelProcessProxyMessage newMessage = new()
        {
            ProcessId = processId,
            TriggerEventId = triggerEventName,
            ExternalTopicName = publishTopic,
            EventData = data != null ? data as KernelProcessEventData : null
        };

        return newMessage;
    }
}


===== process\Runtime\MapExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text.Json;
using Microsoft.Extensions.Logging;
using Microsoft.SemanticKernel.Process.Internal;

namespace Microsoft.SemanticKernel.Process.Runtime;

internal static class MapExtensions
{
    public static (IEnumerable, KernelProcess, string) Initialize(this KernelProcessMap map, ProcessMessage message, ILogger? logger)
    {
        IEnumerable inputValues = message.GetMapInput(logger);
        KernelProcess mapOperation;
        string startEventId;

        if (map.Operation is KernelProcess kernelProcess)
        {
            startEventId = DefineOperationEventId(kernelProcess, message);
            mapOperation = kernelProcess;
        }
        else
        {
            startEventId = ProcessConstants.MapEventId;
            foreach (var kvp in message.Values)
            {
                if (kvp.Value is KernelProcessEventData eventData)
                {
                    message.Values[kvp.Key] = eventData.RepackAsKernelProcessEventDataList().ToArray();
                }
            }

            string? parameterName = message.Values.SingleOrDefault(kvp => IsEqual(inputValues, kvp.Value)).Key;
            string proxyId = Guid.NewGuid().ToString("N");
            mapOperation =
                new KernelProcess(
                    new KernelProcessState($"Map{map.Operation.State.Name}", map.Operation.State.Version, proxyId),
                    [map.Operation],
                    new() { { ProcessConstants.MapEventId, [new KernelProcessEdge(proxyId, new KernelProcessFunctionTarget(map.Operation.State.Id!, message.FunctionName, parameterName))] } });
        }

        return (inputValues, mapOperation, startEventId);
    }

    public static IEnumerable<KernelProcessEventData> RepackAsKernelProcessEventDataList(this KernelProcessEventData eventData)
    {
        var valueData = eventData.ToObject();
        var valueType = valueData!.GetType();

        if (typeof(IEnumerable).IsAssignableFrom(valueType))
        {
            var elementType = valueType.IsArray ? valueType.GetElementType() : valueType.GetGenericArguments().FirstOrDefault();
            if (elementType != null)
            {
                var kernelProcessEventDataList = new List<KernelProcessEventData>();
                foreach (var item in (IEnumerable)valueData)
                {
                    var kernelProcessEventData = KernelProcessEventData.FromObject(item);
                    if (kernelProcessEventData != null)
                    {
                        kernelProcessEventDataList.Add(kernelProcessEventData);
                    }
                    else
                    {
                        throw new KernelException($"Internal Map Error: Collection contains an element that cannot be serialized - {eventData.ObjectType}/{item.GetType().FullName}.");
                    }
                }
                return kernelProcessEventDataList;
            }

            throw new KernelException($"Internal Map Error: Input parameter is not a collection of serializable elements - {eventData.ObjectType}.");
        }

        throw new KernelException($"Internal Map Error: Input parameter is not enumerable - {eventData.ObjectType}.");
    }

    private static IEnumerable GetMapInput(this ProcessMessage message, ILogger? logger)
    {
        if (message.TargetEventData == null)
        {
            throw new KernelException($"Internal Map Error: Input data not present - {message.SourceId}/{message.DestinationId}.").Log(logger);
        }

        Type valueType = message.TargetEventData.GetType();
        object? valueData = message.TargetEventData;
        // Unpacking object to be an array compatible with map step initialization
        if (message.TargetEventData is KernelProcessEventData eventData)
        {
            valueData = eventData.ToObject();
            valueType = valueData!.GetType();

            if (typeof(IEnumerable).IsAssignableFrom(valueType) && valueType.HasElementType)
            {
                var repackedList = eventData.RepackAsKernelProcessEventDataList();
                valueData = repackedList.ToArray();
                valueType = valueData!.GetType();
            }
        }

        return typeof(IEnumerable).IsAssignableFrom(valueType) && valueType.HasElementType ?
            (IEnumerable)valueData! :
            throw new KernelException($"Internal Map Error: Input parameter is not enumerable - {message.SourceId}/{message.DestinationId} [{valueType.FullName}].").Log(logger);
    }

    private static string DefineOperationEventId(KernelProcess mapOperation, ProcessMessage message)
    {
        // Fails when zero or multiple candidate edges exist.  No reason a map-operation should be irrational.
        return
            mapOperation.Edges.SingleOrDefault(kvp => kvp.Value.Any(e => (e.OutputTarget as KernelProcessFunctionTarget)!.FunctionName == message.FunctionName)).Key ??
            throw new InvalidOperationException($"The map operation does not have an input edge that matches the message destination: {mapOperation.State.Name}/{mapOperation.State.Id}.");
    }

    private static bool IsEqual(IEnumerable targetData, object? possibleValue)
    {
        // Short circuit for null candidate
        if (possibleValue == null)
        {
            return false;
        }

        // Object equality is valid for LocalRuntime
        if (targetData == possibleValue)
        {
            return true;
        }

        // DAPR runtime requires a deeper comparison
        Type candidateType = possibleValue.GetType();

        // Candidate must be enumerable with element type
        if (!typeof(IEnumerable).IsAssignableFrom(candidateType) ||
            !candidateType.HasElementType)
        {
            return false;
        }

        // Types much match
        Type targetType = targetData.GetType();
        if (candidateType != targetData.GetType())
        {
            return false;
        }

        if (targetType.GetElementType() == candidateType.GetElementType())
        {
            // Data has already been serialized to make get this far.
            // Let's use serialization for equality check.
            // Note: We aren't looking for equivalency.  We are testing
            // for a clone of the exact same data instances.
            string targetDataJson = JsonSerializer.Serialize(targetData);
            string possibleValueJson = JsonSerializer.Serialize(possibleValue);
            return string.Equals(targetDataJson, possibleValueJson, StringComparison.Ordinal);
        }

        return false;
    }
}


===== process\Runtime\ProcessEvent.cs =====

// Copyright (c) Microsoft. All rights reserved.
using Microsoft.SemanticKernel.Process.Internal;

namespace Microsoft.SemanticKernel.Process.Runtime;

/// <summary>
/// A wrapper around <see cref="KernelProcessEvent"/> that helps to manage the namespace of the event.
/// </summary>
public record ProcessEvent
{
    /// <summary>
    /// The namespace of the event.
    /// </summary>
    public string Namespace { get; init; } = string.Empty;

    /// <summary>
    /// The source Id of the event.
    /// </summary>
    public string SourceId { get; init; } = string.Empty;

    /// <summary>
    /// An optional data payload associated with the event.
    /// </summary>
    public object? Data { get; init; }

    /// <summary>
    /// The visibility of the event.
    /// </summary>
    public KernelProcessEventVisibility Visibility { get; init; }

    /// <summary>
    /// This event represents a runtime error / exception raised internally by the framework.
    /// </summary>
    public bool IsError { get; init; }

    /// <summary>
    /// The Qualified Id of the event.
    /// </summary>
    internal string QualifiedId => $"{this.Namespace}{ProcessConstants.EventIdSeparator}{this.SourceId}";

    internal string? WrittenToThread { get; init; }

    /// <summary>
    /// Creates a new <see cref="ProcessEvent"/> from a <see cref="KernelProcessEvent"/>.
    /// </summary>
    /// <param name="kernelProcessEvent">The <see cref="KernelProcessEvent"/></param>
    /// <param name="eventNamespace">The namespace of the event.</param>
    /// <param name="isError">Indicates if event is from a runtime error.</param>
    internal static ProcessEvent Create(KernelProcessEvent kernelProcessEvent, string eventNamespace, bool isError = false) =>
        new()
        {
            Namespace = eventNamespace,
            SourceId = kernelProcessEvent.Id,
            Data = KernelProcessEventData.FromObject(kernelProcessEvent.Data),
            Visibility = kernelProcessEvent.Visibility,
            IsError = isError,
        };

    /// <summary>
    /// Creates a new <see cref="ProcessEvent"/>.
    /// </summary>
    /// <param name="data">data passed in the event</param>
    /// <param name="eventNamespace">The namespace of the event.</param>
    /// <param name="sourceId">event source id</param>
    /// <param name="eventVisibility">visibility of the event</param>
    /// <param name="isError">Indicates if event is from a runtime error.</param>
    /// <param name="writtenToThread">Thread Id of the event</param>
    /// <returns></returns>
    internal static ProcessEvent Create(object? data, string eventNamespace, string sourceId, KernelProcessEventVisibility eventVisibility, bool isError = false, string? writtenToThread = null) =>
        new()
        {
            Namespace = eventNamespace,
            SourceId = sourceId,
            Data = KernelProcessEventData.FromObject(data),
            IsError = isError,
            Visibility = eventVisibility,
            WrittenToThread = writtenToThread,
        };

    internal KernelProcessEvent ToKernelProcessEvent()
    {
        return new KernelProcessEvent
        {
            Id = this.SourceId,
            Data = this.Data,
            Visibility = this.Visibility,
        };
    }
}


===== process\Runtime\ProcessMessage.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace Microsoft.SemanticKernel.Process.Runtime;

/// <summary>
/// Represents a message used in a process runtime.
/// </summary>
/// <remarks>
/// Initializes a new instance of the <see cref="ProcessMessage"/> class.
/// </remarks>
/// <param name="SourceId">The source identifier of the message.</param>
/// <param name="DestinationId">The destination identifier of the message.</param>
/// <param name="FunctionName">The name of the function associated with the message.</param>
/// <param name="Values">The dictionary of values associated with the message.</param>
/// <param name="writtenToThread"></param>
[KnownType(typeof(KernelProcessError))]
[KnownType(typeof(KernelProcessProxyMessage))]
public record ProcessMessage(
    string SourceId,
    string DestinationId,
    string FunctionName,
    Dictionary<string, object?> Values, string? writtenToThread = null)
{
    /// <summary>
    /// Id of the the event that triggered the process message
    /// </summary>
    public string? SourceEventId { get; init; }

    /// <summary>
    /// The Id of the target event. This may be null if the message is not targeting a sub-process.
    /// </summary>
    public string? TargetEventId { get; init; }

    /// <summary>
    /// The data associated with the target event. This may be null if the message is not targeting a sub-process.
    /// </summary>
    public object? TargetEventData { get; init; }

    /// <summary>
    /// The Id of the group that the message belongs to. This may be null if the message is not part of a group.
    /// </summary>
    public string? GroupId { get; init; }

    /// <summary>
    /// An evaluation string that will be evaluated to determine the thread to run on.
    /// </summary>
    public string? ThreadEval { get; init; }

    /// <summary>
    /// An evaluation string that will be evaluated to determine the messages to send to the target.
    /// </summary>
    public List<string>? MessagesInEval { get; init; }

    /// <summary>
    /// An evaluation string that will be evaluated to determine the inputs to send to the target.
    /// </summary>
    public Dictionary<string, string>? InputEvals { get; init; }
}


===== process\Runtime\ProcessMessageFactory.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;

namespace Microsoft.SemanticKernel.Process.Runtime;

/// <summary>
/// A factory class for creating <see cref="ProcessMessage"/> instances.
/// </summary>
internal static class ProcessMessageFactory
{
    /// <summary>
    /// Creates a new <see cref="ProcessMessage"/> instance from a <see cref="KernelProcessEdge"/> and a data object.
    /// </summary>
    /// <param name="edge">An instance of <see cref="KernelProcessEdge"/></param>
    /// <param name="sourceEventId">id of the source steps generating the event</param>
    /// <param name="data">A data object.</param>
    /// <param name="writtenToThread">Optional thread id where the event was written</param>
    /// <returns>An instance of <see cref="ProcessMessage"/></returns>
    internal static ProcessMessage CreateFromEdge(KernelProcessEdge edge, string sourceEventId, object? data, string? writtenToThread = null)
    {
        if (edge.OutputTarget is KernelProcessFunctionTarget functionTarget)
        {
            Dictionary<string, object?> parameterValue = [];
            if (!string.IsNullOrWhiteSpace(functionTarget.ParameterName))
            {
                parameterValue.Add(functionTarget.ParameterName!, data);
            }

            ProcessMessage newMessage = new(edge.SourceStepId, functionTarget.StepId, functionTarget.FunctionName, parameterValue)
            {
                SourceEventId = sourceEventId,
                TargetEventId = functionTarget.TargetEventId,
                TargetEventData = data,
                GroupId = edge.GroupId,
                writtenToThread = writtenToThread
            };

            return newMessage;
        }
        else if (edge.OutputTarget is KernelProcessAgentInvokeTarget agentTarget)
        {
            return new ProcessMessage(sourceEventId, agentTarget.StepId, "", [])
            {
                SourceEventId = sourceEventId,
                TargetEventId = null,
                TargetEventData = data,
                GroupId = edge.GroupId,
                writtenToThread = writtenToThread,
                MessagesInEval = agentTarget.MessagesInEval,
                InputEvals = agentTarget.InputEvals,
                ThreadEval = agentTarget.ThreadEval
            };
        }

        throw new KernelException($"Unsupported target type: {edge.OutputTarget.GetType().Name}");
    }
}


===== process\TestsShared\CloudEvents\MockCloudEventClient.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Threading.Tasks;
using Microsoft.SemanticKernel;

namespace SemanticKernel.Process.TestsShared.CloudEvents;
/// <summary>
/// Class used for testing purposes to mock emitting external cloud events
/// </summary>
public class MockCloudEventClient : IExternalKernelProcessMessageChannel
{
    /// <summary>
    /// Initialization counter for testing
    /// </summary>
    public int InitializationCounter { get; set; } = 0;
    /// <summary>
    /// Uninitialization counter for testing
    /// </summary>
    public int UninitializationCounter { get; set; } = 0;
    /// <summary>
    /// Captures cloud events emitted for testing
    /// </summary>
    public List<KernelProcessProxyMessage> CloudEvents { get; set; } = [];

    private static MockCloudEventClient? s_instance = null;

    /// <summary>
    /// Instance of <see cref="MockCloudEventClient"/> when used as singleton
    /// </summary>
    public static MockCloudEventClient Instance
    {
        get
        {
            return s_instance ??= new MockCloudEventClient();
        }
    }

    /// <summary>
    /// For testing purposes reset public properties
    /// </summary>
    public void Reset()
    {
        this.InitializationCounter = 0;
        this.UninitializationCounter = 0;
        this.CloudEvents.Clear();
    }

    /// <inheritdoc/>
    public Task EmitExternalEventAsync(string externalTopicEvent, KernelProcessProxyMessage message)
    {
        if (message != null)
        {
            this.CloudEvents.Add(message);
        }

        return Task.CompletedTask;
    }

    /// <inheritdoc/>
    public ValueTask Initialize()
    {
        this.InitializationCounter++;
        return ValueTask.CompletedTask;
    }

    /// <inheritdoc/>
    public ValueTask Uninitialize()
    {
        this.UninitializationCounter++;
        return ValueTask.CompletedTask;
    }
}


===== process\TestsShared\CloudEvents\MockCloudEventData.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Runtime.Serialization;
using System.Text.Json.Serialization;
using Microsoft.SemanticKernel;

namespace SemanticKernel.Process.TestsShared.CloudEvents;

/// <summary>
/// Mock cloud event data used for testing purposes only
/// </summary>
public class MockCloudEventData
{
    /// <summary>
    /// Name of the mock topic
    /// </summary>
    [DataMember]
    [JsonPropertyName("topicName")]
    public required string TopicName { get; set; }

    /// <summary>
    /// Data emitted in the mock cloud event
    /// </summary>
    [DataMember]
    [JsonPropertyName("data")]
    public KernelProcessProxyMessage? Data { get; set; }
}


===== process\TestsShared\Services\CounterService.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Threading;

namespace SemanticKernel.Process.TestsShared.Services;

internal sealed class CounterService : ICounterService
{
    internal int _counter = 0;
    public int GetCount()
    {
        return this._counter;
    }

    public int IncreaseCount()
    {
        Interlocked.Increment(ref this._counter);
        return this._counter;
    }
}


===== process\TestsShared\Services\ICounterService.cs =====

// Copyright (c) Microsoft. All rights reserved.
namespace SemanticKernel.Process.TestsShared.Services;

/// <summary>
/// Interface for Counter Service used by <see cref="TestsShared.Steps.CommonSteps.CountStep"/>
/// </summary>
public interface ICounterService
{
    /// <summary>
    /// Increase count
    /// </summary>
    /// <returns></returns>
    int IncreaseCount();

    /// <summary>
    /// Get current count
    /// </summary>
    /// <returns></returns>
    int GetCount();
}


===== process\TestsShared\Setup\KernelSetup.cs =====

// Copyright (c) Microsoft. All rights reserved.
using Microsoft.Extensions.DependencyInjection;
using Microsoft.SemanticKernel;
using SemanticKernel.Process.TestsShared.Services;

namespace SemanticKernel.Process.TestsShared.Setup;

internal static class KernelSetup
{
    public static Kernel SetupKernelWithCounterService(CounterService counterService)
    {
        IKernelBuilder builder = Kernel.CreateBuilder();

        builder.Services.AddSingleton<ICounterService>(counterService);

        return builder.Build();
    }
}


===== process\TestsShared\Steps\CommonSteps.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.Threading.Tasks;
using Microsoft.SemanticKernel;
using SemanticKernel.Process.TestsShared.Services;

namespace SemanticKernel.Process.TestsShared.Steps;

#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member

/// <summary>
/// Collection of common steps used by UnitTests and IntegrationUnitTests
/// </summary>
public static class CommonSteps
{
    /// <summary>
    /// The step that counts how many times it has been invoked.
    /// </summary>
    public sealed class CountStep : KernelProcessStep
    {
        public const string CountFunction = nameof(Count);

        private readonly ICounterService _counter;
        public CountStep(ICounterService counterService)
        {
            this._counter = counterService;
        }

        [KernelFunction]
        public string Count()
        {
            int count = this._counter.IncreaseCount();

            return count.ToString();
        }
    }

    /// <summary>
    /// The step that counts how many times it has been invoked.
    /// </summary>
    public sealed class EvenNumberDetectorStep : KernelProcessStep
    {
        /// <summary>
        /// Output events emitted by <see cref="EvenNumberDetectorStep"/>
        /// </summary>
        public static class OutputEvents
        {
            /// <summary>
            /// Event number event name
            /// </summary>
            public const string EvenNumber = nameof(EvenNumber);
            /// <summary>
            /// Event number event name
            /// </summary>
            public const string OddNumber = nameof(OddNumber);
        }

        /// <summary>
        /// Step that emits different event depending if the number is odd or even
        /// </summary>
        /// <param name="numberString">number to be evaluated</param>
        /// <param name="context">instance of <see cref="KernelProcessStepContext"/></param>
        /// <returns></returns>
        [KernelFunction]
        public async Task DetectEvenNumberAsync(string numberString, KernelProcessStepContext context)
        {
            var number = int.Parse(numberString);
            if (number % 2 == 0)
            {
                await context.EmitEventAsync(OutputEvents.EvenNumber, numberString);
                return;
            }

            await context.EmitEventAsync(OutputEvents.OddNumber, numberString);
        }
    }

    /// <summary>
    /// A step that echos its input.
    /// </summary>
    public sealed class EchoStep : KernelProcessStep
    {
        [KernelFunction]
        public string Echo(string message)
        {
            Console.WriteLine($"[ECHO] {message}");
            return message;
        }
    }
}


===== samples\AgentUtilities\BaseAgentsTest.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.ObjectModel;
using System.Diagnostics;
using Azure.AI.Agents.Persistent;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.Agents.OpenAI;
using Microsoft.SemanticKernel.ChatCompletion;
using OpenAI.Assistants;
using OpenAI.Files;
using ChatTokenUsage = OpenAI.Chat.ChatTokenUsage;
using UsageDetails = Microsoft.Extensions.AI.UsageDetails;

/// <summary>
/// Base class for samples that demonstrate the usage of host agents
/// based on API's such as Open AI Assistants or Azure AI Agents.
/// </summary>
public abstract class BaseAgentsTest<TClient>(ITestOutputHelper output) : BaseAgentsTest(output)
{
    /// <summary>
    /// Gets the root client for the service.
    /// </summary>
    protected abstract TClient Client { get; }
}

/// <summary>
/// Base class for samples that demonstrate the usage of agents.
/// </summary>
public abstract class BaseAgentsTest(ITestOutputHelper output) : BaseTest(output, redirectSystemConsoleOutput: true)
{
    /// <summary>
    /// Metadata key to indicate the assistant as created for a sample.
    /// </summary>
    protected const string SampleMetadataKey = "sksample";

    /// <summary>
    /// Metadata to indicate the object was created for a sample.
    /// </summary>
    /// <remarks>
    /// While the samples do attempt delete the objects it creates, it is possible
    /// that some may remain.  This metadata can be used to identify and sample
    /// objects for manual clean-up.
    /// </remarks>
    protected static readonly ReadOnlyDictionary<string, string> SampleMetadata =
        new(new Dictionary<string, string>
        {
            { SampleMetadataKey, bool.TrueString }
        });

    protected (string? pluginName, string functionName) ParseFunctionName(string functionName)
    {
        string[] parts = functionName.Split("-", 2);
        if (parts.Length == 1)
        {
            return (null, parts[0]);
        }
        return (parts[0], parts[1]);
    }

    /// <summary>
    /// Common method to write formatted agent chat content to the console.
    /// </summary>
    protected void WriteAgentChatMessage(ChatMessageContent message)
    {
        // Include ChatMessageContent.AuthorName in output, if present.
        string authorExpression = message.Role == AuthorRole.User ? string.Empty : FormatAuthor();
        // Include TextContent (via ChatMessageContent.Content), if present.
        string contentExpression = string.IsNullOrWhiteSpace(message.Content) ? string.Empty : message.Content;
        bool isCode = message.Metadata?.ContainsKey(OpenAIAssistantAgent.CodeInterpreterMetadataKey) ?? false;
        string codeMarker = isCode ? "\n  [CODE]\n" : " ";
        System.Console.WriteLine($"\n# {message.Role}{authorExpression}:{codeMarker}{contentExpression}");

        // Provide visibility for inner content (that isn't TextContent).
        foreach (KernelContent item in message.Items)
        {
            if (item is AnnotationContent annotation)
            {
                if (annotation.Kind == AnnotationKind.UrlCitation)
                {
                    Console.WriteLine($"  [{item.GetType().Name}] {annotation.Label}: {annotation.ReferenceId} - {annotation.Title}");
                }
                else
                {
                    Console.WriteLine($"  [{item.GetType().Name}] {annotation.Label}: File #{annotation.ReferenceId}");
                }
            }
            else if (item is ActionContent action)
            {
                Console.WriteLine($"  [{item.GetType().Name}] {action.Text}");
            }
            else if (item is ReasoningContent reasoning)
            {
                Console.WriteLine($"  [{item.GetType().Name}] {reasoning.Text.DefaultIfEmpty("Thinking...")}");
            }
            else if (item is FileReferenceContent fileReference)
            {
                Console.WriteLine($"  [{item.GetType().Name}] File #{fileReference.FileId}");
            }
            else if (item is ImageContent image)
            {
                Console.WriteLine($"  [{item.GetType().Name}] {image.Uri?.ToString() ?? image.DataUri ?? $"{image.Data?.Length} bytes"}");
            }
            else if (item is FunctionCallContent functionCall)
            {
                Console.WriteLine($"  [{item.GetType().Name}] {functionCall.Id}");
            }
            else if (item is FunctionResultContent functionResult)
            {
                Console.WriteLine($"  [{item.GetType().Name}] {functionResult.CallId} - {functionResult.Result?.AsJson() ?? "*"}");
            }
        }

        if (message.Metadata?.TryGetValue("Usage", out object? usage) ?? false)
        {
            if (usage is RunStepTokenUsage assistantUsage)
            {
                WriteUsage(assistantUsage.TotalTokenCount, assistantUsage.InputTokenCount, assistantUsage.OutputTokenCount);
            }
            else if (usage is RunStepCompletionUsage agentUsage)
            {
                WriteUsage(agentUsage.TotalTokens, agentUsage.PromptTokens, agentUsage.CompletionTokens);
            }
            else if (usage is ChatTokenUsage chatUsage)
            {
                WriteUsage(chatUsage.TotalTokenCount, chatUsage.InputTokenCount, chatUsage.OutputTokenCount);
            }
            else if (usage is UsageDetails usageDetails)
            {
                WriteUsage(usageDetails.TotalTokenCount ?? 0, usageDetails.InputTokenCount ?? 0, usageDetails.OutputTokenCount ?? 0);
            }
        }

        string FormatAuthor() => message.AuthorName is not null ? $" - {message.AuthorName ?? " * "}" : string.Empty;

        void WriteUsage(long totalTokens, long inputTokens, long outputTokens)
        {
            Console.WriteLine($"  [Usage] Tokens: {totalTokens}, Input: {inputTokens}, Output: {outputTokens}");
        }
    }

    /// <summary>
    /// Common method to write formatted agent streaming chat content to the console.
    /// </summary>
    protected async Task<AgentThread?> WriteAgentStreamMessageAsync(IAsyncEnumerable<AgentResponseItem<StreamingChatMessageContent>> responseItems)
    {
        var first = true;
        AgentThread? thread = null;
        await foreach (var responseItem in responseItems)
        {
            var message = responseItem.Message;
            if (first)
            {
                Console.Write($"# {message.AuthorName ?? message.Role.ToString()}> ");
                first = false;
            }
            Console.Write(message.Content);
            thread = responseItem.Thread;
        }
        Console.WriteLine();

        return thread;
    }

    protected async Task DownloadResponseContentAsync(OpenAIFileClient client, ChatMessageContent message)
    {
        foreach (KernelContent item in message.Items)
        {
            if (item is AnnotationContent annotation)
            {
                await this.DownloadFileContentAsync(client, annotation.ReferenceId!);
            }
        }
    }

    protected async Task DownloadResponseImageAsync(OpenAIFileClient client, ChatMessageContent message)
    {
        foreach (KernelContent item in message.Items)
        {
            if (item is FileReferenceContent fileReference)
            {
                await this.DownloadFileContentAsync(client, fileReference.FileId, launchViewer: true);
            }
        }
    }

    private async Task DownloadFileContentAsync(OpenAIFileClient client, string fileId, bool launchViewer = false)
    {
        OpenAIFile fileInfo = client.GetFile(fileId);
        if (fileInfo.Purpose == FilePurpose.AssistantsOutput)
        {
            string filePath = Path.Combine(Path.GetTempPath(), Path.GetFileName(fileInfo.Filename));
            if (launchViewer)
            {
                filePath = Path.ChangeExtension(filePath, ".png");
            }

            BinaryData content = await client.DownloadFileAsync(fileId);
            File.WriteAllBytes(filePath, content.ToArray());
            Console.WriteLine($"  File #{fileId} saved to: {filePath}");

            if (launchViewer)
            {
                Process.Start(
                    new ProcessStartInfo
                    {
                        FileName = "cmd.exe",
                        Arguments = $"/C start {filePath}"
                    });
            }
        }
    }
}


===== samples\AgentUtilities\BaseAssistantTest.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.ClientModel;
using System.Diagnostics;
using Azure.Identity;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.Agents.OpenAI;
using OpenAI;
using OpenAI.Assistants;
using OpenAI.Files;

/// <summary>
/// Base class for samples that demonstrate the usage of <see cref="OpenAIAssistantAgent"/>.
/// </summary>
public abstract class BaseAssistantTest : BaseAgentsTest<OpenAIClient>
{
    protected BaseAssistantTest(ITestOutputHelper output) : base(output)
    {
        this.Client =
            this.UseOpenAIConfig ?
                OpenAIAssistantAgent.CreateOpenAIClient(new ApiKeyCredential(this.ApiKey ?? throw new ConfigurationNotFoundException("OpenAI:ApiKey"))) :
                !string.IsNullOrWhiteSpace(this.ApiKey) ?
                    OpenAIAssistantAgent.CreateAzureOpenAIClient(new ApiKeyCredential(this.ApiKey), new Uri(this.Endpoint!)) :
                    OpenAIAssistantAgent.CreateAzureOpenAIClient(new AzureCliCredential(), new Uri(this.Endpoint!));

        this.AssistantClient = this.Client.GetAssistantClient();
    }

    /// <inheritdoc/>
    protected override OpenAIClient Client { get; }

    /// <summary>
    /// Gets the the <see cref="AssistantClient"/>.
    /// </summary>
    protected AssistantClient AssistantClient { get; }

    protected async Task DownloadResponseContentAsync(ChatMessageContent message)
    {
        OpenAIFileClient fileClient = this.Client.GetOpenAIFileClient();

        foreach (KernelContent item in message.Items)
        {
            if (item is AnnotationContent annotation)
            {
                await this.DownloadFileContentAsync(fileClient, annotation.ReferenceId!);
            }
        }
    }

    protected async Task DownloadResponseImageAsync(ChatMessageContent message)
    {
        OpenAIFileClient fileClient = this.Client.GetOpenAIFileClient();

        foreach (KernelContent item in message.Items)
        {
            if (item is FileReferenceContent fileReference)
            {
                await this.DownloadFileContentAsync(fileClient, fileReference.FileId, launchViewer: true);
            }
        }
    }

    private async Task DownloadFileContentAsync(OpenAIFileClient fileClient, string fileId, bool launchViewer = false)
    {
        OpenAIFile fileInfo = fileClient.GetFile(fileId);
        if (fileInfo.Purpose == FilePurpose.AssistantsOutput)
        {
            string filePath = Path.Combine(Path.GetTempPath(), Path.GetFileName(fileInfo.Filename));
            if (launchViewer)
            {
                filePath = Path.ChangeExtension(filePath, ".png");
            }

            BinaryData content = await fileClient.DownloadFileAsync(fileId);
            File.WriteAllBytes(filePath, content.ToArray());
            Console.WriteLine($"  File #{fileId} saved to: {filePath}");

            if (launchViewer)
            {
                Process.Start(
                    new ProcessStartInfo
                    {
                        FileName = "cmd.exe",
                        Arguments = $"/C start {filePath}"
                    });
            }
        }
    }
}


===== samples\AgentUtilities\BaseAzureAgentTest.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.ObjectModel;
using System.Diagnostics;
using Azure.AI.Agents.Persistent;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.Agents.OpenAI;
using Microsoft.SemanticKernel.ChatCompletion;
using OpenAI.Assistants;
using OpenAI.Files;

using ChatTokenUsage = OpenAI.Chat.ChatTokenUsage;

/// <summary>
/// Base class for samples that demonstrate the usage of agents.
/// </summary>
public abstract class BaseAzureTest(ITestOutputHelper output) : BaseTest(output, redirectSystemConsoleOutput: true)
{
    /// <summary>
    /// Metadata key to indicate the assistant as created for a sample.
    /// </summary>
    protected const string AssistantSampleMetadataKey = "sksample";

    protected override bool ForceOpenAI => false;

    /// <summary>
    /// Metadata to indicate the object was created for a sample.
    /// </summary>
    /// <remarks>
    /// While the samples do attempt delete the objects it creates, it is possible
    /// that some may remain.  This metadata can be used to identify and sample
    /// objects for manual clean-up.
    /// </remarks>
    protected static readonly ReadOnlyDictionary<string, string> SampleMetadata =
        new(new Dictionary<string, string>
        {
            { AssistantSampleMetadataKey, bool.TrueString }
        });

    /// <summary>
    /// Common method to write formatted agent chat content to the console.
    /// </summary>
    protected void WriteAgentChatMessage(ChatMessageContent message)
    {
        // Include ChatMessageContent.AuthorName in output, if present.
        string authorExpression = message.Role == AuthorRole.User ? string.Empty : $" - {message.AuthorName ?? "*"}";
        // Include TextContent (via ChatMessageContent.Content), if present.
        string contentExpression = string.IsNullOrWhiteSpace(message.Content) ? string.Empty : message.Content;
        bool isCode = message.Metadata?.ContainsKey(OpenAIAssistantAgent.CodeInterpreterMetadataKey) ?? false;
        string codeMarker = isCode ? "\n  [CODE]\n" : " ";
        Console.WriteLine($"\n# {message.Role}{authorExpression}:{codeMarker}{contentExpression}");

        // Provide visibility for inner content (that isn't TextContent).
        foreach (KernelContent item in message.Items)
        {
            if (item is AnnotationContent annotation)
            {
                Console.WriteLine($"  [{item.GetType().Name}] {annotation.Label}: File #{annotation.ReferenceId}");
            }
            else if (item is FileReferenceContent fileReference)
            {
                Console.WriteLine($"  [{item.GetType().Name}] File #{fileReference.FileId}");
            }
            else if (item is ImageContent image)
            {
                Console.WriteLine($"  [{item.GetType().Name}] {image.Uri?.ToString() ?? image.DataUri ?? $"{image.Data?.Length} bytes"}");
            }
            else if (item is FunctionCallContent functionCall)
            {
                Console.WriteLine($"  [{item.GetType().Name}] {functionCall.Id}");
            }
            else if (item is FunctionResultContent functionResult)
            {
                Console.WriteLine($"  [{item.GetType().Name}] {functionResult.CallId} - {functionResult.Result?.AsJson() ?? "*"}");
            }
        }

        if (message.Metadata?.TryGetValue("Usage", out object? usage) ?? false)
        {
            if (usage is RunStepTokenUsage assistantUsage)
            {
                WriteUsage(assistantUsage.TotalTokenCount, assistantUsage.InputTokenCount, assistantUsage.OutputTokenCount);
            }
            else if (usage is RunStepCompletionUsage agentUsage)
            {
                WriteUsage(agentUsage.TotalTokens, agentUsage.PromptTokens, agentUsage.CompletionTokens);
            }
            else if (usage is ChatTokenUsage chatUsage)
            {
                WriteUsage(chatUsage.TotalTokenCount, chatUsage.InputTokenCount, chatUsage.OutputTokenCount);
            }
        }

        void WriteUsage(long totalTokens, long inputTokens, long outputTokens)
        {
            Console.WriteLine($"  [Usage] Tokens: {totalTokens}, Input: {inputTokens}, Output: {outputTokens}");
        }
    }

    protected async Task DownloadResponseContentAsync(OpenAIFileClient client, ChatMessageContent message)
    {
        foreach (KernelContent item in message.Items)
        {
            if (item is AnnotationContent annotation)
            {
                await this.DownloadFileContentAsync(client, annotation.ReferenceId!);
            }
        }
    }

    protected async Task DownloadResponseImageAsync(OpenAIFileClient client, ChatMessageContent message)
    {
        foreach (KernelContent item in message.Items)
        {
            if (item is FileReferenceContent fileReference)
            {
                await this.DownloadFileContentAsync(client, fileReference.FileId, launchViewer: true);
            }
        }
    }

    private async Task DownloadFileContentAsync(OpenAIFileClient client, string fileId, bool launchViewer = false)
    {
        OpenAIFile fileInfo = client.GetFile(fileId);
        if (fileInfo.Purpose == FilePurpose.AssistantsOutput)
        {
            string filePath = Path.Combine(Path.GetTempPath(), Path.GetFileName(fileInfo.Filename));
            if (launchViewer)
            {
                filePath = Path.ChangeExtension(filePath, ".png");
            }

            BinaryData content = await client.DownloadFileAsync(fileId);
            File.WriteAllBytes(filePath, content.ToArray());
            Console.WriteLine($"  File #{fileId} saved to: {filePath}");

            if (launchViewer)
            {
                Process.Start(
                    new ProcessStartInfo
                    {
                        FileName = "cmd.exe",
                        Arguments = $"/C start {filePath}"
                    });
            }
        }
    }
}


===== samples\AgentUtilities\BaseAzureTest.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Diagnostics;
using Azure.AI.Agents.Persistent;
using Azure.AI.Projects;
using Azure.Identity;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.Agents.AzureAI;

/// <summary>
/// Base class for samples that demonstrate the usage of <see cref="AzureAIAgent"/>.
/// </summary>
public abstract class BaseAzureAgentTest : BaseAgentsTest<PersistentAgentsClient>
{
    protected BaseAzureAgentTest(ITestOutputHelper output) : base(output)
    {
        this.Client = AzureAIAgent.CreateAgentsClient(TestConfiguration.AzureAI.Endpoint, new AzureCliCredential());
    }

    protected override PersistentAgentsClient Client { get; }

    protected AIProjectClient CreateFoundryProjectClient()
    {
        return new AIProjectClient(new Uri(TestConfiguration.AzureAI.Endpoint), new AzureCliCredential());
    }

    protected async Task<string> GetConnectionId(string connectionName)
    {
        AIProjectClient client = CreateFoundryProjectClient();
        Connections connectionClient = client.GetConnectionsClient();
        Connection connection =
            await connectionClient.GetConnectionsAsync().Where(connection => connection.Name == connectionName).FirstOrDefaultAsync() ??
            throw new InvalidOperationException($"Connection '{connectionName}' not found in project '{TestConfiguration.AzureAI.Endpoint}'.");
        return connection.Id;
    }

    protected async Task DownloadContentAsync(ChatMessageContent message)
    {
        foreach (KernelContent item in message.Items)
        {
            if (item is AnnotationContent annotation)
            {
                await this.DownloadFileAsync(annotation.ReferenceId!);
            }
        }
    }

    protected async Task DownloadFileAsync(string fileId, bool launchViewer = false)
    {
        PersistentAgentFileInfo fileInfo = this.Client.Files.GetFile(fileId);
        if (fileInfo.Purpose == PersistentAgentFilePurpose.AgentsOutput)
        {
            string filePath = Path.Combine(Path.GetTempPath(), Path.GetFileName(fileInfo.Filename));
            if (launchViewer)
            {
                filePath = Path.ChangeExtension(filePath, ".png");
            }

            BinaryData content = await this.Client.Files.GetFileContentAsync(fileId);
            File.WriteAllBytes(filePath, content.ToArray());
            Console.WriteLine($"  File #{fileId} saved to: {filePath}");

            if (launchViewer)
            {
                Process.Start(
                    new ProcessStartInfo
                    {
                        FileName = "cmd.exe",
                        Arguments = $"/C start {filePath}"
                    });
            }
        }
    }
}


===== samples\AgentUtilities\BaseBedrockAgentTest.cs =====

// Copyright (c) Microsoft. All rights reserved.

using Amazon.BedrockAgent;
using Amazon.BedrockAgent.Model;
using Amazon.BedrockAgentRuntime;
using Microsoft.SemanticKernel.Agents.Bedrock;

/// <summary>
/// Base class for samples that demonstrate the usage of AWS Bedrock agents.
/// </summary>
public abstract class BaseBedrockAgentTest : BaseAgentsTest
{
    protected const string AgentDescription = "A helpful assistant who helps users find information.";
    protected const string AgentInstruction = "You're a helpful assistant who helps users find information.";
    protected readonly AmazonBedrockAgentClient Client;
    protected readonly AmazonBedrockAgentRuntimeClient RuntimeClient;

    protected BaseBedrockAgentTest(ITestOutputHelper output) : base(output)
    {
        Client = new AmazonBedrockAgentClient();
        RuntimeClient = new AmazonBedrockAgentRuntimeClient();
    }

    protected CreateAgentRequest GetCreateAgentRequest(string agentName) => new()
    {
        AgentName = agentName,
        Description = AgentDescription,
        Instruction = AgentInstruction,
        AgentResourceRoleArn = TestConfiguration.BedrockAgent.AgentResourceRoleArn,
        FoundationModel = TestConfiguration.BedrockAgent.FoundationModel,
    };

    protected override void Dispose(bool disposing)
    {
        Client?.Dispose();
        RuntimeClient?.Dispose();
        base.Dispose(disposing);
    }

    /// <summary>
    /// Override this method to create an agent with desired settings.
    /// </summary>
    /// <param name="agentName">The name of the agent to create. Must be unique.</param>
    protected abstract Task<BedrockAgent> CreateAgentAsync(string agentName);
}


===== samples\AgentUtilities\BaseOrchestrationTest.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.ClientModel;
using System.Text;
using System.Text.Json;
using Azure.AI.Agents.Persistent;
using Azure.Identity;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.Agents.AzureAI;
using Microsoft.SemanticKernel.Agents.OpenAI;
using Microsoft.SemanticKernel.ChatCompletion;
using OpenAI.Assistants;

/// <summary>
/// Base class for samples that demonstrate the usage of host agents
/// based on API's such as Open AI Assistants or Azure AI Agents.
/// </summary>
public abstract class BaseOrchestrationTest(ITestOutputHelper output) : BaseAgentsTest(output)
{
    protected const int ResultTimeoutInSeconds = 30;

    protected virtual bool EnableLogging => true;

    protected new ILoggerFactory LoggerFactory => this.EnableLogging ? base.LoggerFactory : NullLoggerFactory.Instance;

    protected ChatCompletionAgent CreateChatCompletionAgent(string instructions, string? description = null, string? name = null, Kernel? kernel = null)
    {
        return
            new ChatCompletionAgent
            {
                Name = name,
                Description = description,
                Instructions = instructions,
                Kernel = kernel ?? this.CreateKernelWithChatCompletion(),
            };
    }

    protected async Task<OpenAIAssistantAgent> CreateOpenAIAssistantAgentAsync(string instructions, string? description = null, string? name = null, Kernel? kernel = null)
    {
        var client =
            this.UseOpenAIConfig ?
                OpenAIAssistantAgent.CreateOpenAIClient(new ApiKeyCredential(this.ApiKey ?? throw new ConfigurationNotFoundException("OpenAI:ApiKey"))) :
                !string.IsNullOrWhiteSpace(this.ApiKey) ?
                    OpenAIAssistantAgent.CreateAzureOpenAIClient(new ApiKeyCredential(this.ApiKey), new Uri(this.Endpoint!)) :
                    OpenAIAssistantAgent.CreateAzureOpenAIClient(new AzureCliCredential(), new Uri(this.Endpoint!));

        var assistantClient = client.GetAssistantClient();

        var createOptions = new AssistantCreationOptions
        {
            Name = name,
            Description = description,
            Instructions = instructions,
        };

        Assistant definition = await assistantClient.CreateAssistantAsync(this.Model, createOptions);
        return new OpenAIAssistantAgent(
            definition,
            assistantClient)
        {
            Kernel = kernel ?? new Kernel(),
        };
    }

    protected async Task<AzureAIAgent> CreateAzureAIAgentAsync(string instructions, string? description = null, string? name = null, Kernel? kernel = null, IEnumerable<Azure.AI.Agents.Persistent.ToolDefinition>? tools = null)
    {
        var agentsClient = AzureAIAgent.CreateAgentsClient(TestConfiguration.AzureAI.Endpoint, new AzureCliCredential());

        PersistentAgent definition = await agentsClient.Administration.CreateAgentAsync(
            TestConfiguration.AzureAI.ChatModelId,
            name,
            description,
            instructions,
            tools);

        return
            new(definition, agentsClient)
            {
                Kernel = kernel ?? new Kernel(),
            };
    }

    protected static void WriteResponse(ChatMessageContent response)
    {
        if (!string.IsNullOrEmpty(response.Content))
        {
            System.Console.WriteLine($"\n# RESPONSE {response.Role}{(response.AuthorName is not null ? $" - {response.AuthorName}" : string.Empty)}: {response}");
        }
    }

    protected static void WriteStreamedResponse(IEnumerable<StreamingChatMessageContent> streamedResponses)
    {
        string? authorName = null;
        AuthorRole? authorRole = null;
        StringBuilder builder = new();
        foreach (StreamingChatMessageContent response in streamedResponses)
        {
            authorName ??= response.AuthorName;
            authorRole ??= response.Role;

            if (!string.IsNullOrEmpty(response.Content))
            {
                builder.Append($"({JsonSerializer.Serialize(response.Content)})");
            }
        }

        if (builder.Length > 0)
        {
            System.Console.WriteLine($"\n# STREAMED {authorRole ?? AuthorRole.Assistant}{(authorName is not null ? $" - {authorName}" : string.Empty)}: {builder}\n");
        }
    }

    protected sealed class OrchestrationMonitor
    {
        public List<StreamingChatMessageContent> StreamedResponses = [];

        public ChatHistory History { get; } = [];

        public ValueTask ResponseCallback(ChatMessageContent response)
        {
            this.History.Add(response);
            WriteResponse(response);
            return ValueTask.CompletedTask;
        }

        public ValueTask StreamingResultCallback(StreamingChatMessageContent streamedResponse, bool isFinal)
        {
            this.StreamedResponses.Add(streamedResponse);

            if (isFinal)
            {
                WriteStreamedResponse(this.StreamedResponses);
                this.StreamedResponses.Clear();
            }

            return ValueTask.CompletedTask;
        }
    }
}


===== samples\AgentUtilities\BaseResponsesAgentTest.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.ClientModel;
using System.ClientModel.Primitives;
using Microsoft.SemanticKernel.Agents.OpenAI;
using OpenAI;
using OpenAI.Files;
using OpenAI.Responses;
using OpenAI.VectorStores;

/// <summary>
/// Base class for samples that demonstrate the usage of <see cref="OpenAIResponseAgent"/>.
/// </summary>
public abstract class BaseResponsesAgentTest : BaseAgentsTest<OpenAIResponseClient>
{
    protected BaseResponsesAgentTest(ITestOutputHelper output, string? model = null) : base(output)
    {
        var options = new OpenAIClientOptions();
        if (this.EnableLogging)
        {
            options.MessageLoggingPolicy = new MessageLoggingPolicy(new()
            {
                EnableLogging = true,
                EnableMessageLogging = true,
                EnableMessageContentLogging = true,
                LoggerFactory = this.LoggerFactory
            });
        }

        this.Client = new(model: model ?? TestConfiguration.OpenAI.ChatModelId, credential: new ApiKeyCredential(TestConfiguration.OpenAI.ApiKey), options: options);
        this.FileClient = new OpenAIFileClient(TestConfiguration.OpenAI.ApiKey);
        this.VectorStoreClient = new VectorStoreClient(TestConfiguration.OpenAI.ApiKey);
    }

    protected OpenAIFileClient FileClient { get; set; }

    protected VectorStoreClient VectorStoreClient { get; set; }

    protected bool EnableLogging { get; set; } = false;

    /// <inheritdoc/>
    protected override OpenAIResponseClient Client { get; }
}


===== samples\InternalUtilities\BaseTest.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.ClientModel;
using System.Reflection;
using System.Text;
using System.Text.Json;
using Azure.AI.OpenAI;
using Azure.Identity;
using Microsoft.Extensions.AI;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.ChatCompletion;

public abstract class BaseTest : TextWriter
{
    /// <summary>
    /// Flag to force usage of OpenAI configuration if both <see cref="TestConfiguration.OpenAI"/>
    /// and <see cref="TestConfiguration.AzureOpenAI"/> are defined.
    /// If 'false', Azure takes precedence.
    /// </summary>
    protected virtual bool ForceOpenAI { get; } = false;

    protected ITestOutputHelper Output { get; }

    protected ILoggerFactory LoggerFactory { get; }

    /// <summary>
    /// This property makes the samples Console friendly. Allowing them to be copied and pasted into a Console app, with minimal changes.
    /// </summary>
    public BaseTest Console => this;

    protected bool UseOpenAIConfig => this.ForceOpenAI || string.IsNullOrEmpty(TestConfiguration.AzureOpenAI.Endpoint);

    protected string? ApiKey =>
        this.UseOpenAIConfig ?
            TestConfiguration.OpenAI.ApiKey :
            TestConfiguration.AzureOpenAI.ApiKey;

    protected string? Endpoint => UseOpenAIConfig ? null : TestConfiguration.AzureOpenAI.Endpoint;

    protected string Model =>
        this.UseOpenAIConfig ?
            TestConfiguration.OpenAI.ChatModelId :
            TestConfiguration.AzureOpenAI.ChatDeploymentName;

    /// <summary>
    /// Returns true if the test configuration has a valid Bing API key.
    /// </summary>
    protected bool UseBingSearch => TestConfiguration.Bing.ApiKey is not null;

    protected Kernel CreateKernelWithChatCompletion(string? modelName = null)
        => this.CreateKernelWithChatCompletion(useChatClient: false, out _, modelName);

    protected Kernel CreateKernelWithChatCompletion(bool useChatClient, out IChatClient? chatClient, string? modelName = null)
    {
        var builder = Kernel.CreateBuilder();

        if (useChatClient)
        {
            chatClient = AddChatClientToKernel(builder);
        }
        else
        {
            chatClient = null;
            AddChatCompletionToKernel(builder, modelName);
        }

        return builder.Build();
    }

    protected void AddChatCompletionToKernel(IKernelBuilder builder, string? modelName = null)
    {
        if (this.UseOpenAIConfig)
        {
            builder.AddOpenAIChatCompletion(
                modelName ?? TestConfiguration.OpenAI.ChatModelId,
                TestConfiguration.OpenAI.ApiKey);
        }
        else if (!string.IsNullOrEmpty(this.ApiKey))
        {
            builder.AddAzureOpenAIChatCompletion(
                modelName ?? TestConfiguration.AzureOpenAI.ChatDeploymentName,
                TestConfiguration.AzureOpenAI.Endpoint,
                TestConfiguration.AzureOpenAI.ApiKey);
        }
        else
        {
            builder.AddAzureOpenAIChatCompletion(
                modelName ?? TestConfiguration.AzureOpenAI.ChatDeploymentName,
                TestConfiguration.AzureOpenAI.Endpoint,
                new AzureCliCredential());
        }
    }

    protected IChatClient AddChatClientToKernel(IKernelBuilder builder)
    {
#pragma warning disable CA2000 // Dispose objects before losing scope
        IChatClient chatClient;
        if (this.UseOpenAIConfig)
        {
            chatClient = new OpenAI.OpenAIClient(TestConfiguration.OpenAI.ApiKey)
                .GetChatClient(TestConfiguration.OpenAI.ChatModelId)
                .AsIChatClient();
        }
        else if (!string.IsNullOrEmpty(this.ApiKey))
        {
            chatClient = new AzureOpenAIClient(
                    endpoint: new Uri(TestConfiguration.AzureOpenAI.Endpoint),
                    credential: new ApiKeyCredential(TestConfiguration.AzureOpenAI.ApiKey))
                .GetChatClient(TestConfiguration.AzureOpenAI.ChatDeploymentName)
                .AsIChatClient();
        }
        else
        {
            chatClient = new AzureOpenAIClient(
                    endpoint: new Uri(TestConfiguration.AzureOpenAI.Endpoint),
                    credential: new AzureCliCredential())
                .GetChatClient(TestConfiguration.AzureOpenAI.ChatDeploymentName)
                .AsIChatClient();
        }

        IChatClient functionCallingChatClient = chatClient.AsBuilder().UseKernelFunctionInvocation().Build();
        builder.Services.AddSingleton(functionCallingChatClient);
        return functionCallingChatClient;
#pragma warning restore CA2000 // Dispose objects before losing scope
    }

    protected BaseTest(ITestOutputHelper output, bool redirectSystemConsoleOutput = false)
    {
        this.Output = output;
        this.LoggerFactory = new XunitLogger(output);

        IConfigurationRoot configRoot = new ConfigurationBuilder()
            .AddJsonFile("appsettings.Development.json", true)
            .AddEnvironmentVariables()
            .AddUserSecrets(Assembly.GetExecutingAssembly())
            .Build();

        TestConfiguration.Initialize(configRoot);

        // Redirect System.Console output to the test output if requested
        if (redirectSystemConsoleOutput)
        {
            System.Console.SetOut(this);
        }
    }

    /// <inheritdoc/>
    public override void WriteLine(object? value = null)
        => this.Output.WriteLine(value ?? string.Empty);

    /// <inheritdoc/>
    public override void WriteLine(string? format, params object?[] arg)
        => this.Output.WriteLine(format ?? string.Empty, arg);

    /// <inheritdoc/>
    public override void WriteLine(string? value)
        => this.Output.WriteLine(value ?? string.Empty);

    /// <inheritdoc/>
    /// <remarks>
    /// <see cref="ITestOutputHelper"/> only supports output that ends with a newline.
    /// User this method will resolve in a call to <see cref="WriteLine(string?)"/>.
    /// </remarks>
    public override void Write(object? value = null)
        => this.Output.WriteLine(value ?? string.Empty);

    /// <inheritdoc/>
    /// <remarks>
    /// <see cref="ITestOutputHelper"/> only supports output that ends with a newline.
    /// User this method will resolve in a call to <see cref="WriteLine(string?)"/>.
    /// </remarks>
    public override void Write(char[]? buffer)
        => this.Output.WriteLine(new string(buffer));

    /// <inheritdoc/>
    public override Encoding Encoding => Encoding.UTF8;

    /// <summary>
    /// Outputs the last message in the chat history.
    /// </summary>
    /// <param name="chatHistory">Chat history</param>
    protected void OutputLastMessage(ChatHistory chatHistory)
    {
        var message = chatHistory.Last();

        Console.WriteLine($"{message.Role}: {message.Content}");
        Console.WriteLine("------------------------");
    }

    /// <summary>
    /// Outputs the last message in the chat messages history.
    /// </summary>
    /// <param name="chatHistory">Chat messages history</param>
    protected void OutputLastMessage(IReadOnlyCollection<ChatMessage> chatHistory)
    {
        var message = chatHistory.Last();

        Console.WriteLine($"{message.Role}: {message.Text}");
        Console.WriteLine("------------------------");
    }

    /// <summary>
    /// Outputs out the stream of generated message tokens.
    /// </summary>
    protected async Task StreamMessageOutputAsync(IChatCompletionService chatCompletionService, ChatHistory chatHistory, AuthorRole authorRole)
    {
        bool roleWritten = false;
        string fullMessage = string.Empty;

        await foreach (var chatUpdate in chatCompletionService.GetStreamingChatMessageContentsAsync(chatHistory))
        {
            if (!roleWritten && chatUpdate.Role.HasValue)
            {
                Console.Write($"{chatUpdate.Role.Value}: {chatUpdate.Content}");
                roleWritten = true;
            }

            if (chatUpdate.Content is { Length: > 0 })
            {
                fullMessage += chatUpdate.Content;
                Console.Write(chatUpdate.Content);
            }
        }

        Console.WriteLine("\n------------------------");
        chatHistory.AddMessage(authorRole, fullMessage);
    }

    /// <summary>
    /// Utility method to write a horizontal rule to the console.
    /// </summary>
    protected void WriteHorizontalRule()
        => Console.WriteLine(new string('-', HorizontalRuleLength));

    protected sealed class LoggingHandler(HttpMessageHandler innerHandler, ITestOutputHelper output) : DelegatingHandler(innerHandler)
    {
        private static readonly JsonSerializerOptions s_jsonSerializerOptions = new() { WriteIndented = true };

        private readonly ITestOutputHelper _output = output;

        protected override async Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
        {
            // Log the request details
            if (request.Content is not null)
            {
                var content = await request.Content.ReadAsStringAsync(cancellationToken);
                this._output.WriteLine("=== REQUEST ===");
                try
                {
                    string formattedContent = JsonSerializer.Serialize(JsonSerializer.Deserialize<JsonElement>(content), s_jsonSerializerOptions);
                    this._output.WriteLine(formattedContent);
                }
                catch (JsonException)
                {
                    this._output.WriteLine(content);
                }
                this._output.WriteLine(string.Empty);
            }

            // Call the next handler in the pipeline
            var response = await base.SendAsync(request, cancellationToken);

            if (response.Content is not null)
            {
                // Log the response details
                var responseContent = await response.Content.ReadAsStringAsync(cancellationToken);
                this._output.WriteLine("=== RESPONSE ===");
                this._output.WriteLine(responseContent);
                this._output.WriteLine(string.Empty);
            }

            return response;
        }
    }

    #region private
    private const int HorizontalRuleLength = 80;
    #endregion
}


===== samples\InternalUtilities\ConfigurationNotFoundException.cs =====

// Copyright (c) Microsoft. All rights reserved.

public sealed class ConfigurationNotFoundException : Exception
{
    public string? Section { get; }
    public string? Key { get; }

    public ConfigurationNotFoundException(string section, string key)
        : base($"Configuration key '{section}:{key}' not found")
    {
        this.Section = section;
        this.Key = key;
    }

    public ConfigurationNotFoundException(string section)
    : base($"Configuration section '{section}' not found")
    {
        this.Section = section;
    }

    public ConfigurationNotFoundException() : base()
    {
    }

    public ConfigurationNotFoundException(string? message, Exception? innerException) : base(message, innerException)
    {
    }
}


===== samples\InternalUtilities\EmbeddedResource.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Reflection;

namespace Resources;

/// <summary>
/// Resource helper to load resources embedded in the assembly. By default we embed only
/// text files, so the helper is limited to returning text.
///
/// You can find information about embedded resources here:
/// * https://learn.microsoft.com/dotnet/core/extensions/create-resource-files
/// * https://learn.microsoft.com/dotnet/api/system.reflection.assembly.getmanifestresourcestream?view=net-7.0
///
/// To know which resources are embedded, check the csproj file.
/// </summary>
internal static class EmbeddedResource
{
    private static readonly string? s_namespace = typeof(EmbeddedResource).Namespace;

    internal static string Read(string fileName)
    {
        // Get the current assembly. Note: this class is in the same assembly where the embedded resources are stored.
        Assembly assembly =
            typeof(EmbeddedResource).GetTypeInfo().Assembly ??
            throw new ConfigurationNotFoundException($"[{s_namespace}] {fileName} assembly not found");

        // Resources are mapped like types, using the namespace and appending "." (dot) and the file name
        var resourceName = $"{s_namespace}." + fileName;
        using Stream resource =
            assembly.GetManifestResourceStream(resourceName) ??
            throw new ConfigurationNotFoundException($"{resourceName} resource not found");

        // Return the resource content, in text format.
        using var reader = new StreamReader(resource);
        return reader.ReadToEnd();
    }

    internal static Stream? ReadStream(string fileName)
    {
        // Get the current assembly. Note: this class is in the same assembly where the embedded resources are stored.
        Assembly assembly =
            typeof(EmbeddedResource).GetTypeInfo().Assembly ??
            throw new ConfigurationNotFoundException($"[{s_namespace}] {fileName} assembly not found");

        // Resources are mapped like types, using the namespace and appending "." (dot) and the file name
        var resourceName = $"{s_namespace}." + fileName;
        return assembly.GetManifestResourceStream(resourceName);
    }

    internal static async Task<ReadOnlyMemory<byte>> ReadAllAsync(string fileName)
    {
        await using Stream? resourceStream = ReadStream(fileName);
        using var memoryStream = new MemoryStream();

        // Copy the resource stream to the memory stream
        await resourceStream!.CopyToAsync(memoryStream);

        // Convert the memory stream's buffer to ReadOnlyMemory<byte>
        // Note: ToArray() creates a copy of the buffer, which is fine for converting to ReadOnlyMemory<byte>
        return new ReadOnlyMemory<byte>(memoryStream.ToArray());
    }
}


===== samples\InternalUtilities\EnumerableExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

public static class EnumerableExtensions
{
    public static IEnumerable<List<TSource>> ChunkByAggregate<TSource, TAccumulate>(
        this IEnumerable<TSource> source,
        TAccumulate seed,
        Func<TAccumulate, TSource, TAccumulate> aggregator,
        Func<TAccumulate, int, bool> predicate)
    {
        using var enumerator = source.GetEnumerator();
        var aggregate = seed;
        var index = 0;
        var chunk = new List<TSource>();

        while (enumerator.MoveNext())
        {
            var current = enumerator.Current;

            aggregate = aggregator(aggregate, current);

            if (predicate(aggregate, index++))
            {
                chunk.Add(current);
            }
            else
            {
                if (chunk.Count > 0)
                {
                    yield return chunk;
                }

                chunk = [current];
                aggregate = aggregator(seed, current);
                index = 1;
            }
        }

        if (chunk.Count > 0)
        {
            yield return chunk;
        }
    }
}


===== samples\InternalUtilities\Env.cs =====

// Copyright (c) Microsoft. All rights reserved.

using Microsoft.Extensions.Configuration;

#pragma warning disable CA1812 // Avoid uninstantiated internal classes

internal sealed class Env
{
    /// <summary>
    /// Simple helper used to load env vars and secrets like credentials,
    /// to avoid hard coding them in the sample code
    /// </summary>
    /// <param name="name">Secret name / Env var name</param>
    /// <returns>Value found in Secret Manager or Environment Variable</returns>
    internal static string Var(string name)
    {
        var configuration = new ConfigurationBuilder()
            .AddUserSecrets<Env>()
            .Build();

        var value = configuration[name];
        if (!string.IsNullOrEmpty(value))
        {
            return value;
        }

        value = Environment.GetEnvironmentVariable(name);
        if (string.IsNullOrEmpty(value))
        {
            throw new YourAppException($"Secret / Env var not set: {name}");
        }

        return value;
    }
}


===== samples\InternalUtilities\JsonResultTranslator.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Text.Json;
using Microsoft.SemanticKernel;

namespace Resources;
/// <summary>
/// Supports parsing json from a text block that may contain literals delimiters:
/// <list type="table">
/// <item>
/// <code>
/// [json]
/// </code>
/// </item>
/// <item>
/// <code>
/// ```
/// [json]
/// ```
/// </code>
/// </item>
/// <item>
/// <code>
/// ```json
/// [json]
/// ```
/// </code>
/// </item>
/// </list>
/// </summary>
/// <remarks>
/// Encountering json with this form of delimiters is not uncommon for agent scenarios.
/// </remarks>
public static class JsonResultTranslator
{
    private const string LiteralDelimiter = "```";
    private const string JsonPrefix = "json";

    /// <summary>
    /// Utility method for extracting a JSON result from an agent response.
    /// </summary>
    /// <param name="result">A text result</param>
    /// <typeparam name="TResult">The target type of the <see cref="FunctionResult"/>.</typeparam>
    /// <returns>The JSON translated to the requested type.</returns>
    public static TResult? Translate<TResult>(string? result)
    {
        if (string.IsNullOrWhiteSpace(result))
        {
            return default;
        }

        string rawJson = ExtractJson(result);

        return JsonSerializer.Deserialize<TResult>(rawJson);
    }

    private static string ExtractJson(string result)
    {
        // Search for initial literal delimiter: ```
        int startIndex = result.IndexOf(LiteralDelimiter, System.StringComparison.Ordinal);
        if (startIndex < 0)
        {
            // No initial delimiter, return entire expression.
            return result;
        }

        startIndex += LiteralDelimiter.Length;

        // Accommodate "json" prefix, if present.
        if (JsonPrefix.Equals(result.Substring(startIndex, JsonPrefix.Length), System.StringComparison.OrdinalIgnoreCase))
        {
            startIndex += JsonPrefix.Length;
        }

        // Locate final literal delimiter
        int endIndex = result.IndexOf(LiteralDelimiter, startIndex, System.StringComparison.OrdinalIgnoreCase);
        if (endIndex < 0)
        {
            endIndex = result.Length;
        }

        // Extract JSON
        return result.Substring(startIndex, endIndex - startIndex);
    }
}


===== samples\InternalUtilities\ObjectExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Text.Json;

public static class ObjectExtensions
{
    private static readonly JsonSerializerOptions s_jsonOptionsCache = new() { WriteIndented = true };

    public static string AsJson(this object obj)
    {
        return JsonSerializer.Serialize(obj, s_jsonOptionsCache);
    }
}


===== samples\InternalUtilities\RepoFiles.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Reflection;

public static class RepoFiles
{
    /// <summary>
    /// Scan the local folders from the repo, looking for "prompt_template_samples" folder.
    /// </summary>
    /// <returns>The full path to prompt_template_samples folder.</returns>
    public static string SamplePluginsPath()
    {
        const string Folder = "prompt_template_samples";

        static bool SearchPath(string pathToFind, out string result, int maxAttempts = 10)
        {
            var currDir = Path.GetFullPath(Assembly.GetExecutingAssembly().Location);
            bool found;
            do
            {
                result = Path.Join(currDir, pathToFind);
                found = Directory.Exists(result);
                currDir = Path.GetFullPath(Path.Combine(currDir, ".."));
            } while (maxAttempts-- > 0 && !found);

            return found;
        }

        if (!SearchPath(Folder, out var path))
        {
            throw new YourAppException("Plugins directory not found. The app needs the plugins from the repo to work.");
        }

        return path;
    }
}


===== samples\InternalUtilities\StringExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

public static class StringExtensions
{
    public static string DefaultIfEmpty(this string text, string? defaultText = null) =>
        string.IsNullOrWhiteSpace(text) ? defaultText ?? string.Empty : text;
}


===== samples\InternalUtilities\TestConfiguration.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using Microsoft.Extensions.Configuration;

public sealed class TestConfiguration
{
    private readonly IConfigurationRoot _configRoot;
    private static TestConfiguration? s_instance;

    private TestConfiguration(IConfigurationRoot configRoot)
    {
        this._configRoot = configRoot;
    }

    public static void Initialize(IConfigurationRoot configRoot)
    {
        s_instance = new TestConfiguration(configRoot);
    }

    public static IConfigurationRoot? ConfigurationRoot => s_instance?._configRoot;
    public static OllamaConfig Ollama => LoadSection<OllamaConfig>();
    public static OpenAIConfig OpenAI => LoadSection<OpenAIConfig>();
    public static OnnxConfig Onnx => LoadSection<OnnxConfig>();
    public static AzureOpenAIConfig AzureOpenAI => LoadSection<AzureOpenAIConfig>();
    public static AzureAIInferenceConfig AzureAIInference => LoadSection<AzureAIInferenceConfig>();
    public static AzureAIConfig AzureAI => LoadSection<AzureAIConfig>();
    public static AzureOpenAIConfig AzureOpenAIImages => LoadSection<AzureOpenAIConfig>();
    public static AzureOpenAIEmbeddingsConfig AzureOpenAIEmbeddings => LoadSection<AzureOpenAIEmbeddingsConfig>();
    public static AzureAISearchConfig AzureAISearch => LoadSection<AzureAISearchConfig>();
    public static QdrantConfig Qdrant => LoadSection<QdrantConfig>();
    public static WeaviateConfig Weaviate => LoadSection<WeaviateConfig>();
    public static KeyVaultConfig KeyVault => LoadSection<KeyVaultConfig>();
    public static HuggingFaceConfig HuggingFace => LoadSection<HuggingFaceConfig>();
    public static PineconeConfig Pinecone => LoadSection<PineconeConfig>();
    public static BingConfig Bing => LoadSection<BingConfig>();
    public static GoogleConfig Google => LoadSection<GoogleConfig>();
    public static TavilyConfig Tavily => LoadSection<TavilyConfig>();
    public static GithubConfig Github => LoadSection<GithubConfig>();
    public static PostgresConfig Postgres => LoadSection<PostgresConfig>();
    public static RedisConfig Redis => LoadSection<RedisConfig>();
    public static JiraConfig Jira => LoadSection<JiraConfig>();
    public static ChromaConfig Chroma => LoadSection<ChromaConfig>();
    public static MongoDBConfig MongoDB => LoadSection<MongoDBConfig>();
    public static ChatGPTRetrievalPluginConfig ChatGPTRetrievalPlugin => LoadSection<ChatGPTRetrievalPluginConfig>();
    public static MsGraphConfiguration MSGraph => LoadSection<MsGraphConfiguration>();
    public static MistralAIConfig MistralAI => LoadSection<MistralAIConfig>();
    public static GoogleAIConfig GoogleAI => LoadSection<GoogleAIConfig>();
    public static VertexAIConfig VertexAI => LoadSection<VertexAIConfig>();
    public static CosmosMongoConfig CosmosMongo => LoadSection<CosmosMongoConfig>();
    public static ApplicationInsightsConfig ApplicationInsights => LoadSection<ApplicationInsightsConfig>();
    public static CrewAIConfig CrewAI => LoadSection<CrewAIConfig>();
    public static BedrockConfig Bedrock => LoadSection<BedrockConfig>();
    public static BedrockAgentConfig BedrockAgent => LoadSection<BedrockAgentConfig>();
    public static A2AConfig A2A => LoadSection<A2AConfig>();
    public static Mem0Config Mem0 => LoadSection<Mem0Config>();

    public static IConfigurationSection GetSection(string caller)
    {
        return s_instance?._configRoot.GetSection(caller) ??
               throw new ConfigurationNotFoundException(section: caller);
    }

    private static T LoadSection<T>([CallerMemberName] string? caller = null)
    {
        if (s_instance is null)
        {
            throw new InvalidOperationException(
                "TestConfiguration must be initialized with a call to Initialize(IConfigurationRoot) before accessing configuration values.");
        }

        if (string.IsNullOrEmpty(caller))
        {
            throw new ArgumentNullException(nameof(caller));
        }

        return s_instance._configRoot.GetSection(caller).Get<T>() ??
               throw new ConfigurationNotFoundException(section: caller);
    }

#pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor.
    public class OpenAIConfig
    {
        public string ModelId { get; set; }
        public string ChatModelId { get; set; }
        public string EmbeddingModelId { get; set; }
        public string ApiKey { get; set; }
    }

    public class AzureAIInferenceConfig
    {
        public string ServiceId { get; set; }
        public string Endpoint { get; set; }
        public string? ApiKey { get; set; }
        public string ChatModelId { get; set; }
    }

    public class OnnxConfig
    {
        public string ModelId { get; set; }
        public string ModelPath { get; set; }
        public string EmbeddingModelId { get; set; }
        public string EmbeddingModelPath { get; set; }
        public string EmbeddingVocabPath { get; set; }
    }

    public class AzureAIConfig
    {
        public string ChatModelId { get; set; }
        public string Endpoint { get; set; }
        public string WorkflowEndpoint { get; set; }
        public string BingConnectionId { get; set; }
        public string VectorStoreId { get; set; }
        public string AgentId { get; set; }
    }

    public class AzureOpenAIConfig
    {
        public string ServiceId { get; set; }
        public string DeploymentName { get; set; }
        public string ModelId { get; set; }
        public string ChatDeploymentName { get; set; }
        public string ChatModelId { get; set; }
        public string ImageDeploymentName { get; set; }
        public string ImageModelId { get; set; }
        public string ImageEndpoint { get; set; }
        public string Endpoint { get; set; }
        public string ApiKey { get; set; }
        public string ImageApiKey { get; set; }
        public string AgentId { get; set; }
    }

    public class AzureOpenAIEmbeddingsConfig
    {
        public string DeploymentName { get; set; }
        public string Endpoint { get; set; }
        public string ApiKey { get; set; }
    }

    public class AzureAISearchConfig
    {
        public string Endpoint { get; set; }
        public string ApiKey { get; set; }
        public string IndexName { get; set; }
    }

    public class QdrantConfig
    {
        public string Endpoint { get; set; }
        public string Port { get; set; }
    }

    public class WeaviateConfig
    {
        public string Scheme { get; set; }
        public string Endpoint { get; set; }
        public string Port { get; set; }
        public string ApiKey { get; set; }
    }

    public class KeyVaultConfig
    {
        public string Endpoint { get; set; }
        public string ClientId { get; set; }
        public string ClientSecret { get; set; }
    }

    public class HuggingFaceConfig
    {
        public string ApiKey { get; set; }
        public string ModelId { get; set; }
        public string EmbeddingModelId { get; set; }
    }

    public class PineconeConfig
    {
        public string ApiKey { get; set; }
        public string Environment { get; set; }
    }

    public class BingConfig
    {
        public string Endpoint { get; set; } = "https://api.bing.microsoft.com/v7.0/search";
        public string ApiKey { get; set; }
    }

    public class GoogleConfig
    {
        public string ApiKey { get; set; }
        public string SearchEngineId { get; set; }
    }

    public class TavilyConfig
    {
        public string Endpoint { get; set; } = "https://api.tavily.com/search";
        public string ApiKey { get; set; }
    }

    public class GithubConfig
    {
        public string PAT { get; set; }
    }

    public class PostgresConfig
    {
        public string ConnectionString { get; set; }
    }

    public class RedisConfig
    {
        public string Configuration { get; set; }
    }

    public class JiraConfig
    {
        public string ApiKey { get; set; }
        public string Email { get; set; }
        public string Domain { get; set; }
    }

    public class ChromaConfig
    {
        public string Endpoint { get; set; }
    }

    public class MongoDBConfig
    {
        public string ConnectionString { get; set; }
    }

    public class ChatGPTRetrievalPluginConfig
    {
        public string Token { get; set; }
    }

    public class MistralAIConfig
    {
        public string ApiKey { get; set; }
        public string ChatModelId { get; set; }
        public string EmbeddingModelId { get; set; }
        public string ImageModelId { get; set; }
    }

    public class GoogleAIConfig
    {
        public string ApiKey { get; set; }
        public string EmbeddingModelId { get; set; }
        public GeminiConfig Gemini { get; set; }

        public class GeminiConfig
        {
            public string ModelId { get; set; }
        }
    }

    public class VertexAIConfig
    {
        public string? BearerKey { get; set; }
        public string EmbeddingModelId { get; set; }
        public string Location { get; set; }
        public string ProjectId { get; set; }
        public string? ClientId { get; set; }
        public string? ClientSecret { get; set; }
        public GeminiConfig Gemini { get; set; }

        public class GeminiConfig
        {
            public string ModelId { get; set; }
        }
    }

    public class OllamaConfig
    {
        public string? ModelId { get; set; }
        public string? EmbeddingModelId { get; set; }

        public string Endpoint { get; set; } = "http://localhost:11434";
    }

    public class CosmosMongoConfig
    {
        public string ConnectionString { get; set; }
        public string DatabaseName { get; set; }
    }

    public class ApplicationInsightsConfig
    {
        public string ConnectionString { get; set; }
    }

    /// <summary>
    /// Graph API connector configuration model.
    /// </summary>
    public class MsGraphConfiguration
    {
        /// <summary>
        /// Gets or sets the client ID.
        /// </summary>
        public string ClientId { get; }

        /// <summary>
        /// Gets or sets the tenant/directory ID.
        /// </summary>
        public string TenantId { get; }

        /// <summary>
        /// Gets or sets the API permission scopes.
        /// </summary>
        /// <remarks>
        /// Keeping this parameters nullable and out of the constructor is a workaround for
        /// nested types not working with IConfigurationSection.Get.
        /// See https://github.com/dotnet/runtime/issues/77677
        /// </remarks>
        public IEnumerable<string> Scopes { get; set; } = [];

        /// <summary>
        /// Gets or sets the redirect URI to use.
        /// </summary>
        public Uri RedirectUri { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="MsGraphConfiguration"/> class.
        /// </summary>
        /// <param name="clientId">The client id.</param>
        /// <param name="tenantId">The tenant id.</param>
        /// <param name="redirectUri">The redirect URI.</param>
        public MsGraphConfiguration(
            [NotNull] string clientId,
            [NotNull] string tenantId,
            [NotNull] Uri redirectUri)
        {
            this.ClientId = clientId;
            this.TenantId = tenantId;
            this.RedirectUri = redirectUri;
        }
    }

    public class CrewAIConfig
    {
        public string Endpoint { get; set; }
        public string AuthToken { get; set; }
    }

    public class BedrockConfig
    {
        public string? EmbeddingModelId { get; set; }
    }

    public class BedrockAgentConfig
    {
        public string AgentResourceRoleArn { get; set; }
        public string FoundationModel { get; set; }
        public string? KnowledgeBaseId { get; set; }
    }

    public class A2AConfig
    {
        public Uri AgentUrl { get; set; } = new Uri("http://localhost:5000");
    }

    public class Mem0Config
    {
        public string? BaseAddress { get; set; }
        public string ApiKey { get; set; }
    }
}


===== samples\InternalUtilities\TextOutputHelperExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

public static class TextOutputHelperExtensions
{
    public static void WriteLine(this ITestOutputHelper testOutputHelper, object target)
    {
        testOutputHelper.WriteLine(target.ToString());
    }

    public static void WriteLine(this ITestOutputHelper testOutputHelper)
    {
        testOutputHelper.WriteLine(string.Empty);
    }

    public static void Write(this ITestOutputHelper testOutputHelper)
    {
        testOutputHelper.WriteLine(string.Empty);
    }

    /// <summary>
    /// Current interface ITestOutputHelper does not have a Write method. This extension method adds it to make it analogous to Console.Write when used in Console apps.
    /// </summary>
    /// <param name="testOutputHelper">TestOutputHelper</param>
    /// <param name="target">Target object to write</param>
    public static void Write(this ITestOutputHelper testOutputHelper, object target)
    {
        testOutputHelper.WriteLine(target.ToString());
    }
}


===== samples\InternalUtilities\XunitLogger.cs =====

// Copyright (c) Microsoft. All rights reserved.

using Microsoft.Extensions.Logging;

/// <summary>
/// A logger that writes to the Xunit test output
/// </summary>
internal sealed class XunitLogger(ITestOutputHelper output) : ILoggerFactory, ILogger, IDisposable
{
    private object? _scopeState;

    /// <inheritdoc/>
    public void Log<TState>(LogLevel logLevel, EventId eventId, TState state, Exception? exception, Func<TState, Exception?, string> formatter)
    {
        var localState = state?.ToString();
        var line = this._scopeState is not null ? $"{this._scopeState} {localState}" : localState;
        output.WriteLine(line);
    }

    /// <inheritdoc/>
    public bool IsEnabled(LogLevel logLevel) => true;

    /// <inheritdoc/>
    public IDisposable BeginScope<TState>(TState state) where TState : notnull
    {
        this._scopeState = state;
        return this;
    }

    /// <inheritdoc/>
    public void Dispose()
    {
        // This class is marked as disposable to support the BeginScope method.
        // However, there is no need to dispose anything.
    }

    public ILogger CreateLogger(string categoryName) => this;

    public void AddProvider(ILoggerProvider provider) => throw new NotSupportedException();
}


===== samples\InternalUtilities\YourAppException.cs =====

// Copyright (c) Microsoft. All rights reserved.

public class YourAppException : Exception
{
    public YourAppException() : base()
    {
    }

    public YourAppException(string message) : base(message)
    {
    }

    public YourAppException(string message, Exception innerException) : base(message, innerException)
    {
    }
}


===== src\Data\VectorStoreErrorHandler.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Data.Common;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;

namespace Microsoft.Extensions.VectorData;

#pragma warning disable MEVD9000 // Type is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.

/// <summary>
/// Contains helpers for reading vector store model properties and their attributes.
/// </summary>
[ExcludeFromCodeCoverage]
internal static class VectorStoreErrorHandler
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Task<TResult> RunOperationAsync<TResult, TException>(
        VectorStoreMetadata metadata,
        string operationName,
        Func<Task<TResult>> operation)
        where TException : Exception
    {
        return RunOperationAsync<TResult, TException>(
            new VectorStoreCollectionMetadata()
            {
                CollectionName = null,
                VectorStoreName = metadata.VectorStoreName,
                VectorStoreSystemName = metadata.VectorStoreSystemName,
            },
            operationName,
            operation);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static async Task<TResult> RunOperationAsync<TResult, TException>(
        VectorStoreCollectionMetadata metadata,
        string operationName,
        Func<Task<TResult>> operation)
        where TException : Exception
    {
        try
        {
            return await operation.Invoke().ConfigureAwait(false);
        }
        catch (AggregateException ex) when (ex.InnerException is TException innerEx)
        {
            throw new VectorStoreException("Call to vector store failed.", ex)
            {
                VectorStoreSystemName = metadata.VectorStoreSystemName,
                VectorStoreName = metadata.VectorStoreName,
                CollectionName = metadata.CollectionName,
                OperationName = operationName
            };
        }
        catch (TException ex)
        {
            throw new VectorStoreException("Call to vector store failed.", ex)
            {
                VectorStoreSystemName = metadata.VectorStoreSystemName,
                VectorStoreName = metadata.VectorStoreName,
                CollectionName = metadata.CollectionName,
                OperationName = operationName
            };
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static TResult RunOperation<TResult, TException>(
        VectorStoreMetadata metadata,
        string operationName,
        Func<TResult> operation)
        where TException : Exception
    {
        return RunOperation<TResult, TException>(
            new VectorStoreCollectionMetadata()
            {
                CollectionName = null,
                VectorStoreName = metadata.VectorStoreName,
                VectorStoreSystemName = metadata.VectorStoreSystemName,
            },
            operationName,
            operation);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static TResult RunOperation<TResult, TException>(
        VectorStoreCollectionMetadata metadata,
        string operationName,
        Func<TResult> operation)
        where TException : Exception
    {
        try
        {
            return operation.Invoke();
        }
        catch (AggregateException ex) when (ex.InnerException is TException innerEx)
        {
            throw new VectorStoreException("Call to vector store failed.", ex)
            {
                VectorStoreSystemName = metadata.VectorStoreSystemName,
                VectorStoreName = metadata.VectorStoreName,
                CollectionName = metadata.CollectionName,
                OperationName = operationName
            };
        }
        catch (TException ex)
        {
            throw new VectorStoreException("Call to vector store failed.", ex)
            {
                VectorStoreSystemName = metadata.VectorStoreSystemName,
                VectorStoreName = metadata.VectorStoreName,
                CollectionName = metadata.CollectionName,
                OperationName = operationName
            };
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static async Task<TResult> RunOperationWithRetryAsync<TResult, TException>(
        VectorStoreCollectionMetadata metadata,
        string operationName,
        int maxRetries,
        int delayInMilliseconds,
        Func<Task<TResult>> operation,
        CancellationToken cancellationToken)
        where TException : Exception
    {
        var retries = 0;

        var exceptions = new List<Exception>();

        while (retries < maxRetries)
        {
            try
            {
                return await operation.Invoke().ConfigureAwait(false);
            }
            catch (AggregateException ex) when (ex.InnerException is TException innerEx)
            {
                retries++;
                exceptions.Add(ex);

                if (retries >= maxRetries)
                {
                    throw new VectorStoreException("Call to vector store failed.", new AggregateException(exceptions))
                    {
                        VectorStoreSystemName = metadata.VectorStoreSystemName,
                        VectorStoreName = metadata.VectorStoreName,
                        CollectionName = metadata.CollectionName,
                        OperationName = operationName
                    };
                }

                await Task.Delay(delayInMilliseconds, cancellationToken).ConfigureAwait(false);
            }
            catch (TException ex)
            {
                retries++;
                exceptions.Add(ex);

                if (retries >= maxRetries)
                {
                    throw new VectorStoreException("Call to vector store failed.", new AggregateException(exceptions))
                    {
                        VectorStoreSystemName = metadata.VectorStoreSystemName,
                        VectorStoreName = metadata.VectorStoreName,
                        CollectionName = metadata.CollectionName,
                        OperationName = operationName
                    };
                }

                await Task.Delay(delayInMilliseconds, cancellationToken).ConfigureAwait(false);
            }
        }

        throw new VectorStoreException("Call to vector store failed.", new AggregateException(exceptions))
        {
            VectorStoreSystemName = metadata.VectorStoreSystemName,
            VectorStoreName = metadata.VectorStoreName,
            CollectionName = metadata.CollectionName,
            OperationName = operationName
        };
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static async Task RunOperationAsync<TException>(
        VectorStoreCollectionMetadata metadata,
        string operationName,
        Func<Task> operation)
        where TException : Exception
    {
        try
        {
            await operation.Invoke().ConfigureAwait(false);
        }
        catch (AggregateException ex) when (ex.InnerException is TException innerEx)
        {
            throw new VectorStoreException("Call to vector store failed.", ex)
            {
                VectorStoreSystemName = metadata.VectorStoreSystemName,
                VectorStoreName = metadata.VectorStoreName,
                CollectionName = metadata.CollectionName,
                OperationName = operationName
            };
        }
        catch (TException ex)
        {
            throw new VectorStoreException("Call to vector store failed.", ex)
            {
                VectorStoreSystemName = metadata.VectorStoreSystemName,
                VectorStoreName = metadata.VectorStoreName,
                CollectionName = metadata.CollectionName,
                OperationName = operationName
            };
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static async Task RunOperationWithRetryAsync<TException>(
        VectorStoreCollectionMetadata metadata,
        string operationName,
        int maxRetries,
        int delayInMilliseconds,
        Func<Task> operation,
        CancellationToken cancellationToken)
        where TException : Exception
    {
        var retries = 0;

        var exceptions = new List<Exception>();

        while (retries < maxRetries)
        {
            try
            {
                await operation.Invoke().ConfigureAwait(false);
                return;
            }
            catch (AggregateException ex) when (ex.InnerException is TException innerEx)
            {
                retries++;
                exceptions.Add(ex);

                if (retries >= maxRetries)
                {
                    throw new VectorStoreException("Call to vector store failed.", new AggregateException(exceptions))
                    {
                        VectorStoreSystemName = metadata.VectorStoreSystemName,
                        VectorStoreName = metadata.VectorStoreName,
                        CollectionName = metadata.CollectionName,
                        OperationName = operationName
                    };
                }

                await Task.Delay(delayInMilliseconds, cancellationToken).ConfigureAwait(false);
            }
            catch (TException ex)
            {
                retries++;
                exceptions.Add(ex);

                if (retries >= maxRetries)
                {
                    throw new VectorStoreException("Call to vector store failed.", new AggregateException(exceptions))
                    {
                        VectorStoreSystemName = metadata.VectorStoreSystemName,
                        VectorStoreName = metadata.VectorStoreName,
                        CollectionName = metadata.CollectionName,
                        OperationName = operationName
                    };
                }

                await Task.Delay(delayInMilliseconds, cancellationToken).ConfigureAwait(false);
            }
        }

        throw new VectorStoreException("Call to vector store failed.", new AggregateException(exceptions))
        {
            VectorStoreSystemName = metadata.VectorStoreSystemName,
            VectorStoreName = metadata.VectorStoreName,
            CollectionName = metadata.CollectionName,
            OperationName = operationName
        };
    }

    public struct ConfiguredCancelableErrorHandlingAsyncEnumerable<TResult, TException>
        where TException : Exception
    {
        private readonly ConfiguredCancelableAsyncEnumerable<TResult> _enumerable;
        private readonly VectorStoreCollectionMetadata _metadata;
        private readonly string _operationName;

        public ConfiguredCancelableErrorHandlingAsyncEnumerable(
            ConfiguredCancelableAsyncEnumerable<TResult> enumerable,
            VectorStoreCollectionMetadata metadata,
            string operationName)
        {
            this._enumerable = enumerable;
            this._metadata = metadata;
            this._operationName = operationName;
        }

        public ConfiguredCancelableErrorHandlingAsyncEnumerable(
            ConfiguredCancelableAsyncEnumerable<TResult> enumerable,
            VectorStoreMetadata metadata,
            string operationName)
        {
            this._enumerable = enumerable;
            this._metadata = new()
            {
                CollectionName = null,
                VectorStoreName = metadata.VectorStoreName,
                VectorStoreSystemName = metadata.VectorStoreSystemName,
            };
            this._operationName = operationName;
        }

        public ConfiguredCancelableErrorHandlingAsyncEnumerable<TResult, TException>.Enumerator GetAsyncEnumerator(CancellationToken cancellationToken = default)
        {
            return new Enumerator(this._enumerable.WithCancellation(cancellationToken).GetAsyncEnumerator(), this._metadata, this._operationName);
        }

        public ConfiguredCancelableErrorHandlingAsyncEnumerable<TResult, TException> ConfigureAwait(bool continueOnCapturedContext)
        {
            return new ConfiguredCancelableErrorHandlingAsyncEnumerable<TResult, TException>(this._enumerable.ConfigureAwait(continueOnCapturedContext), this._metadata, this._operationName);
        }

        public struct Enumerator(
            ConfiguredCancelableAsyncEnumerable<TResult>.Enumerator enumerator,
            VectorStoreCollectionMetadata metadata,
            string operationName)
        {
            public async ValueTask<bool> MoveNextAsync()
            {
                try
                {
                    return await enumerator.MoveNextAsync();
                }
                catch (AggregateException ex) when (ex.InnerException is TException innerEx)
                {
                    throw new VectorStoreException("Call to vector store failed.", ex)
                    {
                        VectorStoreSystemName = metadata.VectorStoreSystemName,
                        VectorStoreName = metadata.VectorStoreName,
                        CollectionName = metadata.CollectionName,
                        OperationName = operationName
                    };
                }
                catch (TException ex)
                {
                    throw new VectorStoreException("Call to vector store failed.", ex)
                    {
                        VectorStoreSystemName = metadata.VectorStoreSystemName,
                        VectorStoreName = metadata.VectorStoreName,
                        CollectionName = metadata.CollectionName,
                        OperationName = operationName
                    };
                }
            }
            public TResult Current => enumerator.Current;
        }
    }

    internal static Task<bool> ReadWithErrorHandlingAsync(
        this DbDataReader reader,
        VectorStoreCollectionMetadata metadata,
        string operationName,
        CancellationToken cancellationToken)
        => VectorStoreErrorHandler.RunOperationAsync<bool, DbException>(
            metadata,
            operationName,
            () => reader.ReadAsync(cancellationToken));

    internal static Task<bool> ReadWithErrorHandlingAsync(
        this DbDataReader reader,
        VectorStoreMetadata metadata,
        string operationName,
        CancellationToken cancellationToken)
        => VectorStoreErrorHandler.RunOperationAsync<bool, DbException>(
            metadata,
            operationName,
            () => reader.ReadAsync(cancellationToken));

    internal static async Task<TResult> ExecuteWithErrorHandlingAsync<TResult>(
        this DbConnection connection,
        VectorStoreMetadata metadata,
        string operationName,
        Func<Task<TResult>> operation,
        CancellationToken cancellationToken)
    {
        return await ExecuteWithErrorHandlingAsync(
            connection,
            new VectorStoreCollectionMetadata
            {
                VectorStoreSystemName = metadata.VectorStoreSystemName,
                VectorStoreName = metadata.VectorStoreName,
                CollectionName = null
            },
            operationName,
            operation,
            cancellationToken).ConfigureAwait(false);
    }

    internal static async Task<TResult> ExecuteWithErrorHandlingAsync<TResult>(
        this DbConnection connection,
        VectorStoreCollectionMetadata metadata,
        string operationName,
        Func<Task<TResult>> operation,
        CancellationToken cancellationToken)
    {
        if (connection.State != System.Data.ConnectionState.Open)
        {
            await connection.OpenAsync(cancellationToken).ConfigureAwait(false);
        }

        try
        {
            return await operation().ConfigureAwait(false);
        }
        catch (DbException ex)
        {
#if NET
            await connection.DisposeAsync().ConfigureAwait(false);
#else
            connection.Dispose();
#endif

            throw new VectorStoreException("Call to vector store failed.", ex)
            {
                VectorStoreSystemName = metadata.VectorStoreSystemName,
                VectorStoreName = metadata.VectorStoreName,
                CollectionName = metadata.CollectionName,
                OperationName = operationName
            };
        }
        catch (IOException ex)
        {
#if NET
            await connection.DisposeAsync().ConfigureAwait(false);
#else
            connection.Dispose();
#endif

            throw new VectorStoreException("Call to vector store failed.", ex)
            {
                VectorStoreSystemName = metadata.VectorStoreSystemName,
                VectorStoreName = metadata.VectorStoreName,
                CollectionName = metadata.CollectionName,
                OperationName = operationName
            };
        }
        catch (Exception)
        {
#if NET
            await connection.DisposeAsync().ConfigureAwait(false);
#else
            connection.Dispose();
#endif
            throw;
        }
    }
}


===== src\Diagnostics\ActivityExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;

namespace Microsoft.SemanticKernel.Diagnostics;

[ExcludeFromCodeCoverage]
internal static class ActivityExtensions
{
    /// <summary>
    /// Starts an activity with the specified name and tags.
    /// </summary>
    public static Activity? StartActivityWithTags(this ActivitySource source, string name, IEnumerable<KeyValuePair<string, object?>> tags, ActivityKind kind = ActivityKind.Internal)
        => source.StartActivity(name, kind, default(ActivityContext), tags);

    /// <summary>
    /// Adds tags to the activity.
    /// </summary>
    public static Activity SetTags(this Activity activity, ReadOnlySpan<KeyValuePair<string, object?>> tags)
    {
        foreach (var tag in tags)
        {
            activity.SetTag(tag.Key, tag.Value);
        }

        return activity;
    }

    /// <summary>
    /// Adds an event to the activity. Should only be used for events that contain sensitive data.
    /// </summary>
    public static Activity AttachSensitiveDataAsEvent(this Activity activity, string name, IEnumerable<KeyValuePair<string, object?>> tags)
    {
        activity.AddEvent(new ActivityEvent(
            name,
            tags: [.. tags]
        ));

        return activity;
    }

    /// <summary>
    /// Sets the error status and type on the activity.
    /// </summary>
    public static Activity SetError(this Activity activity, Exception exception)
    {
        activity.SetTag("error.type", exception.GetType().FullName);
        activity.SetStatus(ActivityStatusCode.Error, exception.Message);
        return activity;
    }

    public static async IAsyncEnumerable<TResult> RunWithActivityAsync<TResult>(
        Func<Activity?> getActivity,
        Func<IAsyncEnumerable<TResult>> operation,
        [EnumeratorCancellation] CancellationToken cancellationToken)
    {
        using var activity = getActivity();

        ConfiguredCancelableAsyncEnumerable<TResult> result;

        try
        {
            result = operation().WithCancellation(cancellationToken).ConfigureAwait(false);
        }
        catch (Exception ex) when (activity is not null)
        {
            activity.SetError(ex);
            throw;
        }

        var resultEnumerator = result.ConfigureAwait(false).GetAsyncEnumerator();

        try
        {
            while (true)
            {
                try
                {
                    if (!await resultEnumerator.MoveNextAsync())
                    {
                        break;
                    }
                }
                catch (Exception ex) when (activity is not null)
                {
                    activity.SetError(ex);
                    throw;
                }

                yield return resultEnumerator.Current;
            }
        }
        finally
        {
            await resultEnumerator.DisposeAsync();
        }
    }
}


===== src\Diagnostics\CompilerServicesAttributes.cs =====

// Copyright (c) Microsoft. All rights reserved.

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

#if !NETCOREAPP
#pragma warning disable IDE0005 // Using directive is unnecessary.

using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;

namespace System.Runtime.CompilerServices;

[AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
[ExcludeFromCodeCoverage]
internal sealed class CallerArgumentExpressionAttribute : Attribute
{
    public CallerArgumentExpressionAttribute(string parameterName)
    {
        this.ParameterName = parameterName;
    }

    public string ParameterName { get; }
}

/// <summary>Specifies that a type has required members or that a member is required.</summary>
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Field | AttributeTargets.Property, AllowMultiple = false, Inherited = false)]
[EditorBrowsable(EditorBrowsableState.Never)]
internal sealed class RequiredMemberAttribute : Attribute;

[AttributeUsage(AttributeTargets.All, AllowMultiple = true, Inherited = false)]
internal sealed class CompilerFeatureRequiredAttribute : Attribute
{
    public CompilerFeatureRequiredAttribute(string featureName)
    {
        this.FeatureName = featureName;
    }

    /// <summary>
    /// The name of the compiler feature.
    /// </summary>
    public string FeatureName { get; }

    /// <summary>
    /// If true, the compiler can choose to allow access to the location where this attribute is applied if it does not understand <see cref="FeatureName"/>.
    /// </summary>
    public bool IsOptional { get; init; }

    /// <summary>
    /// The <see cref="FeatureName"/> used for the ref structs C# feature.
    /// </summary>
    public const string RefStructs = nameof(RefStructs);

    /// <summary>
    /// The <see cref="FeatureName"/> used for the required members C# feature.
    /// </summary>
    public const string RequiredMembers = nameof(RequiredMembers);
}

#endif


===== src\Diagnostics\DynamicallyAccessedMembersAttribute.cs =====

// Copyright (c) Microsoft. All rights reserved.

#if !NET5_0_OR_GREATER
namespace System.Diagnostics.CodeAnalysis;

/// <summary>
/// Polyfill for the DynamicallyAccessedMembersAttribute not available in .NET Standard 2.0.
/// Indicates that certain members on a specified <see cref="Type"/> are accessed dynamically,
/// for example through <see cref="System.Reflection"/>.
/// </summary>
/// <remarks>
/// This allows tools to understand which members are being accessed during the execution
/// of a program.
///
/// This attribute is valid on members whose type is <see cref="Type"/> or <see cref="string"/>.
///
/// When this attribute is applied to a location of type <see cref="string"/>, the assumption is
/// that the string represents a fully qualified type name.
///
/// When this attribute is applied to a class, interface, or struct, the members specified
/// can be accessed dynamically on <see cref="Type"/> instances returned from calling
/// <see cref="object.GetType"/> on instances of that class, interface, or struct.
///
/// If the attribute is applied to a method it's treated as a special case and it implies
/// the attribute should be applied to the "this" parameter of the method. As such the attribute
/// should only be used on instance methods of types assignable to System.Type (or string, but no methods
/// will use it there).
/// </remarks>
[AttributeUsage(
        AttributeTargets.Field | AttributeTargets.ReturnValue | AttributeTargets.GenericParameter |
        AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.Method |
        AttributeTargets.Class | AttributeTargets.Interface | AttributeTargets.Struct,
        Inherited = false)]
internal sealed class DynamicallyAccessedMembersAttribute : Attribute
{
    /// <summary>
    /// Initializes a new instance of the <see cref="DynamicallyAccessedMembersAttribute"/> class
    /// with the specified member types.
    /// </summary>
    /// <param name="memberTypes">The types of members dynamically accessed.</param>
    public DynamicallyAccessedMembersAttribute(DynamicallyAccessedMemberTypes memberTypes)
    {
        this.MemberTypes = memberTypes;
    }

    /// <summary>
    /// Gets the <see cref="DynamicallyAccessedMemberTypes"/> which specifies the type
    /// of members dynamically accessed.
    /// </summary>
    public DynamicallyAccessedMemberTypes MemberTypes { get; }
}

/// <summary>
/// Specifies the types of members that are dynamically accessed.
///
/// This enumeration has a <see cref="FlagsAttribute"/> attribute that allows a
/// bitwise combination of its member values.
/// </summary>
[Flags]
internal enum DynamicallyAccessedMemberTypes
{
    /// <summary>
    /// Specifies no members.
    /// </summary>
    None = 0,

    /// <summary>
    /// Specifies the default, parameterless public constructor.
    /// </summary>
    PublicParameterlessConstructor = 0x0001,

    /// <summary>
    /// Specifies all public constructors.
    /// </summary>
    PublicConstructors = 0x0002 | PublicParameterlessConstructor,

    /// <summary>
    /// Specifies all non-public constructors.
    /// </summary>
    NonPublicConstructors = 0x0004,

    /// <summary>
    /// Specifies all public methods.
    /// </summary>
    PublicMethods = 0x0008,

    /// <summary>
    /// Specifies all non-public methods.
    /// </summary>
    NonPublicMethods = 0x0010,

    /// <summary>
    /// Specifies all public fields.
    /// </summary>
    PublicFields = 0x0020,

    /// <summary>
    /// Specifies all non-public fields.
    /// </summary>
    NonPublicFields = 0x0040,

    /// <summary>
    /// Specifies all public nested types.
    /// </summary>
    PublicNestedTypes = 0x0080,

    /// <summary>
    /// Specifies all non-public nested types.
    /// </summary>
    NonPublicNestedTypes = 0x0100,

    /// <summary>
    /// Specifies all public properties.
    /// </summary>
    PublicProperties = 0x0200,

    /// <summary>
    /// Specifies all non-public properties.
    /// </summary>
    NonPublicProperties = 0x0400,

    /// <summary>
    /// Specifies all public events.
    /// </summary>
    PublicEvents = 0x0800,

    /// <summary>
    /// Specifies all non-public events.
    /// </summary>
    NonPublicEvents = 0x1000,

    /// <summary>
    /// Specifies all interfaces implemented by the type.
    /// </summary>
    Interfaces = 0x2000,

    /// <summary>
    /// Specifies all members.
    /// </summary>
    All = ~None
}
#endif


===== src\Diagnostics\ExceptionExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Diagnostics.CodeAnalysis;
using System.Threading;

namespace System;

/// <summary>
/// Exception extension methods.
/// </summary>
[ExcludeFromCodeCoverage]
internal static class ExceptionExtensions
{
    /// <summary>
    /// Check if an exception is of a type that should not be caught by the kernel.
    /// </summary>
    /// <param name="ex">Exception.</param>
    /// <returns>True if <paramref name="ex"/> is a critical exception and should not be caught.</returns>
    internal static bool IsCriticalException(this Exception ex)
        => ex is ThreadAbortException
            or AccessViolationException
            or AppDomainUnloadedException
            or BadImageFormatException
            or CannotUnloadAppDomainException
            or InvalidProgramException;
}


===== src\Diagnostics\ExperimentalAttribute.cs =====

// Copyright (c) Microsoft. All rights reserved.

// This is a copy of:
// https://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/System/Diagnostics/CodeAnalysis/ExperimentalAttribute.cs
// made internal rather than public.

#if !NET8_0_OR_GREATER
namespace System.Diagnostics.CodeAnalysis;

/// <summary>
///  Indicates that an API is experimental and it may change in the future.
/// </summary>
/// <remarks>
///   This attribute allows call sites to be flagged with a diagnostic that indicates that an experimental
///   feature is used. Authors can use this attribute to ship preview features in their assemblies.
/// </remarks>
[ExcludeFromCodeCoverage]
[AttributeUsage(AttributeTargets.Assembly |
                AttributeTargets.Module |
                AttributeTargets.Class |
                AttributeTargets.Struct |
                AttributeTargets.Enum |
                AttributeTargets.Constructor |
                AttributeTargets.Method |
                AttributeTargets.Property |
                AttributeTargets.Field |
                AttributeTargets.Event |
                AttributeTargets.Interface |
                AttributeTargets.Delegate, Inherited = false)]
internal sealed class ExperimentalAttribute : Attribute
{
    /// <summary>
    ///  Initializes a new instance of the <see cref="ExperimentalAttribute"/> class, specifying the ID that the compiler will use
    ///  when reporting a use of the API the attribute applies to.
    /// </summary>
    /// <param name="diagnosticId">The ID that the compiler will use when reporting a use of the API the attribute applies to.</param>
    public ExperimentalAttribute(string diagnosticId)
    {
        this.DiagnosticId = diagnosticId;
    }

    /// <summary>
    ///  Gets the ID that the compiler will use when reporting a use of the API the attribute applies to.
    /// </summary>
    /// <value>The unique diagnostic ID.</value>
    /// <remarks>
    ///  The diagnostic ID is shown in build output for warnings and errors.
    ///  <para>This property represents the unique ID that can be used to suppress the warnings or errors, if needed.</para>
    /// </remarks>
    public string DiagnosticId { get; }

    /// <summary>
    ///  Gets or sets the URL for corresponding documentation.
    ///  The API accepts a format string instead of an actual URL, creating a generic URL that includes the diagnostic ID.
    /// </summary>
    /// <value>The format string that represents a URL to corresponding documentation.</value>
    /// <remarks>An example format string is <c>https://contoso.com/obsoletion-warnings/{0}</c>.</remarks>
    public string? UrlFormat { get; set; }
}
#endif


===== src\Diagnostics\IsExternalInit.cs =====

// Copyright (c) Microsoft. All rights reserved.

#if !NET8_0_OR_GREATER

namespace System.Runtime.CompilerServices;

/// <summary>
/// Reserved to be used by the compiler for tracking metadata.
/// This class should not be used by developers in source code.
/// </summary>
internal static class IsExternalInit;

#endif


===== src\Diagnostics\KernelVerify.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Text.RegularExpressions;

namespace Microsoft.SemanticKernel;

[ExcludeFromCodeCoverage]
internal static partial class KernelVerify
{
#if NET
    [GeneratedRegex("^[0-9A-Za-z_]*$")]
    private static partial Regex AllowedPluginNameSymbolsRegex();

    [GeneratedRegex("^[0-9A-Za-z_-]*$")]
    private static partial Regex AllowedFunctionNameSymbolsRegex();
#else
    private static Regex AllowedPluginNameSymbolsRegex() => s_allowedPluginNameSymbolsRegex;
    private static readonly Regex s_allowedPluginNameSymbolsRegex = new("^[0-9A-Za-z_]*$", RegexOptions.Compiled);

    private static Regex AllowedFunctionNameSymbolsRegex() => s_allowedFunctionNameSymbolsRegex;
    private static readonly Regex s_allowedFunctionNameSymbolsRegex = new("^[0-9A-Za-z_-]*$", RegexOptions.Compiled);
#endif

    internal static void ValidPluginName([NotNull] string? pluginName, IReadOnlyKernelPluginCollection? plugins = null, [CallerArgumentExpression(nameof(pluginName))] string? paramName = null)
    {
        Verify.NotNullOrWhiteSpace(pluginName);
        if (!AllowedPluginNameSymbolsRegex().IsMatch(pluginName))
        {
            Verify.ThrowArgumentInvalidName("plugin name", pluginName, paramName);
        }

        if (plugins is not null && plugins.Contains(pluginName))
        {
            throw new ArgumentException($"A plugin with the name '{pluginName}' already exists.");
        }
    }

    internal static void ValidFunctionName([NotNull] string? functionName, [CallerArgumentExpression(nameof(functionName))] string? paramName = null)
    {
        Verify.NotNullOrWhiteSpace(functionName);
        if (!AllowedFunctionNameSymbolsRegex().IsMatch(functionName))
        {
            Verify.ThrowArgumentInvalidName("function name", functionName, paramName);
        }
    }

    /// <summary>
    /// Make sure every function parameter name is unique
    /// </summary>
    /// <param name="parameters">List of parameters</param>
    internal static IReadOnlyList<KernelParameterMetadata> ParametersUniqueness(IReadOnlyList<KernelParameterMetadata> parameters)
    {
        int count = parameters.Count;
        if (count > 0)
        {
            var seen = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
            for (int i = 0; i < count; i++)
            {
                KernelParameterMetadata p = parameters[i];
                if (string.IsNullOrWhiteSpace(p.Name))
                {
                    string paramName = $"{nameof(parameters)}[{i}].{p.Name}";
                    if (p.Name is null)
                    {
                        Verify.ThrowArgumentNullException(paramName);
                    }
                    else
                    {
                        Verify.ThrowArgumentWhiteSpaceException(paramName);
                    }
                }

                if (!seen.Add(p.Name))
                {
                    throw new ArgumentException($"The function has two or more parameters with the same name '{p.Name}'");
                }
            }
        }

        return parameters;
    }
}


===== src\Diagnostics\LoggingExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

namespace Microsoft.SemanticKernel.Diagnostics;

[ExcludeFromCodeCoverage]
internal static partial class LoggingExtensions
{
    internal static async Task RunWithLoggingAsync(
        ILogger logger,
        string operationName,
        Func<Task> operation)
    {
        logger.LogInvoked(operationName);

        try
        {
            await operation().ConfigureAwait(false);

            logger.LogCompleted(operationName);
        }
        catch (OperationCanceledException)
        {
            logger.LogInvocationCanceled(operationName);
            throw;
        }
        catch (Exception ex)
        {
            logger.LogInvocationFailed(operationName, ex);
            throw;
        }
    }

    internal static async Task<TResult> RunWithLoggingAsync<TResult>(
        ILogger logger,
        string operationName,
        Func<Task<TResult>> operation)
    {
        logger.LogInvoked(operationName);

        try
        {
            var result = await operation().ConfigureAwait(false);

            logger.LogCompleted(operationName);

            return result;
        }
        catch (OperationCanceledException)
        {
            logger.LogInvocationCanceled(operationName);
            throw;
        }
        catch (Exception ex)
        {
            logger.LogInvocationFailed(operationName, ex);
            throw;
        }
    }

    internal static async IAsyncEnumerable<TResult> RunWithLoggingAsync<TResult>(
        ILogger logger,
        string operationName,
        Func<IAsyncEnumerable<TResult>> operation,
        [EnumeratorCancellation] CancellationToken cancellationToken)
    {
        logger.LogInvoked(operationName);

        IAsyncEnumerator<TResult> enumerator;

        try
        {
            enumerator = operation().GetAsyncEnumerator(cancellationToken);
        }
        catch (OperationCanceledException)
        {
            logger.LogInvocationCanceled(operationName);
            throw;
        }
        catch (Exception ex)
        {
            logger.LogInvocationFailed(operationName, ex);
            throw;
        }

        try
        {
            while (true)
            {
                try
                {
                    if (!await enumerator.MoveNextAsync().ConfigureAwait(false))
                    {
                        break;
                    }
                }
                catch (OperationCanceledException)
                {
                    logger.LogInvocationCanceled(operationName);
                    throw;
                }
                catch (Exception ex)
                {
                    logger.LogInvocationFailed(operationName, ex);
                    throw;
                }

                yield return enumerator.Current;
            }

            logger.LogCompleted(operationName);
        }
        finally
        {
            await enumerator.DisposeAsync().ConfigureAwait(false);
        }
    }

    [LoggerMessage(LogLevel.Debug, "{OperationName} invoked.")]
    private static partial void LogInvoked(this ILogger logger, string operationName);

    [LoggerMessage(LogLevel.Debug, "{OperationName} completed.")]
    private static partial void LogCompleted(this ILogger logger, string operationName);

    [LoggerMessage(LogLevel.Debug, "{OperationName} canceled.")]
    private static partial void LogInvocationCanceled(this ILogger logger, string operationName);

    [LoggerMessage(LogLevel.Error, "{OperationName} failed.")]
    private static partial void LogInvocationFailed(this ILogger logger, string operationName, Exception exception);
}


===== src\Diagnostics\ModelDiagnostics.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Text.Json;
using Microsoft.SemanticKernel.ChatCompletion;

namespace Microsoft.SemanticKernel.Diagnostics;

/// <summary>
/// Model diagnostics helper class that provides a set of methods to trace model activities with the OTel semantic conventions.
/// This class contains experimental features and may change in the future.
/// To enable these features, set one of the following switches to true:
///     `Microsoft.SemanticKernel.Experimental.GenAI.EnableOTelDiagnostics`
///     `Microsoft.SemanticKernel.Experimental.GenAI.EnableOTelDiagnosticsSensitive`
/// Or set the following environment variables to true:
///    `SEMANTICKERNEL_EXPERIMENTAL_GENAI_ENABLE_OTEL_DIAGNOSTICS`
///    `SEMANTICKERNEL_EXPERIMENTAL_GENAI_ENABLE_OTEL_DIAGNOSTICS_SENSITIVE`
/// </summary>
[System.Diagnostics.CodeAnalysis.Experimental("SKEXP0001")]
[System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
internal static class ModelDiagnostics
{
    private static readonly string s_namespace = typeof(ModelDiagnostics).Namespace!;
    private static readonly ActivitySource s_activitySource = new(s_namespace);

    private const string EnableDiagnosticsSwitch = "Microsoft.SemanticKernel.Experimental.GenAI.EnableOTelDiagnostics";
    private const string EnableSensitiveEventsSwitch = "Microsoft.SemanticKernel.Experimental.GenAI.EnableOTelDiagnosticsSensitive";
    private const string EnableDiagnosticsEnvVar = "SEMANTICKERNEL_EXPERIMENTAL_GENAI_ENABLE_OTEL_DIAGNOSTICS";
    private const string EnableSensitiveEventsEnvVar = "SEMANTICKERNEL_EXPERIMENTAL_GENAI_ENABLE_OTEL_DIAGNOSTICS_SENSITIVE";

    private static readonly bool s_enableDiagnostics = AppContextSwitchHelper.GetConfigValue(EnableDiagnosticsSwitch, EnableDiagnosticsEnvVar);
    private static readonly bool s_enableSensitiveEvents = AppContextSwitchHelper.GetConfigValue(EnableSensitiveEventsSwitch, EnableSensitiveEventsEnvVar);

    /// <summary>
    /// Start a text completion activity for a given model.
    /// The activity will be tagged with the a set of attributes specified by the semantic conventions.
    /// </summary>
    [RequiresUnreferencedCode("Calls System.Text.Json.JsonSerializer.Serialize<TValue>(TValue, JsonSerializerOptions)")]
    [RequiresDynamicCode("Calls System.Text.Json.JsonSerializer.Serialize<TValue>(TValue, JsonSerializerOptions)")]
    internal static Activity? StartCompletionActivity<TPromptExecutionSettings>(
        Uri? endpoint,
        string modelName,
        string modelProvider,
        string prompt,
        TPromptExecutionSettings? executionSettings) where TPromptExecutionSettings : PromptExecutionSettings
    {
        if (!IsModelDiagnosticsEnabled())
        {
            return null;
        }

        const string OperationName = "text_completion";
        var activity = s_activitySource.StartActivityWithTags(
            $"{OperationName} {modelName}",
            [
                new(ModelDiagnosticsTags.Operation, OperationName),
                new(ModelDiagnosticsTags.System, modelProvider),
                new(ModelDiagnosticsTags.Model, modelName),
            ],
            ActivityKind.Client);

        if (endpoint is not null)
        {
            activity?.SetTags([
                // Skip the query string in the uri as it may contain keys
                new(ModelDiagnosticsTags.Address, endpoint.GetLeftPart(UriPartial.Path)),
                new(ModelDiagnosticsTags.Port, endpoint.Port),
            ]);
        }

        AddOptionalTags(activity, executionSettings);

        if (s_enableSensitiveEvents)
        {
            activity?.AttachSensitiveDataAsEvent(
                ModelDiagnosticsTags.UserMessage,
                [
                    new(ModelDiagnosticsTags.EventName, prompt),
                    new(ModelDiagnosticsTags.System, modelProvider),
                ]);
        }

        return activity;
    }

    /// <summary>
    /// Start a chat completion activity for a given model.
    /// The activity will be tagged with the a set of attributes specified by the semantic conventions.
    /// </summary>
    [RequiresUnreferencedCode("Calls System.Text.Json.JsonSerializer.Serialize<TValue>(TValue, JsonSerializerOptions)")]
    [RequiresDynamicCode("Calls System.Text.Json.JsonSerializer.Serialize<TValue>(TValue, JsonSerializerOptions)")]
    internal static Activity? StartCompletionActivity<TPromptExecutionSettings>(
        Uri? endpoint,
        string modelName,
        string modelProvider,
        ChatHistory chatHistory,
        TPromptExecutionSettings? executionSettings) where TPromptExecutionSettings : PromptExecutionSettings
    {
        if (!IsModelDiagnosticsEnabled())
        {
            return null;
        }

        const string OperationName = "chat";
        var activity = s_activitySource.StartActivityWithTags(
            $"{OperationName} {modelName}",
            [
                new(ModelDiagnosticsTags.Operation, OperationName),
                new(ModelDiagnosticsTags.System, modelProvider),
                new(ModelDiagnosticsTags.Model, modelName),
            ],
            ActivityKind.Client);

        if (endpoint is not null)
        {
            activity?.SetTags([
                // Skip the query string in the uri as it may contain keys
                new(ModelDiagnosticsTags.Address, endpoint.GetLeftPart(UriPartial.Path)),
                new(ModelDiagnosticsTags.Port, endpoint.Port),
            ]);
        }

        AddOptionalTags(activity, executionSettings);

        if (s_enableSensitiveEvents)
        {
            foreach (var message in chatHistory)
            {
                var formattedContent = JsonSerializer.Serialize(ToGenAIConventionsFormat(message));
                activity?.AttachSensitiveDataAsEvent(
                    ModelDiagnosticsTags.RoleToEventMap[message.Role],
                    [
                        new(ModelDiagnosticsTags.EventName, formattedContent),
                        new(ModelDiagnosticsTags.System, modelProvider),
                    ]);
            }
        }

        return activity;
    }

    /// <summary>
    /// Start an agent invocation activity and return the activity.
    /// </summary>
    [RequiresUnreferencedCode("Calls System.Text.Json.JsonSerializer.Serialize<TValue>(TValue, JsonSerializerOptions)")]
    [RequiresDynamicCode("Calls System.Text.Json.JsonSerializer.Serialize<TValue>(TValue, JsonSerializerOptions)")]
    internal static Activity? StartAgentInvocationActivity(
        string agentId,
        string agentName,
        string? agentDescription,
        Kernel? kernel,
        ICollection<ChatMessageContent> messages)
    {
        if (!IsModelDiagnosticsEnabled())
        {
            return null;
        }

        const string OperationName = "invoke_agent";

        var activity = s_activitySource.StartActivityWithTags(
            $"{OperationName} {agentName}",
            [
                new(ModelDiagnosticsTags.Operation, OperationName),
                new(ModelDiagnosticsTags.AgentId, agentId),
                new(ModelDiagnosticsTags.AgentName, agentName)
            ],
            ActivityKind.Internal);

        if (!string.IsNullOrWhiteSpace(agentDescription))
        {
            activity?.SetTag(ModelDiagnosticsTags.AgentDescription, agentDescription);
        }

        if (kernel is not null && kernel.Plugins.Count > 0)
        {
            activity?.SetTag(
                ModelDiagnosticsTags.AgentToolDefinitions,
                JsonSerializer.Serialize(kernel.Plugins.GetFunctionsMetadata().Select(m => ToGenAIConventionsFormat(m))));
        }

        if (IsSensitiveEventsEnabled())
        {
            activity?.SetTag(
                ModelDiagnosticsTags.AgentInvocationInput,
                JsonSerializer.Serialize(messages.Select(m => ToGenAIConventionsFormat(m))));
        }

        return activity;
    }

    /// <summary>
    /// Set the agent response for a given activity.
    /// </summary>
    [RequiresUnreferencedCode("Calls System.Text.Json.JsonSerializer.Serialize<TValue>(TValue, JsonSerializerOptions)")]
    [RequiresDynamicCode("Calls System.Text.Json.JsonSerializer.Serialize<TValue>(TValue, JsonSerializerOptions)")]
    internal static void SetAgentResponse(this Activity activity, IEnumerable<ChatMessageContent>? responses)
    {
        if (!IsModelDiagnosticsEnabled() || responses is null)
        {
            return;
        }

        if (s_enableSensitiveEvents)
        {
            activity?.SetTag(
                ModelDiagnosticsTags.AgentInvocationOutput,
                JsonSerializer.Serialize(responses.Select(r => ToGenAIConventionsFormat(r))));
        }
    }

    /// <summary>
    /// End the agent streaming response for a given activity.
    /// </summary>
    [RequiresUnreferencedCode("Calls System.Text.Json.JsonSerializer.Serialize<TValue>(TValue, JsonSerializerOptions)")]
    [RequiresDynamicCode("Calls System.Text.Json.JsonSerializer.Serialize<TValue>(TValue, JsonSerializerOptions)")]
    internal static void EndAgentStreamingResponse(
        this Activity activity,
        IEnumerable<StreamingChatMessageContent>? contents)
    {
        if (!IsModelDiagnosticsEnabled() || contents is null)
        {
            return;
        }

        Dictionary<int, List<StreamingKernelContent>> choices = [];
        foreach (var content in contents)
        {
            if (!choices.TryGetValue(content.ChoiceIndex, out var choiceContents))
            {
                choiceContents = [];
                choices[content.ChoiceIndex] = choiceContents;
            }

            choiceContents.Add(content);
        }

        var chatCompletions = choices.Select(choiceContents =>
            {
                var lastContent = (StreamingChatMessageContent)choiceContents.Value.Last();
                var chatMessage = choiceContents.Value.Select(c => c.ToString()).Aggregate((a, b) => a + b);
                return new ChatMessageContent(lastContent.Role ?? AuthorRole.Assistant, chatMessage, metadata: lastContent.Metadata);
            }).ToList();

        activity?.SetTag(
            ModelDiagnosticsTags.AgentInvocationOutput,
            JsonSerializer.Serialize(chatCompletions.Select(r => ToGenAIConventionsFormat(r))));
    }

    /// <summary>
    /// Set the text completion response for a given activity.
    /// The activity will be enriched with the response attributes specified by the semantic conventions.
    /// </summary>
    [RequiresUnreferencedCode("Calls System.Text.Json.JsonSerializer.Serialize<TValue>(TValue, JsonSerializerOptions)")]
    [RequiresDynamicCode("Calls System.Text.Json.JsonSerializer.Serialize<TValue>(TValue, JsonSerializerOptions)")]
    internal static void SetCompletionResponse(this Activity activity, IEnumerable<TextContent> completions, int? promptTokens = null, int? completionTokens = null)
        => SetCompletionResponse(activity, completions, promptTokens, completionTokens, ToGenAIConventionsChoiceFormat);

    /// <summary>
    /// Set the chat completion response for a given activity.
    /// The activity will be enriched with the response attributes specified by the semantic conventions.
    /// </summary>
    [RequiresUnreferencedCode("Calls System.Text.Json.JsonSerializer.Serialize<TValue>(TValue, JsonSerializerOptions)")]
    [RequiresDynamicCode("Calls System.Text.Json.JsonSerializer.Serialize<TValue>(TValue, JsonSerializerOptions)")]
    internal static void SetCompletionResponse(this Activity activity, IEnumerable<ChatMessageContent> completions, int? promptTokens = null, int? completionTokens = null)
        => SetCompletionResponse(activity, completions, promptTokens, completionTokens, ToGenAIConventionsChoiceFormat);

    /// <summary>
    /// Notify the end of streaming for a given activity.
    /// </summary>
    [RequiresUnreferencedCode("Calls System.Text.Json.JsonSerializer.Serialize<TValue>(TValue, JsonSerializerOptions)")]
    [RequiresDynamicCode("Calls System.Text.Json.JsonSerializer.Serialize<TValue>(TValue, JsonSerializerOptions)")]
    internal static void EndStreaming(
        this Activity activity,
        IEnumerable<StreamingKernelContent>? contents,
        IEnumerable<FunctionCallContent>? toolCalls = null,
        int? promptTokens = null,
        int? completionTokens = null)
    {
        if (IsModelDiagnosticsEnabled())
        {
            var choices = OrganizeStreamingContent(contents);
            SetCompletionResponse(activity, choices, toolCalls, promptTokens, completionTokens);
        }
    }

    /// <summary>
    /// Set the response id for a given activity.
    /// </summary>
    /// <param name="activity">The activity to set the response id</param>
    /// <param name="responseId">The response id</param>
    /// <returns>The activity with the response id set for chaining</returns>
    internal static Activity SetResponseId(this Activity activity, string responseId) => activity.SetTag(ModelDiagnosticsTags.ResponseId, responseId);

    /// <summary>
    /// Set the input tokens usage for a given activity.
    /// </summary>
    /// <param name="activity">The activity to set the input tokens usage</param>
    /// <param name="inputTokens">The number of input tokens used</param>
    /// <returns>The activity with the input tokens usage set for chaining</returns>
    internal static Activity SetInputTokensUsage(this Activity activity, int inputTokens) => activity.SetTag(ModelDiagnosticsTags.InputTokens, inputTokens);

    /// <summary>
    /// Set the output tokens usage for a given activity.
    /// </summary>
    /// <param name="activity">The activity to set the output tokens usage</param>
    /// <param name="outputTokens">The number of output tokens used</param>
    /// <returns>The activity with the output tokens usage set for chaining</returns>
    internal static Activity SetOutputTokensUsage(this Activity activity, int outputTokens) => activity.SetTag(ModelDiagnosticsTags.OutputTokens, outputTokens);

    /// <summary>
    /// Check if model diagnostics is enabled
    /// Model diagnostics is enabled if either EnableModelDiagnostics or EnableSensitiveEvents is set to true and there are listeners.
    /// </summary>
    internal static bool IsModelDiagnosticsEnabled()
    {
        return (s_enableDiagnostics || s_enableSensitiveEvents) && s_activitySource.HasListeners();
    }

    /// <summary>
    /// Check if sensitive events are enabled.
    /// Sensitive events are enabled if EnableSensitiveEvents is set to true and there are listeners.
    /// </summary>
    internal static bool IsSensitiveEventsEnabled() => s_enableSensitiveEvents && s_activitySource.HasListeners();

    internal static bool HasListeners() => s_activitySource.HasListeners();

    #region Private
    [RequiresUnreferencedCode("Calls System.Text.Json.JsonSerializer.Serialize<TValue>(TValue, JsonSerializerOptions)")]
    [RequiresDynamicCode("Calls System.Text.Json.JsonSerializer.Serialize<TValue>(TValue, JsonSerializerOptions)")]
    private static void AddOptionalTags<TPromptExecutionSettings>(Activity? activity, TPromptExecutionSettings? executionSettings)
        where TPromptExecutionSettings : PromptExecutionSettings
    {
        if (activity is null || executionSettings is null)
        {
            return;
        }

        // Serialize and deserialize the execution settings to get the extension data
        var deserializedSettings = JsonSerializer.Deserialize<PromptExecutionSettings>(JsonSerializer.Serialize(executionSettings));
        if (deserializedSettings is null || deserializedSettings.ExtensionData is null)
        {
            return;
        }

        void TryAddTag(string key, string tag)
        {
            if (deserializedSettings.ExtensionData.TryGetValue(key, out var value))
            {
                activity.SetTag(tag, value);
            }
        }

        TryAddTag("max_tokens", ModelDiagnosticsTags.MaxToken);
        TryAddTag("temperature", ModelDiagnosticsTags.Temperature);
        TryAddTag("top_p", ModelDiagnosticsTags.TopP);
    }

    /// <summary>
    /// Convert a chat message to a JSON object based on the OTel GenAI Semantic Conventions format
    /// </summary>
    private static object ToGenAIConventionsFormat(ChatMessageContent chatMessage)
    {
        return new
        {
            role = chatMessage.Role.ToString(),
            name = chatMessage.AuthorName,
            content = chatMessage.Content,
            tool_calls = ToGenAIConventionsFormat(chatMessage.Items),
        };
    }

    /// <summary>
    /// Helper method to convert tool calls to a list of JSON object based on the OTel GenAI Semantic Conventions format
    /// </summary>
    private static List<object> ToGenAIConventionsFormat(ChatMessageContentItemCollection chatMessageContentItems)
    {
        return chatMessageContentItems.OfType<FunctionCallContent>().Select(functionCall => (object)new
        {
            id = functionCall.Id,
            function = new
            {
                name = functionCall.FunctionName,
                arguments = functionCall.Arguments
            },
            type = "function"
        }).ToList();
    }

    /// <summary>
    /// Convert a function metadata to a JSON object based on the OTel GenAI Semantic Conventions format
    /// </summary>
    private static object ToGenAIConventionsFormat(KernelFunctionMetadata metadata)
    {
        var properties = new Dictionary<string, KernelJsonSchema>();
        var required = new List<string>();

        foreach (var param in metadata.Parameters)
        {
            if (param.Schema is not null)
            {
                properties[param.Name] = param.Schema;
            }
            if (param.IsRequired)
            {
                required.Add(param.Name);
            }
        }

        return new
        {
            type = "function",
            name = metadata.Name,
            description = metadata.Description,
            parameters = new
            {
                type = "object",
                properties,
                required,
            }
        };
    }

    /// <summary>
    /// Convert a chat model response to a JSON string based on the OTel GenAI Semantic Conventions format
    /// </summary>
    [RequiresUnreferencedCode("Calls System.Text.Json.JsonSerializer.Serialize<TValue>(TValue, JsonSerializerOptions)")]
    [RequiresDynamicCode("Calls System.Text.Json.JsonSerializer.Serialize<TValue>(TValue, JsonSerializerOptions)")]
    private static string ToGenAIConventionsChoiceFormat(ChatMessageContent chatMessage, int index)
    {
        var jsonObject = new
        {
            index,
            message = ToGenAIConventionsFormat(chatMessage),
            tool_calls = ToGenAIConventionsFormat(chatMessage.Items),
            finish_reason = chatMessage.Metadata?.TryGetValue("FinishReason", out var finishReason) == true ? finishReason : null
        };

        return JsonSerializer.Serialize(jsonObject);
    }

    /// <summary>
    /// Convert a text model response to a JSON string based on the OTel GenAI Semantic Conventions format
    /// </summary>
    [RequiresUnreferencedCode("Calls System.Text.Json.JsonSerializer.Serialize<TValue>(TValue, JsonSerializerOptions)")]
    [RequiresDynamicCode("Calls System.Text.Json.JsonSerializer.Serialize<TValue>(TValue, JsonSerializerOptions)")]
    private static string ToGenAIConventionsChoiceFormat(TextContent textContent, int index)
    {
        var jsonObject = new
        {
            index,
            message = textContent.Text,
            finish_reason = textContent.Metadata?.TryGetValue("FinishReason", out var finishReason) == true ? finishReason : null
        };

        return JsonSerializer.Serialize(jsonObject);
    }

    /// <summary>
    /// Set the completion response for a given activity.
    /// The `formatCompletions` delegate won't be invoked if events are disabled.
    /// </summary>
    private static void SetCompletionResponse<T>(
        Activity activity,
        IEnumerable<T> completions,
        int? inputTokens,
        int? outputTokens,
        Func<T, int, string> formatCompletion) where T : KernelContent
    {
        if (!IsModelDiagnosticsEnabled())
        {
            return;
        }

        if (inputTokens != null)
        {
            activity.SetTag(ModelDiagnosticsTags.InputTokens, inputTokens);
        }

        if (outputTokens != null)
        {
            activity.SetTag(ModelDiagnosticsTags.OutputTokens, outputTokens);
        }

        activity.SetFinishReasons(completions);

        if (s_enableSensitiveEvents)
        {
            bool responseIdSet = false;
            int index = 0;
            foreach (var completion in completions)
            {
                if (!responseIdSet)
                {
                    activity.SetResponseId(completion);
                    responseIdSet = true;
                }

                var formattedContent = formatCompletion(completion, index++);
                activity.AttachSensitiveDataAsEvent(
                    ModelDiagnosticsTags.Choice,
                    [
                        new(ModelDiagnosticsTags.EventName, formattedContent),
                    ]);
            }
        }
        else
        {
            activity.SetResponseId(completions.FirstOrDefault());
        }
    }

    /// <summary>
    /// Set the streaming completion response for a given activity.
    /// </summary>
    [RequiresUnreferencedCode("Calls System.Text.Json.JsonSerializer.Serialize<TValue>(TValue, JsonSerializerOptions)")]
    [RequiresDynamicCode("Calls System.Text.Json.JsonSerializer.Serialize<TValue>(TValue, JsonSerializerOptions)")]
    private static void SetCompletionResponse(
        Activity activity,
        Dictionary<int, List<StreamingKernelContent>> choices,
        IEnumerable<FunctionCallContent>? toolCalls,
        int? promptTokens,
        int? completionTokens)
    {
        if (!IsModelDiagnosticsEnabled() || choices.Count == 0)
        {
            return;
        }

        // Assuming all metadata is in the last chunk of the choice
        switch (choices.FirstOrDefault().Value?.FirstOrDefault())
        {
            case StreamingTextContent:
                var textCompletions = choices.Select(choiceContents =>
                    {
                        var lastContent = (StreamingTextContent)choiceContents.Value.Last();
                        var text = choiceContents.Value.Select(c => c.ToString()).Aggregate((a, b) => a + b);
                        return new TextContent(text, metadata: lastContent.Metadata);
                    }).ToList();
                SetCompletionResponse(activity, textCompletions, promptTokens, completionTokens);
                break;
            case StreamingChatMessageContent:
                var chatCompletions = choices.Select(choiceContents =>
                {
                    var lastContent = (StreamingChatMessageContent)choiceContents.Value.Last();
                    var chatMessage = choiceContents.Value.Select(c => c.ToString()).Aggregate((a, b) => a + b);
                    return new ChatMessageContent(lastContent.Role ?? AuthorRole.Assistant, chatMessage, metadata: lastContent.Metadata);
                }).ToList();
                // It's currently not allowed to request multiple results per prompt while auto-invoke is enabled.
                // Therefore, we can assume that there is only one completion per prompt when tool calls are present.
                foreach (var functionCall in toolCalls ?? [])
                {
                    chatCompletions.FirstOrDefault()?.Items.Add(functionCall);
                }
                SetCompletionResponse(activity, chatCompletions, promptTokens, completionTokens);
                break;
        }
    }

    // Returns an activity for chaining
    private static Activity SetFinishReasons(this Activity activity, IEnumerable<KernelContent> completions)
    {
        var finishReasons = completions.Select(c =>
        {
            if (c.Metadata?.TryGetValue("FinishReason", out var finishReason) == true && !string.IsNullOrEmpty(finishReason as string))
            {
                return finishReason;
            }

            return "N/A";
        });

        if (finishReasons.Any())
        {
            activity.SetTag(ModelDiagnosticsTags.FinishReason, $"[{string.Join(",",
                finishReasons.Select(finishReason => $"\"{finishReason}\""))}]");
        }

        return activity;
    }

    // Returns an activity for chaining
    private static Activity SetResponseId(this Activity activity, KernelContent? completion)
    {
        if (completion?.Metadata?.TryGetValue("Id", out var id) == true && !string.IsNullOrEmpty(id as string))
        {
            activity.SetTag(ModelDiagnosticsTags.ResponseId, id);
        }

        return activity;
    }

    /// <summary>
    /// Organize streaming content by choice index
    /// </summary>
    private static Dictionary<int, List<StreamingKernelContent>> OrganizeStreamingContent(IEnumerable<StreamingKernelContent>? contents)
    {
        Dictionary<int, List<StreamingKernelContent>> choices = [];
        if (contents is null)
        {
            return choices;
        }

        foreach (var content in contents)
        {
            if (!choices.TryGetValue(content.ChoiceIndex, out var choiceContents))
            {
                choiceContents = [];
                choices[content.ChoiceIndex] = choiceContents;
            }

            choiceContents.Add(content);
        }

        return choices;
    }

    /// <summary>
    /// Tags used in model diagnostics
    /// </summary>
    private static class ModelDiagnosticsTags
    {
        // Activity tags
        public const string System = "gen_ai.system";
        public const string Operation = "gen_ai.operation.name";
        public const string Model = "gen_ai.request.model";
        public const string MaxToken = "gen_ai.request.max_tokens";
        public const string Temperature = "gen_ai.request.temperature";
        public const string TopP = "gen_ai.request.top_p";
        public const string ResponseId = "gen_ai.response.id";
        public const string ResponseModel = "gen_ai.response.model";
        public const string FinishReason = "gen_ai.response.finish_reason";
        public const string InputTokens = "gen_ai.usage.input_tokens";
        public const string OutputTokens = "gen_ai.usage.output_tokens";
        public const string Address = "server.address";
        public const string Port = "server.port";
        public const string AgentId = "gen_ai.agent.id";
        public const string AgentName = "gen_ai.agent.name";
        public const string AgentDescription = "gen_ai.agent.description";
        public const string AgentInvocationInput = "gen_ai.input.messages";
        public const string AgentInvocationOutput = "gen_ai.output.messages";
        public const string AgentToolDefinitions = "gen_ai.tool.definitions";

        // Activity events
        public const string EventName = "gen_ai.event.content";
        public const string SystemMessage = "gen_ai.system.message";
        public const string UserMessage = "gen_ai.user.message";
        public const string AssistantMessage = "gen_ai.assistant.message";
        public const string ToolMessage = "gen_ai.tool.message";
        public const string DeveloperMessage = "gen_ai.tool.developer";
        public const string Choice = "gen_ai.choice";
        public static readonly Dictionary<AuthorRole, string> RoleToEventMap = new()
            {
                { AuthorRole.System, SystemMessage },
                { AuthorRole.User, UserMessage },
                { AuthorRole.Assistant, AssistantMessage },
                { AuthorRole.Tool, ToolMessage },
                { AuthorRole.Developer, DeveloperMessage }
            };
    }
    # endregion
}


===== src\Diagnostics\NullableAttributes.cs =====

// Copyright (c) Microsoft. All rights reserved.

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

// This was copied from https://github.com/dotnet/runtime/blob/39b9607807f29e48cae4652cd74735182b31182e/src/libraries/System.Private.CoreLib/src/System/Diagnostics/CodeAnalysis/NullableAttributes.cs
// and updated to have the scope of the attributes be internal.

#if !NETCOREAPP
namespace System.Diagnostics.CodeAnalysis;

/// <summary>Specifies that null is allowed as an input even if the corresponding type disallows it.</summary>
[AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property, Inherited = false)]
internal sealed class AllowNullAttribute : Attribute
{
}

/// <summary>Specifies that null is disallowed as an input even if the corresponding type allows it.</summary>
[AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property, Inherited = false)]
internal sealed class DisallowNullAttribute : Attribute
{
}

/// <summary>Specifies that an output may be null even if the corresponding type disallows it.</summary>
[AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue, Inherited = false)]
internal sealed class MaybeNullAttribute : Attribute
{
}

/// <summary>Specifies that an output will not be null even if the corresponding type allows it.</summary>
[AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue, Inherited = false)]
internal sealed class NotNullAttribute : Attribute
{
}

/// <summary>Specifies that when a method returns <see cref="ReturnValue"/>, the parameter may be null even if the corresponding type disallows it.</summary>
[ExcludeFromCodeCoverage]
[AttributeUsage(AttributeTargets.Parameter, Inherited = false)]
internal sealed class MaybeNullWhenAttribute : Attribute
{
    /// <summary>Initializes the attribute with the specified return value condition.</summary>
    /// <param name="returnValue">
    /// The return value condition. If the method returns this value, the associated parameter may be null.
    /// </param>
    public MaybeNullWhenAttribute(bool returnValue) => this.ReturnValue = returnValue;

    /// <summary>Gets the return value condition.</summary>
    public bool ReturnValue { get; }
}

/// <summary>Specifies that when a method returns <see cref="ReturnValue"/>, the parameter will not be null even if the corresponding type allows it.</summary>
[ExcludeFromCodeCoverage]
[AttributeUsage(AttributeTargets.Parameter, Inherited = false)]
internal sealed class NotNullWhenAttribute : Attribute
{
    /// <summary>Initializes the attribute with the specified return value condition.</summary>
    /// <param name="returnValue">
    /// The return value condition. If the method returns this value, the associated parameter will not be null.
    /// </param>
    public NotNullWhenAttribute(bool returnValue) => this.ReturnValue = returnValue;

    /// <summary>Gets the return value condition.</summary>
    public bool ReturnValue { get; }
}

/// <summary>Specifies that the output will be non-null if the named parameter is non-null.</summary>
[ExcludeFromCodeCoverage]
[AttributeUsage(AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue, AllowMultiple = true, Inherited = false)]
internal sealed class NotNullIfNotNullAttribute : Attribute
{
    /// <summary>Initializes the attribute with the associated parameter name.</summary>
    /// <param name="parameterName">
    /// The associated parameter name.  The output will be non-null if the argument to the parameter specified is non-null.
    /// </param>
    public NotNullIfNotNullAttribute(string parameterName) => this.ParameterName = parameterName;

    /// <summary>Gets the associated parameter name.</summary>
    public string ParameterName { get; }
}

/// <summary>Applied to a method that will never return under any circumstance.</summary>
[AttributeUsage(AttributeTargets.Method, Inherited = false)]
internal sealed class DoesNotReturnAttribute : Attribute
{
}

/// <summary>Specifies that the method will not return if the associated Boolean parameter is passed the specified value.</summary>
[ExcludeFromCodeCoverage]
[AttributeUsage(AttributeTargets.Parameter, Inherited = false)]
internal sealed class DoesNotReturnIfAttribute : Attribute
{
    /// <summary>Initializes the attribute with the specified parameter value.</summary>
    /// <param name="parameterValue">
    /// The condition parameter value. Code after the method will be considered unreachable by diagnostics if the argument to
    /// the associated parameter matches this value.
    /// </param>
    public DoesNotReturnIfAttribute(bool parameterValue) => this.ParameterValue = parameterValue;

    /// <summary>Gets the condition parameter value.</summary>
    public bool ParameterValue { get; }
}

#endif

#if !NETCOREAPP || NETCOREAPP3_1

/// <summary>Specifies that the method or property will ensure that the listed field and property members have not-null values.</summary>
[ExcludeFromCodeCoverage]
[AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, Inherited = false, AllowMultiple = true)]
internal sealed class MemberNotNullAttribute : Attribute
{
    /// <summary>Initializes the attribute with a field or property member.</summary>
    /// <param name="member">
    /// The field or property member that is promised to be not-null.
    /// </param>
    [SuppressMessage("Design", "CA1019:Define accessors for attribute arguments")]
    public MemberNotNullAttribute(string member) => this.Members = [member];

    /// <summary>Initializes the attribute with the list of field and property members.</summary>
    /// <param name="members">
    /// The list of field and property members that are promised to be not-null.
    /// </param>
    public MemberNotNullAttribute(params string[] members) => this.Members = members;

    /// <summary>Gets field or property member names.</summary>
    public string[] Members { get; }
}

/// <summary>Specifies that the method or property will ensure that the listed field and property members have not-null values when returning with the specified return value condition.</summary>
[ExcludeFromCodeCoverage]
[AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, Inherited = false, AllowMultiple = true)]
internal sealed class MemberNotNullWhenAttribute : Attribute
{
    /// <summary>Initializes the attribute with the specified return value condition and a field or property member.</summary>
    /// <param name="returnValue">
    /// The return value condition. If the method returns this value, the associated parameter will not be null.
    /// </param>
    /// <param name="member">
    /// The field or property member that is promised to be not-null.
    /// </param>
    [SuppressMessage("Design", "CA1019:Define accessors for attribute arguments")]
    public MemberNotNullWhenAttribute(bool returnValue, string member)
    {
        this.ReturnValue = returnValue;
        this.Members = [member];
    }

    /// <summary>Initializes the attribute with the specified return value condition and list of field and property members.</summary>
    /// <param name="returnValue">
    /// The return value condition. If the method returns this value, the associated parameter will not be null.
    /// </param>
    /// <param name="members">
    /// The list of field and property members that are promised to be not-null.
    /// </param>
    public MemberNotNullWhenAttribute(bool returnValue, params string[] members)
    {
        this.ReturnValue = returnValue;
        this.Members = members;
    }

    /// <summary>Gets the return value condition.</summary>
    public bool ReturnValue { get; }

    /// <summary>Gets field or property member names.</summary>
    public string[] Members { get; }
}

#endif


===== src\Diagnostics\RequiresDynamicCodeAttribute.cs =====

// Copyright (c) Microsoft. All rights reserved.

#if !NET7_0_OR_GREATER
namespace System.Diagnostics.CodeAnalysis;

/// <summary>
/// Polyfill for the RequiresDynamicCodeAttribute not available in .NET Standard 2.0.
/// Indicates that the specified method requires the ability to generate new code at runtime,
/// for example through <see cref="Reflection"/>.
/// </summary>
/// <remarks>
/// This allows tools to understand which methods are unsafe to call when compiling ahead of time.
/// </remarks>
[AttributeUsage(AttributeTargets.Method | AttributeTargets.Constructor | AttributeTargets.Class, Inherited = false)]
internal sealed class RequiresDynamicCodeAttribute : Attribute
{
    /// <summary>
    /// Initializes a new instance of the <see cref="RequiresDynamicCodeAttribute"/> class
    /// with the specified message.
    /// </summary>
    /// <param name="message">
    /// A message that contains information about the usage of dynamic code.
    /// </param>
    public RequiresDynamicCodeAttribute(string message)
    {
        this.Message = message;
    }

    /// <summary>
    /// Gets a message that contains information about the usage of dynamic code.
    /// </summary>
    public string Message { get; }

    /// <summary>
    /// Gets or sets an optional URL that contains more information about the method,
    /// why it requires dynamic code, and what options a consumer has to deal with it.
    /// </summary>
    public string? Url { get; set; }
}
#endif


===== src\Diagnostics\RequiresUnreferencedCodeAttribute.cs =====

// Copyright (c) Microsoft. All rights reserved.

#if !NET5_0_OR_GREATER
namespace System.Diagnostics.CodeAnalysis;

/// <summary>
/// Polyfill for the RequiresUnreferencedCodeAttribute not available in .NET Standard 2.0.
/// Indicates that the specified method requires dynamic access to code that is not referenced
/// statically, for example through <see cref="Reflection"/>.
/// </summary>
/// <remarks>
/// This allows tools to understand which methods are unsafe to call when removing unreferenced
/// code from an application.
/// </remarks>
[AttributeUsage(AttributeTargets.Method | AttributeTargets.Constructor | AttributeTargets.Class, Inherited = false)]
internal sealed class RequiresUnreferencedCodeAttribute : Attribute
{
    /// <summary>
    /// Initializes a new instance of the <see cref="RequiresUnreferencedCodeAttribute"/> class
    /// with the specified message.
    /// </summary>
    /// <param name="message">
    /// A message that contains information about the usage of unreferenced code.
    /// </param>
    public RequiresUnreferencedCodeAttribute(string message)
    {
        this.Message = message;
    }

    /// <summary>
    /// Gets a message that contains information about the usage of unreferenced code.
    /// </summary>
    public string Message { get; }

    /// <summary>
    /// Gets or sets an optional URL that contains more information about the method,
    /// why it requires unreferenced code, and what options a consumer has to deal with it.
    /// </summary>
    public string? Url { get; set; }
}
#endif


===== src\Diagnostics\Throw.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;

// Source Originally from: https://github.com/dotnet/extensions/blob/ef3f0a/src/Shared/Throw/Throw.cs

namespace Microsoft.SemanticKernel;

/// <summary>
/// Defines static methods used to throw exceptions.
/// </summary>
/// <remarks>
/// The main purpose is to reduce code size, improve performance, and standardize exception
/// messages.
/// </remarks>
[SuppressMessage("Minor Code Smell", "S4136:Method overloads should be grouped together", Justification = "Doesn't work with the region layout")]
[SuppressMessage("Minor Code Smell", "S2333:Partial is gratuitous in this context", Justification = "Some projects add additional partial parts.")]
[SuppressMessage("Design", "CA1716", Justification = "Not part of an API")]

[ExcludeFromCodeCoverage]
internal static partial class Throw
{
    #region For Object

    /// <summary>
    /// Throws an <see cref="System.ArgumentNullException"/> if the specified argument is <see langword="null"/>.
    /// </summary>
    /// <typeparam name="T">Argument type to be checked for <see langword="null"/>.</typeparam>
    /// <param name="argument">Object to be checked for <see langword="null"/>.</param>
    /// <param name="paramName">The name of the parameter being checked.</param>
    /// <returns>The original value of <paramref name="argument"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    [return: NotNull]
    public static T IfNull<T>([NotNull] T argument, [CallerArgumentExpression(nameof(argument))] string paramName = "")
    {
        if (argument is null)
        {
            ArgumentNullException(paramName);
        }

        return argument;
    }

    /// <summary>
    /// Throws an <see cref="System.ArgumentNullException"/> if the specified argument is <see langword="null"/>,
    /// or <see cref="System.ArgumentException" /> if the specified member is <see langword="null"/>.
    /// </summary>
    /// <typeparam name="TParameter">Argument type to be checked for <see langword="null"/>.</typeparam>
    /// <typeparam name="TMember">Member type to be checked for <see langword="null"/>.</typeparam>
    /// <param name="argument">Argument to be checked for <see langword="null"/>.</param>
    /// <param name="member">Object member to be checked for <see langword="null"/>.</param>
    /// <param name="paramName">The name of the parameter being checked.</param>
    /// <param name="memberName">The name of the member.</param>
    /// <returns>The original value of <paramref name="member"/>.</returns>
    /// <example>
    /// <code language="csharp">
    /// Throws.IfNullOrMemberNull(myObject, myObject?.MyProperty)
    /// </code>
    /// </example>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    [return: NotNull]
    public static TMember IfNullOrMemberNull<TParameter, TMember>(
        [NotNull] TParameter argument,
        [NotNull] TMember member,
        [CallerArgumentExpression(nameof(argument))] string paramName = "",
        [CallerArgumentExpression(nameof(member))] string memberName = "")
    {
        if (argument is null)
        {
            ArgumentNullException(paramName);
        }

        if (member is null)
        {
            ArgumentException(paramName, $"Member {memberName} of {paramName} is null");
        }

        return member;
    }

    /// <summary>
    /// Throws an <see cref="System.ArgumentException" /> if the specified member is <see langword="null"/>.
    /// </summary>
    /// <typeparam name="TParameter">Argument type.</typeparam>
    /// <typeparam name="TMember">Member type to be checked for <see langword="null"/>.</typeparam>
    /// <param name="argument">Argument to which member belongs.</param>
    /// <param name="member">Object member to be checked for <see langword="null"/>.</param>
    /// <param name="paramName">The name of the parameter being checked.</param>
    /// <param name="memberName">The name of the member.</param>
    /// <returns>The original value of <paramref name="member"/>.</returns>
    /// <example>
    /// <code language="csharp">
    /// Throws.IfMemberNull(myObject, myObject.MyProperty)
    /// </code>
    /// </example>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    [return: NotNull]
    [SuppressMessage("Style", "IDE0060:Remove unused parameter", Justification = "Analyzer isn't seeing the reference to 'argument' in the attribute")]
    public static TMember IfMemberNull<TParameter, TMember>(
        TParameter argument,
        [NotNull] TMember member,
        [CallerArgumentExpression(nameof(argument))] string paramName = "",
        [CallerArgumentExpression(nameof(member))] string memberName = "")
        where TParameter : notnull
    {
        if (member is null)
        {
            ArgumentException(paramName, $"Member {memberName} of {paramName} is null");
        }

        return member;
    }

    #endregion

    #region For String

    /// <summary>
    /// Throws either an <see cref="System.ArgumentNullException"/> or an <see cref="System.ArgumentException"/>
    /// if the specified string is <see langword="null"/> or whitespace respectively.
    /// </summary>
    /// <param name="argument">String to be checked for <see langword="null"/> or whitespace.</param>
    /// <param name="paramName">The name of the parameter being checked.</param>
    /// <returns>The original value of <paramref name="argument"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    [return: NotNull]
    public static string IfNullOrWhitespace([NotNull] string? argument, [CallerArgumentExpression(nameof(argument))] string paramName = "")
    {
#if !NETCOREAPP3_1_OR_GREATER
        if (argument == null)
        {
            ArgumentNullException(paramName);
        }
#endif

        if (string.IsNullOrWhiteSpace(argument))
        {
            if (argument == null)
            {
                ArgumentNullException(paramName);
            }
            else
            {
                ArgumentException(paramName, "Argument is whitespace");
            }
        }

        return argument;
    }

    /// <summary>
    /// Throws an <see cref="System.ArgumentNullException"/> if the string is <see langword="null"/>,
    /// or <see cref="System.ArgumentException"/> if it is empty.
    /// </summary>
    /// <param name="argument">String to be checked for <see langword="null"/> or empty.</param>
    /// <param name="paramName">The name of the parameter being checked.</param>
    /// <returns>The original value of <paramref name="argument"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    [return: NotNull]
    public static string IfNullOrEmpty([NotNull] string? argument, [CallerArgumentExpression(nameof(argument))] string paramName = "")
    {
#if !NETCOREAPP3_1_OR_GREATER
        if (argument == null)
        {
            ArgumentNullException(paramName);
        }
#endif

        if (string.IsNullOrEmpty(argument))
        {
            if (argument == null)
            {
                ArgumentNullException(paramName);
            }
            else
            {
                ArgumentException(paramName, "Argument is an empty string");
            }
        }

        return argument;
    }

    #endregion

    #region For Buffer

    /// <summary>
    /// Throws an <see cref="System.ArgumentException"/> if the argument's buffer size is less than the required buffer size.
    /// </summary>
    /// <param name="bufferSize">The actual buffer size.</param>
    /// <param name="requiredSize">The required buffer size.</param>
    /// <param name="paramName">The name of the parameter to be checked.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void IfBufferTooSmall(int bufferSize, int requiredSize, string paramName = "")
    {
        if (bufferSize < requiredSize)
        {
            ArgumentException(paramName, $"Buffer too small, needed a size of {requiredSize} but got {bufferSize}");
        }
    }

    #endregion

    #region For Enums

    /// <summary>
    /// Throws an <see cref="System.ArgumentOutOfRangeException"/> if the enum value is not valid.
    /// </summary>
    /// <param name="argument">The argument to evaluate.</param>
    /// <param name="paramName">The name of the parameter being checked.</param>
    /// <typeparam name="T">The type of the enumeration.</typeparam>
    /// <returns>The original value of <paramref name="argument"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T IfOutOfRange<T>(T argument, [CallerArgumentExpression(nameof(argument))] string paramName = "")
        where T : struct, Enum
    {
#if NET5_0_OR_GREATER
        if (!Enum.IsDefined<T>(argument))
#else
        if (!Enum.IsDefined(typeof(T), argument))
#endif
        {
            ArgumentOutOfRangeException(paramName, $"{argument} is an invalid value for enum type {typeof(T)}");
        }

        return argument;
    }

    #endregion

    #region For Collections

    /// <summary>
    /// Throws an <see cref="System.ArgumentNullException"/> if the collection is <see langword="null"/>,
    /// or <see cref="System.ArgumentException"/> if it is empty.
    /// </summary>
    /// <param name="argument">The collection to evaluate.</param>
    /// <param name="paramName">The name of the parameter being checked.</param>
    /// <typeparam name="T">The type of objects in the collection.</typeparam>
    /// <returns>The original value of <paramref name="argument"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    [return: NotNull]

    // The method has actually 100% coverage, but due to a bug in the code coverage tool,
    // a lower number is reported. Therefore, we temporarily exclude this method
    // from the coverage measurements. Once the bug in the code coverage tool is fixed,
    // the exclusion attribute can be removed.
    [ExcludeFromCodeCoverage]
    public static IEnumerable<T> IfNullOrEmpty<T>([NotNull] IEnumerable<T>? argument, [CallerArgumentExpression(nameof(argument))] string paramName = "")
    {
        if (argument == null)
        {
            ArgumentNullException(paramName);
        }
        else
        {
            switch (argument)
            {
                case ICollection<T> collection:
                    if (collection.Count == 0)
                    {
                        ArgumentException(paramName, "Collection is empty");
                    }

                    break;
                case IReadOnlyCollection<T> readOnlyCollection:
                    if (readOnlyCollection.Count == 0)
                    {
                        ArgumentException(paramName, "Collection is empty");
                    }

                    break;
                default:
                    using (IEnumerator<T> enumerator = argument.GetEnumerator())
                    {
                        if (!enumerator.MoveNext())
                        {
                            ArgumentException(paramName, "Collection is empty");
                        }
                    }

                    break;
            }
        }

        return argument;
    }

    #endregion

    #region Exceptions

    /// <summary>
    /// Throws an <see cref="System.ArgumentNullException"/>.
    /// </summary>
    /// <param name="paramName">The name of the parameter that caused the exception.</param>
#if !NET6_0_OR_GREATER
    [MethodImpl(MethodImplOptions.NoInlining)]
#endif
    [DoesNotReturn]
    public static void ArgumentNullException(string paramName)
        => throw new ArgumentNullException(paramName);

    /// <summary>
    /// Throws an <see cref="System.ArgumentNullException"/>.
    /// </summary>
    /// <param name="paramName">The name of the parameter that caused the exception.</param>
    /// <param name="message">A message that describes the error.</param>
#if !NET6_0_OR_GREATER
    [MethodImpl(MethodImplOptions.NoInlining)]
#endif
    [DoesNotReturn]
    public static void ArgumentNullException(string paramName, string? message)
        => throw new ArgumentNullException(paramName, message);

    /// <summary>
    /// Throws an <see cref="System.ArgumentOutOfRangeException"/>.
    /// </summary>
    /// <param name="paramName">The name of the parameter that caused the exception.</param>
#if !NET6_0_OR_GREATER
    [MethodImpl(MethodImplOptions.NoInlining)]
#endif
    [DoesNotReturn]
    public static void ArgumentOutOfRangeException(string paramName)
        => throw new ArgumentOutOfRangeException(paramName);

    /// <summary>
    /// Throws an <see cref="System.ArgumentOutOfRangeException"/>.
    /// </summary>
    /// <param name="paramName">The name of the parameter that caused the exception.</param>
    /// <param name="message">A message that describes the error.</param>
#if !NET6_0_OR_GREATER
    [MethodImpl(MethodImplOptions.NoInlining)]
#endif
    [DoesNotReturn]
    public static void ArgumentOutOfRangeException(string paramName, string? message)
        => throw new ArgumentOutOfRangeException(paramName, message);

    /// <summary>
    /// Throws an <see cref="System.ArgumentOutOfRangeException"/>.
    /// </summary>
    /// <param name="paramName">The name of the parameter that caused the exception.</param>
    /// <param name="actualValue">The value of the argument that caused this exception.</param>
    /// <param name="message">A message that describes the error.</param>
#if !NET6_0_OR_GREATER
    [MethodImpl(MethodImplOptions.NoInlining)]
#endif
    [DoesNotReturn]
    public static void ArgumentOutOfRangeException(string paramName, object? actualValue, string? message)
        => throw new ArgumentOutOfRangeException(paramName, actualValue, message);

    /// <summary>
    /// Throws an <see cref="System.ArgumentException"/>.
    /// </summary>
    /// <param name="paramName">The name of the parameter that caused the exception.</param>
    /// <param name="message">A message that describes the error.</param>
#if !NET6_0_OR_GREATER
    [MethodImpl(MethodImplOptions.NoInlining)]
#endif
    [DoesNotReturn]
    public static void ArgumentException(string paramName, string? message)
        => throw new ArgumentException(message, paramName);

    /// <summary>
    /// Throws an <see cref="System.ArgumentException"/>.
    /// </summary>
    /// <param name="paramName">The name of the parameter that caused the exception.</param>
    /// <param name="message">A message that describes the error.</param>
    /// <param name="innerException">The exception that is the cause of the current exception.</param>
    /// <remarks>
    /// If the <paramref name="innerException"/> is not a <see langword="null"/>, the current exception is raised in a catch
    /// block that handles the inner exception.
    /// </remarks>
#if !NET6_0_OR_GREATER
    [MethodImpl(MethodImplOptions.NoInlining)]
#endif
    [DoesNotReturn]
    public static void ArgumentException(string paramName, string? message, Exception? innerException)
        => throw new ArgumentException(message, paramName, innerException);

    /// <summary>
    /// Throws an <see cref="System.InvalidOperationException"/>.
    /// </summary>
    /// <param name="message">A message that describes the error.</param>
#if !NET6_0_OR_GREATER
    [MethodImpl(MethodImplOptions.NoInlining)]
#endif
    [DoesNotReturn]
    public static void InvalidOperationException(string message)
        => throw new InvalidOperationException(message);

    /// <summary>
    /// Throws an <see cref="System.InvalidOperationException"/>.
    /// </summary>
    /// <param name="message">A message that describes the error.</param>
    /// <param name="innerException">The exception that is the cause of the current exception.</param>
#if !NET6_0_OR_GREATER
    [MethodImpl(MethodImplOptions.NoInlining)]
#endif
    [DoesNotReturn]
    public static void InvalidOperationException(string message, Exception? innerException)
        => throw new InvalidOperationException(message, innerException);

    #endregion

    #region For Integer

    /// <summary>
    /// Throws an <see cref="System.ArgumentOutOfRangeException"/>  if the specified number is less than min.
    /// </summary>
    /// <param name="argument">Number to be expected being less than min.</param>
    /// <param name="min">The number that must be less than the argument.</param>
    /// <param name="paramName">The name of the parameter being checked.</param>
    /// <returns>The original value of <paramref name="argument"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static int IfLessThan(int argument, int min, [CallerArgumentExpression(nameof(argument))] string paramName = "")
    {
        if (argument < min)
        {
            ArgumentOutOfRangeException(paramName, argument, $"Argument less than minimum value {min}");
        }

        return argument;
    }

    /// <summary>
    /// Throws an <see cref="System.ArgumentOutOfRangeException"/> if the specified number is greater than max.
    /// </summary>
    /// <param name="argument">Number to be expected being greater than max.</param>
    /// <param name="max">The number that must be greater than the argument.</param>
    /// <param name="paramName">The name of the parameter being checked.</param>
    /// <returns>The original value of <paramref name="argument"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static int IfGreaterThan(int argument, int max, [CallerArgumentExpression(nameof(argument))] string paramName = "")
    {
        if (argument > max)
        {
            ArgumentOutOfRangeException(paramName, argument, $"Argument greater than maximum value {max}");
        }

        return argument;
    }

    /// <summary>
    /// Throws an <see cref="System.ArgumentOutOfRangeException"/> if the specified number is less or equal than min.
    /// </summary>
    /// <param name="argument">Number to be expected being less or equal than min.</param>
    /// <param name="min">The number that must be less or equal than the argument.</param>
    /// <param name="paramName">The name of the parameter being checked.</param>
    /// <returns>The original value of <paramref name="argument"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static int IfLessThanOrEqual(int argument, int min, [CallerArgumentExpression(nameof(argument))] string paramName = "")
    {
        if (argument <= min)
        {
            ArgumentOutOfRangeException(paramName, argument, $"Argument less or equal than minimum value {min}");
        }

        return argument;
    }

    /// <summary>
    /// Throws an <see cref="System.ArgumentOutOfRangeException"/> if the specified number is greater or equal than max.
    /// </summary>
    /// <param name="argument">Number to be expected being greater or equal than max.</param>
    /// <param name="max">The number that must be greater or equal than the argument.</param>
    /// <param name="paramName">The name of the parameter being checked.</param>
    /// <returns>The original value of <paramref name="argument"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static int IfGreaterThanOrEqual(int argument, int max, [CallerArgumentExpression(nameof(argument))] string paramName = "")
    {
        if (argument >= max)
        {
            ArgumentOutOfRangeException(paramName, argument, $"Argument greater or equal than maximum value {max}");
        }

        return argument;
    }

    /// <summary>
    /// Throws an <see cref="System.ArgumentOutOfRangeException"/> if the specified number is not in the specified range.
    /// </summary>
    /// <param name="argument">Number to be expected being greater or equal than max.</param>
    /// <param name="min">The lower bound of the allowed range of argument values.</param>
    /// <param name="max">The upper bound of the allowed range of argument values.</param>
    /// <param name="paramName">The name of the parameter being checked.</param>
    /// <returns>The original value of <paramref name="argument"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static int IfOutOfRange(int argument, int min, int max, [CallerArgumentExpression(nameof(argument))] string paramName = "")
    {
        if (argument < min || argument > max)
        {
            ArgumentOutOfRangeException(paramName, argument, $"Argument not in the range [{min}..{max}]");
        }

        return argument;
    }

    /// <summary>
    /// Throws an <see cref="System.ArgumentOutOfRangeException"/> if the specified number is equal to 0.
    /// </summary>
    /// <param name="argument">Number to be expected being not equal to zero.</param>
    /// <param name="paramName">The name of the parameter being checked.</param>
    /// <returns>The original value of <paramref name="argument"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static int IfZero(int argument, [CallerArgumentExpression(nameof(argument))] string paramName = "")
    {
        if (argument == 0)
        {
            ArgumentOutOfRangeException(paramName, "Argument is zero");
        }

        return argument;
    }

    #endregion

    #region For Unsigned Integer

    /// <summary>
    /// Throws an <see cref="System.ArgumentOutOfRangeException"/>  if the specified number is less than min.
    /// </summary>
    /// <param name="argument">Number to be expected being less than min.</param>
    /// <param name="min">The number that must be less than the argument.</param>
    /// <param name="paramName">The name of the parameter being checked.</param>
    /// <returns>The original value of <paramref name="argument"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static uint IfLessThan(uint argument, uint min, [CallerArgumentExpression(nameof(argument))] string paramName = "")
    {
        if (argument < min)
        {
            ArgumentOutOfRangeException(paramName, argument, $"Argument less than minimum value {min}");
        }

        return argument;
    }

    /// <summary>
    /// Throws an <see cref="System.ArgumentOutOfRangeException"/> if the specified number is greater than max.
    /// </summary>
    /// <param name="argument">Number to be expected being greater than max.</param>
    /// <param name="max">The number that must be greater than the argument.</param>
    /// <param name="paramName">The name of the parameter being checked.</param>
    /// <returns>The original value of <paramref name="argument"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static uint IfGreaterThan(uint argument, uint max, [CallerArgumentExpression(nameof(argument))] string paramName = "")
    {
        if (argument > max)
        {
            ArgumentOutOfRangeException(paramName, argument, $"Argument greater than maximum value {max}");
        }

        return argument;
    }

    /// <summary>
    /// Throws an <see cref="System.ArgumentOutOfRangeException"/> if the specified number is less or equal than min.
    /// </summary>
    /// <param name="argument">Number to be expected being less or equal than min.</param>
    /// <param name="min">The number that must be less or equal than the argument.</param>
    /// <param name="paramName">The name of the parameter being checked.</param>
    /// <returns>The original value of <paramref name="argument"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static uint IfLessThanOrEqual(uint argument, uint min, [CallerArgumentExpression(nameof(argument))] string paramName = "")
    {
        if (argument <= min)
        {
            ArgumentOutOfRangeException(paramName, argument, $"Argument less or equal than minimum value {min}");
        }

        return argument;
    }

    /// <summary>
    /// Throws an <see cref="System.ArgumentOutOfRangeException"/> if the specified number is greater or equal than max.
    /// </summary>
    /// <param name="argument">Number to be expected being greater or equal than max.</param>
    /// <param name="max">The number that must be greater or equal than the argument.</param>
    /// <param name="paramName">The name of the parameter being checked.</param>
    /// <returns>The original value of <paramref name="argument"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static uint IfGreaterThanOrEqual(uint argument, uint max, [CallerArgumentExpression(nameof(argument))] string paramName = "")
    {
        if (argument >= max)
        {
            ArgumentOutOfRangeException(paramName, argument, $"Argument greater or equal than maximum value {max}");
        }

        return argument;
    }

    /// <summary>
    /// Throws an <see cref="System.ArgumentOutOfRangeException"/> if the specified number is not in the specified range.
    /// </summary>
    /// <param name="argument">Number to be expected being greater or equal than max.</param>
    /// <param name="min">The lower bound of the allowed range of argument values.</param>
    /// <param name="max">The upper bound of the allowed range of argument values.</param>
    /// <param name="paramName">The name of the parameter being checked.</param>
    /// <returns>The original value of <paramref name="argument"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static uint IfOutOfRange(uint argument, uint min, uint max, [CallerArgumentExpression(nameof(argument))] string paramName = "")
    {
        if (argument < min || argument > max)
        {
            ArgumentOutOfRangeException(paramName, argument, $"Argument not in the range [{min}..{max}]");
        }

        return argument;
    }

    /// <summary>
    /// Throws an <see cref="System.ArgumentOutOfRangeException"/> if the specified number is equal to 0.
    /// </summary>
    /// <param name="argument">Number to be expected being not equal to zero.</param>
    /// <param name="paramName">The name of the parameter being checked.</param>
    /// <returns>The original value of <paramref name="argument"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static uint IfZero(uint argument, [CallerArgumentExpression(nameof(argument))] string paramName = "")
    {
        if (argument == 0U)
        {
            ArgumentOutOfRangeException(paramName, "Argument is zero");
        }

        return argument;
    }

    #endregion

    #region For Long

    /// <summary>
    /// Throws an <see cref="System.ArgumentOutOfRangeException"/>  if the specified number is less than min.
    /// </summary>
    /// <param name="argument">Number to be expected being less than min.</param>
    /// <param name="min">The number that must be less than the argument.</param>
    /// <param name="paramName">The name of the parameter being checked.</param>
    /// <returns>The original value of <paramref name="argument"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static long IfLessThan(long argument, long min, [CallerArgumentExpression(nameof(argument))] string paramName = "")
    {
        if (argument < min)
        {
            ArgumentOutOfRangeException(paramName, argument, $"Argument less than minimum value {min}");
        }

        return argument;
    }

    /// <summary>
    /// Throws an <see cref="System.ArgumentOutOfRangeException"/> if the specified number is greater than max.
    /// </summary>
    /// <param name="argument">Number to be expected being greater than max.</param>
    /// <param name="max">The number that must be greater than the argument.</param>
    /// <param name="paramName">The name of the parameter being checked.</param>
    /// <returns>The original value of <paramref name="argument"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static long IfGreaterThan(long argument, long max, [CallerArgumentExpression(nameof(argument))] string paramName = "")
    {
        if (argument > max)
        {
            ArgumentOutOfRangeException(paramName, argument, $"Argument greater than maximum value {max}");
        }

        return argument;
    }

    /// <summary>
    /// Throws an <see cref="System.ArgumentOutOfRangeException"/> if the specified number is less or equal than min.
    /// </summary>
    /// <param name="argument">Number to be expected being less or equal than min.</param>
    /// <param name="min">The number that must be less or equal than the argument.</param>
    /// <param name="paramName">The name of the parameter being checked.</param>
    /// <returns>The original value of <paramref name="argument"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static long IfLessThanOrEqual(long argument, long min, [CallerArgumentExpression(nameof(argument))] string paramName = "")
    {
        if (argument <= min)
        {
            ArgumentOutOfRangeException(paramName, argument, $"Argument less or equal than minimum value {min}");
        }

        return argument;
    }

    /// <summary>
    /// Throws an <see cref="System.ArgumentOutOfRangeException"/> if the specified number is greater or equal than max.
    /// </summary>
    /// <param name="argument">Number to be expected being greater or equal than max.</param>
    /// <param name="max">The number that must be greater or equal than the argument.</param>
    /// <param name="paramName">The name of the parameter being checked.</param>
    /// <returns>The original value of <paramref name="argument"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static long IfGreaterThanOrEqual(long argument, long max, [CallerArgumentExpression(nameof(argument))] string paramName = "")
    {
        if (argument >= max)
        {
            ArgumentOutOfRangeException(paramName, argument, $"Argument greater or equal than maximum value {max}");
        }

        return argument;
    }

    /// <summary>
    /// Throws an <see cref="System.ArgumentOutOfRangeException"/> if the specified number is not in the specified range.
    /// </summary>
    /// <param name="argument">Number to be expected being greater or equal than max.</param>
    /// <param name="min">The lower bound of the allowed range of argument values.</param>
    /// <param name="max">The upper bound of the allowed range of argument values.</param>
    /// <param name="paramName">The name of the parameter being checked.</param>
    /// <returns>The original value of <paramref name="argument"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static long IfOutOfRange(long argument, long min, long max, [CallerArgumentExpression(nameof(argument))] string paramName = "")
    {
        if (argument < min || argument > max)
        {
            ArgumentOutOfRangeException(paramName, argument, $"Argument not in the range [{min}..{max}]");
        }

        return argument;
    }

    /// <summary>
    /// Throws an <see cref="System.ArgumentOutOfRangeException"/> if the specified number is equal to 0.
    /// </summary>
    /// <param name="argument">Number to be expected being not equal to zero.</param>
    /// <param name="paramName">The name of the parameter being checked.</param>
    /// <returns>The original value of <paramref name="argument"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static long IfZero(long argument, [CallerArgumentExpression(nameof(argument))] string paramName = "")
    {
        if (argument == 0L)
        {
            ArgumentOutOfRangeException(paramName, "Argument is zero");
        }

        return argument;
    }

    #endregion

    #region For Unsigned Long

    /// <summary>
    /// Throws an <see cref="System.ArgumentOutOfRangeException"/>  if the specified number is less than min.
    /// </summary>
    /// <param name="argument">Number to be expected being less than min.</param>
    /// <param name="min">The number that must be less than the argument.</param>
    /// <param name="paramName">The name of the parameter being checked.</param>
    /// <returns>The original value of <paramref name="argument"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ulong IfLessThan(ulong argument, ulong min, [CallerArgumentExpression(nameof(argument))] string paramName = "")
    {
        if (argument < min)
        {
            ArgumentOutOfRangeException(paramName, argument, $"Argument less than minimum value {min}");
        }

        return argument;
    }

    /// <summary>
    /// Throws an <see cref="System.ArgumentOutOfRangeException"/> if the specified number is greater than max.
    /// </summary>
    /// <param name="argument">Number to be expected being greater than max.</param>
    /// <param name="max">The number that must be greater than the argument.</param>
    /// <param name="paramName">The name of the parameter being checked.</param>
    /// <returns>The original value of <paramref name="argument"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ulong IfGreaterThan(ulong argument, ulong max, [CallerArgumentExpression(nameof(argument))] string paramName = "")
    {
        if (argument > max)
        {
            ArgumentOutOfRangeException(paramName, argument, $"Argument greater than maximum value {max}");
        }

        return argument;
    }

    /// <summary>
    /// Throws an <see cref="System.ArgumentOutOfRangeException"/> if the specified number is less or equal than min.
    /// </summary>
    /// <param name="argument">Number to be expected being less or equal than min.</param>
    /// <param name="min">The number that must be less or equal than the argument.</param>
    /// <param name="paramName">The name of the parameter being checked.</param>
    /// <returns>The original value of <paramref name="argument"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ulong IfLessThanOrEqual(ulong argument, ulong min, [CallerArgumentExpression(nameof(argument))] string paramName = "")
    {
        if (argument <= min)
        {
            ArgumentOutOfRangeException(paramName, argument, $"Argument less or equal than minimum value {min}");
        }

        return argument;
    }

    /// <summary>
    /// Throws an <see cref="System.ArgumentOutOfRangeException"/> if the specified number is greater or equal than max.
    /// </summary>
    /// <param name="argument">Number to be expected being greater or equal than max.</param>
    /// <param name="max">The number that must be greater or equal than the argument.</param>
    /// <param name="paramName">The name of the parameter being checked.</param>
    /// <returns>The original value of <paramref name="argument"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ulong IfGreaterThanOrEqual(ulong argument, ulong max, [CallerArgumentExpression(nameof(argument))] string paramName = "")
    {
        if (argument >= max)
        {
            ArgumentOutOfRangeException(paramName, argument, $"Argument greater or equal than maximum value {max}");
        }

        return argument;
    }

    /// <summary>
    /// Throws an <see cref="System.ArgumentOutOfRangeException"/> if the specified number is not in the specified range.
    /// </summary>
    /// <param name="argument">Number to be expected being greater or equal than max.</param>
    /// <param name="min">The lower bound of the allowed range of argument values.</param>
    /// <param name="max">The upper bound of the allowed range of argument values.</param>
    /// <param name="paramName">The name of the parameter being checked.</param>
    /// <returns>The original value of <paramref name="argument"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ulong IfOutOfRange(ulong argument, ulong min, ulong max, [CallerArgumentExpression(nameof(argument))] string paramName = "")
    {
        if (argument < min || argument > max)
        {
            ArgumentOutOfRangeException(paramName, argument, $"Argument not in the range [{min}..{max}]");
        }

        return argument;
    }

    /// <summary>
    /// Throws an <see cref="System.ArgumentOutOfRangeException"/> if the specified number is equal to 0.
    /// </summary>
    /// <param name="argument">Number to be expected being not equal to zero.</param>
    /// <param name="paramName">The name of the parameter being checked.</param>
    /// <returns>The original value of <paramref name="argument"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ulong IfZero(ulong argument, [CallerArgumentExpression(nameof(argument))] string paramName = "")
    {
        if (argument == 0UL)
        {
            ArgumentOutOfRangeException(paramName, "Argument is zero");
        }

        return argument;
    }

    #endregion

    #region For Double

    /// <summary>
    /// Throws an <see cref="System.ArgumentOutOfRangeException"/> if the specified number is less than min.
    /// </summary>
    /// <param name="argument">Number to be expected being less than min.</param>
    /// <param name="min">The number that must be less than the argument.</param>
    /// <param name="paramName">The name of the parameter being checked.</param>
    /// <returns>The original value of <paramref name="argument"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static double IfLessThan(double argument, double min, [CallerArgumentExpression(nameof(argument))] string paramName = "")
    {
        // strange conditional needed in order to handle NaN values correctly
#pragma warning disable S1940 // Boolean checks should not be inverted
        if (!(argument >= min))
#pragma warning restore S1940 // Boolean checks should not be inverted
        {
            ArgumentOutOfRangeException(paramName, argument, $"Argument less than minimum value {min}");
        }

        return argument;
    }

    /// <summary>
    /// Throws an <see cref="System.ArgumentOutOfRangeException"/> if the specified number is greater than max.
    /// </summary>
    /// <param name="argument">Number to be expected being greater than max.</param>
    /// <param name="max">The number that must be greater than the argument.</param>
    /// <param name="paramName">The name of the parameter being checked.</param>
    /// <returns>The original value of <paramref name="argument"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static double IfGreaterThan(double argument, double max, [CallerArgumentExpression(nameof(argument))] string paramName = "")
    {
        // strange conditional needed in order to handle NaN values correctly
#pragma warning disable S1940 // Boolean checks should not be inverted
        if (!(argument <= max))
#pragma warning restore S1940 // Boolean checks should not be inverted
        {
            ArgumentOutOfRangeException(paramName, argument, $"Argument greater than maximum value {max}");
        }

        return argument;
    }

    /// <summary>
    /// Throws an <see cref="System.ArgumentOutOfRangeException"/> if the specified number is less or equal than min.
    /// </summary>
    /// <param name="argument">Number to be expected being less or equal than min.</param>
    /// <param name="min">The number that must be less or equal than the argument.</param>
    /// <param name="paramName">The name of the parameter being checked.</param>
    /// <returns>The original value of <paramref name="argument"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static double IfLessThanOrEqual(double argument, double min, [CallerArgumentExpression(nameof(argument))] string paramName = "")
    {
        // strange conditional needed in order to handle NaN values correctly
#pragma warning disable S1940 // Boolean checks should not be inverted
        if (!(argument > min))
#pragma warning restore S1940 // Boolean checks should not be inverted
        {
            ArgumentOutOfRangeException(paramName, argument, $"Argument less or equal than minimum value {min}");
        }

        return argument;
    }

    /// <summary>
    /// Throws an <see cref="System.ArgumentOutOfRangeException"/> if the specified number is greater or equal than max.
    /// </summary>
    /// <param name="argument">Number to be expected being greater or equal than max.</param>
    /// <param name="max">The number that must be greater or equal than the argument.</param>
    /// <param name="paramName">The name of the parameter being checked.</param>
    /// <returns>The original value of <paramref name="argument"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static double IfGreaterThanOrEqual(double argument, double max, [CallerArgumentExpression(nameof(argument))] string paramName = "")
    {
        // strange conditional needed in order to handle NaN values correctly
#pragma warning disable S1940 // Boolean checks should not be inverted
        if (!(argument < max))
#pragma warning restore S1940 // Boolean checks should not be inverted
        {
            ArgumentOutOfRangeException(paramName, argument, $"Argument greater or equal than maximum value {max}");
        }

        return argument;
    }

    /// <summary>
    /// Throws an <see cref="System.ArgumentOutOfRangeException"/> if the specified number is not in the specified range.
    /// </summary>
    /// <param name="argument">Number to be expected being greater or equal than max.</param>
    /// <param name="min">The lower bound of the allowed range of argument values.</param>
    /// <param name="max">The upper bound of the allowed range of argument values.</param>
    /// <param name="paramName">The name of the parameter being checked.</param>
    /// <returns>The original value of <paramref name="argument"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static double IfOutOfRange(double argument, double min, double max, [CallerArgumentExpression(nameof(argument))] string paramName = "")
    {
        // strange conditional needed in order to handle NaN values correctly
        if (!(min <= argument && argument <= max))
        {
            ArgumentOutOfRangeException(paramName, argument, $"Argument not in the range [{min}..{max}]");
        }

        return argument;
    }

    /// <summary>
    /// Throws an <see cref="System.ArgumentOutOfRangeException"/> if the specified number is equal to 0.
    /// </summary>
    /// <param name="argument">Number to be expected being not equal to zero.</param>
    /// <param name="paramName">The name of the parameter being checked.</param>
    /// <returns>The original value of <paramref name="argument"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static double IfZero(double argument, [CallerArgumentExpression(nameof(argument))] string paramName = "")
    {
#pragma warning disable S1244 // Floating point numbers should not be tested for equality
        if (argument == 0.0)
#pragma warning restore S1244 // Floating point numbers should not be tested for equality
        {
            ArgumentOutOfRangeException(paramName, "Argument is zero");
        }

        return argument;
    }

    #endregion
}


===== src\Diagnostics\UnconditionalSuppressMessageAttribute.cs =====

// Copyright (c) Microsoft. All rights reserved.

#if !NET8_0_OR_GREATER
namespace System.Diagnostics.CodeAnalysis;

/// <summary>
/// Polyfill for the UnconditionalSuppressMessageAttribute introduced in .NET 8.0
/// Suppresses reporting of a specific rule violation, allowing multiple suppressions on a
/// single code artifact.
/// </summary>
/// <remarks>
/// <see cref="UnconditionalSuppressMessageAttribute"/> is different than
/// <see cref="SuppressMessageAttribute"/> in that it doesn't have a
/// <see cref="ConditionalAttribute"/>. So it is always preserved in the compiled assembly.
/// </remarks>
[AttributeUsage(AttributeTargets.All, Inherited = false, AllowMultiple = true)]
internal sealed class UnconditionalSuppressMessageAttribute : Attribute
{
    /// <summary>
    /// Initializes a new instance of the <see cref="UnconditionalSuppressMessageAttribute"/>
    /// class, specifying the category of the tool and the identifier for an analysis rule.
    /// </summary>
    /// <param name="category">The category for the attribute.</param>
    /// <param name="checkId">The identifier of the analysis rule the attribute applies to.</param>
    public UnconditionalSuppressMessageAttribute(string category, string checkId)
    {
        this.Category = category;
        this.CheckId = checkId;
    }

    /// <summary>
    /// Gets the category identifying the classification of the attribute.
    /// </summary>
    /// <remarks>
    /// The <see cref="Category"/> property describes the tool or tool analysis category
    /// for which a message suppression attribute applies.
    /// </remarks>
    public string Category { get; }

    /// <summary>
    /// Gets the identifier of the analysis tool rule to be suppressed.
    /// </summary>
    /// <remarks>
    /// Concatenated together, the <see cref="Category"/> and <see cref="CheckId"/>
    /// properties form a unique check identifier.
    /// </remarks>
    public string CheckId { get; }

    /// <summary>
    /// Gets or sets the scope of the code that is relevant for the attribute.
    /// </summary>
    /// <remarks>
    /// The Scope property is an optional argument that specifies the metadata scope for which
    /// the attribute is relevant.
    /// </remarks>
    public string? Scope { get; set; }

    /// <summary>
    /// Gets or sets a fully qualified path that represents the target of the attribute.
    /// </summary>
    /// <remarks>
    /// The <see cref="Target"/> property is an optional argument identifying the analysis target
    /// of the attribute. An example value is "System.IO.Stream.ctor():System.Void".
    /// Because it is fully qualified, it can be long, particularly for targets such as parameters.
    /// The analysis tool user interface should be capable of automatically formatting the parameter.
    /// </remarks>
    public string? Target { get; set; }

    /// <summary>
    /// Gets or sets an optional argument expanding on exclusion criteria.
    /// </summary>
    /// <remarks>
    /// The <see cref="MessageId "/> property is an optional argument that specifies additional
    /// exclusion where the literal metadata target is not sufficiently precise. For example,
    /// the <see cref="UnconditionalSuppressMessageAttribute"/> cannot be applied within a method,
    /// and it may be desirable to suppress a violation against a statement in the method that will
    /// give a rule violation, but not against all statements in the method.
    /// </remarks>
    public string? MessageId { get; set; }

    /// <summary>
    /// Gets or sets the justification for suppressing the code analysis message.
    /// </summary>
    public string? Justification { get; set; }
}
#endif


===== src\Diagnostics\UnreachableException.cs =====

// Copyright (c) Microsoft. All rights reserved.

#if !NET8_0_OR_GREATER

// Polyfill for using UnreachableException with .NET Standard 2.0

namespace System.Diagnostics;

#pragma warning disable CA1064 // Exceptions should be public
#pragma warning disable CA1812 // Internal class that is (sometimes) never instantiated.

/// <summary>
/// Exception thrown when the program executes an instruction that was thought to be unreachable.
/// </summary>
internal sealed class UnreachableException : Exception
{
    private const string MessageText = "The program executed an instruction that was thought to be unreachable.";

    /// <summary>
    /// Initializes a new instance of the <see cref="UnreachableException"/> class with the default error message.
    /// </summary>
    public UnreachableException()
        : base(MessageText)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="UnreachableException"/>
    /// class with a specified error message.
    /// </summary>
    /// <param name="message">The error message that explains the reason for the exception.</param>
    public UnreachableException(string? message)
        : base(message ?? MessageText)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="UnreachableException"/>
    /// class with a specified error message and a reference to the inner exception that is the cause of
    /// this exception.
    /// </summary>
    /// <param name="message">The error message that explains the reason for the exception.</param>
    /// <param name="innerException">The exception that is the cause of the current exception.</param>
    public UnreachableException(string? message, Exception? innerException)
        : base(message ?? MessageText, innerException)
    {
    }
}

#endif


===== src\Diagnostics\Verify.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text.RegularExpressions;

namespace Microsoft.SemanticKernel;

[ExcludeFromCodeCoverage]
internal static partial class Verify
{
#if NET
    [GeneratedRegex("^[^.]+\\.[^.]+$")]
    private static partial Regex FilenameRegex();
#else
    private static Regex FilenameRegex() => s_filenameRegex;
    private static readonly Regex s_filenameRegex = new("^[^.]+\\.[^.]+$", RegexOptions.Compiled);
#endif

    /// <summary>
    /// Equivalent of ArgumentNullException.ThrowIfNull
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static void NotNull([NotNull] object? obj, [CallerArgumentExpression(nameof(obj))] string? paramName = null)
    {
#if NET
        ArgumentNullException.ThrowIfNull(obj, paramName);
#else
        if (obj is null)
        {
            ThrowArgumentNullException(paramName);
        }
#endif
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static void NotNullOrWhiteSpace([NotNull] string? str, [CallerArgumentExpression(nameof(str))] string? paramName = null)
    {
#if NET
        ArgumentException.ThrowIfNullOrWhiteSpace(str, paramName);
#else
        NotNull(str, paramName);
        if (string.IsNullOrWhiteSpace(str))
        {
            ThrowArgumentWhiteSpaceException(paramName);
        }
#endif
    }

    internal static void NotNullOrEmpty<T>(IList<T> list, [CallerArgumentExpression(nameof(list))] string? paramName = null)
    {
        NotNull(list, paramName);
        if (list.Count == 0)
        {
            throw new ArgumentException("The value cannot be empty.", paramName);
        }
    }

    public static void True(bool condition, string message, [CallerArgumentExpression(nameof(condition))] string? paramName = null)
    {
        if (!condition)
        {
            throw new ArgumentException(message, paramName);
        }
    }

    internal static void ValidFilename([NotNull] string? filename, [CallerArgumentExpression(nameof(filename))] string? paramName = null)
    {
        NotNullOrWhiteSpace(filename);
        if (!FilenameRegex().IsMatch(filename))
        {
            throw new ArgumentException($"Invalid filename format: '{filename}'. Filename should consist of an actual name and a file extension.", paramName);
        }
    }

    public static void ValidateUrl(string url, bool allowQuery = false, [CallerArgumentExpression(nameof(url))] string? paramName = null)
    {
        NotNullOrWhiteSpace(url, paramName);

        if (!Uri.TryCreate(url, UriKind.Absolute, out var uri) || string.IsNullOrEmpty(uri.Host))
        {
            throw new ArgumentException($"The `{url}` is not valid.", paramName);
        }

        if (!allowQuery && !string.IsNullOrEmpty(uri.Query))
        {
            throw new ArgumentException($"The `{url}` is not valid: it cannot contain query parameters.", paramName);
        }

        if (!string.IsNullOrEmpty(uri.Fragment))
        {
            throw new ArgumentException($"The `{url}` is not valid: it cannot contain URL fragments.", paramName);
        }
    }

    internal static void StartsWith([NotNull] string? text, string prefix, string message, [CallerArgumentExpression(nameof(text))] string? textParamName = null)
    {
        Debug.Assert(prefix is not null);

        NotNullOrWhiteSpace(text, textParamName);
        if (!text.StartsWith(prefix, StringComparison.OrdinalIgnoreCase))
        {
            throw new ArgumentException(textParamName, message);
        }
    }

    internal static void DirectoryExists(string path)
    {
        if (!Directory.Exists(path))
        {
            throw new DirectoryNotFoundException($"Directory '{path}' could not be found.");
        }
    }

    [DoesNotReturn]
    internal static void ThrowArgumentInvalidName(string kind, string name, string? paramName) =>
        throw new ArgumentException($"A {kind} can contain only ASCII letters, digits, and underscores: '{name}' is not a valid name.", paramName);

    [DoesNotReturn]
    internal static void ThrowArgumentNullException(string? paramName) =>
        throw new ArgumentNullException(paramName);

    [DoesNotReturn]
    internal static void ThrowArgumentWhiteSpaceException(string? paramName) =>
        throw new ArgumentException("The value cannot be an empty string or composed entirely of whitespace.", paramName);

    [DoesNotReturn]
    internal static void ThrowArgumentOutOfRangeException<T>(string? paramName, T actualValue, string message) =>
        throw new ArgumentOutOfRangeException(paramName, actualValue, message);

    private static readonly HashSet<string> s_invalidLocationCharacters = [
        "://",
        "..",
        "\\",
        "/",
        "@",
        "?",
        "#",
        "[",
        "]",
        "&",
        ":",
        "<",
        ">",
        "'",
        "\"",
        "+",
        "|",
        "="
    ];

    /// <summary>
    /// Validates that a hostname segment string is safe for use as a URL segment, preventing URL injection.
    /// </summary>
    /// <param name="hostNameSegment">The hostname segment string to validate (e.g., 'us-east1', 'europe-west4')</param>
    /// <param name="paramName">Optional parameter name for the exception</param>
    /// <exception cref="ArgumentException">Thrown when the location contains invalid characters or patterns</exception>
    internal static void ValidHostnameSegment(string hostNameSegment, [CallerArgumentExpression(nameof(hostNameSegment))] string? paramName = null)
    {
        // Check for URL injection patterns and invalid characters
        if (s_invalidLocationCharacters.Any(hostNameSegment.Contains))
        {
            throw new ArgumentException($"The location '{hostNameSegment}' contains invalid characters that could enable URL injection.", paramName);
        }

        // Validate location format (allows alphanumeric, hyphens, and underscores)
        // Common format examples: us-east1, europe-west4, asia-northeast1
        if (!System.Text.RegularExpressions.Regex.IsMatch(hostNameSegment, @"^[a-zA-Z0-9][a-zA-Z0-9\-_]*[a-zA-Z0-9]$"))
        {
            throw new ArgumentException($"The location '{hostNameSegment}' is not valid. Location must start and end with alphanumeric characters and can contain hyphens and underscores.", paramName);
        }
    }

    internal static void NotLessThan(int value, int limit, [CallerArgumentExpression(nameof(value))] string? paramName = null)
    {
        if (value < limit)
        {
            throw new ArgumentOutOfRangeException(paramName, $"{paramName} must be greater than or equal to {limit}.");
        }
    }
}


===== src\EmptyCollections\EmptyReadonlyDictionary.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections;
using System.Collections.Generic;

#pragma warning disable IDE0009 // use this directive
#pragma warning disable CA1716

// Original source from
// https://raw.githubusercontent.com/dotnet/extensions/main/src/Shared/EmptyCollections/EmptyReadOnlyList.cs

[System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
internal sealed class EmptyReadOnlyDictionary<TKey, TValue> : IReadOnlyDictionary<TKey, TValue>, IDictionary<TKey, TValue>
    where TKey : notnull
{
    public static readonly EmptyReadOnlyDictionary<TKey, TValue> Instance = new();

    public int Count => 0;
    public TValue this[TKey key] => throw new KeyNotFoundException();
    public bool ContainsKey(TKey key) => false;
    public IEnumerable<TKey> Keys => EmptyReadOnlyList<TKey>.Instance;
    public IEnumerable<TValue> Values => EmptyReadOnlyList<TValue>.Instance;

    public IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator() => EmptyReadOnlyList<KeyValuePair<TKey, TValue>>.Instance.GetEnumerator();
    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

    ICollection<TKey> IDictionary<TKey, TValue>.Keys => Array.Empty<TKey>();
    ICollection<TValue> IDictionary<TKey, TValue>.Values => Array.Empty<TValue>();
    bool ICollection<KeyValuePair<TKey, TValue>>.IsReadOnly => true;
    TValue IDictionary<TKey, TValue>.this[TKey key]
    {
        get => throw new KeyNotFoundException();
        set => throw new NotSupportedException();
    }

    public bool TryGetValue(TKey key, out TValue value)
    {
#pragma warning disable CS8601 // The recommended implementation: https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2.trygetvalue
        value = default;
#pragma warning restore

        return false;
    }

    void ICollection<KeyValuePair<TKey, TValue>>.Clear()
    {
        // nop
    }

    void ICollection<KeyValuePair<TKey, TValue>>.CopyTo(KeyValuePair<TKey, TValue>[] array, int arrayIndex)
    {
        // nop
    }

    void IDictionary<TKey, TValue>.Add(TKey key, TValue value) => throw new NotSupportedException();
    bool IDictionary<TKey, TValue>.Remove(TKey key) => false;
    void ICollection<KeyValuePair<TKey, TValue>>.Add(KeyValuePair<TKey, TValue> item) => throw new NotSupportedException();
    bool ICollection<KeyValuePair<TKey, TValue>>.Contains(KeyValuePair<TKey, TValue> item) => false;
    bool ICollection<KeyValuePair<TKey, TValue>>.Remove(KeyValuePair<TKey, TValue> item) => false;
}


===== src\EmptyCollections\EmptyReadonlyList.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections;
using System.Collections.Generic;

#pragma warning disable IDE0009 // use this directive
#pragma warning disable CA1716

// Original source from
// https://raw.githubusercontent.com/dotnet/extensions/main/src/Shared/EmptyCollections/EmptyReadOnlyList.cs

[System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
[System.Diagnostics.CodeAnalysis.SuppressMessage("Design", "CA1001:Types that own disposable fields should be disposable", Justification = "Static field, lifetime matches the process")]
internal sealed class EmptyReadOnlyList<T> : IReadOnlyList<T>, ICollection<T>
{
    public static readonly EmptyReadOnlyList<T> Instance = new();
    private readonly Enumerator _enumerator = new();

    public IEnumerator<T> GetEnumerator() => _enumerator;
    IEnumerator IEnumerable.GetEnumerator() => _enumerator;
    public int Count => 0;
    public T this[int index] => throw new ArgumentOutOfRangeException(nameof(index));

    void ICollection<T>.CopyTo(T[] array, int arrayIndex)
    {
        // nop
    }

    bool ICollection<T>.Contains(T item) => false;
    bool ICollection<T>.IsReadOnly => true;
    void ICollection<T>.Add(T item) => throw new NotSupportedException();
    bool ICollection<T>.Remove(T item) => false;

    void ICollection<T>.Clear()
    {
        // nop
    }

    internal sealed class Enumerator : IEnumerator<T>
    {
        public void Dispose()
        {
            // nop
        }

        public void Reset()
        {
            // nop
        }

        public bool MoveNext() => false;
        public T Current => throw new InvalidOperationException();
        object IEnumerator.Current => throw new InvalidOperationException();
    }
}


===== src\Functions\FunctionName.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Diagnostics.CodeAnalysis;

namespace Microsoft.SemanticKernel;

/// <summary>
/// Represents a function name.
/// </summary>
[ExcludeFromCodeCoverage]
internal sealed class FunctionName
{
    /// <summary>
    /// The plugin name.
    /// </summary>
    public string? PluginName { get; }

    /// <summary>
    /// The function name.
    /// </summary>
    public string Name { get; }

    /// <summary>
    /// Initializes a new instance of the <see cref="FunctionName"/> class.
    /// </summary>
    /// <param name="name">The function name.</param>
    /// <param name="pluginName">The plugin name.</param>
    public FunctionName(string name, string? pluginName = null)
    {
        Verify.NotNull(name);

        this.Name = name;
        this.PluginName = pluginName;
    }

    /// <summary>
    /// Gets the fully-qualified name of the function.
    /// </summary>
    /// <param name="functionName">The function name.</param>
    /// <param name="pluginName">The plugin name.</param>
    /// <param name="functionNameSeparator">The function name separator.</param>
    /// <returns>Fully-qualified name of the function.</returns>
    public static string ToFullyQualifiedName(string functionName, string? pluginName = null, string functionNameSeparator = "-")
    {
        return string.IsNullOrEmpty(pluginName) ? functionName : $"{pluginName}{functionNameSeparator}{functionName}";
    }

    /// <summary>
    /// Creates a new instance of the <see cref="FunctionName"/> class.
    /// </summary>
    /// <param name="fullyQualifiedName">Fully-qualified name of the function.</param>
    /// <param name="functionNameSeparator">The function name separator.</param>
    public static FunctionName Parse(string fullyQualifiedName, string functionNameSeparator = "-")
    {
        Verify.NotNull(fullyQualifiedName);

        string? pluginName = null;
        string functionName = fullyQualifiedName;

        int separatorPos = fullyQualifiedName.IndexOf(functionNameSeparator, StringComparison.Ordinal);
        if (separatorPos >= 0)
        {
            pluginName = fullyQualifiedName.AsSpan(0, separatorPos).Trim().ToString();
            functionName = fullyQualifiedName.AsSpan(separatorPos + functionNameSeparator.Length).Trim().ToString();
        }

        return new FunctionName(name: functionName, pluginName: pluginName);
    }
}


===== src\Http\HttpClientExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Diagnostics.CodeAnalysis;
using System.Net;
using System.Net.Http;
using System.Threading;
using System.Threading.Tasks;

namespace Microsoft.SemanticKernel.Http;

[ExcludeFromCodeCoverage]
internal static class HttpClientExtensions
{
    /// <summary>
    /// Sends an HTTP request using the provided <see cref="HttpClient"/> instance and checks for a successful response.
    /// If the response is not successful, it logs an error and throws an <see cref="HttpOperationException"/>.
    /// </summary>
    /// <param name="client">The <see cref="HttpClient"/> instance to use for sending the request.</param>
    /// <param name="request">The <see cref="HttpRequestMessage"/> to send.</param>
    /// <param name="completionOption">Indicates if HttpClient operations should be considered completed either as soon as a response is available,
    /// or after reading the entire response message including the content.</param>
    /// <param name="cancellationToken">A <see cref="CancellationToken"/> for canceling the request.</param>
    /// <returns>The <see cref="HttpResponseMessage"/> representing the response.</returns>
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Design", "CA1031:Do not catch general exception types", Justification = "By design. See comment below.")]
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Reliability", "CA2016:Forward the 'CancellationToken' parameter to methods", Justification = "The `ReadAsStringAsync` method in the NetStandard 2.0 version does not have an overload that accepts the cancellation token.")]
    internal static async Task<HttpResponseMessage> SendWithSuccessCheckAsync(this HttpClient client, HttpRequestMessage request, HttpCompletionOption completionOption, CancellationToken cancellationToken)
    {
        HttpResponseMessage? response = null;
        try
        {
            response = await client.SendAsync(request, completionOption, cancellationToken).ConfigureAwait(false);
        }
        catch (HttpRequestException e)
        {
            throw new HttpOperationException(HttpStatusCode.BadRequest, null, e.Message, e);
        }

        if (!response.IsSuccessStatusCode)
        {
            string? responseContent = null;
            try
            {
                // On .NET Framework, EnsureSuccessStatusCode disposes of the response content;
                // that was changed years ago in .NET Core, but for .NET Framework it means in order
                // to read the response content in the case of failure, that has to be
                // done before calling EnsureSuccessStatusCode.
                responseContent = await response!.Content.ReadAsStringAsync().ConfigureAwait(false);
                response.EnsureSuccessStatusCode(); // will always throw
            }
            catch (Exception e)
            {
                throw new HttpOperationException(response.StatusCode, responseContent, e.Message, e);
            }
        }

        return response;
    }

    /// <summary>
    /// Sends an HTTP request using the provided <see cref="HttpClient"/> instance and checks for a successful response.
    /// If the response is not successful, it logs an error and throws an <see cref="HttpOperationException"/>.
    /// </summary>
    /// <param name="client">The <see cref="HttpClient"/> instance to use for sending the request.</param>
    /// <param name="request">The <see cref="HttpRequestMessage"/> to send.</param>
    /// <param name="cancellationToken">A <see cref="CancellationToken"/> for canceling the request.</param>
    /// <returns>The <see cref="HttpResponseMessage"/> representing the response.</returns>
    internal static async Task<HttpResponseMessage> SendWithSuccessCheckAsync(this HttpClient client, HttpRequestMessage request, CancellationToken cancellationToken)
    {
        return await client.SendWithSuccessCheckAsync(request, HttpCompletionOption.ResponseContentRead, cancellationToken).ConfigureAwait(false);
    }
}


===== src\Http\HttpClientProvider.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Diagnostics.CodeAnalysis;
using System.Net.Http;
#if NET
using System.Net.Security;
using System.Security.Cryptography.X509Certificates;
#endif
using Microsoft.Extensions.DependencyInjection;

#pragma warning disable CA2000 // Dispose objects before losing scope
#pragma warning disable CA2215 // Dispose methods should call base class dispose

namespace Microsoft.SemanticKernel.Http;

/// <summary>
/// Provides functionality for retrieving instances of HttpClient.
/// </summary>
[ExcludeFromCodeCoverage]
internal static class HttpClientProvider
{
    /// <summary>
    /// Retrieves an instance of HttpClient.
    /// </summary>
    /// <returns>An instance of HttpClient.</returns>
    public static HttpClient GetHttpClient() => new(NonDisposableHttpClientHandler.Instance, disposeHandler: false);

    /// <summary>
    /// Retrieves an instance of HttpClient.
    /// </summary>
    /// <returns>An instance of HttpClient.</returns>
    public static HttpClient GetHttpClient(HttpClient? httpClient = null) => httpClient ?? GetHttpClient();

    /// <summary>
    /// Retrieves an instance of HttpClient.
    /// </summary>
    /// <returns>An instance of HttpClient.</returns>
    public static HttpClient GetHttpClient(IServiceProvider? serviceProvider = null) => GetHttpClient(serviceProvider?.GetService<HttpClient>());

    /// <summary>
    /// Retrieves an instance of HttpClient.
    /// </summary>
    /// <returns>An instance of HttpClient.</returns>
    public static HttpClient GetHttpClient(HttpClient? httpClient, IServiceProvider serviceProvider) => httpClient ?? GetHttpClient(serviceProvider?.GetService<HttpClient>());

    /// <summary>
    /// Represents a singleton implementation of <see cref="HttpClientHandler"/> that is not disposable.
    /// </summary>
    private sealed class NonDisposableHttpClientHandler : DelegatingHandler
    {
        /// <summary>
        /// Private constructor to prevent direct instantiation of the class.
        /// </summary>
        private NonDisposableHttpClientHandler() : base(CreateHandler())
        {
        }

        /// <summary>
        /// Gets the singleton instance of <see cref="NonDisposableHttpClientHandler"/>.
        /// </summary>
        public static NonDisposableHttpClientHandler Instance { get; } = new();

        /// <summary>
        /// Disposes the underlying resources held by the <see cref="NonDisposableHttpClientHandler"/>.
        /// This implementation does nothing to prevent unintended disposal, as it may affect all references.
        /// </summary>
        /// <param name="disposing">True if called from <see cref="Dispose"/>, false if called from a finalizer.</param>
        protected override void Dispose(bool disposing)
        {
            // Do nothing if called explicitly from Dispose, as it may unintentionally affect all references.
            // The base.Dispose(disposing) is not called to avoid invoking the disposal of HttpClientHandler resources.
            // This implementation assumes that the HttpMessageHandler is being used as a singleton and should not be disposed directly.
        }

#if NET
        private static SocketsHttpHandler CreateHandler()
        {
            return new SocketsHttpHandler()
            {
                // Limit the lifetime of connections to better respect any DNS changes
                PooledConnectionLifetime = TimeSpan.FromMinutes(2),

                // Check cert revocation
                SslOptions = new SslClientAuthenticationOptions()
                {
                    CertificateRevocationCheckMode = X509RevocationMode.Online,
                },
            };
        }
#elif NETSTANDARD2_0
        private static HttpClientHandler CreateHandler()
        {
            var handler = new HttpClientHandler();
            try
            {
                handler.CheckCertificateRevocationList = true;
            }
            catch (PlatformNotSupportedException) { } // not supported on older frameworks
            return handler;
        }
#elif NET462
        private static HttpClientHandler CreateHandler()
            => new();
#endif
    }
}


===== src\Http\HttpContentExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Net.Http;
using System.Threading;
using System.Threading.Tasks;

namespace Microsoft.SemanticKernel.Http;

/// <summary>
/// Provides extension methods for working with HTTP content in a way that translates HttpRequestExceptions into HttpOperationExceptions.
/// </summary>
[ExcludeFromCodeCoverage]
internal static class HttpContentExtensions
{
    /// <summary>
    /// Reads the content of the HTTP response as a string and translates any HttpRequestException into an HttpOperationException.
    /// </summary>
    /// <param name="httpContent">The HTTP content to read.</param>
    /// <param name="cancellationToken">The cancellation token.</param>
    /// <returns>A string representation of the HTTP content.</returns>
    public static async Task<string> ReadAsStringWithExceptionMappingAsync(this HttpContent httpContent, CancellationToken cancellationToken = default)
    {
        try
        {
            return await httpContent.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
        }
        catch (HttpRequestException ex)
        {
            throw new HttpOperationException(message: ex.Message, innerException: ex);
        }
    }

    /// <summary>
    /// Reads the content of the HTTP response as a stream and translates any HttpRequestException into an HttpOperationException.
    /// </summary>
    /// <param name="httpContent">The HTTP content to read.</param>
    /// <param name="cancellationToken">The cancellation token.</param>
    /// <returns>A stream representing the HTTP content.</returns>
    public static async Task<Stream> ReadAsStreamAndTranslateExceptionAsync(this HttpContent httpContent, CancellationToken cancellationToken = default)
    {
        try
        {
            return await httpContent.ReadAsStreamAsync(cancellationToken).ConfigureAwait(false);
        }
        catch (HttpRequestException ex)
        {
            throw new HttpOperationException(message: ex.Message, innerException: ex);
        }
    }

    /// <summary>
    /// Reads the content of the HTTP response as a byte array and translates any HttpRequestException into an HttpOperationException.
    /// </summary>
    /// <param name="httpContent">The HTTP content to read.</param>
    /// <param name="cancellationToken">The cancellation token.</param>
    /// <returns>A byte array representing the HTTP content.</returns>
    public static async Task<byte[]> ReadAsByteArrayAndTranslateExceptionAsync(this HttpContent httpContent, CancellationToken cancellationToken = default)
    {
        try
        {
            return await httpContent.ReadAsByteArrayAsync(cancellationToken).ConfigureAwait(false);
        }
        catch (HttpRequestException ex)
        {
            throw new HttpOperationException(message: ex.Message, innerException: ex);
        }
    }
}


===== src\Http\HttpContentPolyfills.cs =====

// Copyright (c) Microsoft. All rights reserved.

#if !NET5_0_OR_GREATER

using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Threading;
using System.Threading.Tasks;

namespace System.Net.Http;

[ExcludeFromCodeCoverage]
internal static class HttpContentPolyfills
{
    internal static Task<string> ReadAsStringAsync(this HttpContent httpContent, CancellationToken cancellationToken)
        => httpContent.ReadAsStringAsync();

    internal static Task<Stream> ReadAsStreamAsync(this HttpContent httpContent, CancellationToken cancellationToken)
        => httpContent.ReadAsStreamAsync();

    internal static Task<byte[]> ReadAsByteArrayAsync(this HttpContent httpContent, CancellationToken cancellationToken)
        => httpContent.ReadAsByteArrayAsync();
}

#endif


===== src\Http\HttpHeaderConstant.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Diagnostics.CodeAnalysis;

namespace Microsoft.SemanticKernel.Http;

/// <summary>Provides HTTP header names and values for common purposes.</summary>
[ExcludeFromCodeCoverage]
internal static class HttpHeaderConstant
{
    public static class Names
    {
        /// <summary>HTTP header name to use to include the Semantic Kernel package version in all HTTP requests issued by Semantic Kernel.</summary>
        public static string SemanticKernelVersion => "Semantic-Kernel-Version";

        /// <summary>HTTP User-Agent header name.</summary>
        public static string UserAgent => "User-Agent";
    }

    public static class Values
    {
        /// <summary>User agent string to use for all HTTP requests issued by Semantic Kernel.</summary>
        public static string UserAgent => "Semantic-Kernel";

        /// <summary>
        /// Gets the version of the <see cref="System.Reflection.Assembly"/> in which the specific type is declared.
        /// </summary>
        /// <param name="type">Type for which the assembly version is returned.</param>
        public static string GetAssemblyVersion(Type type)
        {
            return type.Assembly.GetName().Version!.ToString();
        }
    }
}


===== src\Http\HttpRequest.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Diagnostics.CodeAnalysis;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text;
using System.Text.Json;
using Microsoft.SemanticKernel.Text;

namespace Microsoft.SemanticKernel;

[ExcludeFromCodeCoverage]
internal static class HttpRequest
{
    private static readonly HttpMethod s_patchMethod = new("PATCH");

    public static HttpRequestMessage CreateGetRequest(string url, object? payload = null) =>
        CreateRequest(HttpMethod.Get, url, payload);

    public static HttpRequestMessage CreatePostRequest(string url, object? payload = null) =>
        CreateRequest(HttpMethod.Post, url, payload);

    public static HttpRequestMessage CreatePostRequest(Uri url, object? payload = null) =>
        CreateRequest(HttpMethod.Post, url, payload);

    public static HttpRequestMessage CreatePutRequest(string url, object? payload = null) =>
        CreateRequest(HttpMethod.Put, url, payload);

    public static HttpRequestMessage CreatePatchRequest(string url, object? payload = null) =>
        CreateRequest(s_patchMethod, url, payload);

    public static HttpRequestMessage CreateDeleteRequest(string url, object? payload = null) =>
        CreateRequest(HttpMethod.Delete, url, payload);

    private static HttpRequestMessage CreateRequest(HttpMethod method, string url, object? payload) =>
        new(method, url) { Content = CreateJsonContent(payload) };

    private static HttpRequestMessage CreateRequest(HttpMethod method, Uri url, object? payload) =>
        new(method, url) { Content = CreateJsonContent(payload) };

    private static HttpContent? CreateJsonContent(object? payload)
    {
        HttpContent? content = null;
        if (payload is not null)
        {
            byte[] utf8Bytes = payload is string s ?
                Encoding.UTF8.GetBytes(s) :
                JsonSerializer.SerializeToUtf8Bytes(payload, JsonOptionsCache.Default);

            content = new ByteArrayContent(utf8Bytes);
            content.Headers.ContentType = new MediaTypeHeaderValue("application/json") { CharSet = "utf-8" };
        }

        return content;
    }
}


===== src\Http\HttpResponseStream.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Net.Http;

namespace Microsoft.SemanticKernel.Http;

/// <summary>
/// Associate a response stream with its parent response for parity in life-cycle management.
/// </summary>
[SuppressMessage("Performance", "CA1812:Avoid uninstantiated internal classes", Justification = "This class is an internal utility.")]
[ExcludeFromCodeCoverage]
internal sealed class HttpResponseStream(Stream stream, HttpResponseMessage response) : Stream
{
    private readonly Stream _stream = stream;
    private readonly HttpResponseMessage _response = response;

    public override bool CanRead => this._stream.CanRead;

    public override bool CanSeek => this._stream.CanSeek;

    public override bool CanWrite => this._stream.CanWrite;

    public override long Length => this._stream.Length;

    public override long Position { get => this._stream.Position; set => this._stream.Position = value; }

    public override void Flush()
    {
        this._stream.Flush();
    }

    public override int Read(byte[] buffer, int offset, int count)
    {
        return this._stream.Read(buffer, offset, count);
    }

    public override long Seek(long offset, SeekOrigin origin)
    {
        return this._stream.Seek(offset, origin);
    }

    public override void SetLength(long value)
    {
        this._stream.SetLength(value);
    }

    public override void Write(byte[] buffer, int offset, int count)
    {
        this._stream.Write(buffer, offset, count);
    }

    protected override void Dispose(bool disposing)
    {
        base.Dispose(disposing);

        if (disposing)
        {
            this._stream.Dispose();
            this._response.Dispose();
        }
    }
}


===== src\Linq\AsyncEnumerable.cs =====

// Copyright (c) Microsoft. All rights reserved.

#pragma warning disable IDE0005 // Using directive is unnecessary
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
#pragma warning restore IDE0005 // Using directive is unnecessary

#pragma warning disable IDE1006 // Naming Styles

// Used for compatibility with System.Linq.AsyncEnumerable Nuget pkg
namespace System.Linq;

[ExcludeFromCodeCoverage]
internal static class AsyncEnumerable
{
    public static IAsyncEnumerable<T> Empty<T>() => EmptyAsyncEnumerable<T>.Instance;

#pragma warning disable VSTHRD002 // Avoid problematic synchronous waits
    public static IEnumerable<T> ToEnumerable<T>(this IAsyncEnumerable<T> source, CancellationToken cancellationToken = default)
    {
        var enumerator = source.GetAsyncEnumerator(cancellationToken);
        try
        {
            while (enumerator.MoveNextAsync().AsTask().GetAwaiter().GetResult())
            {
                yield return enumerator.Current;
            }
        }
        finally
        {
            enumerator.DisposeAsync().AsTask().GetAwaiter().GetResult();
        }
    }
#pragma warning restore VSTHRD002 // Avoid problematic synchronous waits

#pragma warning disable CS1998 // Async method lacks 'await' operators and will run synchronously
    public static async IAsyncEnumerable<T> ToAsyncEnumerable<T>(this IEnumerable<T> source)
    {
        foreach (var item in source)
        {
            yield return item;
        }
    }
#pragma warning restore CS1998 // Async method lacks 'await' operators and will run synchronously

    public static async ValueTask<T?> FirstOrDefaultAsync<T>(this IAsyncEnumerable<T> source, CancellationToken cancellationToken = default)
    {
        await foreach (var item in source.WithCancellation(cancellationToken).ConfigureAwait(false))
        {
            return item;
        }

        return default;
    }

    public static async ValueTask<T?> LastOrDefaultAsync<T>(this IAsyncEnumerable<T> source, CancellationToken cancellationToken = default)
    {
        var last = default(T)!; // NB: Only matters when hasLast is set to true.
        var hasLast = false;

        await foreach (var item in source.WithCancellation(cancellationToken).ConfigureAwait(false))
        {
            hasLast = true;
            last = item;
        }

        return hasLast ? last! : default;
    }

    public static async ValueTask<List<T>> ToListAsync<T>(this IAsyncEnumerable<T> source, CancellationToken cancellationToken = default)
    {
        var result = new List<T>();

        await foreach (var item in source.WithCancellation(cancellationToken).ConfigureAwait(false))
        {
            result.Add(item);
        }

        return result;
    }

    public static async ValueTask<bool> ContainsAsync<T>(this IAsyncEnumerable<T> source, T value)
    {
        await foreach (var item in source.ConfigureAwait(false))
        {
            if (EqualityComparer<T>.Default.Equals(item, value))
            {
                return true;
            }
        }

        return false;
    }

    public static async ValueTask<int> CountAsync<T>(this IAsyncEnumerable<T> source, CancellationToken cancellationToken = default)
    {
        int count = 0;
        await foreach (var _ in source.WithCancellation(cancellationToken).ConfigureAwait(false))
        {
            checked { count++; }
        }

        return count;
    }

    public static async IAsyncEnumerable<T> Cast<T>(this IAsyncEnumerable<object> source)
    {
        await foreach (var item in source.ConfigureAwait(false))
        {
            yield return (T)item;
        }
    }

    public static async IAsyncEnumerable<T> Reverse<T>(this IAsyncEnumerable<T> source, [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        T[] results = await source.ToArrayAsync(cancellationToken).ConfigureAwait(false);
        for (int i = results.Length - 1; i >= 0; i--)
        {
            yield return results[i];
        }
    }

    public static async ValueTask<TSource> FirstAsync<TSource>(this IAsyncEnumerable<TSource> source, CancellationToken cancellationToken = default)
    {
        await foreach (var item in source.WithCancellation(cancellationToken).ConfigureAwait(false))
        {
            return item;
        }

        throw new InvalidOperationException("Sequence contains no elements");
    }

    public static async ValueTask<TSource> LastAsync<TSource>(this IAsyncEnumerable<TSource> source, CancellationToken cancellationToken = default)
    {
        var enumerator = source.GetAsyncEnumerator(cancellationToken);
        try
        {
            if (await enumerator.MoveNextAsync().ConfigureAwait(false))
            {
                var last = enumerator.Current;
                while (await enumerator.MoveNextAsync().ConfigureAwait(false))
                {
                    last = enumerator.Current;
                }

                return last;
            }

            throw new InvalidOperationException("Sequence contains no elements");
        }
        finally
        {
            await enumerator.DisposeAsync().ConfigureAwait(false);
        }
    }

    public static async ValueTask<TSource> SingleAsync<TSource>(this IAsyncEnumerable<TSource> source, CancellationToken cancellationToken = default)
    {
        var enumerator = source.GetAsyncEnumerator(cancellationToken);
        try
        {
            if (await enumerator.MoveNextAsync().ConfigureAwait(false))
            {
                var result = enumerator.Current;
                if (await enumerator.MoveNextAsync().ConfigureAwait(false))
                {
                    throw new InvalidOperationException("Sequence contains more than one element");
                }

                return result;
            }

            throw new InvalidOperationException("Sequence contains no elements");
        }
        finally
        {
            await enumerator.DisposeAsync().ConfigureAwait(false);
        }
    }

    /// <summary>
    /// Determines whether any element of an async-enumerable sequence satisfies a condition.
    /// </summary>
    /// <typeparam name="TSource">The type of the elements in the source sequence.</typeparam>
    /// <param name="source">An async-enumerable sequence whose elements to apply the predicate to.</param>
    /// <param name="predicate">A function to test each element for a condition.</param>
    /// <param name="cancellationToken">The optional cancellation token to be used for cancelling the sequence at any time.</param>
    /// <returns>An async-enumerable sequence containing a single element determining whether any elements in the source sequence pass the test in the specified predicate.</returns>
    /// <remarks>The return type of this operator differs from the corresponding operator on IEnumerable in order to retain asynchronous behavior.</remarks>
    public static async ValueTask<bool> AnyAsync<TSource>(this IAsyncEnumerable<TSource> source, Func<TSource, bool> predicate, CancellationToken cancellationToken = default)
    {
        await foreach (var item in source.WithCancellation(cancellationToken).ConfigureAwait(false))
        {
            if (predicate(item))
            {
                return true;
            }
        }

        return false;
    }

    /// <summary>
    /// Determines whether any element of an async-enumerable sequence satisfies a condition.
    /// </summary>
    /// <typeparam name="TSource">The type of the elements in the source sequence.</typeparam>
    /// <param name="source">An async-enumerable sequence whose elements to apply the predicate to.</param>
    /// <param name="cancellationToken">The optional cancellation token to be used for cancelling the sequence at any time.</param>
    /// <returns>An async-enumerable sequence containing a single element determining whether any elements in the source sequence pass the test in the specified predicate.</returns>
    /// <remarks>The return type of this operator differs from the corresponding operator on IEnumerable in order to retain asynchronous behavior.</remarks>
    public static async ValueTask<bool> AnyAsync<TSource>(this IAsyncEnumerable<TSource> source, CancellationToken cancellationToken = default)
    {
        await foreach (var item in source.WithCancellation(cancellationToken).ConfigureAwait(false))
        {
            return true;
        }

        return false;
    }

    /// <summary>
    /// Projects each element of an <see cref="IAsyncEnumerable{TSource}"/> into a new form by incorporating
    /// an asynchronous transformation function.
    /// </summary>
    /// <typeparam name="TSource">The type of the elements of the source sequence.</typeparam>
    /// <typeparam name="TResult">The type of the elements of the resulting sequence.</typeparam>
    /// <param name="source">An <see cref="IAsyncEnumerable{TSource}"/> to invoke a transform function on.</param>
    /// <param name="selector">
    /// A transform function to apply to each element. This function takes an element of
    /// type TSource and returns an element of type TResult.
    /// </param>
    /// <param name="cancellationToken">
    /// A CancellationToken to observe while iterating through the sequence.
    /// </param>
    /// <returns>
    /// An <see cref="IAsyncEnumerable{TResult}"/> whose elements are the result of invoking the transform
    /// function on each element of the original sequence.
    /// </returns>
    /// <exception cref="ArgumentNullException">Thrown when the source or selector is null.</exception>
    public static async IAsyncEnumerable<TResult> Select<TSource, TResult>(
       this IAsyncEnumerable<TSource> source,
       Func<TSource, TResult> selector,
       [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        await foreach (var item in source.WithCancellation(cancellationToken).ConfigureAwait(false))
        {
            yield return selector(item);
        }
    }

    /// <summary>Sorts the elements of a sequence in ascending order.</summary>
    /// <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
    /// <typeparam name="TKey">The type of the key returned by <paramref name="keySelector"/>.</typeparam>
    /// <param name="source">A sequence of values to order.</param>
    /// <param name="keySelector">A function to extract a key from an element.</param>
    /// <returns>An <see cref="IAsyncEnumerable{TElement}"/> whose elements are sorted according to a key.</returns>
    public static async IAsyncEnumerable<TSource> OrderBy<TSource, TKey>(this IAsyncEnumerable<TSource> source, Func<TSource, TKey> keySelector)
    {
        var results = await source.ToArrayAsync().ConfigureAwait(false);
        var keys = results.Select(keySelector).ToArray();
        Array.Sort(keys, results);
        foreach (var result in results)
        {
            yield return result;
        }
    }

    /// <summary>
    /// Creates an array from an async-enumerable sequence.
    /// </summary>
    /// <typeparam name="TSource">The type of the elements in the source sequence.</typeparam>
    /// <param name="source">The source async-enumerable sequence to get an array of elements for.</param>
    /// <param name="cancellationToken">The optional cancellation token to be used for cancelling the sequence at any time.</param>
    /// <returns>An async-enumerable sequence containing a single element with an array containing all the elements of the source sequence.</returns>
    /// <exception cref="ArgumentNullException"><paramref name="source"/> is null.</exception>
    /// <remarks>The return type of this operator differs from the corresponding operator on IEnumerable in order to retain asynchronous behavior.</remarks>
    public static async ValueTask<TSource[]> ToArrayAsync<TSource>(this IAsyncEnumerable<TSource> source, CancellationToken cancellationToken = default)
    {
        List<TSource> results = [];
        await foreach (var result in source.WithCancellation(cancellationToken).ConfigureAwait(false))
        {
            results.Add(result);
        }

        return results.ToArray();
    }

    /// <summary>
    /// Filters the elements of an async-enumerable sequence based on a predicate.
    /// </summary>
    /// <typeparam name="TSource">The type of the elements in the source sequence.</typeparam>
    /// <param name="source">An async-enumerable sequence whose elements to filter.</param>
    /// <param name="predicate">A function to test each source element for a condition.</param>
    /// <returns>An async-enumerable sequence that contains elements from the input sequence that satisfy the condition.</returns>
    /// <exception cref="ArgumentNullException"><paramref name="source"/> or <paramref name="predicate"/> is null.</exception>
    public static async IAsyncEnumerable<TSource> Where<TSource>(this IAsyncEnumerable<TSource> source, Func<TSource, bool> predicate)
    {
        await foreach (var result in source.ConfigureAwait(false))
        {
            if (predicate(result))
            {
                yield return result;
            }
        }
    }

    private sealed class EmptyAsyncEnumerable<T> : IAsyncEnumerable<T>, IAsyncEnumerator<T>
    {
        public static readonly EmptyAsyncEnumerable<T> Instance = new();
        public IAsyncEnumerator<T> GetAsyncEnumerator(CancellationToken cancellationToken = default) => this;
        public ValueTask<bool> MoveNextAsync() => new(false);
        public T Current => default!;
        public ValueTask DisposeAsync() => default;
    }
}


===== src\Linq\EnumerableExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Linq;

[ExcludeFromCodeCoverage]
internal static class EnumerableExtensions
{
    public static IEnumerable<TSource> TakeLast<TSource>(this IEnumerable<TSource> source, int count)
    {
        Debug.Assert(source is not null);

#if NETCOREAPP2_0_OR_GREATER || NETSTANDARD2_1_OR_GREATER
        return Enumerable.TakeLast(source, count);
#else
        return source.Skip(System.Math.Max(0, source.Count() - count));
#endif
    }
}


===== src\Model\Freezable.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Diagnostics.CodeAnalysis;

namespace Microsoft.SemanticKernel;

/// <summary>
/// Represents a freezable object.
/// </summary>
[SuppressMessage("Performance", "CA1812:Avoid uninstantiated internal classes", Justification = "This class is an internal utility.")]
[ExcludeFromCodeCoverage]
internal sealed class Freezable
{
    public bool IsFrozen { get; private set; }

    /// <summary>
    /// Makes the current instance unmodifiable.
    /// </summary>
    public void Freeze()
    {
        if (this.IsFrozen)
        {
            return;
        }

        this.IsFrozen = true;
    }

    /// <summary>
    /// Throws an <see cref="InvalidOperationException"/> if the object is frozen.
    /// </summary>
    /// <exception cref="InvalidOperationException"></exception>
    public void ThrowIfFrozen()
    {
        if (this.IsFrozen)
        {
            throw new InvalidOperationException("The object is frozen and cannot be modified.");
        }
    }
}


===== src\Schema\KernelJsonSchemaBuilder.cs =====

// Copyright (c) Microsoft. All rights reserved.

#pragma warning disable IDE0005 // Using directive is unnecessary.
using System;
#pragma warning restore IDE0005 // Using directive is unnecessary.
using System.Diagnostics.CodeAnalysis;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Text.Json.Serialization.Metadata;
using Microsoft.Extensions.AI;

#pragma warning disable IDE0010 // Add missing cases

namespace Microsoft.SemanticKernel;

// TODO: The JSON schema should match the JsonSerializerOptions used for actually performing
// the serialization, e.g. whether public fields should be included in the schema should
// match whether public fields will be serialized/deserialized. For now we can assume the
// default, but if/when a JSO is able to be provided via a Kernel, we should:
// 1) Use the JSO from the Kernel used to create the KernelFunction when constructing the schema
// 2) Check when the schema is being used (e.g. function calling) whether the JSO being used is equivalent to
//    whichever was used to build the schema, and if it's not, generate a new schema for that JSO
[ExcludeFromCodeCoverage]
internal static class KernelJsonSchemaBuilder
{
    private static JsonSerializerOptions? s_options;
    internal static readonly AIJsonSchemaCreateOptions s_schemaOptions = new();

    private static readonly JsonElement s_trueSchemaAsObject = JsonDocument.Parse("{}").RootElement;
    private static readonly JsonElement s_falseSchemaAsObject = JsonDocument.Parse("""{"not":true}""").RootElement;

    [RequiresUnreferencedCode("Uses reflection to generate JSON schema, making it incompatible with AOT scenarios.")]
    [RequiresDynamicCode("Uses reflection to generate JSON schema, making it incompatible with AOT scenarios.")]
    public static KernelJsonSchema Build(Type type, string? description = null, AIJsonSchemaCreateOptions? configuration = null)
    {
        return Build(type, GetDefaultOptions(), description, configuration);
    }

    public static KernelJsonSchema Build(
        Type type,
        JsonSerializerOptions options,
        string? description = null,
        AIJsonSchemaCreateOptions? configuration = null)
    {
        configuration ??= s_schemaOptions;
        // To be compatible with the previous behavior of MEAI 9.3.0 (when description is empty, should not be included in the schema)
        string? schemaDescription = string.IsNullOrEmpty(description) ? null : description;
        JsonElement schemaDocument = AIJsonUtilities.CreateJsonSchema(type, schemaDescription, serializerOptions: options, inferenceOptions: configuration);
        switch (schemaDocument.ValueKind)
        {
            case JsonValueKind.False:
                schemaDocument = s_falseSchemaAsObject;
                break;
            case JsonValueKind.True:
                schemaDocument = s_trueSchemaAsObject;
                break;
        }

        return KernelJsonSchema.Parse(schemaDocument.GetRawText());
    }

    [RequiresUnreferencedCode("Uses JsonStringEnumConverter and DefaultJsonTypeInfoResolver classes, making it incompatible with AOT scenarios.")]
    [RequiresDynamicCode("Uses JsonStringEnumConverter and DefaultJsonTypeInfoResolver classes, making it incompatible with AOT scenarios.")]
    private static JsonSerializerOptions GetDefaultOptions()
    {
        if (s_options is null)
        {
            JsonSerializerOptions options = new()
            {
                TypeInfoResolver = new DefaultJsonTypeInfoResolver(),
                Converters = { new JsonStringEnumConverter() },
            };
            options.MakeReadOnly();
            s_options = options;
        }

        return s_options;
    }
}


===== src\System\AppContextSwitchHelper.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Diagnostics.CodeAnalysis;

namespace Microsoft.SemanticKernel;

/// <summary>
/// Helper class to get app context switch value
/// </summary>
[ExcludeFromCodeCoverage]
internal static class AppContextSwitchHelper
{
    /// <summary>
    /// Returns the value of the specified app switch or environment variable if it is set.
    /// If the switch or environment variable is not set, return false.
    /// The app switch value takes precedence over the environment variable.
    /// </summary>
    /// <param name="appContextSwitchName">The name of the app switch.</param>
    /// <param name="envVarName">The name of the environment variable.</param>
    /// <returns>The value of the app switch or environment variable if it is set; otherwise, false.</returns>
    public static bool GetConfigValue(string appContextSwitchName, string envVarName)
    {
        if (AppContext.TryGetSwitch(appContextSwitchName, out bool value))
        {
            return value;
        }

        string? envVarValue = Environment.GetEnvironmentVariable(envVarName);
        if (envVarValue != null && bool.TryParse(envVarValue, out value))
        {
            return value;
        }

        return false;
    }
}


===== src\System\EmptyKeyedServiceProvider.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;

namespace Microsoft.Extensions.DependencyInjection;

/// <summary>Provides an implementation of <see cref="IKeyedServiceProvider"/> that contains no services.</summary>
internal sealed class EmptyKeyedServiceProvider : IKeyedServiceProvider
{
    /// <summary>Gets a singleton instance of <see cref="EmptyKeyedServiceProvider"/>.</summary>
    public static EmptyKeyedServiceProvider Instance { get; } = new();

    /// <inheritdoc />
    public object? GetService(Type serviceType) => null;

    /// <inheritdoc />
    public object? GetKeyedService(Type serviceType, object? serviceKey) => null;

    /// <inheritdoc />
    public object GetRequiredKeyedService(Type serviceType, object? serviceKey) =>
        this.GetKeyedService(serviceType, serviceKey) ??
        throw new InvalidOperationException($"No service for type '{serviceType}' and key '{serviceKey}' has been registered.");
}


===== src\System\EnvExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Diagnostics.CodeAnalysis;

namespace System;

[ExcludeFromCodeCoverage]
internal static class EnvExtensions
{
    /// <summary>
    /// Source: https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/src/DiagnosticsOptions.cs
    /// Values: https://learn.microsoft.com/en-us/dotnet/api/azure.core.diagnosticsoptions.istelemetryenabled?view=azure-dotnet
    /// </summary>
    internal static bool? GetBoolEnvVar(string name)
    {
        string? value = Environment.GetEnvironmentVariable(name);

        if (string.Equals(bool.TrueString, value, StringComparison.OrdinalIgnoreCase) ||
            string.Equals("1", value, StringComparison.OrdinalIgnoreCase))
        {
            return true;
        }

        if (string.Equals(bool.FalseString, value, StringComparison.OrdinalIgnoreCase) ||
            string.Equals("0", value, StringComparison.OrdinalIgnoreCase))
        {
            return false;
        }

        return null;
    }
}


===== src\System\IListExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;

namespace Microsoft.SemanticKernel;

[ExcludeFromCodeCoverage]
internal static class IListExtensions
{
    /// <summary>
    /// Adds a range of elements from the specified <see cref="IEnumerable{T}"/> source to the target <see cref="IList{T}"/>.
    /// </summary>
    /// <typeparam name="T">The type of elements in the list.</typeparam>
    /// <param name="target">The target <see cref="IList{T}"/> to add elements to.</param>
    /// <param name="source">The source <see cref="IEnumerable{T}"/> containing elements to add to the target <see cref="IList{T}"/>.</param>
    internal static void AddRange<T>(this IList<T> target, IEnumerable<T> source)
    {
        Debug.Assert(target is not null);
        Debug.Assert(source is not null);

        if (target is List<T> list)
        {
            list.AddRange(source);
        }
        else
        {
            foreach (var item in source!)
            {
                target!.Add(item);
            }
        }
    }
}


===== src\System\IndexRange.cs =====

// Copyright (c) Microsoft. All rights reserved.

#if !NET8_0_OR_GREATER

// Polyfill for using Index and Range with .NET Standard 2.0 (see https://www.meziantou.net/how-to-use-csharp-8-indices-and-ranges-in-dotnet-standard-2-0-and-dotn.htm)

// https://github.com/dotnet/runtime/blob/419e949d258ecee4c40a460fb09c66d974229623/src/libraries/System.Private.CoreLib/src/System/Index.cs
// https://github.com/dotnet/runtime/blob/419e949d258ecee4c40a460fb09c66d974229623/src/libraries/System.Private.CoreLib/src/System/Range.cs

#pragma warning disable RCS1168
#pragma warning disable RCS1211
#pragma warning disable RCS1220
#pragma warning disable IDE0009
#pragma warning disable IDE0011
#pragma warning disable IDE0038
#pragma warning disable IDE0046
#pragma warning disable IDE0048
#pragma warning disable IDE0090
#pragma warning disable IDE0301
#pragma warning disable CS8604

using System.Runtime.CompilerServices;

namespace System
{
    /// <summary>Represent a type can be used to index a collection either from the start or the end.</summary>
    /// <remarks>
    /// Index is used by the C# compiler to support the new index syntax
    /// <code>
    /// int[] someArray = new int[5] { 1, 2, 3, 4, 5 } ;
    /// int lastElement = someArray[^1]; // lastElement = 5
    /// </code>
    /// </remarks>
    internal readonly struct Index : IEquatable<Index>
    {
        private readonly int _value;

        /// <summary>Construct an Index using a value and indicating if the index is from the start or from the end.</summary>
        /// <param name="value">The index value. it has to be zero or positive number.</param>
        /// <param name="fromEnd">Indicating if the index is from the start or from the end.</param>
        /// <remarks>
        /// If the Index constructed from the end, index value 1 means pointing at the last element and index value 0 means pointing at beyond last element.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Index(int value, bool fromEnd = false)
        {
            if (value < 0)
            {
                throw new ArgumentOutOfRangeException(nameof(value), "value must be non-negative");
            }

            if (fromEnd)
                _value = ~value;
            else
                _value = value;
        }

        // The following private constructors mainly created for perf reason to avoid the checks
        private Index(int value)
        {
            _value = value;
        }

        /// <summary>Create an Index pointing at first element.</summary>
        public static Index Start => new Index(0);

        /// <summary>Create an Index pointing at beyond last element.</summary>
        public static Index End => new Index(~0);

        /// <summary>Create an Index from the start at the position indicated by the value.</summary>
        /// <param name="value">The index value from the start.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Index FromStart(int value)
        {
            if (value < 0)
            {
                throw new ArgumentOutOfRangeException(nameof(value), "value must be non-negative");
            }

            return new Index(value);
        }

        /// <summary>Create an Index from the end at the position indicated by the value.</summary>
        /// <param name="value">The index value from the end.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Index FromEnd(int value)
        {
            if (value < 0)
            {
                throw new ArgumentOutOfRangeException(nameof(value), "value must be non-negative");
            }

            return new Index(~value);
        }

        /// <summary>Returns the index value.</summary>
        public int Value
        {
            get
            {
                if (_value < 0)
                {
                    return ~_value;
                }
                else
                {
                    return _value;
                }
            }
        }

        /// <summary>Indicates whether the index is from the start or the end.</summary>
        public bool IsFromEnd => _value < 0;

        /// <summary>Calculate the offset from the start using the giving collection length.</summary>
        /// <param name="length">The length of the collection that the Index will be used with. length has to be a positive value</param>
        /// <remarks>
        /// For performance reason, we don't validate the input length parameter and the returned offset value against negative values.
        /// we don't validate either the returned offset is greater than the input length.
        /// It is expected Index will be used with collections which always have non negative length/count. If the returned offset is negative and
        /// then used to index a collection will get out of range exception which will be same affect as the validation.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetOffset(int length)
        {
            var offset = _value;
            if (IsFromEnd)
            {
                // offset = length - (~value)
                // offset = length + (~(~value) + 1)
                // offset = length + value + 1

                offset += length + 1;
            }
            return offset;
        }

        /// <summary>Indicates whether the current Index object is equal to another object of the same type.</summary>
        /// <param name="value">An object to compare with this object</param>
        public override bool Equals(object? value) => value is Index && _value == ((Index)value)._value;

        /// <summary>Indicates whether the current Index object is equal to another Index object.</summary>
        /// <param name="other">An object to compare with this object</param>
        public bool Equals(Index other) => _value == other._value;

        /// <summary>Returns the hash code for this instance.</summary>
        public override int GetHashCode() => _value;

        /// <summary>Converts integer number to an Index.</summary>
        public static implicit operator Index(int value) => FromStart(value);

        /// <summary>Converts the value of the current Index object to its equivalent string representation.</summary>
        public override string ToString()
        {
            if (IsFromEnd)
                return "^" + ((uint)Value).ToString();

            return ((uint)Value).ToString();
        }
    }

    /// <summary>Represent a range has start and end indexes.</summary>
    /// <remarks>
    /// Range is used by the C# compiler to support the range syntax.
    /// <code>
    /// int[] someArray = new int[5] { 1, 2, 3, 4, 5 };
    /// int[] subArray1 = someArray[0..2]; // { 1, 2 }
    /// int[] subArray2 = someArray[1..^0]; // { 2, 3, 4, 5 }
    /// </code>
    /// </remarks>
    internal readonly struct Range : IEquatable<Range>
    {
        /// <summary>Represent the inclusive start index of the Range.</summary>
        public Index Start { get; }

        /// <summary>Represent the exclusive end index of the Range.</summary>
        public Index End { get; }

        /// <summary>Construct a Range object using the start and end indexes.</summary>
        /// <param name="start">Represent the inclusive start index of the range.</param>
        /// <param name="end">Represent the exclusive end index of the range.</param>
        public Range(Index start, Index end)
        {
            Start = start;
            End = end;
        }

        /// <summary>Indicates whether the current Range object is equal to another object of the same type.</summary>
        /// <param name="value">An object to compare with this object</param>
        public override bool Equals(object? value) =>
            value is Range r &&
            r.Start.Equals(Start) &&
            r.End.Equals(End);

        /// <summary>Indicates whether the current Range object is equal to another Range object.</summary>
        /// <param name="other">An object to compare with this object</param>
        public bool Equals(Range other) => other.Start.Equals(Start) && other.End.Equals(End);

        /// <summary>Returns the hash code for this instance.</summary>
        public override int GetHashCode()
        {
            return Start.GetHashCode() * 31 + End.GetHashCode();
        }

        /// <summary>Converts the value of the current Range object to its equivalent string representation.</summary>
        public override string ToString()
        {
            return Start + ".." + End;
        }

        /// <summary>Create a Range object starting from start index to the end of the collection.</summary>
        public static Range StartAt(Index start) => new Range(start, Index.End);

        /// <summary>Create a Range object starting from first element in the collection to the end Index.</summary>
        public static Range EndAt(Index end) => new Range(Index.Start, end);

        /// <summary>Create a Range object starting from first element to the end.</summary>
        public static Range All => new Range(Index.Start, Index.End);

        /// <summary>Calculate the start offset and length of range object using a collection length.</summary>
        /// <param name="length">The length of the collection that the range will be used with. length has to be a positive value.</param>
        /// <remarks>
        /// For performance reason, we don't validate the input length parameter against negative values.
        /// It is expected Range will be used with collections which always have non negative length/count.
        /// We validate the range is inside the length scope though.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public (int Offset, int Length) GetOffsetAndLength(int length)
        {
            int start;
            var startIndex = Start;
            if (startIndex.IsFromEnd)
                start = length - startIndex.Value;
            else
                start = startIndex.Value;

            int end;
            var endIndex = End;
            if (endIndex.IsFromEnd)
                end = length - endIndex.Value;
            else
                end = endIndex.Value;

            if ((uint)end > (uint)length || (uint)start > (uint)end)
            {
                throw new ArgumentOutOfRangeException(nameof(length));
            }

            return (start, end - start);
        }
    }
}

namespace System.Runtime.CompilerServices
{
    internal static class RuntimeHelpers
    {
        /// <summary>
        /// Slices the specified array using the specified range.
        /// </summary>
        public static T[] GetSubArray<T>(T[] array, Range range)
        {
            if (array == null)
            {
                throw new ArgumentNullException(nameof(array));
            }

            (int offset, int length) = range.GetOffsetAndLength(array.Length);

            if (default(T) != null || typeof(T[]) == array.GetType())
            {
                // We know the type of the array to be exactly T[].

                if (length == 0)
                {
                    return Array.Empty<T>();
                }

                var dest = new T[length];
                Array.Copy(array, offset, dest, 0, length);
                return dest;
            }
            else
            {
                // The array is actually a U[] where U:T.
                var dest = (T[])Array.CreateInstance(array.GetType().GetElementType(), length);
                Array.Copy(array, offset, dest, 0, length);
                return dest;
            }
        }
    }
}

#endif


===== src\System\InternalTypeConverter.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Concurrent;
using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;

namespace Microsoft.SemanticKernel;

/// <summary>
/// Provides internal utility methods for converting types to strings with consideration for CultureInfo.
/// </summary>
[ExcludeFromCodeCoverage]
internal static class InternalTypeConverter
{
    /// <summary>
    /// Converts the given object value to a string representation using the appropriate CultureInfo.
    /// </summary>
    /// <param name="value">The object to convert.</param>
    /// <param name="culture">The CultureInfo to consider during conversion.</param>
    /// <returns>A string representation of the object value, considering the specified CultureInfo.</returns>
    public static string? ConvertToString(object? value, CultureInfo? culture = null)
    {
        if (value is null) { return null; }

        var sourceType = value.GetType();

        var converterDelegate = GetTypeToStringConverterDelegate(sourceType);

        return converterDelegate is null
            ? value.ToString()
            : converterDelegate(value, culture ?? CultureInfo.InvariantCulture);
    }

    /// <summary>
    /// Retrieves a type-to-string converter delegate for the specified source type.
    /// </summary>
    /// <param name="sourceType">The source Type for which to retrieve the type-to-string converter delegate.</param>
    /// <returns>A Func delegate for converting the source type to a string, considering CultureInfo, or null if no suitable converter is found.</returns>
    private static Func<object?, CultureInfo, string?>? GetTypeToStringConverterDelegate(Type sourceType) =>
        s_converters.GetOrAdd(sourceType, static sourceType =>
        {
            // Strings just render as themselves.
            if (sourceType == typeof(string))
            {
                return (input, cultureInfo) => (string)input!;
            }

            // Look up and use a type converter.
            if (TypeConverterFactory.GetTypeConverter(sourceType) is TypeConverter converter && converter.CanConvertTo(typeof(string)))
            {
                return (input, cultureInfo) =>
                {
                    return converter.ConvertToString(context: null, cultureInfo, input);
                };
            }

            return null;
        });

    /// <summary>Converter functions for converting types to strings.</summary>
    private static readonly ConcurrentDictionary<Type, Func<object?, CultureInfo, string?>?> s_converters = new();
}


===== src\System\NonNullCollection.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;

namespace Microsoft.SemanticKernel;

/// <summary>
/// Provides a collection of non-null items.
/// </summary>
[ExcludeFromCodeCoverage]
[SuppressMessage("Performance", "CA1812:Avoid uninstantiated internal classes", Justification = "This class is an internal utility.")]
internal sealed class NonNullCollection<T> : IList<T>, IReadOnlyList<T>
{
    /// <summary>
    /// The underlying list of items.
    /// </summary>
    private readonly List<T> _items;

    /// <summary>
    /// Initializes a new instance of the <see cref="NonNullCollection{T}"/> class.
    /// </summary>
    public NonNullCollection() => this._items = [];

    /// <summary>
    /// Initializes a new instance of the <see cref="NonNullCollection{T}"/> class.
    /// </summary>
    /// <param name="items">The initial collection of items to populate this collection.</param>
    public NonNullCollection(IEnumerable<T> items)
    {
        Verify.NotNull(items);
        this._items = new(items);
    }

    /// <summary>
    /// Gets or sets the item at the specified index in the collection.
    /// </summary>
    /// <param name="index">The index of the item to get or set.</param>
    /// <returns>The item at the specified index.</returns>
    /// <exception cref="ArgumentNullException"><paramref name="value"/> is null.</exception>
    /// <exception cref="ArgumentOutOfRangeException">The <paramref name="index"/> was not valid for this collection.</exception>
    public T this[int index]
    {
        get => this._items[index];
        set
        {
            Verify.NotNull(value);
            this._items[index] = value;
        }
    }

    /// <summary>
    /// Gets the number of items in the collection.
    /// </summary>
    public int Count => this._items.Count;

    /// <summary>
    /// Adds an item to the collection.
    /// </summary>
    /// <param name="item">The item to add.</param>
    /// <exception cref="ArgumentNullException"><paramref name="item"/> is null.</exception>
    public void Add(T item)
    {
        Verify.NotNull(item);
        this._items.Add(item);
    }

    /// <summary>
    /// Removes all items from the collection.
    /// </summary>
    public void Clear() => this._items.Clear();

    /// <summary>
    /// Determines whether an item is in the collection.
    /// </summary>
    /// <param name="item">The item to locate.</param>
    /// <returns>True if the item is found in the collection; otherwise, false.</returns>
    /// <exception cref="ArgumentNullException"><paramref name="item"/> is null.</exception>
    public bool Contains(T item)
    {
        Verify.NotNull(item);
        return this._items.Contains(item);
    }

    /// <summary>
    /// Copies all of the items in the collection to an array, starting at the specified destination array index.
    /// </summary>
    /// <param name="array">The destination array into which the items should be copied.</param>
    /// <param name="arrayIndex">The zero-based index into <paramref name="array"/> at which copying should begin.</param>
    /// <exception cref="ArgumentNullException"><paramref name="array"/> is null.</exception>
    /// <exception cref="ArgumentException">The number of items in the collection is greater than the available space from <paramref name="arrayIndex"/> to the end of <paramref name="array"/>.</exception>
    /// <exception cref="ArgumentOutOfRangeException"><paramref name="arrayIndex"/> is less than 0.</exception>
    public void CopyTo(T[] array, int arrayIndex) => this._items.CopyTo(array, arrayIndex);

    /// <summary>
    /// Searches for the specified item and returns the index of the first occurrence.
    /// </summary>
    /// <param name="item">The item to locate.</param>
    /// <returns>The index of the first found occurrence of the specified item; -1 if the item could not be found.</returns>
    public int IndexOf(T item)
    {
        Verify.NotNull(item);
        return this._items.IndexOf(item);
    }

    /// <summary>
    /// Inserts an item into the collection at the specified index.
    /// </summary>
    /// <param name="index">The index at which the item should be inserted.</param>
    /// <param name="item">The item to insert.</param>
    /// <exception cref="ArgumentNullException"><paramref name="item"/> is null.</exception>
    public void Insert(int index, T item)
    {
        Verify.NotNull(item);
        this._items.Insert(index, item);
    }

    /// <summary>
    /// Removes the first occurrence of the specified item from the collection.
    /// </summary>
    /// <param name="item">The item to remove from the collection.</param>
    /// <returns>True if the item was successfully removed; false if it wasn't located in the collection.</returns>
    /// <exception cref="ArgumentNullException"><paramref name="item"/> is null.</exception>
    public bool Remove(T item)
    {
        Verify.NotNull(item);
        return this._items.Remove(item);
    }

    /// <summary>
    /// Removes the item at the specified index from the collection.
    /// </summary>
    /// <param name="index">The index of the item to remove.</param>
    public void RemoveAt(int index) => this._items.RemoveAt(index);

    bool ICollection<T>.IsReadOnly => false;

    IEnumerator IEnumerable.GetEnumerator() => this._items.GetEnumerator();

    IEnumerator<T> IEnumerable<T>.GetEnumerator() => this._items.GetEnumerator();
}


===== src\System\TypeConverterFactory.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;

namespace Microsoft.SemanticKernel;

/// <summary>
/// Factory for creating TypeConverter instances based on a provided type.
/// </summary>
[ExcludeFromCodeCoverage]
internal static class TypeConverterFactory
{
    /// <summary>
    /// Returns a TypeConverter instance for the specified type.
    /// </summary>
    /// <param name="type">The Type of the object to convert.</param>
    /// <returns>A TypeConverter instance if a suitable converter is found, otherwise null.</returns>
    internal static TypeConverter? GetTypeConverter(Type type)
    {
        // In an ideal world, this would use TypeDescriptor.GetConverter. However, that is not friendly to
        // any form of ahead-of-time compilation, as it could end up requiring functionality that was trimmed.
        // Instead, we just use a hard-coded set of converters for the types we know about and then also support
        // types that are explicitly attributed with TypeConverterAttribute.

        if (type == typeof(string)) { return new StringConverter(); }
        if (type == typeof(byte)) { return new ByteConverter(); }
        if (type == typeof(sbyte)) { return new SByteConverter(); }
        if (type == typeof(bool)) { return new BooleanConverter(); }
        if (type == typeof(ushort)) { return new UInt16Converter(); }
        if (type == typeof(short)) { return new Int16Converter(); }
        if (type == typeof(char)) { return new CharConverter(); }
        if (type == typeof(uint)) { return new UInt32Converter(); }
        if (type == typeof(int)) { return new Int32Converter(); }
        if (type == typeof(ulong)) { return new UInt64Converter(); }
        if (type == typeof(long)) { return new Int64Converter(); }
        if (type == typeof(float)) { return new SingleConverter(); }
        if (type == typeof(double)) { return new DoubleConverter(); }
        if (type == typeof(decimal)) { return new DecimalConverter(); }
        if (type == typeof(TimeSpan)) { return new TimeSpanConverter(); }
        if (type == typeof(DateTime)) { return new DateTimeConverter(); }
        if (type == typeof(DateTimeOffset)) { return new DateTimeOffsetConverter(); }
        if (type == typeof(Uri)) { return new UriTypeConverter(); }
        if (type == typeof(Guid)) { return new GuidConverter(); }
        if (type.IsEnum) { return CreateEnumConverter(type); }

        if (type.GetCustomAttribute<TypeConverterAttribute>() is TypeConverterAttribute tca &&
            Type.GetType(tca.ConverterTypeName, throwOnError: false) is Type converterType &&
            Activator.CreateInstance(converterType) is TypeConverter converter)
        {
            return converter;
        }

        return null;
    }

    [UnconditionalSuppressMessage("ReflectionAnalysis", "IL2067:UnrecognizedReflectionPattern", Justification = "Trimmer does not trim enums. See the PR - https://github.com/dotnet/runtime/pull/100347 for more details.")]
    private static EnumConverter CreateEnumConverter(Type type)
    {
        Debug.Assert(type.IsEnum || type == typeof(Enum));
        return new EnumConverter(type);
    }
}


===== src\System\ValueTaskExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

#if !NETCOREAPP

using System;
using System.Threading.Tasks;

/// <summary>
/// Convenience extensions for ValueTask patterns within .netstandard2.0 projects.
/// </summary>
internal static class ValueTaskExtensions
{
    /// <summary>
    /// Creates a <see cref="ValueTask{TResult}"/> that's completed successfully with the specified result.
    /// </summary>
    /// <example>
    /// <c>
    /// int value = 33;
    /// return value.AsValueTask();
    /// </c>
    /// </example>
    public static ValueTask<TValue> AsValueTask<TValue>(this TValue value) => new(value);

    /// <summary>
    /// Creates a <see cref="ValueTask{TResult}"/> that's failed and is associated with an exception.
    /// </summary>
    /// <example>
    /// <c>
    /// int value = 33;
    /// return value.AsValueTask();
    /// </c>
    /// </example>
    public static ValueTask<TValue> AsValueTask<TValue>(this Exception exception) => new(Task.FromException<TValue>(exception));

    /// <summary>
    /// Present a regular task as a ValueTask.
    /// </summary>
    /// <example>
    /// <c>return Task.CompletedTask.AsValueTask();</c>
    /// </example>
    public static ValueTask AsValueTask(this Task task) => new(task);
}

#endif


===== src\Text\BoolJsonConverter.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Diagnostics.CodeAnalysis;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace Microsoft.SemanticKernel.Text;

#pragma warning disable CA1812 // Instantiated via JsonConverterAttribute

/// <summary>
/// Deserializes a bool from a string. This is useful when deserializing a <see cref="PromptExecutionSettings"/> instance that contains bool properties.
/// Serializing a <see cref="PromptExecutionSettings"/> instance without this converter will throw a 'System.Text.Json.JsonException : The JSON value could not be converted to System.Nullable'
/// if there are any bool properties.
/// </summary>
[ExcludeFromCodeCoverage]
internal sealed class BoolJsonConverter : JsonConverter<bool>
{
    /// <inheritdoc/>
    public override bool Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        if (reader.TokenType == JsonTokenType.String)
        {
            string? value = reader.GetString();
            if (value is null)
            {
                return false;
            }
            if (bool.TryParse(value, out var boolValue))
            {
                return boolValue;
            }

            throw new ArgumentException($"Value '{value}' can be parsed as a boolean value");
        }
        else if (reader.TokenType == JsonTokenType.True)
        {
            return true;
        }
        else if (reader.TokenType == JsonTokenType.False)
        {
            return false;
        }

        throw new ArgumentException($"Invalid token type found '{reader.TokenType}', expected a boolean value.");
    }

    /// <inheritdoc/>
    public override void Write(Utf8JsonWriter writer, bool value, JsonSerializerOptions options)
    {
        writer.WriteBooleanValue(value);
    }
}


===== src\Text\DataUriParser.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;

#pragma warning disable CA1307 // Specify StringComparison
#pragma warning disable CA1847 // Use StringBuilder.Append when concatenating strings

namespace Microsoft.SemanticKernel.Text;

/// <summary>
/// Data Uri Scheme Parser based on RFC 2397.
/// https://datatracker.ietf.org/doc/html/rfc2397
/// </summary>
[ExcludeFromCodeCoverage]
internal static class DataUriParser
{
    private const string Scheme = "data:";

    private static readonly char[] s_base64Chars = {
            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'
        };
    /// <summary>
    /// Extension method to test whether the value is a base64 string
    /// </summary>
    /// <param name="value">Value to test</param>
    /// <returns>Boolean value, true if the string is base64, otherwise false</returns>
    private static bool IsBase64String(string? value)
    {
        // The quickest test. If the value is null or is equal to 0 it is not base64
        // Base64 string's length is always divisible by four, i.e. 8, 16, 20 etc. 
        // If it is not you can return false. Quite effective
        // Further, if it meets the above criteria, then test for spaces.
        // If it contains spaces, it is not base64
        if (value is null
            || value.Length == 0
            || value.Length % 4 != 0
            || value.Contains(' ')
            || value.Contains('\t')
            || value.Contains('\r')
            || value.Contains('\n'))
        {
            return false;
        }

        // 98% of all non base64 values are invalidated by this time.
        var index = value.Length - 1;

        // if there is padding step back
        if (value[index] == '=') { index--; }

        // if there are two padding chars step back a second time
        if (value[index] == '=') { index--; }

        // Now traverse over characters
        for (var i = 0; i <= index; i++)
        {
            // If any of the character is not from the allowed list
            if (!s_base64Chars.Contains(value[i]))
            {
                // return false
                return false;
            }
        }

        // If we got here, then the value is a valid base64 string
        return true;
    }

    internal static DataUri Parse(string? dataUri)
    {
        Verify.NotNullOrWhiteSpace(dataUri, nameof(dataUri));
        if (!dataUri.StartsWith(Scheme, StringComparison.OrdinalIgnoreCase))
        {
            throw new UriFormatException("Invalid data uri format. The data URI must start with 'data:'.");
        }

        var model = new DataUri();
        int currentIndex = Scheme.Length;
        int dataIndex = dataUri.IndexOf(',', currentIndex);

        if (dataIndex == -1)
        {
            throw new UriFormatException("Invalid data uri format. The data URI must contain a comma separating the metadata and the data.");
        }

        string metadata = dataUri.Substring(currentIndex, dataIndex - currentIndex);
        model.Data = dataUri.Substring(dataIndex + 1);

        // Split the metadata into components
        var metadataParts = metadata.Split(';');
        if (metadataParts.Length > 0)
        {
            if (!string.IsNullOrWhiteSpace(metadataParts[0]) && !metadataParts[0].Contains("/"))
            {
                throw new UriFormatException("Invalid data uri format. When provided, the MIME type must have \"type/subtype\" format.");
            }

            // First part is the MIME type
            model.MimeType = metadataParts[0];
        }

        for (int i = 1; i < metadataParts.Length; i++)
        {
            var part = metadataParts[i];
            if (part!.Contains("="))
            {
                var keyValue = part.Split('=');

                // Parameter must have a name and cannot have more than one '=' for values.
                if (string.IsNullOrWhiteSpace(keyValue[0]) || keyValue.Length != 2)
                {
                    throw new UriFormatException("Invalid data uri format. Parameters must have \"name=value\" format.");
                }

                model.Parameters[keyValue[0]] = keyValue[1];

                continue;
            }

            if (i < metadataParts.Length - 1)
            {
                throw new UriFormatException("Invalid data uri format. Parameters must have \"name=value\" format.");
            }

            model.DataFormat = part;
        }

        if (string.Equals(model.DataFormat, "base64", StringComparison.OrdinalIgnoreCase) && !IsBase64String(model.Data))
        {
            throw new UriFormatException("Invalid data uri format. The data is not a valid Base64 string.");
        }

        if (string.IsNullOrEmpty(model.MimeType))
        {
            // By RFC 2397, the default MIME type if not provided is text/plain;charset=US-ASCII
            model.MimeType = "text/plain";
        }

        return model;
    }

    /// <summary>
    /// Represents the data URI parts.
    /// </summary>
    internal sealed class DataUri
    {
        /// <summary>
        /// The mime type of the data.
        /// </summary>
        internal string? MimeType { get; set; }

        /// <summary>
        /// The optional parameters of the data.
        /// </summary>
        internal Dictionary<string, string> Parameters { get; set; } = new();

        /// <summary>
        /// The optional format of the data. Most common is "base64".
        /// </summary>
        public string? DataFormat { get; set; }

        /// <summary>
        /// The data content.
        /// </summary>
        public string? Data { get; set; }
    }
}


===== src\Text\ExceptionJsonConverter.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Diagnostics.CodeAnalysis;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace Microsoft.SemanticKernel.Text;

/// <summary>
/// Serializes an exception as a string. This is useful when serializing an instance of an exception directly or indirectly via serializing an instance that
/// references an exception. For example, when serializing chat history that contains FunctionCallContent or FunctionResultContent items referencing an exception.
/// Serializing an exception without this converter will throw a System.NotSupportedException: Serialization and deserialization of System.Reflection.MethodBase instances is not supported. Path: $.Items.Exception.TargetSite.
/// </summary>
[ExcludeFromCodeCoverage]
internal sealed class ExceptionJsonConverter : JsonConverter<object>
{
    private const string ClassNamePropertyName = "className";
    private const string MessagePropertyName = "message";
    private const string InnerExceptionPropertyName = "innerException";
    private const string StackTracePropertyName = "stackTraceString";

    /// <inheritdoc/>
    public override bool CanConvert(Type typeToConvert)
    {
        return typeof(Exception).IsAssignableFrom(typeToConvert);
    }

    /// <inheritdoc/>
    public override void Write(Utf8JsonWriter writer, object value, JsonSerializerOptions options)
    {
        if (value is Exception ex)
        {
            writer.WriteStartObject();
            writer.WriteString(ClassNamePropertyName, ex.GetType().ToString());
            writer.WriteString(MessagePropertyName, ex.Message);
            if (ex.InnerException is Exception innerEx)
            {
                writer.WritePropertyName(InnerExceptionPropertyName);
                this.Write(writer, innerEx, options);
            }

            writer.WriteString(StackTracePropertyName, ex.StackTrace);
            writer.WriteEndObject();
        }
    }

    /// <inheritdoc/>
    public override object? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        throw new NotImplementedException();
    }
}


===== src\Text\JsonOptionsCache.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Diagnostics.CodeAnalysis;
using System.Text.Json;

namespace Microsoft.SemanticKernel.Text;

/// <summary>Caches common configurations of <see cref="JsonSerializerOptions"/>.</summary>\
/// <remarks>
/// All of the instances include a converter for <see cref="ReadOnlyMemory{T}"/>.
/// Once the System.Text.Json package is upgraded to 8.0+, this will no longer be
/// necessary and the actual default can be used.
/// </remarks>
[ExcludeFromCodeCoverage]
internal static class JsonOptionsCache
{
    /// <summary>
    /// Cached <see cref="JsonSerializerOptions"/> instance for reading and writing JSON using the default settings.
    /// </summary>
    public static JsonSerializerOptions Default { get; } = new();

    /// <summary>
    /// Cached <see cref="JsonSerializerOptions"/> instance for writing JSON with indentation.
    /// </summary>
    public static JsonSerializerOptions WriteIndented { get; } = new()
    {
        WriteIndented = true,
    };

    /// <summary>
    /// Cached <see cref="JsonSerializerOptions"/> instance for reading JSON in a permissive way,
    /// including support for trailing commas, case-insensitive property names, and comments.
    /// </summary>
    public static JsonSerializerOptions ReadPermissive { get; } = new()
    {
        AllowTrailingCommas = true,
        PropertyNameCaseInsensitive = true,
        ReadCommentHandling = JsonCommentHandling.Skip,
    };

    /// <summary>
    /// Gets the <see cref="JsonSerializerOptions"/> configured for serializing chat history data.
    /// </summary>
    public static JsonSerializerOptions ChatHistory { get; } = new()
    {
        Converters = { new ExceptionJsonConverter() }
    };
}


===== src\Text\OptionalBoolJsonConverter.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Diagnostics.CodeAnalysis;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace Microsoft.SemanticKernel.Text;

#pragma warning disable CA1812 // Instantiated via JsonConverterAttribute

/// <summary>
/// Deserializes a bool from a string. This is useful when deserializing a <see cref="PromptExecutionSettings"/> instance that contains bool properties.
/// Serializing a <see cref="PromptExecutionSettings"/> instance without this converter will throw a 'System.Text.Json.JsonException : The JSON value could not be converted to System.Nullable'
/// if there are any bool properties.
/// </summary>
[ExcludeFromCodeCoverage]
internal sealed class OptionalBoolJsonConverter : JsonConverter<bool?>
{
    /// <inheritdoc/>
    public override bool? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        if (reader.TokenType == JsonTokenType.String)
        {
            string? value = reader.GetString();
            if (value is null)
            {
                return null;
            }
            if (bool.TryParse(value, out var boolValue))
            {
                return boolValue;
            }

            throw new ArgumentException($"Value '{value}' can be parsed as a boolean value");
        }
        else if (reader.TokenType == JsonTokenType.True)
        {
            return true;
        }
        else if (reader.TokenType == JsonTokenType.False)
        {
            return false;
        }
        else if (reader.TokenType == JsonTokenType.Null)
        {
            return null;
        }

        throw new ArgumentException($"Invalid token type found '{reader.TokenType}', expected a boolean value.");
    }

    /// <inheritdoc/>
    public override void Write(Utf8JsonWriter writer, bool? value, JsonSerializerOptions options)
    {
        if (value is null)
        {
            writer.WriteNullValue();
        }
        else
        {
            writer.WriteBooleanValue((bool)value);
        }
    }
}


===== src\Text\SseData.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Diagnostics.CodeAnalysis;

namespace Microsoft.SemanticKernel.Text;

#pragma warning disable CA1812 // Avoid uninstantiated internal classes

/// <summary>
/// Represents a single Server-Sent Events (SSE) data object.
/// </summary>
[ExcludeFromCodeCoverage]
internal sealed class SseData
{
    /// <summary>
    /// The name of the sse event.
    /// </summary>
    public string? EventName { get; }

    /// <summary>
    /// Represents the type of data parsed from SSE message.
    /// </summary>
    public Type DataType { get; }

    /// <summary>
    /// Represents the data parsed from SSE message.
    /// </summary>
    public object Data { get; }

    /// <summary>
    /// Represents a single Server-Sent Events (SSE) data object.
    /// </summary>
    /// <param name="eventName">The name of the sse event.</param>
    /// <param name="data">The data parsed from SSE message.</param>
    public SseData(string? eventName, object data)
    {
        Verify.NotNull(data);

        this.EventName = eventName;
        this.DataType = data.GetType();
        this.Data = data;
    }
}


===== src\Text\SseJsonParser.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Runtime.CompilerServices;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;

namespace Microsoft.SemanticKernel.Text;

/// <summary>
/// Internal class for parsing Server-Sent Events (SSE) data from a stream.
/// </summary>
/// <remarks>
/// This is specialized parser for Server-Sent Events (SSE) data that is formatted as JSON.<br/>
/// If you need to parse non-structured json streaming data, use <see cref="StreamJsonParser"/> instead.<br/>
/// <a href="https://html.spec.whatwg.org/multipage/server-sent-events.html#parsing-an-event-stream">SSE specification</a><br/>
/// This class is thread-safe.
/// </remarks>
[ExcludeFromCodeCoverage]
internal static class SseJsonParser
{
    /// <summary>
    /// Parses Server-Sent Events (SSE) data asynchronously from a stream.
    /// </summary>
    /// <param name="stream">The stream containing the SSE data.</param>
    /// <param name="parser">The function to parse each <see cref="SseLine"/> into an <see cref="SseData"/> object.</param>
    /// <param name="cancellationToken">A cancellation token to stop the parsing process.</param>
    /// <remarks><paramref name="stream"/> will be disposed immediately once enumeration is complete.</remarks>
    /// <returns>An asynchronous enumerable sequence of <see cref="SseData"/> objects.</returns>
    internal static async IAsyncEnumerable<SseData> ParseAsync(
        Stream stream,
        Func<SseLine, SseData?> parser,
        [EnumeratorCancellation] CancellationToken cancellationToken)
    {
        try
        {
            using SseReader sseReader = new(stream);
            while (!cancellationToken.IsCancellationRequested)
            {
                SseLine? sseLine = await sseReader.ReadSingleDataEventAsync(cancellationToken).ConfigureAwait(false);
                if (sseLine is null)
                {
                    break; // end of stream
                }

                ReadOnlyMemory<char> value = sseLine.Value.FieldValue;
                if (value.Span.SequenceEqual("[DONE]".AsSpan()))
                {
                    break;
                }

                var sseData = parser(sseLine.Value);
                if (sseData is not null)
                {
                    yield return sseData;
                }
            }
        }
        finally
        {
            // Always dispose the stream immediately once enumeration is complete for any reason
#if NETCOREAPP3_0_OR_GREATER
            await stream.DisposeAsync().ConfigureAwait(false);
#else
            stream.Dispose();
#endif
        }
    }

    /// <summary>
    /// Parses Server-Sent Events (SSE) data asynchronously from a stream and deserializes the data into the specified type.
    /// </summary>
    /// <typeparam name="T">The type to deserialize the data into.</typeparam>
    /// <param name="stream">The stream containing the SSE data.</param>
    /// <param name="cancellationToken">A cancellation token to stop the parsing process.</param>
    /// <returns>An asynchronous enumerable sequence of deserialized objects of type <typeparamref name="T"/>.</returns>
    internal static async IAsyncEnumerable<T> ParseAsync<T>(Stream stream, [EnumeratorCancellation] CancellationToken cancellationToken)
    {
        await foreach (var sseData in ParseAsync(stream, DeserializeTargetType, cancellationToken).ConfigureAwait(false))
        {
            yield return (T)sseData.Data;
        }

        static SseData? DeserializeTargetType(SseLine sseLine)
        {
            var obj = JsonSerializer.Deserialize<T>(sseLine.FieldValue.Span, JsonOptionsCache.ReadPermissive);
            return new SseData(sseLine.EventName, obj!);
        }
    }
}


===== src\Text\SseLine.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Diagnostics.CodeAnalysis;

namespace Microsoft.SemanticKernel.Text;

/// <summary>
/// Represents a line of a Server-Sent Events (SSE) stream.
/// </summary>
/// <remarks>
/// <a href="https://html.spec.whatwg.org/multipage/server-sent-events.html#parsing-an-event-stream">SSE specification</a>
/// </remarks>
[ExcludeFromCodeCoverage]
internal readonly struct SseLine : IEquatable<SseLine>
{
    private readonly string _original;
    private readonly int _colonIndex;
    private readonly int _valueIndex;

    /// <summary>
    /// Represents an empty SSE line.
    /// </summary>
    /// <remarks>
    /// The <see cref="Empty"/> property is a static instance of the <see cref="SseLine"/> struct.
    /// </remarks>
    internal static SseLine Empty { get; } = new(string.Empty, 0, false, null);

    internal SseLine(string original, int colonIndex, bool hasSpaceAfterColon, string? lastEventName)
    {
        this._original = original;
        this._colonIndex = colonIndex;
        this._valueIndex = colonIndex >= 0 ? colonIndex + (hasSpaceAfterColon ? 2 : 1) : -1;
        if (this._valueIndex >= this._original.Length)
        {
            this._valueIndex = -1;
        }

        this.EventName = lastEventName;
    }

    /// <summary>
    /// The name of the last event for the Server-Sent Events (SSE) line.
    /// </summary>
    public string? EventName { get; }

    /// <summary>
    /// Determines whether the SseLine is empty.
    /// </summary>
    public bool IsEmpty => this._original.Length == 0;

    /// <summary>
    /// Gets a value indicating whether the value of the SseLine is empty.
    /// </summary>
    public bool IsValueEmpty => this._valueIndex < 0;

    /// <summary>
    /// Determines whether the SseLine is comment line.
    /// </summary>
    public bool IsComment => !this.IsEmpty && this._original[0] == ':';

    /// <summary>
    /// Represents a field name in a Server-Sent Events (SSE) line.
    /// </summary>
    public ReadOnlyMemory<char> FieldName => this._colonIndex >= 0 ? this._original.AsMemory(0, this._colonIndex) : this._original.AsMemory();

    /// <summary>
    /// Represents a field value in Server-Sent Events (SSE) format.
    /// </summary>
    public ReadOnlyMemory<char> FieldValue => this._valueIndex >= 0 ? this._original.AsMemory(this._valueIndex) : string.Empty.AsMemory();

    /// <inheritdoc />
    public override string ToString() => this._original;

    /// <inheritdoc />
    public bool Equals(SseLine other) => this._original.Equals(other._original, StringComparison.Ordinal);

    /// <inheritdoc />
    public override bool Equals(object? obj) => obj is SseLine other && this.Equals(other);

    /// <inheritdoc />
    public override int GetHashCode() => StringComparer.Ordinal.GetHashCode(this._original);

    /// <summary>
    /// Defines the equality operator for comparing two instances of the SseLine class.
    /// </summary>
    public static bool operator ==(SseLine left, SseLine right) => left.Equals(right);

    /// <summary>
    /// Represents the inequality operator for comparing two SseLine objects.
    /// </summary>
    public static bool operator !=(SseLine left, SseLine right) => !left.Equals(right);
}


===== src\Text\SseReader.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Threading;
using System.Threading.Tasks;

namespace Microsoft.SemanticKernel.Text;

/// <summary>
/// Provides a reader for Server-Sent Events (SSE) data.
/// </summary>
/// <remarks>
/// <a href="https://html.spec.whatwg.org/multipage/server-sent-events.html#parsing-an-event-stream">SSE specification</a>
/// </remarks>
[ExcludeFromCodeCoverage]
internal sealed class SseReader(Stream stream) : IDisposable
{
    private readonly Stream _stream = stream;
    private readonly StreamReader _reader = new(stream);
    private string? _lastEventName;

    public SseLine? ReadSingleDataEvent()
    {
        while (this.ReadLine() is { } line)
        {
            if (line.IsEmpty)
            {
                this._lastEventName = null;
                continue;
            }

            if (line.IsComment)
            {
                continue;
            }

            if (line.FieldName.Span.SequenceEqual("event".AsSpan()))
            {
                // Save the last event name
                this._lastEventName = line.FieldValue.ToString();
                continue;
            }

            if (!line.FieldName.Span.SequenceEqual("data".AsSpan()))
            {
                // Skip non-data fields
                continue;
            }

            if (!line.IsValueEmpty)
            {
                // Return data field
                return line;
            }
        }

        return null;
    }

    public async Task<SseLine?> ReadSingleDataEventAsync(CancellationToken cancellationToken)
    {
        while (await this.ReadLineAsync(cancellationToken).ConfigureAwait(false) is { } line)
        {
            if (line.IsEmpty)
            {
                this._lastEventName = null;
                continue;
            }

            if (line.IsComment)
            {
                continue;
            }

            if (line.FieldName.Span.SequenceEqual("event".AsSpan()))
            {
                // Save the last event name
                this._lastEventName = line.FieldValue.ToString();
                continue;
            }

            if (!line.FieldName.Span.SequenceEqual("data".AsSpan()))
            {
                // Skip non-data fields
                continue;
            }

            if (!line.IsValueEmpty)
            {
                // Return data field
                return line;
            }
        }

        return null;
    }

    private SseLine? ReadLine()
    {
        string? lineText = this._reader.ReadLine();
        if (lineText is null)
        {
            return null;
        }

        if (lineText.Length == 0)
        {
            return SseLine.Empty;
        }

        if (this.TryParseLine(lineText, out SseLine line))
        {
            return line;
        }

        return null;
    }

    private async Task<SseLine?> ReadLineAsync(CancellationToken cancellationToken)
    {
        string? lineText = await this._reader.ReadLineAsync(
#if NET
            cancellationToken
#endif
            ).ConfigureAwait(false);

        if (lineText is null)
        {
            return null;
        }

        if (lineText.Length == 0)
        {
            return SseLine.Empty;
        }

        if (this.TryParseLine(lineText, out SseLine line))
        {
            return line;
        }

        return null;
    }

    private bool TryParseLine(string lineText, out SseLine line)
    {
        if (lineText.Length == 0)
        {
            line = default;
            return false;
        }

        ReadOnlySpan<char> lineSpan = lineText.AsSpan();
        int colonIndex = lineSpan.IndexOf(':');
        ReadOnlySpan<char> fieldValue = colonIndex >= 0 ? lineSpan.Slice(colonIndex + 1) : string.Empty.AsSpan();

        bool hasSpace = fieldValue.Length > 0 && fieldValue[0] == ' ';
        line = new SseLine(lineText, colonIndex, hasSpace, this._lastEventName);
        return true;
    }

    public void Dispose()
    {
        this._reader.Dispose();
        this._stream.Dispose();
    }
}


===== src\Text\StreamJsonParser.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Runtime.CompilerServices;
using System.Text;
using System.Text.Json.Nodes;
using System.Threading;
using System.Threading.Tasks;

namespace Microsoft.SemanticKernel.Text;

#pragma warning disable CA1812 // Internal class that is apparently never instantiated
#pragma warning disable CA1846 // Prefer 'AsSpan' over 'Substring' when span-based overloads are available

/// <summary>
/// Internal class for parsing a stream of text which contains a series of discrete JSON strings into en enumerable containing each separate JSON string.
/// </summary>
/// <remarks>
/// This is universal parser for parsing stream of text which contains a series of discrete JSON.<br/>
/// If you need a specialized SSE parser, use <see cref="SseJsonParser"/> instead.<br/>
/// This class is thread-safe.
/// </remarks>
[ExcludeFromCodeCoverage]
internal sealed class StreamJsonParser
{
    /// <summary>
    /// Parses a Stream containing JSON data and yields the individual JSON objects.
    /// </summary>
    /// <param name="stream">The Stream containing the JSON data.</param>
    /// <param name="validateJson">Set to true to enable checking json chunks are well-formed. Default is false.</param>
    /// <param name="cancellationToken">The cancellation token.</param>
    /// <returns>An enumerable collection of string representing the individual JSON objects.</returns>
    /// <remarks>Stream will be disposed after parsing.</remarks>
    public async IAsyncEnumerable<string> ParseAsync(
        Stream stream,
        bool validateJson = false,
        [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        using var reader = new StreamReader(stream, Encoding.UTF8);
        ChunkParser chunkParser = new(reader);
        while (await chunkParser.ExtractNextChunkAsync(validateJson, cancellationToken).ConfigureAwait(false) is { } json)
        {
            yield return json;
        }
    }

    private sealed class ChunkParser
    {
        private readonly StringBuilder _jsonBuilder = new();
        private readonly StreamReader _reader;

        private int _bracketsCount;
        private int _startBracketIndex = -1;
        private bool _insideQuotes;
        private bool _isEscaping;
        private bool _isCompleteJson;
        private char _currentCharacter;
        private string? _lastLine;

        internal ChunkParser(StreamReader reader)
        {
            this._reader = reader;
        }

        internal async Task<string?> ExtractNextChunkAsync(
            bool validateJson,
            CancellationToken cancellationToken)
        {
            this.ResetState();
            string? line;
            while ((line = await this._reader.ReadLineAsync(
#if NET
                cancellationToken
#endif
                ).ConfigureAwait(false)) is not null || this._lastLine is not null)
            {
                if (this._lastLine is not null)
                {
                    line = this._lastLine + line;
                    this._lastLine = null;
                }

                if (this.ProcessLineUntilCompleteJson(line!))
                {
                    return this.GetJsonString(validateJson);
                }

                this.AppendLine(line!);
            }

            return null;
        }

        private bool ProcessLineUntilCompleteJson(string line)
        {
            for (int i = 0; i < line!.Length; i++)
            {
                this._currentCharacter = line[i];

                if (this.IsEscapedCharacterInsideQuotes())
                {
                    continue;
                }

                this.DetermineIfQuoteStartOrEnd();
                this.HandleCurrentCharacterOutsideQuotes(i);

                if (this._isCompleteJson)
                {
                    int nextIndex = i + 1;
                    if (nextIndex < line.Length)
                    {
                        this._lastLine = line.Substring(nextIndex);
                        this.AppendLine(line.Substring(0, nextIndex));
                    }
                    else
                    {
                        this.AppendLine(line);
                    }

                    return true;
                }

                this.ResetEscapeFlag();
            }

            return false;
        }

        private void ResetState()
        {
            this._jsonBuilder.Clear();
            this._bracketsCount = 0;
            this._startBracketIndex = -1;
            this._insideQuotes = false;
            this._isEscaping = false;
            this._isCompleteJson = false;
            this._currentCharacter = default;
        }

        private void AppendLine(string line)
        {
            switch (this._jsonBuilder)
            {
                case { Length: 0 } when this._startBracketIndex >= 0:
                    this._jsonBuilder.Append(line.Substring(this._startBracketIndex));
                    break;
                case { Length: > 0 }:
                    this._jsonBuilder.Append(line);
                    break;
            }
        }

        private string GetJsonString(bool validateJson)
        {
            if (!this._isCompleteJson)
            {
                throw new InvalidOperationException("Cannot get JSON string when JSON is not complete.");
            }

            var json = this._jsonBuilder.ToString();
            if (validateJson)
            {
                _ = JsonNode.Parse(json);
            }

            return json;
        }

        private void MarkJsonAsComplete()
        {
            this._isCompleteJson = true;
        }

        private void ResetEscapeFlag() => this._isEscaping = false;

        private void HandleCurrentCharacterOutsideQuotes(int index)
        {
            if (this._insideQuotes)
            {
                return;
            }

            switch (this._currentCharacter)
            {
                case '{':
                    if (++this._bracketsCount == 1)
                    {
                        this._startBracketIndex = index;
                    }

                    break;
                case '}':
                    if (--this._bracketsCount < 0)
                    {
                        throw new InvalidOperationException("Invalid JSON in stream.");
                    }

                    if (this._bracketsCount == 0)
                    {
                        this.MarkJsonAsComplete();
                    }

                    break;
            }
        }

        private void DetermineIfQuoteStartOrEnd()
        {
            if (this is { _currentCharacter: '\"', _isEscaping: false })
            {
                this._insideQuotes = !this._insideQuotes;
            }
        }

        private bool IsEscapedCharacterInsideQuotes()
        {
            if (this is { _currentCharacter: '\\', _isEscaping: false, _insideQuotes: true })
            {
                this._isEscaping = true;
                return true;
            }

            return false;
        }
    }
}


===== src\Type\TypeExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Threading.Tasks;

namespace System;

/// <summary>
/// Extensions methods for <see cref="System.Type"/>.
/// </summary>
[ExcludeFromCodeCoverage]
internal static class TypeExtensions
{
    /// <summary>
    /// Tries to get the result type from a generic parameter.
    /// </summary>
    /// <param name="returnType">Return type.</param>
    /// <param name="resultType">The result type of the Nullable generic parameter.</param>
    /// <returns><c>true</c> if the result type was successfully retrieved; otherwise, <c>false</c>.</returns>
    /// TODO [@teresaqhoang]: Issue #4202 Cache Generic Types Extraction - Handlebars
    public static bool TryGetGenericResultType(this Type? returnType, out Type resultType)
    {
        resultType = typeof(object);
        if (returnType is null)
        {
            return false;
        }

        if (returnType.IsGenericType)
        {
            Type genericTypeDef = returnType.GetGenericTypeDefinition();

            if (genericTypeDef == typeof(Task<>)
                || genericTypeDef == typeof(Nullable<>)
                || genericTypeDef == typeof(ValueTask<>))
            {
                resultType = returnType.GetGenericArguments()[0];
            }
            else if (genericTypeDef == typeof(IEnumerable<>)
                || genericTypeDef == typeof(IList<>)
                || genericTypeDef == typeof(ICollection<>))
            {
                resultType = typeof(List<>).MakeGenericType(returnType.GetGenericArguments()[0]);
            }
            else if (genericTypeDef == typeof(IDictionary<,>))
            {
                Type[] genericArgs = returnType.GetGenericArguments();
                resultType = typeof(Dictionary<,>).MakeGenericType(genericArgs[0], genericArgs[1]);
            }

            return true;
        }

        return false;
    }

    /// <summary>
    /// Returns a string with the type's name. If the type is generic, it also includes the type parameters in a readable format.
    /// </summary>
    /// <param name="type">Target type.</param>
    public static string GetFriendlyTypeName(this Type type)
    {
        if (type.IsGenericType)
        {
            string typeName = type.GetGenericTypeDefinition().Name;
            // Remove the `1, `2 etc from the type name which indicates the number of generic arguments  
            typeName = typeName.Substring(0, typeName.IndexOf('`', (int)StringComparison.Ordinal));
            string genericArgs = string.Join(", ", type.GetGenericArguments().Select(GetFriendlyTypeName));
            return $"{typeName}<{genericArgs}>";
        }

        return type.Name;
    }
}


===== test\AssertExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using Assert = Xunit.Assert;

namespace SemanticKernel.UnitTests;

internal static class AssertExtensions
{
    /// <summary>Asserts that an exception is an <see cref="ArgumentOutOfRangeException"/> with the specified values.</summary>
    public static void AssertIsArgumentOutOfRange(Exception? e, string expectedParamName, string expectedActualValue)
    {
        ArgumentOutOfRangeException aoore = Assert.IsType<ArgumentOutOfRangeException>(e);
        Assert.Equal(expectedActualValue, aoore.ActualValue);
        Assert.Equal(expectedParamName, aoore.ParamName);
    }
}


===== test\HttpMessageHandlerStub.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Net.Mime;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

#pragma warning disable CA1812 // Internal class that is apparently never instantiated; this class is compiled in tests projects
internal sealed class HttpMessageHandlerStub : HttpMessageHandler
#pragma warning restore CA1812 // Internal class that is apparently never instantiated
{
    public HttpRequestHeaders? RequestHeaders { get; private set; }

    public HttpContentHeaders? ContentHeaders { get; private set; }

    public byte[]? RequestContent { get; private set; }

    public Uri? RequestUri { get; private set; }

    public HttpMethod? Method { get; private set; }

    public HttpResponseMessage ResponseToReturn { get; set; }

    public Queue<HttpResponseMessage> ResponseQueue { get; } = new();
    public byte[]? FirstMultipartContent { get; private set; }

    public HttpMessageHandlerStub()
    {
        this.ResponseToReturn = new HttpResponseMessage(System.Net.HttpStatusCode.OK)
        {
            Content = new StringContent("{}", Encoding.UTF8, MediaTypeNames.Application.Json),
        };
    }

#pragma warning disable VSTHRD002 // Avoid problematic synchronous waits
    protected override HttpResponseMessage Send(HttpRequestMessage request, CancellationToken cancellationToken) =>
        this.SendAsync(request, cancellationToken).GetAwaiter().GetResult();
#pragma warning restore VSTHRD002 // Avoid problematic synchronous waits

    protected async override Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
    {
        this.Method = request.Method;
        this.RequestUri = request.RequestUri;
        this.RequestHeaders = request.Headers;
        this.RequestContent = request.Content is null ? null : await request.Content.ReadAsByteArrayAsync(cancellationToken);

        if (request.Content is MultipartContent multipartContent)
        {
            this.FirstMultipartContent = await multipartContent.First().ReadAsByteArrayAsync(cancellationToken);
        }

        this.ContentHeaders = request.Content?.Headers;

        HttpResponseMessage response =
            this.ResponseQueue.Count == 0 ?
                this.ResponseToReturn :
                this.ResponseToReturn = this.ResponseQueue.Dequeue();

        return response;
    }
}


===== test\MoqExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using Microsoft.Extensions.Logging;
using Moq;

#pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.

internal static class MoqExtensions
{
    public static void VerifyLog<T>(this Mock<ILogger<T>> logger, LogLevel logLevel, string containsMessage, Times times)
    {
        logger.Verify(
            x => x.Log(
                It.Is<LogLevel>(l => l == logLevel),
                It.IsAny<EventId>(),
                It.Is<It.IsAnyType>((v, t) => v.ToString()!.Contains(containsMessage)),
                It.IsAny<Exception>(),
                It.IsAny<Func<It.IsAnyType, Exception, string>>()),
            times);
    }

    public static void VerifyLog(this Mock<ILogger> logger, LogLevel logLevel, string containsMessage, Times times)
    {
        logger.Verify(
            x => x.Log(
                It.Is<LogLevel>(l => l == logLevel),
                It.IsAny<EventId>(),
                It.Is<It.IsAnyType>((v, t) => v.ToString()!.Contains(containsMessage)),
                It.IsAny<Exception>(),
                It.IsAny<Func<It.IsAnyType, Exception, string>>()),
            times);
    }
}


===== test\MultipleHttpMessageHandlerStub.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Net.Mime;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

#pragma warning disable CA1812

internal sealed class MultipleHttpMessageHandlerStub : DelegatingHandler
{
    private int _callIteration = 0;

    public List<HttpRequestHeaders?> RequestHeaders { get; private set; } = [];

    public List<HttpContentHeaders?> ContentHeaders { get; private set; } = [];

    public List<byte[]?> RequestContents { get; private set; } = [];

    public List<Uri?> RequestUris { get; private set; } = [];

    public List<HttpMethod?> Methods { get; private set; } = [];

    public List<HttpResponseMessage> ResponsesToReturn { get; set; } = [];

    internal HttpClient CreateHttpClient() => new(this, false);

    internal void AddJsonResponse(string json)
    {
        this.ResponsesToReturn.Add(new HttpResponseMessage(System.Net.HttpStatusCode.OK)
        {
            Content = new StringContent(json, Encoding.UTF8, MediaTypeNames.Application.Json)
        });
    }

    internal void AddImageResponse(byte[] image)
    {
        var response = new HttpResponseMessage(System.Net.HttpStatusCode.OK)
        {
            Content = new ByteArrayContent(image)
        };
        response.Content.Headers.ContentType = new MediaTypeHeaderValue("image/png");
        this.ResponsesToReturn.Add(response);
    }

    protected override async Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
    {
        this._callIteration++;

        this.Methods.Add(request.Method);
        this.RequestUris.Add(request.RequestUri);
        this.RequestHeaders.Add(request.Headers);
        this.ContentHeaders.Add(request.Content?.Headers);

        var content = request.Content is null ? null : await request.Content.ReadAsByteArrayAsync(cancellationToken);

        this.RequestContents.Add(content);

        return await Task.FromResult(this.ResponsesToReturn[this._callIteration - 1]);
    }

    internal string? GetRequestContentAsString(int index, Encoding? encoding = null)
        => this.RequestContents[index] is null
            ? null
            : (encoding ?? Encoding.UTF8).GetString(this.RequestContents[index]!);
}


