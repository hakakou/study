
===== Functions.Grpc\AssemblyInfo.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Diagnostics.CodeAnalysis;

// This assembly is currently experimental.
[assembly: Experimental("SKEXP0040")]


===== Functions.Grpc\Extensions\GrpcKernelExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.IO;
using System.Net.Http;
using System.Text.Json.Nodes;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.SemanticKernel.Http;
using Microsoft.SemanticKernel.Plugins.Grpc.Model;
using Microsoft.SemanticKernel.Plugins.Grpc.Protobuf;

namespace Microsoft.SemanticKernel.Plugins.Grpc;

/// <summary>
/// <see cref="Kernel"/> extensions methods for gRPC functionality.
/// </summary>
public static class GrpcKernelExtensions
{
    // TODO: Revise XML comments and validate shape of methods is as desired

    /// <summary>
    /// Imports gRPC document from a directory.
    /// </summary>
    /// <param name="kernel">The <see cref="Kernel"/> containing services, plugins, and other state for use throughout the operation.</param>
    /// <param name="parentDirectory">Directory containing the plugin directory.</param>
    /// <param name="pluginDirectoryName">Name of the directory containing the selected plugin.</param>
    /// <returns>A list of all the prompt functions representing the plugin.</returns>
    public static KernelPlugin ImportPluginFromGrpcDirectory(
        this Kernel kernel,
        string parentDirectory,
        string pluginDirectoryName)
    {
        KernelPlugin plugin = CreatePluginFromGrpcDirectory(kernel, parentDirectory, pluginDirectoryName);
        kernel.Plugins.Add(plugin);
        return plugin;
    }

    /// <summary>
    /// Imports gRPC document from a file.
    /// </summary>
    /// <param name="kernel">The <see cref="Kernel"/> containing services, plugins, and other state for use throughout the operation.</param>
    /// <param name="filePath">File path to .proto document.</param>
    /// <param name="pluginName">Name of the plugin to register.</param>
    /// <returns>A list of all the prompt functions representing the plugin.</returns>
    public static KernelPlugin ImportPluginFromGrpcFile(
        this Kernel kernel,
        string filePath,
        string pluginName)
    {
        KernelPlugin plugin = CreatePluginFromGrpcFile(kernel, filePath, pluginName);
        kernel.Plugins.Add(plugin);
        return plugin;
    }

    /// <summary>
    /// Registers an gRPC plugin.
    /// </summary>
    /// <param name="kernel">The <see cref="Kernel"/> containing services, plugins, and other state for use throughout the operation.</param>
    /// <param name="documentStream">.proto document stream.</param>
    /// <param name="pluginName">Plugin name.</param>
    /// <returns>A list of all the prompt functions representing the plugin.</returns>
    public static KernelPlugin ImportPluginFromGrpc(
        this Kernel kernel,
        Stream documentStream,
        string pluginName)
    {
        KernelPlugin plugin = CreatePluginFromGrpc(kernel, documentStream, pluginName);
        kernel.Plugins.Add(plugin);
        return plugin;
    }

    /// <summary>
    /// Imports gRPC document from a directory.
    /// </summary>
    /// <param name="kernel">The <see cref="Kernel"/> containing services, plugins, and other state for use throughout the operation.</param>
    /// <param name="parentDirectory">Directory containing the plugin directory.</param>
    /// <param name="pluginDirectoryName">Name of the directory containing the selected plugin.</param>
    /// <returns>A list of all the prompt functions representing the plugin.</returns>
    public static KernelPlugin CreatePluginFromGrpcDirectory(
        this Kernel kernel,
        string parentDirectory,
        string pluginDirectoryName)
    {
        const string ProtoFile = "grpc.proto";

        KernelVerify.ValidPluginName(pluginDirectoryName, kernel.Plugins);

        var pluginDir = Path.Combine(parentDirectory, pluginDirectoryName);
        Verify.DirectoryExists(pluginDir);

        var filePath = Path.Combine(pluginDir, ProtoFile);
        if (!File.Exists(filePath))
        {
            throw new FileNotFoundException($"No .proto document for the specified path - {filePath} is found.");
        }

        if (kernel.LoggerFactory.CreateLogger(typeof(GrpcKernelExtensions)) is ILogger logger &&
            logger.IsEnabled(LogLevel.Trace))
        {
            logger.LogTrace("Registering gRPC functions from {0} .proto document", filePath);
        }

        using var stream = File.OpenRead(filePath);

        return kernel.CreatePluginFromGrpc(stream, pluginDirectoryName);
    }

    /// <summary>
    /// Imports gRPC document from a file.
    /// </summary>
    /// <param name="kernel">The <see cref="Kernel"/> containing services, plugins, and other state for use throughout the operation.</param>
    /// <param name="filePath">File path to .proto document.</param>
    /// <param name="pluginName">Name of the plugin to register.</param>
    /// <returns>A list of all the prompt functions representing the plugin.</returns>
    public static KernelPlugin CreatePluginFromGrpcFile(
        this Kernel kernel,
        string filePath,
        string pluginName)
    {
        if (!File.Exists(filePath))
        {
            throw new FileNotFoundException($"No .proto document for the specified path - {filePath} is found.");
        }

        if (kernel.LoggerFactory.CreateLogger(typeof(GrpcKernelExtensions)) is ILogger logger &&
            logger.IsEnabled(LogLevel.Trace))
        {
            logger.LogTrace("Registering gRPC functions from {0} .proto document", filePath);
        }

        using var stream = File.OpenRead(filePath);

        return kernel.CreatePluginFromGrpc(stream, pluginName);
    }

    /// <summary>
    /// Registers an gRPC plugin.
    /// </summary>
    /// <param name="kernel">The <see cref="Kernel"/> containing services, plugins, and other state for use throughout the operation.</param>
    /// <param name="documentStream">.proto document stream.</param>
    /// <param name="pluginName">Plugin name.</param>
    /// <returns>A list of all the prompt functions representing the plugin.</returns>
    public static KernelPlugin CreatePluginFromGrpc(
        this Kernel kernel,
        Stream documentStream,
        string pluginName)
    {
        Verify.NotNull(kernel);
        KernelVerify.ValidPluginName(pluginName, kernel.Plugins);

        // Parse
        var parser = new ProtoDocumentParser();

        var operations = parser.Parse(documentStream, pluginName);

        var functions = new List<KernelFunction>();

        ILoggerFactory loggerFactory = kernel.LoggerFactory;

        using var client = HttpClientProvider.GetHttpClient(kernel.Services.GetService<HttpClient>());

        var runner = new GrpcOperationRunner(client);

        ILogger logger = loggerFactory.CreateLogger(typeof(GrpcKernelExtensions)) ?? NullLogger.Instance;
        foreach (var operation in operations)
        {
            try
            {
                logger.LogTrace("Registering gRPC function {0}.{1}", pluginName, operation.Name);
                functions.Add(CreateGrpcFunction(runner, operation, loggerFactory));
            }
            catch (Exception ex) when (!ex.IsCriticalException())
            {
                //Logging the exception and keep registering other gRPC functions
                logger.LogWarning(ex, "Something went wrong while rendering the gRPC function. Function: {0}.{1}. Error: {2}",
                    pluginName, operation.Name, ex.Message);
            }
        }

        return KernelPluginFactory.CreateFromFunctions(pluginName, null, functions);
    }

    #region private

    /// <summary>
    /// Registers KernelFunctionFactory for a gRPC operation.
    /// </summary>
    /// <param name="runner">gRPC operation runner.</param>
    /// <param name="operation">The gRPC operation.</param>
    /// <param name="loggerFactory">The logger factory.</param>
    /// <returns>An instance of <see cref="KernelFunctionFromPrompt"/> class.</returns>
    private static KernelFunction CreateGrpcFunction(
        GrpcOperationRunner runner,
        GrpcOperation operation,
        ILoggerFactory loggerFactory)
    {
        async Task<JsonObject> ExecuteAsync(KernelArguments arguments, CancellationToken cancellationToken)
        {
            try
            {
                return await runner.RunAsync(operation, arguments, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception ex) when (!ex.IsCriticalException() && loggerFactory.CreateLogger(typeof(GrpcKernelExtensions)) is ILogger logger && logger.IsEnabled(LogLevel.Warning))
            {
                logger.LogWarning(ex, "Something went wrong while rendering the gRPC function. Function: {0}. Error: {1}", operation.Name, ex.Message);
                throw;
            }
        }

        return KernelFunctionFactory.CreateFromMethod(
            method: ExecuteAsync,
            parameters: GrpcOperation.CreateParameters(),
            description: operation.Name,
            functionName: operation.Name,
            loggerFactory: loggerFactory);
    }

    #endregion
}


===== Functions.Grpc\GrpcOperationRunner.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Reflection;
using System.Reflection.Emit;
using System.Text.Json;
using System.Text.Json.Nodes;
using System.Threading;
using System.Threading.Tasks;
using Grpc.Core;
using Grpc.Net.Client;
using Microsoft.SemanticKernel.Plugins.Grpc.Model;
using ProtoBuf;

namespace Microsoft.SemanticKernel.Plugins.Grpc;

/// <summary>
/// Runs gRPC operation runner.
/// </summary>
internal sealed class GrpcOperationRunner(HttpClient httpClient)
{
    /// <summary>Serialization options that use a camel casing naming policy.</summary>
    private static readonly JsonSerializerOptions s_camelCaseOptions = new() { PropertyNamingPolicy = JsonNamingPolicy.CamelCase };
    /// <summary>Deserialization options that use case-insensitive property names.</summary>
    private static readonly JsonSerializerOptions s_propertyCaseInsensitiveOptions = new() { PropertyNameCaseInsensitive = true };
    /// <summary>
    /// An instance of the HttpClient class.
    /// </summary>
    private readonly HttpClient _httpClient = httpClient;

    /// <summary>
    /// Runs a gRPC operation.
    /// </summary>
    /// <param name="operation">The operation to run.</param>
    /// <param name="arguments">The operation arguments.</param>
    /// <param name="cancellationToken">The cancellation token.</param>
    /// <returns>The result of the operation run.</returns>
    public async Task<JsonObject> RunAsync(GrpcOperation operation, KernelArguments arguments, CancellationToken cancellationToken = default)
    {
        Verify.NotNull(operation);
        Verify.NotNull(arguments);

        var stringArgument = CastToStringArguments(arguments, operation);

        var address = this.GetAddress(operation, stringArgument);

        var channelOptions = new GrpcChannelOptions { HttpClient = this._httpClient, DisposeHttpClient = false };

        using var channel = GrpcChannel.ForAddress(address, channelOptions);

        var requestType = BuildGrpcOperationDataContractType(operation.Request);

        var responseType = BuildGrpcOperationDataContractType(operation.Response);

        var method = new Method<object, object>
        (
            MethodType.Unary,
            operation.FullServiceName,
            operation.Name,
            this.CreateMarshaller<object>(requestType),
            this.CreateMarshaller<object>(responseType)
        );

        var invoker = channel.CreateCallInvoker();

        var request = this.GenerateOperationRequest(operation, requestType, stringArgument);

        var response = await invoker.AsyncUnaryCall(method, null, new CallOptions(cancellationToken: cancellationToken), request).ConfigureAwait(false);

        return ConvertResponse(response, responseType);
    }

    /// <summary>
    /// Casts argument values of type object to string.
    /// </summary>
    /// <param name="arguments">The kernel arguments to be cast.</param>
    /// <param name="operation">The gRPC operation.</param>
    /// <returns>A dictionary of arguments with string values.</returns>
    /// <exception cref="KernelException">Thrown when an argument has an unsupported, non-string type.</exception>
    private static Dictionary<string, string> CastToStringArguments(KernelArguments arguments, GrpcOperation operation)
    {
        return arguments.ToDictionary(item => item.Key, item =>
        {
            if (item.Value is string stringValue)
            {
                return stringValue;
            }

            throw new KernelException($"Non-string gRPC operation arguments are not supported in Release Candidate 1. This feature will be available soon, but for now, please ensure that all arguments are strings. Operation '{operation.Name}' argument '{item.Key}' is of type '{item.Value?.GetType()}'.");
        });
    }

    /// <summary>
    /// Converts gRPC response.
    /// </summary>
    /// <param name="response">The response to convert.</param>
    /// <param name="responseType">The response type info.</param>
    /// <returns>The converted response.</returns>
    private static JsonObject ConvertResponse(object response, Type responseType)
    {
        var content = JsonSerializer.Serialize(response, responseType, s_camelCaseOptions);

        //First iteration allowing to associate additional metadata with the returned content.
        var result = new JsonObject
        {
            { "content", content },
            { "contentType", "application/json; charset=utf-8" }
        };
        return result;
    }

    /// <summary>
    /// Returns address of a channel that provides connection to a gRPC server.
    /// </summary>
    /// <param name="operation">The gRPC operation.</param>
    /// <param name="arguments">The gRPC operation arguments.</param>
    /// <returns>The channel address.</returns>
    private string GetAddress(GrpcOperation operation, Dictionary<string, string> arguments)
    {
        if (!arguments.TryGetValue(GrpcOperation.AddressArgumentName, out string? address))
        {
            address = operation.Address;
        }

        if (string.IsNullOrEmpty(address))
        {
            throw new KernelException($"No address provided for the '{operation.Name}' gRPC operation.");
        }

        return address!;
    }

    /// <summary>
    /// Creates a marshaller - a typed abstraction for gRPC message serialization and deserialization.
    /// </summary>
    /// <param name="contractType">The message contract data type.</param>
    /// <returns>The marshaller.</returns>
    private Marshaller<T> CreateMarshaller<T>(Type contractType)
    {
        byte[] Serialize(T instance)
        {
            using var memoryStream = new MemoryStream();

            Serializer.NonGeneric.Serialize(memoryStream, instance);

            return memoryStream.ToArray();
        }

        T Deserialize(byte[] source)
        {
            using var memoryStream = new MemoryStream(source);

            return (T)Serializer.NonGeneric.Deserialize(contractType, memoryStream);
        }

        return Marshallers.Create(Serialize, Deserialize);
    }

    /// <summary>
    /// Creates a gRPC operation request.
    /// </summary>
    /// <param name="operation">The gRPC operation.</param>
    /// <param name="type">The operation request data type.</param>
    /// <param name="arguments">The operation arguments.</param>
    /// <returns>The operation request instance.</returns>
    private object GenerateOperationRequest(GrpcOperation operation, Type type, Dictionary<string, string> arguments)
    {
        //Getting 'payload' argument to by used as gRPC request message
        if (!arguments.TryGetValue(GrpcOperation.PayloadArgumentName, out string? payload) ||
            string.IsNullOrEmpty(payload))
        {
            throw new KernelException($"No '{GrpcOperation.PayloadArgumentName}' argument representing gRPC request message is found for the '{operation.Name}' gRPC operation.");
        }

        //Deserializing JSON payload to gRPC request message
        return JsonSerializer.Deserialize(payload!, type, s_propertyCaseInsensitiveOptions) ??
            throw new KernelException($"Unable to create gRPC request message for the '{operation.Name}' gRPC operation.");
    }

    /// <summary>
    /// Builds gRPC operation data contract type.
    /// </summary>
    /// <param name="dataContractMetadata">The data contract type metadata.</param>
    /// <returns>.NET type representing the data contract type.</returns>
    private static TypeInfo BuildGrpcOperationDataContractType(GrpcOperationDataContractType dataContractMetadata)
    {
        var assemblyName = new AssemblyName($"{dataContractMetadata.Name}Assembly");

        var assemblyBuilder = AssemblyBuilder.DefineDynamicAssembly(assemblyName, AssemblyBuilderAccess.Run);

        var moduleBuilder = assemblyBuilder.DefineDynamicModule($"{dataContractMetadata.Name}Module");

        var typeBuilder = moduleBuilder.DefineType(dataContractMetadata.Name, TypeAttributes.Public | TypeAttributes.Sealed | TypeAttributes.Class);

        //Creating and adding a .NET property for each data contract filed
        foreach (var field in dataContractMetadata.Fields)
        {
            var fieldName = field.Name;
            var propertyName = CultureInfo.InvariantCulture.TextInfo.ToTitleCase(field.Name);

            var propertyType = GetNetType(field.TypeName);

            //Creating a private backing field for the property
            var fieldBuilder = typeBuilder.DefineField(fieldName + "_", propertyType, FieldAttributes.Private);
            var propertyBuilder = typeBuilder.DefineProperty(propertyName, PropertyAttributes.None, propertyType, null);

            //Creating the property get method and binding it to the private filed
            var getterBuilder = typeBuilder.DefineMethod("get_" + propertyName, MethodAttributes.Public | MethodAttributes.SpecialName | MethodAttributes.HideBySig, propertyType, Type.EmptyTypes);
            var getterIl = getterBuilder.GetILGenerator();
            getterIl.Emit(OpCodes.Ldarg_0);
            getterIl.Emit(OpCodes.Ldfld, fieldBuilder);
            getterIl.Emit(OpCodes.Ret);

            //Creating the property set method and binding it to the private filed
            var setterBuilder = typeBuilder.DefineMethod("set_" + propertyName, MethodAttributes.Public | MethodAttributes.SpecialName | MethodAttributes.HideBySig, null, [propertyType]);
            var setterIl = setterBuilder.GetILGenerator();
            setterIl.Emit(OpCodes.Ldarg_0);
            setterIl.Emit(OpCodes.Ldarg_1);
            setterIl.Emit(OpCodes.Stfld, fieldBuilder);
            setterIl.Emit(OpCodes.Ret);

            //Registering the property get and set methods.
            propertyBuilder.SetGetMethod(getterBuilder);
            propertyBuilder.SetSetMethod(setterBuilder);

            //Add ProtoMember attribute to the data contract with tag/number
            var dataMemberAttributeBuilder = new CustomAttributeBuilder(typeof(ProtoMemberAttribute).GetConstructor([typeof(int)])!, [field.Number]);
            propertyBuilder.SetCustomAttribute(dataMemberAttributeBuilder);
        }

        //Add ProtoContract attribute to the data contract
        var dataContractAttributeBuilder = new CustomAttributeBuilder(typeof(ProtoContractAttribute).GetConstructor(Type.EmptyTypes)!, []);
        typeBuilder.SetCustomAttribute(dataContractAttributeBuilder);

        return typeBuilder.CreateTypeInfo() ??
            throw new KernelException($"Impossible to create type for '{dataContractMetadata.Name}' data contract.");
    }

    /// <summary>
    /// Returns .net type that corresponds to protobuf data type name.
    /// </summary>
    /// <param name="type">The protobuf data type name.</param>
    /// <returns>The .net type.</returns>
    private static Type GetNetType(string type) =>
        type switch
        {
            "TYPE_DOUBLE" => typeof(double),
            "TYPE_FLOAT" => typeof(float),
            "TYPE_INT64" => typeof(long),
            "TYPE_UINT64" => typeof(ulong),
            "TYPE_INT32" => typeof(int),
            "TYPE_FIXED64" => typeof(ulong),
            "TYPE_FIXED32" => typeof(uint),
            "TYPE_BOOL" => typeof(bool),
            "TYPE_STRING" => typeof(string),
            "TYPE_BYTES" => typeof(byte[]),
            "TYPE_UINT32" => typeof(uint),
            "TYPE_SFIXED32" => typeof(int),
            "TYPE_SFIXED64" => typeof(long),
            "TYPE_SINT32" => typeof(int),
            "TYPE_SINT64" => typeof(long),
            _ => throw new ArgumentException($"Unknown type {type}", nameof(type)),
        };
}


===== Functions.Grpc\Model\GrpcOperation.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;

namespace Microsoft.SemanticKernel.Plugins.Grpc.Model;

/// <summary>
/// The gRPC operation.
/// </summary>
internal sealed class GrpcOperation
{
    /// <summary>
    /// Name of 'address' argument used as override for the address provided by gRPC operation.
    /// </summary>
    internal const string AddressArgumentName = "address";

    /// <summary>
    /// Name of 'payload' argument that represents gRPC operation request message.
    /// </summary>
    internal const string PayloadArgumentName = "payload";

    /// <summary>
    /// Creates an instance of a <see cref="GrpcOperation"/> class.
    /// <param name="serviceName">The service name.</param>
    /// <param name="name">The operation name.</param>
    /// <param name="request">The operation request type metadata.</param>
    /// <param name="response">The operation response type metadata.</param>
    /// </summary>
    public GrpcOperation(
        string serviceName,
        string name,
        GrpcOperationDataContractType request,
        GrpcOperationDataContractType response)
    {
        this.ServiceName = serviceName;
        this.Name = name;
        this.Request = request;
        this.Response = response;
    }

    /// <summary>
    /// The service name.
    /// </summary>
    public string ServiceName { get; set; }

    /// <summary>
    /// The operation name.
    /// </summary>
    public string Name { get; private set; }

    /// <summary>
    /// The full service name that includes that 'package' specifier as prefix.
    /// </summary>
    public string FullServiceName
    {
        get
        {
            if (string.IsNullOrEmpty(this.Package))
            {
                return this.ServiceName;
            }

            return $"{this.Package}.{this.ServiceName}";
        }
    }

    /// <summary>
    /// The gRPC request data contract.
    /// </summary>
    public GrpcOperationDataContractType Request { get; private set; }

    /// <summary>
    /// The gRPC response data contract.
    /// </summary>
    public GrpcOperationDataContractType Response { get; private set; }

    /// <summary>
    /// The address.
    /// </summary>
    public string? Address { get; set; }

    /// <summary>
    /// Specifier to prevent name clashes between types.
    /// </summary>
    public string? Package { get; set; }

    /// <summary>
    /// Returns list of gRPC operation parameters.
    /// </summary>
    /// <returns>The list of parameters.</returns>
    internal static List<KernelParameterMetadata> CreateParameters() =>
    [
        // Register the "address" parameter so that it's possible to override it if needed.
        new(GrpcOperation.AddressArgumentName)
        {
            Description = "Address for gRPC channel to use.",
        },

        // Register the "payload" parameter to be used as gRPC operation request message.
        new(GrpcOperation.PayloadArgumentName)
        {
            Description = "gRPC request message.",
        },
    ];
}


===== Functions.Grpc\Model\GrpcOperationDataContractType.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;

namespace Microsoft.SemanticKernel.Plugins.Grpc.Model;

/// <summary>
/// The gRPC operation data contract.
/// </summary>
internal sealed class GrpcOperationDataContractType(string name, IList<GrpcOperationDataContractTypeFiled> fields)
{
    /// <summary>
    /// Data contract name
    /// </summary>
    public string Name { get; set; } = name;

    /// <summary>
    /// List of fields
    /// </summary>
    public IList<GrpcOperationDataContractTypeFiled> Fields { get; } = fields;
}


===== Functions.Grpc\Model\GrpcOperationDataContractTypeFiled.cs =====

// Copyright (c) Microsoft. All rights reserved.

namespace Microsoft.SemanticKernel.Plugins.Grpc.Model;

/// <summary>
/// The gRPC operation data contract field.
/// </summary>
internal sealed class GrpcOperationDataContractTypeFiled(string name, int number, string typeName)
{
    /// <summary>
    /// Field name.
    /// </summary>
    public string Name { get; } = name;

    /// <summary>
    /// Field number.
    /// </summary>
    public int Number { get; } = number;

    /// <summary>
    /// Field type name.
    /// </summary>
    public string TypeName { get; } = typeName;
}


===== Functions.Grpc\Protobuf\ProtoDocumentParser.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Google.Protobuf.Reflection;
using Microsoft.SemanticKernel.Plugins.Grpc.Model;
using ProtoBuf;

namespace Microsoft.SemanticKernel.Plugins.Grpc.Protobuf;

/// <summary>
/// Parser for .proto definition documents.
/// </summary>
internal sealed class ProtoDocumentParser
{
    /// <summary>
    /// Parses .proto document.
    /// </summary>
    /// <param name="protoDocument">The .proto document.</param>
    /// <param name="protoFileName">The .proto file logical name.</param>
    /// <returns>List of gRPC operations.</returns>
    public IList<GrpcOperation> Parse(Stream protoDocument, string protoFileName)
    {
        Verify.NotNull(protoDocument);
        Verify.NotNullOrWhiteSpace(protoFileName);

        using var textReader = new StreamReader(protoDocument);

        var descriptor = new FileDescriptorSet();
        descriptor.Add(protoFileName, source: textReader);
        descriptor.Process();

        var errors = descriptor.GetErrors();
        if (errors is not null && errors.Length != 0)
        {
            throw new KernelException($"Parsing of '{protoFileName}' .proto document has failed. Details: {string.Join(";", errors.AsEnumerable())}");
        }

        return this.GetGrpcOperations(descriptor.Files.Single());
    }

    /// <summary>
    /// Parses an .proto document and extracts gRPC operations.
    /// </summary>
    /// <param name="model">The .proto document model.</param>
    /// <returns>List of gRPC operations.</returns>
    private List<GrpcOperation> GetGrpcOperations(FileDescriptorProto model)
    {
        var operations = new List<GrpcOperation>();

        foreach (var service in model.Services)
        {
            foreach (var method in service.Methods)
            {
                var requestContract = this.CreateDataContract(model.MessageTypes, method.InputType, model.Package, method.Name);

                var responseContract = this.CreateDataContract(model.MessageTypes, method.OutputType, model.Package, method.Name);

                operations.Add(new GrpcOperation(service.Name, method.Name, requestContract, responseContract)
                {
                    Package = model.Package
                });
            }
        }

        return operations;
    }

    /// <summary>
    /// Creates gRPC operation data contract.
    /// </summary>
    /// <param name="allMessageTypes">Existing ,message types declared in .proto file.</param>
    /// <param name="messageTypeName">Message type to create the data contract for.</param>
    /// <param name="package">The .proto file 'package' specifier.</param>
    /// <param name="methodName">The method to create data contract for.</param>
    /// <returns>The operation data contract.</returns>
    private GrpcOperationDataContractType CreateDataContract(IList<DescriptorProto> allMessageTypes, string messageTypeName, string package, string methodName)
    {
        var fullTypeName = messageTypeName.TrimStart('.');

        var typeName = fullTypeName;

        if (!string.IsNullOrEmpty(package))
        {
            typeName = fullTypeName.Replace($"{package}.", "");
        }

        var messageType = allMessageTypes.SingleOrDefault(mt => mt.Name == fullTypeName || mt.Name == typeName) ??
            throw new KernelException($"No '{fullTypeName}' message type is found while resolving data contracts for the '{methodName}' method.");

        var fields = this.GetDataContractFields(messageType.Fields);

        return new GrpcOperationDataContractType(fullTypeName, fields);
    }

    /// <summary>
    /// Returns data contract fields.
    /// </summary>
    /// <param name="fields">Message type fields.</param>
    /// <returns>The data contract fields.</returns>
    private List<GrpcOperationDataContractTypeFiled> GetDataContractFields(List<FieldDescriptorProto> fields)
    {
        var result = new List<GrpcOperationDataContractTypeFiled>();

        foreach (var field in fields)
        {
            var type = GetProtobufDataTypeName(field.type);

            result.Add(new GrpcOperationDataContractTypeFiled(field.Name, field.Number, type));
        }

        return result;
    }

    /// <summary>
    /// Returns protobuf data type name.
    /// </summary>
    /// <param name="type">Type descriptor.</param>
    /// <returns>The protobuf data type name.</returns>
    private static string GetProtobufDataTypeName(FieldDescriptorProto.Type type)
    {
        var fieldInfo = typeof(FieldDescriptorProto.Type).GetField(type.ToString());
        if (fieldInfo is not null)
        {
            //Get protobuf type name from enum attribute - [global::ProtoBuf.ProtoEnum(Name = @"TYPE_DOUBLE")]
            var attribute = (ProtoEnumAttribute?)Attribute.GetCustomAttribute(fieldInfo, typeof(ProtoEnumAttribute));
            if (attribute is not null)
            {
                return attribute.Name;
            }
        }

        throw new KernelException($"Impossible to find protobuf type name corresponding to '{type}' type.");
    }
}


===== Functions.Markdown\AssemblyInfo.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Diagnostics.CodeAnalysis;

// This assembly is currently experimental.
[assembly: Experimental("SKEXP0040")]


===== Functions.Markdown\KernelFunctionMarkdown.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Text.Json;
using Markdig;
using Markdig.Syntax;
using Microsoft.Extensions.Logging;

namespace Microsoft.SemanticKernel;

/// <summary>
/// Factory methods for creating <seealso cref="KernelFunction"/> instances.
/// </summary>
public static class KernelFunctionMarkdown
{
    /// <summary>
    /// Creates a <see cref="KernelFunction"/> instance for a prompt function using the specified markdown text.
    /// </summary>
    /// <param name="text">Markdown representation of the <see cref="PromptTemplateConfig"/> to use to create the prompt function.</param>
    /// <param name="functionName">The name of the function.</param>
    /// <param name="promptTemplateFactory">
    /// The <see cref="IPromptTemplateFactory"/> to use when interpreting the prompt template configuration into a <see cref="IPromptTemplate"/>.
    /// If null, a default factory will be used.
    /// </param>
    /// <param name="loggerFactory">The <see cref="ILoggerFactory"/> to use for logging. If null, no logging will be performed.</param>
    /// <returns>The created <see cref="KernelFunction"/>.</returns>
    public static KernelFunction FromPromptMarkdown(
        string text,
        string functionName,
        IPromptTemplateFactory? promptTemplateFactory = null,
        ILoggerFactory? loggerFactory = null)
    {
        Verify.NotNull(text);
        Verify.NotNull(functionName);

        return KernelFunctionFactory.CreateFromPrompt(
            CreateFromPromptMarkdown(text, functionName),
            promptTemplateFactory,
            loggerFactory);
    }

    #region Private methods
    internal static PromptTemplateConfig CreateFromPromptMarkdown(string text, string functionName)
    {
        PromptTemplateConfig promptFunctionModel = new() { Name = functionName };

        foreach (Block block in Markdown.Parse(text))
        {
            if (block is FencedCodeBlock codeBlock)
            {
                switch (codeBlock.Info)
                {
                    case "sk.prompt":
                        promptFunctionModel.Template = codeBlock.Lines.ToString();
                        break;

                    case "sk.execution_settings":
                        var modelSettings = codeBlock.Lines.ToString();
                        var settingsDictionary = JsonSerializer.Deserialize<Dictionary<string, PromptExecutionSettings>>(modelSettings);
                        if (settingsDictionary is not null)
                        {
                            foreach (var keyValue in settingsDictionary)
                            {
                                promptFunctionModel.ExecutionSettings.Add(keyValue.Key, keyValue.Value);
                            }
                        }
                        break;
                }
            }
        }

        return promptFunctionModel;
    }
    #endregion
}


===== Functions.Markdown\MarkdownKernelExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

namespace Microsoft.SemanticKernel;

/// <summary>
/// Class for extensions methods to define functions using prompt markdown format.
/// </summary>
public static class MarkdownKernelExtensions
{
    /// <summary>
    /// Creates a <see cref="KernelFunction"/> instance for a prompt function using the specified markdown text.
    /// </summary>
    /// <param name="kernel">The <see cref="Kernel"/> containing services, plugins, and other state for use throughout the operation.</param>
    /// <param name="text">YAML representation of the <see cref="PromptTemplateConfig"/> to use to create the prompt function</param>
    /// <param name="functionName">The name of the function.</param>
    /// <param name="promptTemplateFactory">
    /// The <see cref="IPromptTemplateFactory"/> to use when interpreting the prompt template configuration into a <see cref="IPromptTemplate"/>.
    /// If null, a default factory will be used.
    /// </param>
    /// <returns>The created <see cref="KernelFunction"/>.</returns>
    public static KernelFunction CreateFunctionFromMarkdown(
        this Kernel kernel,
        string text,
        string functionName,
        IPromptTemplateFactory? promptTemplateFactory = null)
    {
        Verify.NotNull(kernel);
        Verify.NotNull(text);
        Verify.NotNull(functionName);

        return KernelFunctionMarkdown.FromPromptMarkdown(text, functionName, promptTemplateFactory, kernel.LoggerFactory);
    }
}


===== Functions.OpenApi.Extensions\AssemblyInfo.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Diagnostics.CodeAnalysis;

// This assembly is currently experimental.
[assembly: Experimental("SKEXP0040")]


===== Functions.OpenApi.Extensions\Extensions\ApiManifestKernelExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.OpenApi.ApiManifest;
using Microsoft.OpenApi.Readers;
using Microsoft.OpenApi.Services;
using Microsoft.SemanticKernel.Http;
using Microsoft.SemanticKernel.Plugins.OpenApi;
using Microsoft.SemanticKernel.Plugins.OpenApi.Extensions;

namespace Microsoft.SemanticKernel;
/// <summary>
/// Provides extension methods for the <see cref="Kernel"/> class related to OpenAPI functionality.
/// </summary>
public static class ApiManifestKernelExtensions
{
    /// <summary>
    /// Imports a plugin from an API manifest asynchronously.
    /// </summary>
    /// <param name="kernel">The kernel instance.</param>
    /// <param name="pluginName">The name of the plugin.</param>
    /// <param name="filePath">The file path of the API manifest.</param>
    /// <param name="pluginParameters">Optional parameters for the plugin setup.</param>
    /// <param name="cancellationToken">Optional cancellation token.</param>
    /// <returns>The imported plugin.</returns>
    public static async Task<KernelPlugin> ImportPluginFromApiManifestAsync(
        this Kernel kernel,
        string pluginName,
        string filePath,
        ApiManifestPluginParameters? pluginParameters = null,
        CancellationToken cancellationToken = default)
        => await kernel.ImportPluginFromApiManifestAsync(pluginName, filePath, null, pluginParameters, cancellationToken).ConfigureAwait(false);

    /// <summary>
    /// Imports a plugin from an API manifest asynchronously.
    /// </summary>
    /// <param name="kernel">The kernel instance.</param>
    /// <param name="pluginName">The name of the plugin.</param>
    /// <param name="filePath">The file path of the API manifest.</param>
    /// <param name="description">The description of the plugin.</param>
    /// <param name="pluginParameters">Optional parameters for the plugin setup.</param>
    /// <param name="cancellationToken">Optional cancellation token.</param>
    /// <returns>The imported plugin.</returns>
    public static async Task<KernelPlugin> ImportPluginFromApiManifestAsync(
        this Kernel kernel,
        string pluginName,
        string filePath,
        string? description,
        ApiManifestPluginParameters? pluginParameters = null,
        CancellationToken cancellationToken = default)
    {
        KernelPlugin plugin = await kernel.CreatePluginFromApiManifestAsync(pluginName, filePath, description, pluginParameters, cancellationToken).ConfigureAwait(false);
        kernel.Plugins.Add(plugin);
        return plugin;
    }

    /// <summary>
    /// Creates a kernel plugin from an API manifest file asynchronously.
    /// </summary>
    /// <param name="kernel">The kernel instance.</param>
    /// <param name="pluginName">The name of the plugin.</param>
    /// <param name="filePath">The file path of the API manifest.</param>
    /// <param name="pluginParameters">Optional parameters for the plugin setup.</param>
    /// <param name="cancellationToken">Optional cancellation token.</param>
    /// <returns>A task that represents the asynchronous operation. The task result contains the created kernel plugin.</returns>
    public static async Task<KernelPlugin> CreatePluginFromApiManifestAsync(
        this Kernel kernel,
        string pluginName,
        string filePath,
        ApiManifestPluginParameters? pluginParameters = null,
        CancellationToken cancellationToken = default)
        => await kernel.CreatePluginFromApiManifestAsync(pluginName, filePath, null, pluginParameters, cancellationToken).ConfigureAwait(false);

    /// <summary>
    /// Creates a kernel plugin from an API manifest file asynchronously.
    /// </summary>
    /// <param name="kernel">The kernel instance.</param>
    /// <param name="pluginName">The name of the plugin.</param>
    /// <param name="filePath">The file path of the API manifest.</param>
    /// <param name="description">The description of the plugin.</param>
    /// <param name="pluginParameters">Optional parameters for the plugin setup.</param>
    /// <param name="cancellationToken">Optional cancellation token.</param>
    /// <returns>A task that represents the asynchronous operation. The task result contains the created kernel plugin.</returns>
    public static async Task<KernelPlugin> CreatePluginFromApiManifestAsync(
        this Kernel kernel,
        string pluginName,
        string filePath,
        string? description,
        ApiManifestPluginParameters? pluginParameters = null,
        CancellationToken cancellationToken = default)
    {
        Verify.NotNull(kernel);
        KernelVerify.ValidPluginName(pluginName, kernel.Plugins);

#pragma warning disable CA2000 // Dispose objects before losing scope. No need to dispose the Http client here. It can either be an internal client using NonDisposableHttpClientHandler or an external client managed by the calling code, which should handle its disposal.
        var httpClient = HttpClientProvider.GetHttpClient(pluginParameters?.HttpClient ?? kernel.Services.GetService<HttpClient>());
#pragma warning restore CA2000

        if (!File.Exists(filePath))
        {
            throw new FileNotFoundException($"ApiManifest file not found: {filePath}");
        }

        var loggerFactory = kernel.LoggerFactory;
        var logger = loggerFactory.CreateLogger(typeof(ApiManifestKernelExtensions)) ?? NullLogger.Instance;
        using var apiManifestFileJsonContents = DocumentLoader.LoadDocumentFromFilePathAsStream(filePath,
            logger);
        JsonDocument jsonDocument = await JsonDocument.ParseAsync(apiManifestFileJsonContents, cancellationToken: cancellationToken).ConfigureAwait(false);

        ApiManifestDocument document = ApiManifestDocument.Load(jsonDocument.RootElement);

        var functions = new List<KernelFunction>();
        var documentWalker = new OpenApiWalker(new OperationIdNormalizationOpenApiVisitor());
        foreach (var apiDependency in document.ApiDependencies)
        {
            var apiName = apiDependency.Key;
            var apiDependencyDetails = apiDependency.Value;

            var apiDescriptionUrl = apiDependencyDetails.ApiDescriptionUrl;
            if (apiDescriptionUrl is null)
            {
                logger.LogWarning("ApiDescriptionUrl is missing for API dependency: {ApiName}", apiName);
                continue;
            }

            var (parsedDescriptionUrl, isOnlineDescription) = Uri.TryCreate(apiDescriptionUrl, UriKind.Absolute, out var result) ?
                (result, true) :
                (new Uri(Path.Combine(Path.GetDirectoryName(filePath) ?? string.Empty, apiDescriptionUrl)), false);

            using var openApiDocumentStream = isOnlineDescription ?
                await DocumentLoader.LoadDocumentFromUriAsStreamAsync(new Uri(apiDescriptionUrl),
                    logger,
                    httpClient,
                    authCallback: null,
                    pluginParameters?.UserAgent,
                    cancellationToken).ConfigureAwait(false) :
                DocumentLoader.LoadDocumentFromFilePathAsStream(parsedDescriptionUrl.LocalPath,
                    logger);

            var documentReadResult = await new OpenApiStreamReader(new()
            {
                BaseUrl = parsedDescriptionUrl
            }
            ).ReadAsync(openApiDocumentStream, cancellationToken).ConfigureAwait(false);
            var openApiDocument = documentReadResult.OpenApiDocument;
            var openApiDiagnostic = documentReadResult.OpenApiDiagnostic;

            documentWalker.Walk(openApiDocument);

            var requestUrls = new Dictionary<string, List<string>>(StringComparer.OrdinalIgnoreCase);
            var pathMethodPairs = apiDependencyDetails.Requests.Select(request => (request.UriTemplate, request.Method?.ToUpperInvariant()));
            foreach (var (UriTemplate, Method) in pathMethodPairs)
            {
                if (UriTemplate is null || Method is null)
                {
                    continue;
                }

                if (requestUrls.TryGetValue(UriTemplate, out List<string>? value))
                {
                    value.Add(Method);
                    continue;
                }

                requestUrls.Add(UriTemplate, [Method]);
            }

            var predicate = OpenApiFilterService.CreatePredicate(null, null, requestUrls, openApiDocument);
            var filteredOpenApiDocument = OpenApiFilterService.CreateFilteredDocument(openApiDocument, predicate);

            var openApiFunctionExecutionParameters = pluginParameters?.FunctionExecutionParameters?.TryGetValue(apiName, out var parameters) == true
                ? parameters
                : new OpenApiFunctionExecutionParameters()
                {
                    EnableDynamicPayload = false,
                    EnablePayloadNamespacing = true,
                };

#pragma warning disable CA2000 // Dispose objects before losing scope. No need to dispose the Http client here. It can either be an internal client using NonDisposableHttpClientHandler or an external client managed by the calling code, which should handle its disposal.
            var operationRunnerHttpClient = HttpClientProvider.GetHttpClient(openApiFunctionExecutionParameters?.HttpClient ?? kernel.Services.GetService<HttpClient>());
#pragma warning restore CA2000

            var runner = new RestApiOperationRunner(
                operationRunnerHttpClient,
                openApiFunctionExecutionParameters?.AuthCallback,
                openApiFunctionExecutionParameters?.UserAgent,
                openApiFunctionExecutionParameters?.EnableDynamicPayload ?? false,
                openApiFunctionExecutionParameters?.EnablePayloadNamespacing ?? false);

            var server = filteredOpenApiDocument.Servers.FirstOrDefault();
            if (server?.Url is null)
            {
                logger.LogWarning("Server URI not found. Plugin: {0}", pluginName);
                continue;
            }
            var info = OpenApiDocumentParser.ExtractRestApiInfo(filteredOpenApiDocument);
            var security = OpenApiDocumentParser.CreateRestApiOperationSecurityRequirements(filteredOpenApiDocument.SecurityRequirements);
            foreach (var path in filteredOpenApiDocument.Paths)
            {
                var operations = OpenApiDocumentParser.CreateRestApiOperations(filteredOpenApiDocument, path.Key, path.Value, null, logger);
                foreach (RestApiOperation operation in operations)
                {
                    try
                    {
                        logger.LogTrace("Registering Rest function {0}.{1}", pluginName, operation.Id);
                        functions.Add(OpenApiKernelPluginFactory.CreateRestApiFunction(pluginName, runner, info, security, operation, openApiFunctionExecutionParameters, new Uri(server.Url), loggerFactory));
                    }
                    catch (Exception ex) when (!ex.IsCriticalException())
                    {
                        //Logging the exception and keep registering other Rest functions
                        logger.LogWarning(ex, "Something went wrong while rendering the Rest function. Function: {0}.{1}. Error: {2}",
                            pluginName, operation.Id, ex.Message);
                    }
                }
            }
        }

        return KernelPluginFactory.CreateFromFunctions(pluginName, description, functions);
    }
}


===== Functions.OpenApi.Extensions\Extensions\ApiManifestPluginParameters.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Collections.Generic;
using System.Net.Http;

namespace Microsoft.SemanticKernel.Plugins.OpenApi.Extensions;

/// <summary>
/// API manifest plugin parameters.
/// </summary>
public sealed class ApiManifestPluginParameters
{
    /// <summary>
    /// Gets the HTTP client to be used in plugin initialization phase.
    /// </summary>
    public HttpClient? HttpClient { get; init; }

    /// <summary>
    /// Gets the user agent to be used in plugin initialization phase.
    /// </summary>
    public string? UserAgent { get; init; }

    /// <summary>
    /// A map of function execution parameters, where the key is the api dependency key from api manifest
    /// and the value is OpenApiFunctionExecutionParameters specific to that dependency.
    /// </summary>
    public Dictionary<string, OpenApiFunctionExecutionParameters>? FunctionExecutionParameters { get; init; }

    /// <summary>
    /// Initializes a new instance of the <see cref="ApiManifestPluginParameters"/> class.
    /// </summary>
    /// <param name="httpClient">Http client to be used in plugin initialization phase.</param>
    /// <param name="userAgent">User agent to be used in plugin initialization phase.</param>
    /// <param name="functionExecutionParameters">A map of function execution parameters.</param>
    public ApiManifestPluginParameters(
        HttpClient? httpClient = default,
        string? userAgent = default,
        Dictionary<string, OpenApiFunctionExecutionParameters>? functionExecutionParameters = default
    )
    {
        this.HttpClient = httpClient;
        this.UserAgent = userAgent;
        this.FunctionExecutionParameters = functionExecutionParameters;
    }
}


===== Functions.OpenApi.Extensions\Extensions\CopilotAgentPluginKernelExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Runtime.InteropServices;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.OpenApi.Readers;
using Microsoft.OpenApi.Services;
using Microsoft.Plugins.Manifest;
using Microsoft.SemanticKernel.Http;
using Microsoft.SemanticKernel.Plugins.OpenApi;
using Microsoft.SemanticKernel.Plugins.OpenApi.Extensions;

namespace Microsoft.SemanticKernel;
/// <summary>
/// Provides extension methods for the <see cref="Kernel"/> class related to OpenAPI functionality.
/// </summary>
public static class CopilotAgentPluginKernelExtensions
{
    /// <summary>
    /// Imports a plugin from an Copilot Agent Plugin asynchronously.
    /// </summary>
    /// <param name="kernel">The kernel instance.</param>
    /// <param name="pluginName">The name of the plugin.</param>
    /// <param name="filePath">The file path of the Copilot Agent Plugin.</param>
    /// <param name="pluginParameters">Optional parameters for the plugin setup.</param>
    /// <param name="cancellationToken">Optional cancellation token.</param>
    /// <returns>The imported plugin.</returns>
    public static async Task<KernelPlugin> ImportPluginFromCopilotAgentPluginAsync(
        this Kernel kernel,
        string pluginName,
        string filePath,
        CopilotAgentPluginParameters? pluginParameters = null,
        CancellationToken cancellationToken = default)
    {
        KernelPlugin plugin = await kernel.CreatePluginFromCopilotAgentPluginAsync(pluginName, filePath, pluginParameters, cancellationToken).ConfigureAwait(false);
        kernel.Plugins.Add(plugin);
        return plugin;
    }

    /// <summary>
    /// Creates a kernel plugin from an Copilot Agent Plugin file asynchronously.
    /// </summary>
    /// <param name="kernel">The kernel instance.</param>
    /// <param name="pluginName">The name of the plugin.</param>
    /// <param name="filePath">The file path of the Copilot Agent Plugin.</param>
    /// <param name="pluginParameters">Optional parameters for the plugin setup.</param>
    /// <param name="cancellationToken">Optional cancellation token.</param>
    /// <returns>A task that represents the asynchronous operation. The task result contains the created kernel plugin.</returns>
    public static async Task<KernelPlugin> CreatePluginFromCopilotAgentPluginAsync(
        this Kernel kernel,
        string pluginName,
        string filePath,
        CopilotAgentPluginParameters? pluginParameters = null,
        CancellationToken cancellationToken = default)
    {
        Verify.NotNull(kernel);
        KernelVerify.ValidPluginName(pluginName, kernel.Plugins);

#pragma warning disable CA2000 // Dispose objects before losing scope. No need to dispose the Http client here. It can either be an internal client using NonDisposableHttpClientHandler or an external client managed by the calling code, which should handle its disposal.
        var httpClient = HttpClientProvider.GetHttpClient(pluginParameters?.HttpClient ?? kernel.Services.GetService<HttpClient>());
#pragma warning restore CA2000

        if (!File.Exists(filePath))
        {
            throw new FileNotFoundException($"CopilotAgent file not found: {filePath}");
        }

        var loggerFactory = kernel.LoggerFactory;
        var logger = loggerFactory.CreateLogger(typeof(CopilotAgentPluginKernelExtensions)) ?? NullLogger.Instance;
        using var CopilotAgentFileJsonContents = DocumentLoader.LoadDocumentFromFilePathAsStream(filePath,
            logger);

        var results = await PluginManifestDocument.LoadAsync(CopilotAgentFileJsonContents, new ReaderOptions
        {
            ValidationRules = [] // Disable validation rules
        }).ConfigureAwait(false);

        if (!results.IsValid)
        {
            var messages = results.Problems.Select(static p => p.Message).Aggregate(static (a, b) => $"{a}, {b}");
            throw new InvalidOperationException($"Error loading the manifest: {messages}");
        }

        var document = results.Document;
        var openAPIRuntimes = document?.Runtimes?.Where(runtime => runtime.Type == RuntimeType.OpenApi).ToList();
        if (openAPIRuntimes is null || openAPIRuntimes.Count == 0)
        {
            throw new InvalidOperationException("No OpenAPI runtimes found in the manifest.");
        }

        var functions = new List<KernelFunction>();
        var documentWalker = new OpenApiWalker(new OperationIdNormalizationOpenApiVisitor());
        foreach (var runtime in openAPIRuntimes)
        {
            var manifestFunctions = document?.Functions?.Where(f => runtime.RunForFunctions.Contains(f.Name)).ToList();
            if (manifestFunctions is null || manifestFunctions.Count == 0)
            {
                logger.LogWarning("No functions found in the runtime object.");
                continue;
            }

            var openApiRuntime = runtime as OpenApiRuntime;
            var apiDescriptionUrl = openApiRuntime?.Spec?.Url ?? string.Empty;
            if (apiDescriptionUrl.Length == 0)
            {
                logger.LogWarning("No API description URL found in the runtime object.");
                continue;
            }

            var (parsedDescriptionUrl, isOnlineDescription) = Uri.TryCreate(apiDescriptionUrl, UriKind.Absolute, out var result) ?
                (result, true) :
                (new Uri(Path.Combine(Path.GetDirectoryName(filePath) ?? string.Empty, apiDescriptionUrl)), false);

            using var openApiDocumentStream = isOnlineDescription ?
                await DocumentLoader.LoadDocumentFromUriAsStreamAsync(parsedDescriptionUrl,
                    logger,
                    httpClient,
                    authCallback: null,
                    pluginParameters?.UserAgent,
                    cancellationToken).ConfigureAwait(false) :
                DocumentLoader.LoadDocumentFromFilePathAsStream(parsedDescriptionUrl.LocalPath,
                    logger);

            var documentReadResult = await new OpenApiStreamReader(new()
            {
                BaseUrl = parsedDescriptionUrl
            }
            ).ReadAsync(openApiDocumentStream, cancellationToken).ConfigureAwait(false);
            var openApiDocument = documentReadResult.OpenApiDocument;
            var openApiDiagnostic = documentReadResult.OpenApiDiagnostic;

            documentWalker.Walk(openApiDocument);

            var predicate = OpenApiFilterService.CreatePredicate(string.Join(",", manifestFunctions.Select(static f => f.Name)), null, null, openApiDocument);
            var filteredOpenApiDocument = OpenApiFilterService.CreateFilteredDocument(openApiDocument, predicate);

            var server = filteredOpenApiDocument.Servers.FirstOrDefault();
            if (server?.Url is null)
            {
                logger.LogWarning("Server URI not found. Plugin: {0}", pluginName);
                continue;
            }

            var openApiFunctionExecutionParameters = pluginParameters?.FunctionExecutionParameters?.TryGetValue(server.Url, out var parameters) == true
                ? parameters
                : new OpenApiFunctionExecutionParameters()
                {
                    EnableDynamicPayload = false,
                    EnablePayloadNamespacing = true,
                };

#pragma warning disable CA2000 // Dispose objects before losing scope. No need to dispose the Http client here. It can either be an internal client using NonDisposableHttpClientHandler or an external client managed by the calling code, which should handle its disposal.
            var operationRunnerHttpClient = HttpClientProvider.GetHttpClient(openApiFunctionExecutionParameters?.HttpClient ?? kernel.Services.GetService<HttpClient>());
#pragma warning restore CA2000
            static IDictionary<string, string>? CopilotAgentPluginHeadersFactory(RestApiOperation operation, IDictionary<string, object?> arguments, RestApiOperationRunOptions? options)
            {
                var graphAllowedHosts = new[]
                {
                    "graph.microsoft.com",
                    "graph.microsoft.us",
                    "dod-graph.microsoft.us",
                    "graph.microsoft.de",
                    "microsoftgraph.chinacloudapi.cn",
                    "canary.graph.microsoft.com",
                    "graph.microsoft-ppe.com"
                };
                if (options?.ApiHostUrl?.Host is not { } hostString || !graphAllowedHosts.Contains(hostString))
                {
                    return null;
                }
                string frameworkDescription = RuntimeInformation.FrameworkDescription;
                string osDescription = RuntimeInformation.OSDescription;
                string copilotAgentPluginVersion = HttpHeaderConstant.Values.GetAssemblyVersion(typeof(CopilotAgentPluginKernelExtensions));
                var defaultHeaders = new Dictionary<string, string>
                {
                    // TODO: version and format updates
                    ["SdkVersion"] = $"copilot-agent-plugins/{copilotAgentPluginVersion}, (runtimeEnvironment={frameworkDescription}; hostOS={osDescription})",
                    ["client-request-id"] = Guid.NewGuid().ToString()
                };

                var currentHeaders = operation.BuildHeaders(arguments);
                var finalHeaders = defaultHeaders.Concat(currentHeaders).ToDictionary(k => k.Key, v => v.Value);
                return finalHeaders;
            }

            var runner = new RestApiOperationRunner(
                operationRunnerHttpClient,
                openApiFunctionExecutionParameters?.AuthCallback,
                openApiFunctionExecutionParameters?.UserAgent,
                openApiFunctionExecutionParameters?.EnableDynamicPayload ?? false,
                openApiFunctionExecutionParameters?.EnablePayloadNamespacing ?? true,
                headersFactory: CopilotAgentPluginHeadersFactory);

            var info = OpenApiDocumentParser.ExtractRestApiInfo(filteredOpenApiDocument);
            var security = OpenApiDocumentParser.CreateRestApiOperationSecurityRequirements(filteredOpenApiDocument.SecurityRequirements);
            foreach (var path in filteredOpenApiDocument.Paths)
            {
                var operations = OpenApiDocumentParser.CreateRestApiOperations(filteredOpenApiDocument, path.Key, path.Value, null, logger);
                foreach (RestApiOperation operation in operations)
                {
                    try
                    {
                        logger.LogTrace("Registering Rest function {0}.{1}", pluginName, operation.Id);
                        TrimOperationDescriptions(operation);
                        functions.Add(OpenApiKernelPluginFactory.CreateRestApiFunction(pluginName, runner, info, security, operation, openApiFunctionExecutionParameters, new Uri(server.Url), loggerFactory));
                    }
                    catch (Exception ex) when (!ex.IsCriticalException())
                    {
                        // Logging the exception and keep registering other Rest functions
                        logger.LogWarning(ex, "Something went wrong while rendering the Rest function. Function: {0}.{1}. Error: {2}",
                            pluginName, operation.Id, ex.Message);
                    }
                }
            }
        }
        return KernelPluginFactory.CreateFromFunctions(pluginName, null, functions);
    }

    #region private
    private const int MaximumDescription = 1000;

    /// <summary>
    /// Trims the operation descriptions to a maximum length.
    /// </summary>
    private static void TrimOperationDescriptions(RestApiOperation operation)
    {
        // Limit the description
        if (operation.Description?.Length > MaximumDescription)
        {
            operation.Description = operation.Description.Substring(0, MaximumDescription);
        }
    }
    #endregion
}


===== Functions.OpenApi.Extensions\Extensions\CopilotAgentPluginParameters.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Collections.Generic;
using System.Net.Http;

namespace Microsoft.SemanticKernel.Plugins.OpenApi.Extensions;

/// <summary>
/// Copilot Agent Plugin parameters.
/// </summary>
public sealed class CopilotAgentPluginParameters
{
    /// <summary>
    /// Gets the HTTP client to be used in plugin initialization phase.
    /// </summary>
    public HttpClient? HttpClient { get; init; }

    /// <summary>
    /// Gets the user agent to be used in plugin initialization phase.
    /// </summary>
    public string? UserAgent { get; init; }

    /// <summary>
    /// A map of function execution parameters, where the key is the api dependency key from api manifest
    /// and the value is OpenApiFunctionExecutionParameters specific to that dependency.
    /// </summary>
    public Dictionary<string, OpenApiFunctionExecutionParameters>? FunctionExecutionParameters { get; init; }
}


===== Functions.OpenApi.Extensions\Extensions\DeclarativeAgentExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.Plugins.Manifest;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.Plugins.OpenApi;
using Microsoft.SemanticKernel.Plugins.OpenApi.Extensions;

namespace Microsoft.SemanticKernel;

/// <summary>
/// Provides extension methods for loading and managing declarative agents and their Copilot Agent Plugins.
/// </summary>
public static class DeclarativeAgentExtensions
{
    /// <summary>
    /// Creates a chat completion agent from a declarative agent manifest asynchronously.
    /// </summary>
    /// <typeparam name="T">The type of the agent to create.</typeparam>
    /// <param name="kernel">The kernel instance.</param>
    /// <param name="filePath">The file path of the declarative agent manifest.</param>
    /// <param name="pluginParameters">Optional parameters for the Copilot Agent Plugin setup.</param>
    /// <param name="promptExecutionSettings">Optional prompt execution settings. Ensure you enable function calling.</param>
    /// <param name="cancellationToken">Optional cancellation token.</param>
    /// <returns>A task that represents the asynchronous operation. The task result contains the created chat completion agent.</returns>
    public static async Task<T> CreateChatCompletionAgentFromDeclarativeAgentManifestAsync<T>(
        this Kernel kernel,
        string filePath,
        CopilotAgentPluginParameters? pluginParameters = null,
        PromptExecutionSettings? promptExecutionSettings = default,
        CancellationToken cancellationToken = default)
        where T : Agent, new()
    {
        Verify.NotNull(kernel);
        Verify.NotNullOrWhiteSpace(filePath);

        var loggerFactory = kernel.LoggerFactory;
        var logger = loggerFactory.CreateLogger(typeof(DeclarativeAgentExtensions)) ?? NullLogger.Instance;
        using var declarativeAgentFileJsonContents = DocumentLoader.LoadDocumentFromFilePathAsStream(filePath,
            logger);

        var results = await DCManifestDocument.LoadAsync(declarativeAgentFileJsonContents, new ReaderOptions
        {
            ValidationRules = [] // Disable validation rules
        }).ConfigureAwait(false);

        if (!results.IsValid)
        {
            var messages = results.Problems.Select(static p => p.Message).Aggregate(static (a, b) => $"{a}, {b}");
            throw new InvalidOperationException($"Error loading the manifest: {messages}");
        }

        var document = results.Document ?? throw new InvalidOperationException("Error loading the manifest");
        var manifestDirectory = Path.GetDirectoryName(filePath);
        document.Instructions = await GetEffectiveInstructionsAsync(manifestDirectory, document.Instructions, logger, cancellationToken).ConfigureAwait(false);

        var agent = new T
        {
            Name = document.Name,
            Instructions = document.Instructions,
            Kernel = kernel,
            Arguments = new KernelArguments(promptExecutionSettings ?? new PromptExecutionSettings()
            {
                FunctionChoiceBehavior = FunctionChoiceBehavior.Auto(),
            }),
            Description = document.Description,
            LoggerFactory = loggerFactory,
            Id = string.IsNullOrEmpty(document.Id) ? Guid.NewGuid().ToString() : document.Id!,
        };

        if (document.Capabilities is { Count: > 0 })
        {
            logger.LogWarning("Importing capabilities from declarative agent is not supported in semantic kernel.");
        }

        if (document.Actions is { Count: > 0 })
        {
            logger.LogInformation("Importing {ActionsCount} actions from declarative agent.", document.Actions.Count);
            await Task.WhenAll(document.Actions.Select(action => ImportCAPFromActionAsync(action, manifestDirectory, kernel, pluginParameters, logger, cancellationToken))).ConfigureAwait(false);
        }
        return agent;
    }
    private static async Task ImportCAPFromActionAsync(DCAction action, string? manifestDirectory, Kernel kernel, CopilotAgentPluginParameters? pluginParameters, ILogger logger, CancellationToken cancellationToken)
    {
        try
        {
            var capManifestPath = GetFullPath(manifestDirectory, action.File);
            logger.LogInformation("Importing action {ActionName} from declarative agent from path {Path}.", action.Id, capManifestPath);
            await kernel.ImportPluginFromCopilotAgentPluginAsync(action.Id, capManifestPath, pluginParameters, cancellationToken).ConfigureAwait(false);
        }
        catch (Exception ex) when (ex is FileNotFoundException or InvalidOperationException)
        {
            logger.LogError(ex, "Error importing action {ActionName} from declarative agent.", action.Id);
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "Error importing action {ActionName} from declarative agent.", action.Id);
            throw;
        }
    }
    private static async Task<string?> GetEffectiveInstructionsAsync(string? manifestFilePath, string? source, ILogger logger, CancellationToken cancellationToken)
    {
        if (string.IsNullOrEmpty(source) ||
            !source!.StartsWith("$[file('", StringComparison.OrdinalIgnoreCase) ||
            !source.EndsWith("')]", StringComparison.OrdinalIgnoreCase))
        {
            return source;
        }
#if NETCOREAPP3_0_OR_GREATER
        var filePath = source[8..^3];
#else
        var filePath = source.Substring(8, source.Length - 11);
#endif
        filePath = GetFullPath(manifestFilePath, filePath);
        return await DocumentLoader.LoadDocumentFromFilePathAsync(filePath, logger, cancellationToken).ConfigureAwait(false);
    }
    private static string GetFullPath(string? manifestDirectory, string relativeOrAbsolutePath)
    {
        return !Path.IsPathRooted(relativeOrAbsolutePath) && !relativeOrAbsolutePath.StartsWith("http", StringComparison.OrdinalIgnoreCase)
            ? string.IsNullOrEmpty(manifestDirectory)
                ? throw new InvalidOperationException("Invalid manifest file path.")
                : Path.Combine(manifestDirectory, relativeOrAbsolutePath)
            : relativeOrAbsolutePath;
    }
}


===== Functions.OpenApi.Extensions\Extensions\OperationIdNormalizationOpenApiVisitor.cs =====

// Copyright (c) Microsoft. All rights reserved.

using Microsoft.OpenApi.Models;
using Microsoft.OpenApi.Services;

namespace Microsoft.SemanticKernel.Plugins.OpenApi.Extensions;

/// <summary>
/// An OpenAPI visitor that normalizes the operation IDs by replacing dots with underscores.
/// So that the operation IDs can be used as function names in semantic kernel.
/// </summary>
internal sealed class OperationIdNormalizationOpenApiVisitor : OpenApiVisitorBase
{
    public override void Visit(OpenApiOperation operation)
    {
        if (operation is null || operation.OperationId is null)
        {
            return;
        }
        operation.OperationId = operation.OperationId.Replace('.', '_');
    }
}


===== Functions.OpenApi\Authentication\AuthenticateRequestAsyncCallback.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Net.Http;
using System.Threading;
using System.Threading.Tasks;

namespace Microsoft.SemanticKernel.Plugins.OpenApi;

/// <summary>
/// Represents a delegate that defines the method signature for asynchronously authenticating an HTTP request.
/// </summary>
/// <param name="request">The <see cref="HttpRequestMessage"/> to authenticate.</param>
/// <param name="cancellationToken">The cancellation token.</param>
/// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
public delegate Task AuthenticateRequestAsyncCallback(HttpRequestMessage request, CancellationToken cancellationToken = default);


===== Functions.OpenApi\DocumentLoader.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.IO;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.SemanticKernel.Http;

namespace Microsoft.SemanticKernel.Plugins.OpenApi;

internal static class DocumentLoader
{
    internal static async Task<string> LoadDocumentFromUriAsync(
        Uri uri,
        ILogger logger,
        HttpClient httpClient,
        AuthenticateRequestAsyncCallback? authCallback,
        string? userAgent,
        CancellationToken cancellationToken)
    {
        using var response = await LoadDocumentResponseFromUriAsync(uri, logger, httpClient, authCallback, userAgent, cancellationToken).ConfigureAwait(false);
        return await response.Content.ReadAsStringWithExceptionMappingAsync(cancellationToken).ConfigureAwait(false);
    }

    internal static async Task<Stream> LoadDocumentFromUriAsStreamAsync(
        Uri uri,
        ILogger logger,
        HttpClient httpClient,
        AuthenticateRequestAsyncCallback? authCallback,
        string? userAgent,
        CancellationToken cancellationToken)
    {
        //disposing the response disposes the stream
        var response = await LoadDocumentResponseFromUriAsync(uri, logger, httpClient, authCallback, userAgent, cancellationToken).ConfigureAwait(false);
        var stream = await response.Content.ReadAsStreamAndTranslateExceptionAsync(cancellationToken).ConfigureAwait(false);
        return new HttpResponseStream(stream, response);
    }

    private static async Task<HttpResponseMessage> LoadDocumentResponseFromUriAsync(
        Uri uri,
        ILogger logger,
        HttpClient httpClient,
        AuthenticateRequestAsyncCallback? authCallback,
        string? userAgent,
        CancellationToken cancellationToken)
    {
        using var request = new HttpRequestMessage(HttpMethod.Get, uri.ToString());
        request.Headers.UserAgent.Add(ProductInfoHeaderValue.Parse(userAgent ?? HttpHeaderConstant.Values.UserAgent));

        if (authCallback is not null)
        {
            await authCallback(request, cancellationToken).ConfigureAwait(false);
        }

        logger.LogTrace("Importing document from '{Uri}'", uri);

        return await httpClient.SendWithSuccessCheckAsync(request, cancellationToken).ConfigureAwait(false);
    }

    internal static async Task<string> LoadDocumentFromFilePathAsync(
        string filePath,
        ILogger logger,
        CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        CheckIfFileExists(filePath, logger);

        logger.LogTrace("Importing document from '{FilePath}'", filePath);

        using var sr = File.OpenText(filePath);
        return await sr.ReadToEndAsync(
#if NET
            cancellationToken
#endif
            ).ConfigureAwait(false);
    }

    private static void CheckIfFileExists(string filePath, ILogger logger)
    {
        if (!File.Exists(filePath))
        {
            var exception = new FileNotFoundException($"Invalid file path. The specified path '{filePath}' does not exist.");
            logger.LogError(exception, "Invalid file path. The specified path '{FilePath}' does not exist.", filePath);
            throw exception;
        }
    }

    internal static Stream LoadDocumentFromFilePathAsStream(
        string filePath,
        ILogger logger)
    {
        CheckIfFileExists(filePath, logger);

        logger.LogTrace("Importing document from {0}", filePath);

        return File.OpenRead(filePath);
    }

    internal static async Task<string> LoadDocumentFromStreamAsync(
        Stream stream,
        CancellationToken cancellationToken)
    {
        using StreamReader reader = new(stream);
#if NET7_0_OR_GREATER
        return await reader.ReadToEndAsync(cancellationToken).ConfigureAwait(false);
#else
        return await reader.ReadToEndAsync().ConfigureAwait(false);
#endif
    }
}


===== Functions.OpenApi\Extensions\OpenApiFunctionExecutionParameters.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Net.Http;
using Microsoft.Extensions.Logging;
using Microsoft.SemanticKernel.Http;

namespace Microsoft.SemanticKernel.Plugins.OpenApi;

/// <summary>
/// OpenAPI function execution parameters.
/// </summary>
public class OpenApiFunctionExecutionParameters
{
    /// <summary>
    /// HttpClient to use for sending HTTP requests.
    /// </summary>
    public HttpClient? HttpClient { get; set; }

    /// <summary>
    /// Callback for adding authentication data to HTTP requests.
    /// </summary>
    public AuthenticateRequestAsyncCallback? AuthCallback { get; set; }

    /// <summary>
    /// Override for REST API server url.
    /// </summary>
    public Uri? ServerUrlOverride { get; set; }

    /// <summary>
    /// Flag indicating whether to ignore non-compliant errors of the OpenAPI document or not.
    /// If set to true, the execution will not throw exceptions for non-compliant documents.
    /// Please note that enabling this option may result in incomplete or inaccurate execution results.
    /// </summary>
    public bool IgnoreNonCompliantErrors { get; set; }

    /// <summary>
    /// Optional user agent header value.
    /// </summary>
    public string UserAgent { get; set; }

    /// <summary>
    /// Determines whether the REST API operation payload is constructed dynamically based on payload metadata.
    /// It's enabled by default and allows to support operations with simple payload structure - no properties with the same name at different levels.
    /// To support more complex payloads, it should be disabled and the payload should be provided via the 'payload' argument.
    /// See the 'Providing Payload for OpenAPI Functions' ADR for more details: https://github.com/microsoft/semantic-kernel/blob/main/docs/decisions/0062-open-api-payload.md
    /// </summary>
    public bool EnableDynamicPayload { get; set; }

    /// <summary>
    /// Determines whether payload parameter names are augmented with namespaces. It's only applicable when EnableDynamicPayload property is set to true.
    /// Namespaces prevent naming conflicts by adding the parent parameter name as a prefix, separated by dots.
    /// For instance, without namespaces, the 'email' parameter for both the 'sender' and 'receiver' parent parameters
    /// would be resolved from the same 'email' argument, which is incorrect. However, by employing namespaces,
    /// the parameters 'sender.email' and 'sender.receiver' will be correctly resolved from arguments with the same names.
    /// See the 'Providing Payload for OpenAPI Functions' ADR for more details: https://github.com/microsoft/semantic-kernel/blob/main/docs/decisions/0062-open-api-payload.md
    /// </summary>
    public bool EnablePayloadNamespacing { get; set; }

    /// <summary>
    /// Optional list of HTTP operations to skip when importing the OpenAPI document.
    /// </summary>
    [Obsolete("Use OperationSelectionPredicate instead.")]
    public IList<string> OperationsToExclude { get; set; }

    /// <summary>
    /// Operation selection predicate to apply to all OpenAPI document operations.
    /// If set, the predicate will be applied to each operation in the document.
    /// If the predicate returns true, the operation will be imported; otherwise, it will be skipped.
    /// This can be used to import or filter operations based on various operation properties: Id, Path, Method, and Description.
    /// </summary>
    [Experimental("SKEXP0040")]
    public Func<OperationSelectionPredicateContext, bool>? OperationSelectionPredicate { get; set; }

    /// <summary>
    /// A custom HTTP response content reader. It can be useful when the internal reader
    /// for a specific content type is either missing, insufficient, or when custom behavior is desired.
    /// For instance, the internal reader for "application/json" HTTP content reads the content as a string.
    /// This may not be sufficient in cases where the JSON content is large, streamed chunk by chunk, and needs to be accessed
    /// as soon as the first chunk is available. To handle such cases, a custom reader can be provided to read the content
    /// as a stream rather than as a string.
    /// If the custom reader is not provided, or the reader returns null, the internal reader is used.
    /// </summary>
    public HttpResponseContentReader? HttpResponseContentReader { get; set; }

    /// <summary>
    /// A custom factory for the <see cref="RestApiOperationResponse"/>.
    /// It allows modifications of various aspects of the original response, such as adding response headers,
    /// changing response content, adjusting the schema, or providing a completely new response.
    /// If a custom factory is not supplied, the internal factory will be used by default.
    /// </summary>
    public RestApiOperationResponseFactory? RestApiOperationResponseFactory { get; set; }

    /// <summary>
    /// A custom REST API parameter filter.
    /// </summary>
    public RestApiParameterFilter? ParameterFilter { get; set; }

    /// <summary>
    /// The <see cref="ILoggerFactory"/> to use for logging. If null, no logging will be performed.
    /// </summary>
    public ILoggerFactory? LoggerFactory { get; set; }

    /// <summary>
    /// Initializes a new instance of the <see cref="OpenApiFunctionExecutionParameters"/> class.
    /// </summary>
    /// <param name="httpClient">The HttpClient to use for sending HTTP requests.</param>
    /// <param name="authCallback">The callback for adding authentication data to HTTP requests.</param>
    /// <param name="serverUrlOverride">The override for the REST API server URL.</param>
    /// <param name="userAgent">Optional user agent header value.</param>
    /// <param name="ignoreNonCompliantErrors">A flag indicating whether to ignore non-compliant errors of the OpenAPI document or not
    /// If set to true, the execution will not throw exceptions for non-compliant documents.
    /// Please note that enabling this option may result in incomplete or inaccurate execution results.</param>
    /// <param name="enableDynamicOperationPayload">Determines whether the REST API operation payload is constructed dynamically based on payload metadata.
    /// If false, the REST API payload must be provided via the 'payload' argument.</param>
    /// <param name="enablePayloadNamespacing">Determines whether payload parameter names are augmented with namespaces.
    /// Namespaces prevent naming conflicts by adding the parent parameter name as a prefix, separated by dots.</param>
    /// <param name="operationsToExclude">Optional list of operations not to import, e.g. in case they are not supported</param>
    public OpenApiFunctionExecutionParameters(
        HttpClient? httpClient = null,
        AuthenticateRequestAsyncCallback? authCallback = null,
        Uri? serverUrlOverride = null,
        string? userAgent = null,
        bool ignoreNonCompliantErrors = false,
        bool enableDynamicOperationPayload = true,
        bool enablePayloadNamespacing = false,
        IList<string>? operationsToExclude = null)
    {
        this.HttpClient = httpClient;
        this.AuthCallback = authCallback;
        this.ServerUrlOverride = serverUrlOverride;
        this.UserAgent = userAgent ?? HttpHeaderConstant.Values.UserAgent;
        this.IgnoreNonCompliantErrors = ignoreNonCompliantErrors;
        this.EnableDynamicPayload = enableDynamicOperationPayload;
        this.EnablePayloadNamespacing = enablePayloadNamespacing;
#pragma warning disable CS0618 // Type or member is obsolete
        this.OperationsToExclude = operationsToExclude ?? [];
#pragma warning restore CS0618 // Type or member is obsolete
    }
}


===== Functions.OpenApi\Extensions\OpenApiKernelExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.IO;
using System.Net.Http;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.SemanticKernel.Http;
using Microsoft.SemanticKernel.Plugins.OpenApi;

namespace Microsoft.SemanticKernel;

/// <summary>
/// Extension methods for <see cref="Kernel"/> to create and import plugins from OpenAPI specifications.
/// </summary>
public static class OpenApiKernelExtensions
{
    /// <summary>
    /// Creates <see cref="KernelPlugin"/> from an OpenAPI specification and adds it to <see cref="Kernel.Plugins"/>.
    /// </summary>
    /// <param name="kernel">The <see cref="Kernel"/> containing services, plugins, and other state for use throughout the operation.</param>
    /// <param name="pluginName">The plugin name.</param>
    /// <param name="filePath">The file path to the OpenAPI specification.</param>
    /// <param name="executionParameters">The OpenAPI specification parsing and function execution parameters.</param>
    /// <param name="cancellationToken">The cancellation token.</param>
    /// <returns>A <see cref="KernelPlugin"/> instance that contains functions corresponding to the operations defined in the OpenAPI specification.</returns>
    public static async Task<KernelPlugin> ImportPluginFromOpenApiAsync(
        this Kernel kernel,
        string pluginName,
        string filePath,
        OpenApiFunctionExecutionParameters? executionParameters = null,
        CancellationToken cancellationToken = default)
    {
        KernelPlugin plugin = await kernel.CreatePluginFromOpenApiAsync(pluginName, filePath, executionParameters, cancellationToken).ConfigureAwait(false);
        kernel.Plugins.Add(plugin);
        return plugin;
    }

    /// <summary>
    /// Creates <see cref="KernelPlugin"/> from an OpenAPI specification and adds it to <see cref="Kernel.Plugins"/>.
    /// </summary>
    /// <param name="kernel">The <see cref="Kernel"/> containing services, plugins, and other state for use throughout the operation.</param>
    /// <param name="pluginName">The plugin name.</param>
    /// <param name="uri">A URI referencing the OpenAPI specification.</param>
    /// <param name="executionParameters">The OpenAPI specification parsing and function execution parameters.</param>
    /// <param name="cancellationToken">The cancellation token.</param>
    /// <returns>A <see cref="KernelPlugin"/> instance that contains functions corresponding to the operations defined in the OpenAPI specification.</returns>
    public static async Task<KernelPlugin> ImportPluginFromOpenApiAsync(
        this Kernel kernel,
        string pluginName,
        Uri uri,
        OpenApiFunctionExecutionParameters? executionParameters = null,
        CancellationToken cancellationToken = default)
    {
        KernelPlugin plugin = await kernel.CreatePluginFromOpenApiAsync(pluginName, uri, executionParameters, cancellationToken).ConfigureAwait(false);
        kernel.Plugins.Add(plugin);
        return plugin;
    }

    /// <summary>
    /// Creates <see cref="KernelPlugin"/> from an OpenAPI specification and adds it to <see cref="Kernel.Plugins"/>.
    /// </summary>
    /// <param name="kernel">The <see cref="Kernel"/> containing services, plugins, and other state for use throughout the operation.</param>
    /// <param name="pluginName">The plugin name.</param>
    /// <param name="stream">A stream representing the OpenAPI specification.</param>
    /// <param name="executionParameters">The OpenAPI specification parsing and function execution parameters.</param>
    /// <param name="cancellationToken">The cancellation token.</param>
    /// <returns>A <see cref="KernelPlugin"/> instance that contains functions corresponding to the operations defined in the OpenAPI specification.</returns>
    public static async Task<KernelPlugin> ImportPluginFromOpenApiAsync(
        this Kernel kernel,
        string pluginName,
        Stream stream,
        OpenApiFunctionExecutionParameters? executionParameters = null,
        CancellationToken cancellationToken = default)
    {
        KernelPlugin plugin = await kernel.CreatePluginFromOpenApiAsync(pluginName, stream, executionParameters, cancellationToken).ConfigureAwait(false);
        kernel.Plugins.Add(plugin);
        return plugin;
    }

    /// <summary>
    /// Creates <see cref="KernelPlugin"/> from an OpenAPI specification and adds it to <see cref="Kernel.Plugins"/>.
    /// </summary>
    /// <param name="kernel">The <see cref="Kernel"/> containing services, plugins, and other state for use throughout the operation.</param>
    /// <param name="pluginName">The plugin name.</param>
    /// <param name="specification">The specification model.</param>
    /// <param name="executionParameters">The OpenAPI specification parsing and function execution parameters.</param>
    /// <returns>A <see cref="KernelPlugin"/> instance that contains functions corresponding to the operations defined in the OpenAPI specification.</returns>
    public static KernelPlugin ImportPluginFromOpenApi(
        this Kernel kernel,
        string pluginName,
        RestApiSpecification specification,
        OpenApiFunctionExecutionParameters? executionParameters = null)
    {
        KernelPlugin plugin = kernel.CreatePluginFromOpenApi(pluginName, specification, executionParameters);
        kernel.Plugins.Add(plugin);
        return plugin;
    }

    /// <summary>
    /// Creates <see cref="KernelPlugin"/> from an OpenAPI specification.
    /// </summary>
    /// <param name="kernel">The <see cref="Kernel"/> containing services, plugins, and other state for use throughout the operation.</param>
    /// <param name="pluginName">The plugin name.</param>
    /// <param name="filePath">The file path to the OpenAPI specification.</param>
    /// <param name="executionParameters">The OpenAPI specification parsing and function execution parameters.</param>
    /// <param name="cancellationToken">The cancellation token.</param>
    /// <returns>A <see cref="KernelPlugin"/> instance that contains functions corresponding to the operations defined in the OpenAPI specification.</returns>
    public static async Task<KernelPlugin> CreatePluginFromOpenApiAsync(
        this Kernel kernel,
        string pluginName,
        string filePath,
        OpenApiFunctionExecutionParameters? executionParameters = null,
        CancellationToken cancellationToken = default)
    {
        Verify.NotNull(kernel);
        KernelVerify.ValidPluginName(pluginName, kernel.Plugins);

#pragma warning disable CA2000 // Dispose objects before losing scope. No need to dispose the Http client here. It can either be an internal client using NonDisposableHttpClientHandler or an external client managed by the calling code, which should handle its disposal.
        var httpClient = HttpClientProvider.GetHttpClient(executionParameters?.HttpClient ?? kernel.Services.GetService<HttpClient>());
#pragma warning restore CA2000

        ILoggerFactory loggerFactory = executionParameters?.LoggerFactory ?? kernel.LoggerFactory;

        var openApiSpec = await DocumentLoader.LoadDocumentFromFilePathAsync(
            filePath,
            loggerFactory.CreateLogger(typeof(OpenApiKernelExtensions)) ?? NullLogger.Instance,
            cancellationToken).ConfigureAwait(false);

        return await CreateOpenApiPluginAsync(
            kernel,
            pluginName,
            executionParameters,
            httpClient,
            openApiSpec,
            cancellationToken: cancellationToken).ConfigureAwait(false);
    }

    /// <summary>
    /// Creates <see cref="KernelPlugin"/> from an OpenAPI specification.
    /// </summary>
    /// <param name="kernel">The <see cref="Kernel"/> containing services, plugins, and other state for use throughout the operation.</param>
    /// <param name="pluginName">The plugin name.</param>
    /// <param name="uri">A URI referencing the OpenAPI specification.</param>
    /// <param name="executionParameters">The OpenAPI specification parsing and function execution parameters.</param>
    /// <param name="cancellationToken">The cancellation token.</param>
    /// <returns>A <see cref="KernelPlugin"/> instance that contains functions corresponding to the operations defined in the OpenAPI specification.</returns>
    public static async Task<KernelPlugin> CreatePluginFromOpenApiAsync(
        this Kernel kernel,
        string pluginName,
        Uri uri,
        OpenApiFunctionExecutionParameters? executionParameters = null,
        CancellationToken cancellationToken = default)
    {
        Verify.NotNull(kernel);
        KernelVerify.ValidPluginName(pluginName, kernel.Plugins);

#pragma warning disable CA2000 // Dispose objects before losing scope. No need to dispose the Http client here. It can either be an internal client using NonDisposableHttpClientHandler or an external client managed by the calling code, which should handle its disposal.
        var httpClient = HttpClientProvider.GetHttpClient(executionParameters?.HttpClient ?? kernel.Services.GetService<HttpClient>());
#pragma warning restore CA2000

        ILoggerFactory loggerFactory = executionParameters?.LoggerFactory ?? kernel.LoggerFactory;

        var openApiSpec = await DocumentLoader.LoadDocumentFromUriAsync(
            uri,
            loggerFactory.CreateLogger(typeof(OpenApiKernelExtensions)) ?? NullLogger.Instance,
            httpClient,
            executionParameters?.AuthCallback,
            executionParameters?.UserAgent,
            cancellationToken).ConfigureAwait(false);

        return await CreateOpenApiPluginAsync(
            kernel,
            pluginName,
            executionParameters,
            httpClient,
            openApiSpec,
            uri,
            cancellationToken: cancellationToken).ConfigureAwait(false);
    }

    /// <summary>
    /// Creates <see cref="KernelPlugin"/> from an OpenAPI specification.
    /// </summary>
    /// <param name="kernel">The <see cref="Kernel"/> containing services, plugins, and other state for use throughout the operation.</param>
    /// <param name="pluginName">The plugin name.</param>
    /// <param name="stream">A stream representing the OpenAPI specification.</param>
    /// <param name="executionParameters">The OpenAPI specification parsing and function execution parameters.</param>
    /// <param name="cancellationToken">The cancellation token.</param>
    /// <returns>A <see cref="KernelPlugin"/> instance that contains functions corresponding to the operations defined in the OpenAPI specification.</returns>
    public static async Task<KernelPlugin> CreatePluginFromOpenApiAsync(
        this Kernel kernel,
        string pluginName,
        Stream stream,
        OpenApiFunctionExecutionParameters? executionParameters = null,
        CancellationToken cancellationToken = default)
    {
        Verify.NotNull(kernel);
        KernelVerify.ValidPluginName(pluginName, kernel.Plugins);

#pragma warning disable CA2000 // Dispose objects before losing scope. No need to dispose the Http client here. It can either be an internal client using NonDisposableHttpClientHandler or an external client managed by the calling code, which should handle its disposal.
        var httpClient = HttpClientProvider.GetHttpClient(executionParameters?.HttpClient ?? kernel.Services.GetService<HttpClient>());
#pragma warning restore CA2000

        var openApiSpec = await DocumentLoader.LoadDocumentFromStreamAsync(stream, cancellationToken).ConfigureAwait(false);

        return await CreateOpenApiPluginAsync(
            kernel,
            pluginName,
            executionParameters,
            httpClient,
            openApiSpec,
            cancellationToken: cancellationToken).ConfigureAwait(false);
    }

    /// <summary>
    /// Creates <see cref="KernelPlugin"/> from an OpenAPI specification.
    /// </summary>
    /// <param name="kernel">The <see cref="Kernel"/> containing services, plugins, and other state for use throughout the operation.</param>
    /// <param name="pluginName">The plugin name.</param>
    /// <param name="specification">The specification model.</param>
    /// <param name="executionParameters">The OpenAPI specification parsing and function execution parameters.</param>
    /// <param name="cancellationToken">The cancellation token.</param>
    /// <returns>A <see cref="KernelPlugin"/> instance that contains functions corresponding to the operations defined in the OpenAPI specification.</returns>
    public static KernelPlugin CreatePluginFromOpenApi(
        this Kernel kernel,
        string pluginName,
        RestApiSpecification specification,
        OpenApiFunctionExecutionParameters? executionParameters = null,
        CancellationToken cancellationToken = default)
    {
        Verify.NotNull(kernel);
        KernelVerify.ValidPluginName(pluginName, kernel.Plugins);

#pragma warning disable CA2000 // Dispose objects before losing scope. No need to dispose the Http client here. It can either be an internal client using NonDisposableHttpClientHandler or an external client managed by the calling code, which should handle its disposal.
        var httpClient = HttpClientProvider.GetHttpClient(executionParameters?.HttpClient ?? kernel.Services.GetService<HttpClient>());
#pragma warning restore CA2000

        return OpenApiKernelPluginFactory.CreateOpenApiPlugin(
            pluginName: pluginName,
            executionParameters: executionParameters,
            httpClient: httpClient,
            specification: specification,
            loggerFactory: kernel.LoggerFactory);
    }

    #region private

    private static async Task<KernelPlugin> CreateOpenApiPluginAsync(
        Kernel kernel,
        string pluginName,
        OpenApiFunctionExecutionParameters? executionParameters,
        HttpClient httpClient,
        string pluginJson,
        Uri? documentUri = null,
        CancellationToken cancellationToken = default)
    {
        ILoggerFactory loggerFactory = executionParameters?.LoggerFactory ?? kernel.LoggerFactory;

        return await OpenApiKernelPluginFactory.CreateOpenApiPluginAsync(pluginName, executionParameters, httpClient, pluginJson, documentUri, loggerFactory, cancellationToken).ConfigureAwait(false); ;
    }

    #endregion
}


===== Functions.OpenApi\Extensions\OpenApiSchemaExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Globalization;
using System.IO;
using System.Text;
using Microsoft.OpenApi.Models;
using Microsoft.OpenApi.Writers;

namespace Microsoft.SemanticKernel.Plugins.OpenApi;

internal static class OpenApiSchemaExtensions
{
    /// <summary>
    /// Gets a JSON serialized representation of an <see cref="OpenApiSchema"/>
    /// </summary>
    /// <param name="schema">The schema.</param>
    /// <returns>An instance of <see cref="KernelJsonSchema"/> that contains the JSON Schema.</returns>
    internal static KernelJsonSchema ToJsonSchema(this OpenApiSchema schema)
    {
        var schemaBuilder = new StringBuilder();
        var jsonWriter = new OpenApiJsonWriter(new StringWriter(schemaBuilder, CultureInfo.InvariantCulture));
        jsonWriter.Settings.InlineLocalReferences = true;
        schema.SerializeAsV3(jsonWriter);
        return KernelJsonSchema.Parse(schemaBuilder.ToString());
    }
}


===== Functions.OpenApi\Extensions\RestApiOperationExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;

namespace Microsoft.SemanticKernel.Plugins.OpenApi;

/// <summary>
/// Class for extensions methods for the <see cref="RestApiOperation"/> class.
/// </summary>
internal static partial class RestApiOperationExtensions
{
    /// <summary>
    /// Returns list of REST API operation parameters.
    /// </summary>
    /// <param name="operation">The REST API operation.</param>
    /// <param name="addPayloadParamsFromMetadata">Determines whether to include the operation payload parameters from payload metadata.
    /// If false, the 'payload' and 'content-type' artificial parameters are added instead.
    /// </param>
    /// <param name="enablePayloadNamespacing">Determines whether parameter names are augmented with namespaces.
    /// Namespaces are created by prefixing parameter names with their root parameter names.
    /// For instance, without namespaces, the 'email' parameter for both the 'sender' and 'receiver' parent parameters
    /// would be resolved from the same 'email' argument, which is incorrect. However, by employing namespaces,
    /// the parameters 'sender.email' and 'receiver.mail' will be correctly resolved from arguments with the same names.
    /// </param>
    /// <param name="parameterFilter">Filter which can be used to eliminate or modify RestApiParameters.</param>
    /// <returns>The list of parameters.</returns>
    public static IReadOnlyList<RestApiParameter> GetParameters(
        this RestApiOperation operation,
        bool addPayloadParamsFromMetadata = true,
        bool enablePayloadNamespacing = false,
        RestApiParameterFilter? parameterFilter = null)
    {
        var parameters = new List<RestApiParameter>(parameterFilter is null ?
        operation.Parameters :
            operation.Parameters.Select(p => parameterFilter(new(operation, p))).Where(p => p != null).Cast<RestApiParameter>().ToList());

        // Add payload parameters
        if (operation.Payload is not null)
        {
            parameters.AddRange(GetPayloadParameters(operation, addPayloadParamsFromMetadata, enablePayloadNamespacing, parameterFilter));
        }

        foreach (var parameter in parameters)
        {
            // The functionality of replacing invalid symbols and setting the argument name
            // was introduced to handle dashes allowed in OpenAPI parameter names and
            // not supported by SK at that time. More context -
            // https://github.com/microsoft/semantic-kernel/pull/283#discussion_r1156286780
            // It's kept for backward compatibility only.
            parameter.ArgumentName ??= InvalidSymbolsRegex().Replace(parameter.Name, "_");
        }

        return parameters;
    }

    /// <summary>
    /// Returns the default return parameter metadata for a given REST API operation.
    /// </summary>
    /// <param name="operation">The REST API operation object with Responses to parse.</param>
    /// <param name="preferredResponses">A list of preferred response codes to use when selecting the default response.</param>
    /// <returns>The default return parameter metadata, if any.</returns>
    public static KernelReturnParameterMetadata? GetDefaultReturnParameter(this RestApiOperation operation, string[]? preferredResponses = null)
    {
        RestApiExpectedResponse? restOperationResponse = GetDefaultResponse(operation.Responses, preferredResponses ??= s_preferredResponses);

        var returnParameter =
            restOperationResponse is not null ? new KernelReturnParameterMetadata { Description = restOperationResponse.Description, Schema = restOperationResponse.Schema } : null;

        return returnParameter;
    }

    /// <summary>
    /// Retrieves the default response.
    /// </summary>
    /// <param name="responses">Possible REST API responses.</param>
    /// <param name="preferredResponses">The preferred response codes to use when selecting the default response.</param>
    /// <returns>The default response, if any.</returns>
    private static RestApiExpectedResponse? GetDefaultResponse(IDictionary<string, RestApiExpectedResponse> responses, string[] preferredResponses)
    {
        foreach (var code in preferredResponses)
        {
            if (responses.TryGetValue(code, out var response))
            {
                return response;
            }
        }

        // If no appropriate response is found, return null or throw an exception
        return null;
    }

    /// <summary>
    /// Retrieves the payload parameters for a given REST API operation.
    /// </summary>
    /// <param name="operation">The REST API operation to retrieve parameters for.</param>
    /// <param name="useParametersFromMetadata">Flag indicating whether to include parameters from metadata.
    /// If false or not specified, the 'payload' and 'content-type' parameters are added instead.</param>
    /// <param name="enableNamespacing">Flag indicating whether to namespace payload parameter names.</param>
    /// <param name="parameterFilter">Filter which can be used to eliminate or modify RestApiParameters.</param>
    /// <returns>A list of <see cref="RestApiParameter"/> representing the payload parameters.</returns>
    private static List<RestApiParameter> GetPayloadParameters(RestApiOperation operation, bool useParametersFromMetadata, bool enableNamespacing, RestApiParameterFilter? parameterFilter)
    {
        if (useParametersFromMetadata)
        {
            if (operation.Payload is null)
            {
                throw new KernelException($"Payload parameters cannot be retrieved from the '{operation.Id}' operation payload metadata because it is missing.");
            }

            // The 'text/plain' content type payload metadata does not contain parameter names.
            // So, returning artificial 'payload' parameter instead.
            if (operation.Payload.MediaType == MediaTypeTextPlain)
            {
                return [CreatePayloadArtificialParameter(operation)];
            }

            return GetParametersFromPayloadMetadata(operation, operation.Payload, operation.Payload.Properties, enableNamespacing, parameterFilter);
        }

        // Adding artificial 'payload' and 'content-type' in case parameters from payload metadata are not required.
        if (parameterFilter is not null)
        {
            return new RestApiParameter[]
            {
                CreatePayloadArtificialParameter(operation),
                CreateContentTypeArtificialParameter(operation)
            }.Where(p => parameterFilter(new(operation, p)) is not null).ToList();
        }
        return
        [
            CreatePayloadArtificialParameter(operation),
            CreateContentTypeArtificialParameter(operation)
        ];
    }

    /// <summary>
    /// Creates the 'content-type' artificial parameter for a REST API operation.
    /// </summary>
    /// <param name="operation">The REST API operation.</param>
    /// <returns>The 'content-type' artificial parameter.</returns>
    private static RestApiParameter CreateContentTypeArtificialParameter(RestApiOperation operation)
    {
        return new RestApiParameter(
            RestApiOperation.ContentTypeArgumentName,
            "string",
            isRequired: false,
            expand: false,
            RestApiParameterLocation.Body,
            RestApiParameterStyle.Simple,
            description: "Content type of REST API request body.");
    }

    /// <summary>
    /// Creates the 'payload' artificial parameter for a REST API operation.
    /// </summary>
    /// <param name="operation">The REST API operation.</param>
    /// <returns>The 'payload' artificial parameter.</returns>
    private static RestApiParameter CreatePayloadArtificialParameter(RestApiOperation operation)
    {
        return new RestApiParameter(
            RestApiOperation.PayloadArgumentName,
            operation.Payload?.MediaType == MediaTypeTextPlain ? "string" : "object",
            isRequired: true,
            expand: false,
            RestApiParameterLocation.Body,
            RestApiParameterStyle.Simple,
            description: operation.Payload?.Description ?? "REST API request body.",
            schema: operation.Payload?.Schema);
    }

    /// <summary>
    /// Retrieves parameters from REST API payload metadata.
    /// </summary>
    /// <param name="operation">The REST API operation.</param>
    /// <param name="parent">The parent object of the parameter, can be either an instance of <see cref="RestApiPayload"/> or <see cref="RestApiPayloadProperty"/>.</param>
    /// <param name="properties">The REST API payload properties.</param>
    /// <param name="enableNamespacing">Determines whether property names are augmented with namespaces.
    /// Namespaces are created by prefixing property names with their root property names.
    /// </param>
    /// <param name="parameterFilter">Filter which can be used to eliminate or modify RestApiParameters.</param>
    /// <param name="rootPropertyName">The root property name.</param>
    /// <returns>The list of payload parameters.</returns>
    private static List<RestApiParameter> GetParametersFromPayloadMetadata(RestApiOperation operation, object parent, IList<RestApiPayloadProperty> properties, bool enableNamespacing = false, RestApiParameterFilter? parameterFilter = null, string? rootPropertyName = null)
    {
        var parameters = new List<RestApiParameter>();

        foreach (var property in properties)
        {
            var parameterName = GetPropertyName(property, rootPropertyName, enableNamespacing);

            if (!property.Properties.Any())
            {
                // Assign an argument name (sanitized form of the property name) so that the parameter value look-up / resolution functionality in the RestApiOperationRunner
                // class can find the value for the parameter by the argument name in the arguments dictionary. If the argument name is not assigned here, the resolution mechanism
                // will try to find the parameter value by the parameter's original name. However, because the parameter was advertised with the sanitized name by the RestApiOperationExtensions.GetParameters
                // method, no value will be found, and an exception will be thrown: "No argument is found for the 'customerid_contact@odata.bind' payload property."
                property.ArgumentName ??= InvalidSymbolsRegex().Replace(parameterName, "_");

                var parameter = new RestApiParameter(
                    name: parameterName,
                    type: property.Type,
                    isRequired: property.IsRequired,
                    expand: false,
                    location: RestApiParameterLocation.Body,
                    style: RestApiParameterStyle.Simple,
                    defaultValue: property.DefaultValue,
                    description: property.Description,
                    format: property.Format,
                    schema: property.Schema)
                {
                    ArgumentName = property.ArgumentName
                };
                parameter = parameterFilter is null ? parameter : parameterFilter(new(operation, parameter) { Parent = parent });
                if (parameter is not null)
                {
                    parameters.Add(parameter);
                }
            }

            parameters.AddRange(GetParametersFromPayloadMetadata(operation, property, property.Properties, enableNamespacing, parameterFilter, parameterName));
        }

        return parameters;
    }

    /// <summary>
    /// Gets the property name based on the provided parameters.
    /// </summary>
    /// <param name="property">The property.</param>
    /// <param name="rootPropertyName">The root property name to be used for constructing the full property name.</param>
    /// <param name="enableNamespacing">Determines whether to add namespace to property name or not.</param>
    /// <returns>The property name.</returns>
    private static string GetPropertyName(RestApiPayloadProperty property, string? rootPropertyName, bool enableNamespacing = false)
    {
        if (enableNamespacing)
        {
            return string.IsNullOrEmpty(rootPropertyName) ? property.Name : $"{rootPropertyName}.{property.Name}";
        }

        return property.Name;
    }

    private const string MediaTypeTextPlain = "text/plain";
    private static readonly string[] s_preferredResponses = ["200", "201", "202", "203", "204", "205", "206", "207", "208", "226", "2XX", "default"];

#if NET
    [GeneratedRegex("[^0-9A-Za-z_]+")]
    private static partial Regex InvalidSymbolsRegex();
#else
    private static Regex InvalidSymbolsRegex() => s_invalidSymbolsRegex;
    private static readonly Regex s_invalidSymbolsRegex = new("[^0-9A-Za-z_]+", RegexOptions.Compiled);
#endif
}


===== Functions.OpenApi\Extensions\RestApiOperationResponseExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Text.Json;
using Json.Schema;

namespace Microsoft.SemanticKernel;

/// <summary>
/// Class for extensions methods for the <see cref="RestApiOperationResponse"/> class.
/// </summary>
public static class RestApiOperationResponseExtensions
{
    /// <summary>
    /// Validates the response content against the schema.
    /// </summary>
    /// <returns>True if the response is valid, false otherwise.</returns>
    /// <remarks>
    /// If the schema is not specified, the response is considered valid.
    /// If the content type is not specified, the response is considered valid.
    /// If the content type is not supported, the response is considered valid.
    /// Right now, only JSON is supported.
    /// </remarks>
    public static bool IsValid(this RestApiOperationResponse response)
    {
        if (response.ExpectedSchema is null)
        {
            return true;
        }

        if (string.IsNullOrEmpty(response.ContentType))
        {
            return true;
        }

        return response.ContentType! switch
        {
            var ct when ct.StartsWith("application/json", StringComparison.OrdinalIgnoreCase) => ValidateJson(response),
            var ct when ct.StartsWith("application/xml", StringComparison.OrdinalIgnoreCase) => ValidateXml(response),
            var ct when ct.StartsWith("text/plain", StringComparison.OrdinalIgnoreCase) || ct.StartsWith("text/html", StringComparison.OrdinalIgnoreCase) => ValidateTextHtml(response),
            _ => true,
        };
    }

    private static bool ValidateJson(RestApiOperationResponse response)
    {
        try
        {
            var jsonSchema = JsonSchema.FromText(JsonSerializer.Serialize(response.ExpectedSchema));
            using var contentDoc = JsonDocument.Parse(response.Content?.ToString() ?? string.Empty);
            var result = jsonSchema.Evaluate(contentDoc);
            return result.IsValid;
        }
        catch (JsonException)
        {
            return false;
        }
    }

    private static bool ValidateXml(RestApiOperationResponse _)
    {
        // todo -- implement
        return true;
    }

    private static bool ValidateTextHtml(RestApiOperationResponse response)
    {
        try
        {
            var jsonSchema = JsonSchema.FromText(JsonSerializer.Serialize(response.ExpectedSchema));
            using var contentDoc = JsonDocument.Parse($"\"{response.Content}\"");
            var result = jsonSchema.Evaluate(contentDoc);
            return result.IsValid;
        }
        catch (JsonException)
        {
            return false;
        }
    }
}


===== Functions.OpenApi\HttpContentFactory.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Net.Http;

namespace Microsoft.SemanticKernel.Plugins.OpenApi;

/// <summary>
/// Represents a delegate for creating HTTP content for a REST API operation.
/// </summary>
/// <param name="payload">The operation payload metadata.</param>
/// <param name="arguments">The operation arguments.</param>
/// <returns>The object and HttpContent representing the operation payload.</returns>
internal delegate (object Payload, HttpContent Content) HttpContentFactory(RestApiPayload? payload, IDictionary<string, object?> arguments);


===== Functions.OpenApi\HttpResponseContentReader.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Threading;
using System.Threading.Tasks;

namespace Microsoft.SemanticKernel.Plugins.OpenApi;

/// <summary>
/// Represents a delegate for reading HTTP response content.
/// </summary>
/// <param name="context">The context containing HTTP operation details.</param>
/// <param name="cancellationToken">The cancellation token.</param>
/// <returns>The HTTP response content.</returns>
public delegate Task<object?> HttpResponseContentReader(HttpResponseContentReaderContext context, CancellationToken cancellationToken = default);


===== Functions.OpenApi\HttpResponseContentReaderContext.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Net.Http;

namespace Microsoft.SemanticKernel.Plugins.OpenApi;

/// <summary>
/// Represents the context for HTTP response content reader.
/// </summary>
public sealed class HttpResponseContentReaderContext
{
    /// <summary>
    /// Initializes a new instance of the <see cref="HttpResponseContentReaderContext"/> class.
    /// </summary>
    /// <param name="request">HTTP request message.</param>
    /// <param name="response">HTTP response message.</param>
    internal HttpResponseContentReaderContext(HttpRequestMessage request, HttpResponseMessage response)
    {
        this.Request = request;
        this.Response = response;
    }

    /// <summary>
    /// The HTTP request message.
    /// </summary>
    public HttpRequestMessage Request { get; }

    /// <summary>
    /// The HTTP response message.
    /// </summary>
    public HttpResponseMessage Response { get; }
}


===== Functions.OpenApi\Model\RestApiExpectedResponse.cs =====

// Copyright (c) Microsoft. All rights reserved.

namespace Microsoft.SemanticKernel.Plugins.OpenApi;

/// <summary>
/// REST API response.
/// </summary>
public sealed class RestApiExpectedResponse
{
    /// <summary>
    /// Gets the description of the response.
    /// </summary>
    public string Description { get; }

    /// <summary>
    /// Gets the media type of the response.
    /// </summary>
    public string MediaType { get; }

    /// <summary>
    /// The schema of the response.
    /// </summary>
    public KernelJsonSchema? Schema { get; }

    /// <summary>
    /// Initializes a new instance of the <see cref="RestApiExpectedResponse"/> class.
    /// </summary>
    /// <param name="description">The description of the response.</param>
    /// <param name="mediaType">The media type of the response.</param>
    /// <param name="schema">The schema against which the response body should be validated.</param>
    internal RestApiExpectedResponse(string description, string mediaType, KernelJsonSchema? schema = null)
    {
        this.Description = description;
        this.MediaType = mediaType;
        this.Schema = schema;
    }
}


===== Functions.OpenApi\Model\RestApiInfo.cs =====

// Copyright (c) Microsoft. All rights reserved.

namespace Microsoft.SemanticKernel.Plugins.OpenApi;

/// <summary>
/// The REST API information.
/// </summary>
public sealed class RestApiInfo
{
    /// <summary>
    /// The title of the application.
    /// </summary>
    public string? Title { get; init; }

    /// <summary>
    /// A short description of the application.
    /// </summary>
    public string? Description { get; init; }

    /// <summary>
    /// The version of the OpenAPI document.
    /// </summary>
    public string? Version { get; init; }

    /// <summary>
    /// Creates a new instance of the <see cref="RestApiInfo"/> class.
    /// </summary>
    internal RestApiInfo()
    {
    }
}


===== Functions.OpenApi\Model\RestApiOAuthFlow.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;

namespace Microsoft.SemanticKernel.Plugins.OpenApi;

/// <summary>
/// REST API OAuth Flow.
/// </summary>
public sealed class RestApiOAuthFlow
{
    /// <summary>
    /// REQUIRED. The authorization URL to be used for this flow.
    /// Applies to implicit and authorizationCode OAuthFlow.
    /// </summary>
    public Uri AuthorizationUrl { get; init; }

    /// <summary>
    /// REQUIRED. The token URL to be used for this flow.
    /// Applies to password, clientCredentials, and authorizationCode OAuthFlow.
    /// </summary>
    public Uri TokenUrl { get; init; }

    /// <summary>
    /// The URL to be used for obtaining refresh tokens.
    /// </summary>
    public Uri? RefreshUrl { get; init; }

    /// <summary>
    /// REQUIRED. A map between the scope name and a short description for it.
    /// </summary>
    public IDictionary<string, string> Scopes
    {
        get => this._scopes;
        init => this._scopes = value;
    }

    /// <summary>
    /// Creates an instance of a <see cref="RestApiOAuthFlow"/> class.
    /// </summary>
#pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider adding the 'required' modifier or declaring as nullable.
    internal RestApiOAuthFlow()
#pragma warning restore CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider adding the 'required' modifier or declaring as nullable.
    {
    }

    internal void Freeze()
    {
        this._scopes = new ReadOnlyDictionary<string, string>(this._scopes);
    }

    private IDictionary<string, string> _scopes;
}


===== Functions.OpenApi\Model\RestApiOAuthFlows.cs =====

// Copyright (c) Microsoft. All rights reserved.

namespace Microsoft.SemanticKernel.Plugins.OpenApi;

/// <summary>
/// REST API OAuth Flows.
/// </summary>
public sealed class RestApiOAuthFlows
{
    /// <summary>
    /// Configuration for the OAuth Implicit flow
    /// </summary>
    public RestApiOAuthFlow? Implicit { get; init; }

    /// <summary>
    /// Configuration for the OAuth Resource Owner Password flow.
    /// </summary>
    public RestApiOAuthFlow? Password { get; init; }

    /// <summary>
    /// Configuration for the OAuth Client Credentials flow.
    /// </summary>
    public RestApiOAuthFlow? ClientCredentials { get; init; }

    /// <summary>
    /// Configuration for the OAuth Authorization Code flow.
    /// </summary>
    public RestApiOAuthFlow? AuthorizationCode { get; init; }

    /// <summary>
    /// Creates an instance of a <see cref="RestApiOAuthFlows"/> class.
    /// </summary>
    internal RestApiOAuthFlows()
    {
    }

    internal void Freeze()
    {
        this.Implicit?.Freeze();
        this.Password?.Freeze();
        this.ClientCredentials?.Freeze();
        this.AuthorizationCode?.Freeze();
    }
}


===== Functions.OpenApi\Model\RestApiOperation.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net.Http;
using System.Text.Json.Nodes;
using System.Web;

namespace Microsoft.SemanticKernel.Plugins.OpenApi;

/// <summary>
/// The REST API operation.
/// </summary>
public sealed class RestApiOperation
{
    /// <summary>
    /// A static empty dictionary to default to when none is provided.
    /// </summary>
    private static readonly Dictionary<string, object?> s_emptyDictionary = [];

    /// <summary>
    /// Gets the name of an artificial parameter to be used for operation having "text/plain" payload media type.
    /// </summary>
    public static string PayloadArgumentName => "payload";

    /// <summary>
    /// Gets the name of an artificial parameter to be used for indicate payload media-type if it's missing in payload metadata.
    /// </summary>
    public static string ContentTypeArgumentName => "content-type";

    /// <summary>
    /// The operation identifier.
    /// </summary>
    public string? Id { get; }

    /// <summary>
    /// The operation description.
    /// </summary>
    public string? Description
    {
        get => this._description;
        set
        {
            this._freezable.ThrowIfFrozen();
            this._description = value;
        }
    }

    /// <summary>
    /// The operation summary.
    /// </summary>
    public string? Summary
    {
        get => this._summary;
        set
        {
            this._freezable.ThrowIfFrozen();
            this._summary = value;
        }
    }

    /// <summary>
    /// The operation path.
    /// </summary>
    public string Path { get; }

    /// <summary>
    /// The operation method - GET, POST, PUT, DELETE.
    /// </summary>
    public HttpMethod Method { get; }

    /// <summary>
    /// The server.
    /// </summary>
    public IList<RestApiServer> Servers { get; private set; }

    /// <summary>
    ///  Path level servers.
    /// </summary>
    public IList<RestApiServer> PathServers { get; init; }

    /// <summary>
    /// Operation level servers.
    /// </summary>
    public IList<RestApiServer> OperationServers { get; init; }

    /// <summary>
    /// The security requirements.
    /// </summary>
    public IList<RestApiSecurityRequirement> SecurityRequirements { get; private set; }

    /// <summary>
    /// The operation parameters.
    /// </summary>
    public IList<RestApiParameter> Parameters { get; private set; }

    /// <summary>
    /// The list of possible operation responses.
    /// </summary>
    public IDictionary<string, RestApiExpectedResponse> Responses { get; private set; }

    /// <summary>
    /// The operation payload.
    /// </summary>
    public RestApiPayload? Payload { get; }

    /// <summary>
    /// Additional unstructured metadata about the operation.
    /// </summary>
    public IDictionary<string, object?> Extensions
    {
        get => this._extensions;
        init => this._extensions = value;
    }

    /// <summary>
    /// Creates an instance of a <see cref="RestApiOperation"/> class.
    /// </summary>
    /// <param name="id">The operation identifier.</param>
    /// <param name="servers">The servers.</param>
    /// <param name="path">The operation path.</param>
    /// <param name="method">The operation method.</param>
    /// <param name="description">The operation description.</param>
    /// <param name="parameters">The operation parameters.</param>
    /// <param name="responses">The operation responses.</param>
    /// <param name="securityRequirements">The operation security requirements.</param>
    /// <param name="payload">The operation payload.</param>
    /// <param name="pathServers">The path servers.</param>
    /// <param name="operationServers">The operation servers.</param>
    internal RestApiOperation(
        string? id,
        IList<RestApiServer> servers,
        string path,
        HttpMethod method,
        string? description,
        IList<RestApiParameter> parameters,
        IDictionary<string, RestApiExpectedResponse> responses,
        IList<RestApiSecurityRequirement> securityRequirements,
        RestApiPayload? payload = null,
        IList<RestApiServer>? pathServers = null,
        IList<RestApiServer>? operationServers = null)
    {
        this.Id = id;
        this.Servers = servers;
        this.Path = path;
        this.Method = method;
        this.Description = description;
        this.Parameters = parameters;
        this.Responses = responses ?? new Dictionary<string, RestApiExpectedResponse>();
        this.SecurityRequirements = securityRequirements;
        this.Payload = payload;
        this.PathServers = pathServers ?? new List<RestApiServer>();
        this.OperationServers = operationServers ?? new List<RestApiServer>();
    }

    /// <summary>
    /// Builds operation Url.
    /// </summary>
    /// <param name="arguments">The operation arguments.</param>
    /// <param name="serverUrlOverride">Override for REST API operation server url.</param>
    /// <param name="apiHostUrl">The URL of REST API host.</param>
    /// <returns>The operation Url.</returns>
    internal Uri BuildOperationUrl(IDictionary<string, object?> arguments, Uri? serverUrlOverride = null, Uri? apiHostUrl = null)
    {
        var serverUrl = this.GetServerUrl(serverUrlOverride, apiHostUrl, arguments);

        var path = this.BuildPath(this.Path, arguments);

        return new Uri(serverUrl, $"{path.TrimStart('/')}");
    }

    /// <summary>
    /// Builds operation request headers.
    /// </summary>
    /// <param name="arguments">The operation arguments.</param>
    /// <returns>The request headers.</returns>
    internal IDictionary<string, string> BuildHeaders(IDictionary<string, object?> arguments)
    {
        var headers = new Dictionary<string, string>();

        var parameters = this.Parameters.Where(p => p.Location == RestApiParameterLocation.Header);

        foreach (var parameter in parameters)
        {
            var argument = this.GetArgumentForParameter(arguments, parameter);
            if (argument == null)
            {
                // Skipping not required parameter if no argument provided for it.    
                continue;
            }

            var parameterStyle = parameter.Style ?? RestApiParameterStyle.Simple;

            if (!s_parameterSerializers.TryGetValue(parameterStyle, out var serializer))
            {
                throw new KernelException($"The headers parameter '{parameterStyle}' serialization style is not supported.");
            }

            var node = OpenApiTypeConverter.Convert(parameter.Name, parameter.Type, argument, parameter.Schema);

            //Serializing the parameter and adding it to the headers.
            headers.Add(parameter.Name, serializer.Invoke(parameter, node));
        }

        return headers;
    }

    /// <summary>
    /// Builds the operation query string.
    /// </summary>
    /// <param name="arguments">The operation arguments.</param>
    /// <returns>The query string.</returns>
    internal string BuildQueryString(IDictionary<string, object?> arguments)
    {
        var segments = new List<string>();

        var parameters = this.Parameters.Where(p => p.Location == RestApiParameterLocation.Query);

        foreach (var parameter in parameters)
        {
            var argument = this.GetArgumentForParameter(arguments, parameter);
            if (argument == null)
            {
                // Skipping not required parameter if no argument provided for it.    
                continue;
            }

            var parameterStyle = parameter.Style ?? RestApiParameterStyle.Form;

            if (!s_parameterSerializers.TryGetValue(parameterStyle, out var serializer))
            {
                throw new KernelException($"The query string parameter '{parameterStyle}' serialization style is not supported.");
            }

            var node = OpenApiTypeConverter.Convert(parameter.Name, parameter.Type, argument, parameter.Schema);

            // Serializing the parameter and adding it to the query string if there's an argument for it.
            segments.Add(serializer.Invoke(parameter, node));
        }

        return string.Join("&", segments);
    }

    /// <summary>
    /// Makes the current instance unmodifiable.
    /// </summary>
    internal void Freeze()
    {
        this._freezable.Freeze();
        this.Payload?.Freeze();

        this.Parameters = new ReadOnlyCollection<RestApiParameter>(this.Parameters);
        foreach (var parameter in this.Parameters)
        {
            parameter.Freeze();
        }

        this.Servers = new ReadOnlyCollection<RestApiServer>(this.Servers);
        foreach (var server in this.Servers)
        {
            server.Freeze();
        }

        this.SecurityRequirements = new ReadOnlyCollection<RestApiSecurityRequirement>(this.SecurityRequirements);
        foreach (var securityRequirement in this.SecurityRequirements)
        {
            securityRequirement.Freeze();
        }

        this.Responses = new ReadOnlyDictionary<string, RestApiExpectedResponse>(this.Responses);

        this._extensions = new ReadOnlyDictionary<string, object?>(this._extensions);
    }

    #region private

    /// <summary>
    /// Builds operation path.
    /// </summary>
    /// <param name="pathTemplate">The original path template.</param>
    /// <param name="arguments">The operation arguments.</param>
    /// <returns>The path.</returns>
    private string BuildPath(string pathTemplate, IDictionary<string, object?> arguments)
    {
        var parameters = this.Parameters.Where(p => p.Location == RestApiParameterLocation.Path);

        foreach (var parameter in parameters)
        {
            var argument = this.GetArgumentForParameter(arguments, parameter);
            if (argument == null)
            {
                // Skipping not required parameter if no argument provided for it.    
                continue;
            }

            var parameterStyle = parameter.Style ?? RestApiParameterStyle.Simple;

            if (!s_parameterSerializers.TryGetValue(parameterStyle, out var serializer))
            {
                throw new KernelException($"The path parameter '{parameterStyle}' serialization style is not supported.");
            }

            var node = OpenApiTypeConverter.Convert(parameter.Name, parameter.Type, argument, parameter.Schema);

            // Serializing the parameter and adding it to the path.
            pathTemplate = pathTemplate.Replace($"{{{parameter.Name}}}", HttpUtility.UrlEncode(serializer.Invoke(parameter, node)));
        }

        return pathTemplate;
    }

    private object? GetArgumentForParameter(IDictionary<string, object?> arguments, RestApiParameter parameter)
    {
        // Try to get the parameter value by the argument name.
        if (!string.IsNullOrEmpty(parameter.ArgumentName) &&
            arguments.TryGetValue(parameter.ArgumentName!, out object? argument) &&
            argument is not null)
        {
            return argument;
        }

        // Try to get the parameter value by the parameter name.
        if (arguments.TryGetValue(parameter.Name, out argument) &&
            argument is not null)
        {
            return argument;
        }

        if (parameter.IsRequired)
        {
            throw new KernelException($"No argument '{parameter.ArgumentName ?? parameter.Name}' is provided for the '{parameter.Name}' required parameter of the operation - '{this.Id}'.");
        }

        return null;
    }

    /// <summary>
    /// Returns operation server Url.
    /// </summary>
    /// <param name="serverUrlOverride">Override for REST API operation server url.</param>
    /// <param name="apiHostUrl">The URL of REST API host.</param>
    /// <param name="arguments">The operation arguments.</param>
    /// <returns>The operation server url.</returns>
    private Uri GetServerUrl(Uri? serverUrlOverride, Uri? apiHostUrl, IDictionary<string, object?> arguments)
    {
        string serverUrlString;

        if (serverUrlOverride is not null)
        {
            serverUrlString = serverUrlOverride.AbsoluteUri;
        }
        else if (this.Servers is { Count: > 0 } servers && servers[0].Url is { } url)
        {
            serverUrlString = url;

            foreach (var variable in servers[0].Variables)
            {
                var variableName = variable.Key;

                // Try to get the variable value by the argument name.
                if (!string.IsNullOrEmpty(variable.Value.ArgumentName) &&
                    arguments.TryGetValue(variable.Value.ArgumentName!, out object? value) &&
                    value is string { } argStrValue && variable.Value.IsValid(argStrValue))
                {
                    serverUrlString = url.Replace($"{{{variableName}}}", argStrValue);
                }
                // Try to get the variable value by the variable name.
                else if (arguments.TryGetValue(variableName, out value) &&
                    value is string { } strValue &&
                    variable.Value.IsValid(strValue))
                {
                    serverUrlString = url.Replace($"{{{variableName}}}", strValue);
                }
                // Use the default value if no argument is provided.
                else if (variable.Value.Default is not null)
                {
                    serverUrlString = url.Replace($"{{{variableName}}}", variable.Value.Default);
                }
                // Throw an exception if there's no value for the variable.
                else
                {
                    throw new KernelException($"No argument '{variable.Value.ArgumentName ?? variableName}' provided for the '{variableName}' server variable of the operation - '{this.Id}'.");
                }
            }
        }
        else
        {
            serverUrlString =
                apiHostUrl?.AbsoluteUri ??
                throw new InvalidOperationException($"Server url is not defined for operation {this.Id}");
        }

        // Make sure base url ends with trailing slash
        if (!serverUrlString.EndsWith("/", StringComparison.OrdinalIgnoreCase))
        {
            serverUrlString += "/";
        }

        return new Uri(serverUrlString);
    }

    private static readonly Dictionary<RestApiParameterStyle, Func<RestApiParameter, JsonNode, string>> s_parameterSerializers = new()
    {
        { RestApiParameterStyle.Simple, SimpleStyleParameterSerializer.Serialize },
        { RestApiParameterStyle.Form, FormStyleParameterSerializer.Serialize },
        { RestApiParameterStyle.SpaceDelimited, SpaceDelimitedStyleParameterSerializer.Serialize },
        { RestApiParameterStyle.PipeDelimited, PipeDelimitedStyleParameterSerializer.Serialize }
    };

    private IDictionary<string, object?> _extensions = s_emptyDictionary;
    private readonly Freezable _freezable = new();
    private string? _description;
    private string? _summary;

    #endregion
}


===== Functions.OpenApi\Model\RestApiOperationHeadersFactory.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;

namespace Microsoft.SemanticKernel.Plugins.OpenApi;

/// <summary>
/// Represents a delegate for creating headers for a REST API operation.
/// </summary>
/// <param name="operation">The REST API operation.</param>
/// <param name="arguments">The arguments for the operation.</param>
/// <param name="options">The operation run options.</param>
/// <returns>The operation headers.</returns>
internal delegate IDictionary<string, string>? RestApiOperationHeadersFactory(RestApiOperation operation, IDictionary<string, object?> arguments, RestApiOperationRunOptions? options);


===== Functions.OpenApi\Model\RestApiOperationPayloadFactory.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Net.Http;

namespace Microsoft.SemanticKernel.Plugins.OpenApi;

/// <summary>
/// Represents a delegate for creating a payload for a REST API operation.
/// </summary>
/// <param name="operation">The REST API operation.</param>
/// <param name="arguments">The arguments for the operation.</param>
/// <param name="enableDynamicPayload">
/// Determines whether the operation payload is constructed dynamically based on operation payload metadata.
/// If false, the operation payload must be provided via the 'payload' property.
/// </param>
/// <param name="enablePayloadNamespacing">
/// Determines whether payload parameters are resolved from the arguments by
/// full name (parameter name prefixed with the parent property name).
/// </param>
/// <param name="options">The operation run options.</param>
/// <returns>The operation payload.</returns>
internal delegate (object Payload, HttpContent Content)? RestApiOperationPayloadFactory(RestApiOperation operation, IDictionary<string, object?> arguments, bool enableDynamicPayload, bool enablePayloadNamespacing, RestApiOperationRunOptions? options);


===== Functions.OpenApi\Model\RestApiOperationRunOptions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;

namespace Microsoft.SemanticKernel.Plugins.OpenApi;

/// <summary>
/// Options for REST API operation run.
/// </summary>
internal sealed class RestApiOperationRunOptions
{
    /// <summary>
    /// Override for REST API operation server URL.
    /// </summary>
    public Uri? ServerUrlOverride { get; set; }

    /// <summary>
    /// The URL of REST API host.
    /// </summary>
    public Uri? ApiHostUrl { get; set; }

    /// <summary>
    /// The Kernel instance used for the operation run.
    /// </summary>
    public Kernel? Kernel { get; set; }

    /// <summary>
    /// The Kernel function whose invocation triggered the operation run.
    /// </summary>
    public KernelFunction? KernelFunction { get; set; }

    /// <summary>
    /// The Kernel arguments whose associated with the operation run.
    /// </summary>
    public KernelArguments? KernelArguments { get; set; }
}


===== Functions.OpenApi\Model\RestApiOperationUrlFactory.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;

namespace Microsoft.SemanticKernel.Plugins.OpenApi;

/// <summary>
/// Represents a delegate for creating a URL for a REST API operation.
/// </summary>
/// <param name="operation">The REST API operation.</param>
/// <param name="arguments">The arguments for the operation.</param>
/// <param name="options">The operation run options.</param>
/// <returns>The operation URL.</returns>
internal delegate Uri? RestApiOperationUrlFactory(RestApiOperation operation, IDictionary<string, object?> arguments, RestApiOperationRunOptions? options);


===== Functions.OpenApi\Model\RestApiParameter.cs =====

// Copyright (c) Microsoft. All rights reserved.

namespace Microsoft.SemanticKernel.Plugins.OpenApi;

/// <summary>
/// REST API parameter.
/// </summary>
public sealed class RestApiParameter
{
    /// <summary>
    /// The parameter name.
    /// </summary>
    public string Name { get; }

    /// <summary>
    /// The parameter argument name.
    /// If provided, the argument name will be used to search for the parameter value in function arguments.
    /// If no value is found using the argument name, the original name - <see cref="RestApiParameter.Name"/> will be used for the search instead.
    /// </summary>
    public string? ArgumentName
    {
        get => this._argumentName;
        set
        {
            this._freezable.ThrowIfFrozen();
            this._argumentName = value;
        }
    }

    /// <summary>
    /// The parameter type - string, integer, number, boolean, array and object.
    /// </summary>
    internal string Type { get; }

    /// <summary>
    /// The parameter type modifier that refines the generic parameter type to a more specific one.
    /// More details can be found at https://swagger.io/docs/specification/data-models/data-types
    /// </summary>
    public string? Format { get; }

    /// <summary>
    /// The parameter description.
    /// </summary>
    public string? Description { get; }

    /// <summary>
    /// Flag specifying if the parameter is required or not.
    /// </summary>
    public bool IsRequired { get; }

    /// <summary>
    /// The parameter location.
    /// </summary>
    public RestApiParameterLocation Location { get; }

    /// <summary>
    /// The parameter style - defines how multiple values are delimited.
    /// </summary>
    public RestApiParameterStyle? Style { get; }

    /// <summary>
    /// Type of array item for parameters of "array" type.
    /// </summary>
    internal string? ArrayItemType { get; }

    /// <summary>
    /// The default value.
    /// </summary>
    public object? DefaultValue { get; }

    /// <summary>
    /// Specifies whether arrays and objects should generate separate parameters for each array item or object property.
    /// </summary>
    public bool Expand { get; }

    /// <summary>
    /// The schema of the parameter.
    /// </summary>
    public KernelJsonSchema? Schema
    {
        get => this._schema;
        set
        {
            this._freezable.ThrowIfFrozen();
            this._schema = value;
        }
    }

    /// <summary>
    /// Creates an instance of a <see cref="RestApiParameter"/> class.
    /// </summary>
    /// <param name="name">The parameter name.</param>
    /// <param name="type">The parameter type.</param>
    /// <param name="isRequired">Flag specifying if the parameter is required or not.</param>
    /// <param name="expand">Specifies whether arrays and objects should generate separate parameters for each array item or object property.</param>
    /// <param name="location">The parameter location.</param>
    /// <param name="style">The parameter style - defines how multiple values are delimited.</param>
    /// <param name="arrayItemType">Type of array item for parameters of "array" type.</param>
    /// <param name="defaultValue">The parameter default value.</param>
    /// <param name="description">The parameter description.</param>
    /// <param name="format">The parameter type modifier that refines the generic parameter type to a more specific one.
    /// More details can be found at https://swagger.io/docs/specification/data-models/data-types</param>
    /// <param name="schema">The parameter schema.</param>
    internal RestApiParameter(
        string name,
        string type,
        bool isRequired,
        bool expand,
        RestApiParameterLocation location,
        RestApiParameterStyle? style = null,
        string? arrayItemType = null,
        object? defaultValue = null,
        string? description = null,
        string? format = null,
        KernelJsonSchema? schema = null)
    {
        this.Name = name;
        this.Type = type;
        this.IsRequired = isRequired;
        this.Expand = expand;
        this.Location = location;
        this.Style = style;
        this.ArrayItemType = arrayItemType;
        this.DefaultValue = defaultValue;
        this.Description = description;
        this.Format = format;
        this.Schema = schema;
    }
    internal void Freeze()
    {
        this._freezable.Freeze();
    }

    private readonly Freezable _freezable = new();
    private string? _argumentName;
    private KernelJsonSchema? _schema;
}


===== Functions.OpenApi\Model\RestApiParameterLocation.cs =====

// Copyright (c) Microsoft. All rights reserved.

namespace Microsoft.SemanticKernel.Plugins.OpenApi;

/// <summary>
/// REST API parameter location.
/// </summary>
public enum RestApiParameterLocation
{
    /// <summary>
    /// Query parameter.
    /// </summary>
    Query,

    /// <summary>
    /// Header parameter.
    /// </summary>
    Header,

    /// <summary>
    /// Path parameter.
    /// </summary>
    Path,

    /// <summary>
    /// Cookie parameter.
    /// </summary>
    Cookie,

    /// <summary>
    /// Body parameter.
    /// </summary>
    Body,
}


===== Functions.OpenApi\Model\RestApiParameterStyle.cs =====

// Copyright (c) Microsoft. All rights reserved.

namespace Microsoft.SemanticKernel.Plugins.OpenApi;

/// <summary>
/// REST API parameter style.
/// </summary>
public enum RestApiParameterStyle
{
    /// <summary>
    /// Path-style parameters.
    /// </summary>
    Matrix,

    /// <summary>
    /// Label style parameters.
    /// </summary>
    Label,

    /// <summary>
    /// Form style parameters.
    /// </summary>
    Form,

    /// <summary>
    /// Simple style parameters.
    /// </summary>
    Simple,

    /// <summary>
    /// Space separated array values.
    /// </summary>
    SpaceDelimited,

    /// <summary>
    /// Pipe separated array values.
    /// </summary>
    PipeDelimited,

    /// <summary>
    /// Provides a simple way of rendering nested objects using form parameters.
    /// </summary>
    DeepObject
}


===== Functions.OpenApi\Model\RestApiPayload.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Collections.ObjectModel;

namespace Microsoft.SemanticKernel.Plugins.OpenApi;

/// <summary>
/// REST API payload.
/// </summary>
public sealed class RestApiPayload
{
    /// <summary>
    /// The payload MediaType.
    /// </summary>
    public string MediaType { get; }

    /// <summary>
    /// The payload description.
    /// </summary>
    public string? Description { get; }

    /// <summary>
    /// The payload properties.
    /// </summary>
    public IList<RestApiPayloadProperty> Properties { get; private set; }

    /// <summary>
    /// The schema of the parameter.
    /// </summary>
    public KernelJsonSchema? Schema { get; }

    /// <summary>
    /// Creates an instance of a <see cref="RestApiPayload"/> class.
    /// </summary>
    /// <param name="mediaType">The media type.</param>
    /// <param name="properties">The properties.</param>
    /// <param name="description">The description.</param>
    /// <param name="schema">The JSON Schema.</param>
    internal RestApiPayload(string mediaType, IList<RestApiPayloadProperty> properties, string? description = null, KernelJsonSchema? schema = null)
    {
        this.MediaType = mediaType;
        this.Properties = properties;
        this.Description = description;
        this.Schema = schema;
    }

    /// <summary>
    /// Makes the current instance unmodifiable.
    /// </summary>
    internal void Freeze()
    {
        this.Properties = new ReadOnlyCollection<RestApiPayloadProperty>(this.Properties);
        foreach (var property in this.Properties)
        {
            property.Freeze();
        }
    }
}


===== Functions.OpenApi\Model\RestApiPayloadProperty.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Collections.ObjectModel;

namespace Microsoft.SemanticKernel.Plugins.OpenApi;

/// <summary>
/// REST API payload property.
/// </summary>
public sealed class RestApiPayloadProperty
{
    /// <summary>
    /// The property name.
    /// </summary>
    public string Name { get; }

    /// <summary>
    /// The property argument name.
    /// If provided, the argument name will be used to search for the corresponding property value in function arguments.
    /// If no property value is found using the argument name, the original name - <see cref="RestApiPayloadProperty.Name"/> will be used for the search instead.
    /// </summary>
    public string? ArgumentName
    {
        get => this._argumentName;
        set
        {
            this._freezable.ThrowIfFrozen();
            this._argumentName = value;
        }
    }

    /// <summary>
    /// The property type.
    /// </summary>
    internal string Type { get; }

    /// <summary>
    /// The property type modifier that refines the generic parameter type to a more specific one.
    /// More details can be found at https://swagger.io/docs/specification/data-models/data-types
    /// </summary>
    public string? Format { get; }

    /// <summary>
    /// The property description.
    /// </summary>
    public string? Description { get; }

    /// <summary>
    /// Flag specifying if the property is required or not.
    /// </summary>
    public bool IsRequired { get; }

    /// <summary>
    /// The properties.
    /// </summary>
    public IList<RestApiPayloadProperty> Properties { get; private set; }
    /// <summary>
    /// The schema of the parameter.
    /// </summary>
    public KernelJsonSchema? Schema { get; }

    /// <summary>
    /// The default value.
    /// </summary>
    public object? DefaultValue { get; }

    /// <summary>
    /// Creates an instance of a <see cref="RestApiPayloadProperty"/> class.
    /// </summary>
    /// <param name="name">The name of the property.</param>
    /// <param name="type">The type of the property.</param>
    /// <param name="isRequired">A flag specifying if the property is required or not.</param>
    /// <param name="properties">A list of properties for the payload property.</param>
    /// <param name="description">A description of the property.</param>
    /// <param name="format">The parameter type modifier that refines the generic parameter type to a more specific one.
    /// More details can be found at https://swagger.io/docs/specification/data-models/data-types</param>
    /// <param name="schema">The schema of the payload property.</param>
    /// <param name="defaultValue">The default value of the property.</param>
    /// <returns>Returns a new instance of the <see cref="RestApiPayloadProperty"/> class.</returns>
    internal RestApiPayloadProperty(
        string name,
        string type,
        bool isRequired,
        IList<RestApiPayloadProperty> properties,
        string? description = null,
        string? format = null,
        KernelJsonSchema? schema = null,
        object? defaultValue = null)
    {
        this.Name = name;
        this.Type = type;
        this.IsRequired = isRequired;
        this.Description = description;
        this.Properties = properties;
        this.Schema = schema;
        this.Format = format;
        this.DefaultValue = defaultValue;
    }

    /// <summary>
    /// Makes the current instance unmodifiable.
    /// </summary>
    internal void Freeze()
    {
        this.Properties = new ReadOnlyCollection<RestApiPayloadProperty>(this.Properties);
        foreach (var property in this.Properties)
        {
            property.Freeze();
        }

        this._freezable.Freeze();
    }
    private readonly Freezable _freezable = new();
    private string? _argumentName;
}


===== Functions.OpenApi\Model\RestApiSecurityRequirement.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics.CodeAnalysis;

namespace Microsoft.SemanticKernel.Plugins.OpenApi;

/// <summary>
/// The REST API security requirement object.
/// </summary>
#pragma warning disable CA1710 // Identifiers should have correct suffix
public sealed class RestApiSecurityRequirement : IDictionary<RestApiSecurityScheme, IList<string>>, IReadOnlyDictionary<RestApiSecurityScheme, IList<string>>
#pragma warning restore CA1710 // Identifiers should have correct suffix
{
    /// <summary>Creates an instance of a <see cref="RestApiSecurityRequirement"/> class.</summary>
    /// <param name="dictionary">Dictionary containing the security schemes.</param>
    internal RestApiSecurityRequirement(IDictionary<RestApiSecurityScheme, IList<string>>? dictionary = null)
    {
        this._dictionary = dictionary ?? new Dictionary<RestApiSecurityScheme, IList<string>>();
    }

    /// <summary>Gets the number of elements contained in the <see cref="RestApiSecurityRequirement"/>.</summary>
    public int Count => this._dictionary.Count;

    /// <summary>Adds the specified security scheme to the <see cref="RestApiSecurityRequirement"/>.</summary>
    /// <param name="key">The security scheme to add.</param>
    /// <param name="value">The security scheme scopes.</param>
    public void Add(RestApiSecurityScheme key, IList<string> value)
    {
        this._freezable.ThrowIfFrozen();
        this._dictionary.Add(key, value);
    }

    /// <summary>Removes the security scheme with the specified key from the <see cref="RestApiSecurityRequirement"/>.</summary>
    /// <param name="key">The security scheme to remove.</param>
    public bool Remove(RestApiSecurityScheme key)
    {
        this._freezable.ThrowIfFrozen();
        return this._dictionary.Remove(key);
    }

    /// <summary>Removes all the security schemes from the <see cref="RestApiSecurityRequirement"/>.</summary>
    public void Clear()
    {
        this._freezable.ThrowIfFrozen();
        this._dictionary.Clear();
    }

    /// <summary>Determines whether the <see cref="RestApiSecurityRequirement"/> contains a specific security scheme.</summary>
    /// <param name="key">The security scheme to locate in the <see cref="RestApiSecurityRequirement"/>.</param>
    /// <returns>true if the <see cref="RestApiSecurityRequirement"/> contains an element with the specified key; otherwise, false.</returns>
    public bool ContainsKey(RestApiSecurityScheme key)
    {
        return this._dictionary.ContainsKey(key);
    }

    /// <summary>Get the security scheme scopes associated with the specified security scheme.</summary>
    /// <param name="key">The security scheme to get the scopes for.</param>
    /// <param name="value">When this method returns, contains the security scheme scopes associated
    /// with the specified security scheme, if the security scheme is found; otherwise, the default value
    /// for the type of the value parameter. This parameter is passed uninitialized.
    /// </param>
    /// <returns>true if the <see cref="RestApiSecurityRequirement"/> contains an element with the specified key; otherwise, false.</returns>
    public bool TryGetValue(RestApiSecurityScheme key, [MaybeNullWhen(false)] out IList<string> value)
    {
        return this._dictionary.TryGetValue(key, out value);
    }

    /// <summary>Gets or sets the security scheme scopes associated with the specified security scheme.</summary>
    /// <param name="key">The security scheme to get or set the scopes for.</param>
#pragma warning disable CA1043 // Use Integral Or String Argument For Indexers
    public IList<string> this[RestApiSecurityScheme key]
#pragma warning restore CA1043 // Use Integral Or String Argument For Indexers
    {
        get => this._dictionary[key];
        set
        {
            this._freezable.ThrowIfFrozen();
            this._dictionary[key] = value;
        }
    }

    /// <summary>Gets an <see cref="ICollection{RestApiSecurityScheme}"/> of all of the security schemes.</summary>
    public ICollection<RestApiSecurityScheme> Keys => this._dictionary.Keys;

    /// <summary>Gets an <see cref="ICollection{IList}"/> of all of the security scheme scopes.</summary>
    public ICollection<IList<string>> Values => this._dictionary.Values;

    internal void Freeze()
    {
        foreach (var item in this)
        {
            // Freeze the security scheme
            item.Key.Freeze();

            // Freeze the security scheme scopes
            this[item.Key] = new ReadOnlyCollection<string>(item.Value);
        }

        // Freeze the object
        this._freezable.Freeze();
    }

    #region Interface implementations
    /// <inheritdoc/>
    ICollection<RestApiSecurityScheme> IDictionary<RestApiSecurityScheme, IList<string>>.Keys => this._dictionary.Keys;

    /// <inheritdoc/>
    IEnumerable<RestApiSecurityScheme> IReadOnlyDictionary<RestApiSecurityScheme, IList<string>>.Keys => this._dictionary.Keys;

    /// <inheritdoc/>
    IEnumerable<IList<string>> IReadOnlyDictionary<RestApiSecurityScheme, IList<string>>.Values => this._dictionary.Values;

    /// <inheritdoc/>
    bool ICollection<KeyValuePair<RestApiSecurityScheme, IList<string>>>.IsReadOnly => this._freezable.IsFrozen;

    /// <inheritdoc/>
    IList<string> IReadOnlyDictionary<RestApiSecurityScheme, IList<string>>.this[RestApiSecurityScheme key] => this._dictionary[key];

    /// <inheritdoc/>
    IList<string> IDictionary<RestApiSecurityScheme, IList<string>>.this[RestApiSecurityScheme key]
    {
        get => this._dictionary[key];
        set
        {
            this._freezable.ThrowIfFrozen();
            this._dictionary[key] = value;
        }
    }

    /// <inheritdoc/>
    void IDictionary<RestApiSecurityScheme, IList<string>>.Add(RestApiSecurityScheme key, IList<string> value)
    {
        this._freezable.ThrowIfFrozen();
        this._dictionary.Add(key, value);
    }

    /// <inheritdoc/>
    bool IDictionary<RestApiSecurityScheme, IList<string>>.ContainsKey(RestApiSecurityScheme key)
    {
        return this._dictionary.ContainsKey(key);
    }

    /// <inheritdoc/>
    bool IDictionary<RestApiSecurityScheme, IList<string>>.Remove(RestApiSecurityScheme key)
    {
        this._freezable.ThrowIfFrozen();
        return this._dictionary.Remove(key);
    }

    /// <inheritdoc/>
#pragma warning disable CS8769 // Nullability of reference types in value of type does not match target type.
    bool IDictionary<RestApiSecurityScheme, IList<string>>.TryGetValue(RestApiSecurityScheme key, [MaybeNullWhen(false)] out IList<string> value)
    {
        return this._dictionary.TryGetValue(key, out value);
    }
#pragma warning restore CS8769 // Nullability of reference types in value of type does not match target type.

    /// <inheritdoc/>
    void ICollection<KeyValuePair<RestApiSecurityScheme, IList<string>>>.Add(KeyValuePair<RestApiSecurityScheme, IList<string>> item)
    {
        this._freezable.ThrowIfFrozen();
        this._dictionary.Add(item.Key, item.Value);
    }

    /// <inheritdoc/>
    bool ICollection<KeyValuePair<RestApiSecurityScheme, IList<string>>>.Contains(KeyValuePair<RestApiSecurityScheme, IList<string>> item)
    {
        return ((ICollection<KeyValuePair<RestApiSecurityScheme, IList<string>>>)this._dictionary).Contains(item);
    }

    /// <inheritdoc/>
    void ICollection<KeyValuePair<RestApiSecurityScheme, IList<string>>>.CopyTo(KeyValuePair<RestApiSecurityScheme, IList<string>>[] array, int arrayIndex)
    {
        ((ICollection<KeyValuePair<RestApiSecurityScheme, IList<string>>>)this._dictionary).CopyTo(array, arrayIndex);
    }

    /// <inheritdoc/>
    bool ICollection<KeyValuePair<RestApiSecurityScheme, IList<string>>>.Remove(KeyValuePair<RestApiSecurityScheme, IList<string>> item)
    {
        this._freezable.ThrowIfFrozen();
        return this._dictionary.Remove(item.Key);
    }

    /// <inheritdoc/>
    IEnumerator<KeyValuePair<RestApiSecurityScheme, IList<string>>> IEnumerable<KeyValuePair<RestApiSecurityScheme, IList<string>>>.GetEnumerator()
    {
        return this._dictionary.GetEnumerator();
    }

    /// <inheritdoc/>
    IEnumerator IEnumerable.GetEnumerator()
    {
        return this._dictionary.GetEnumerator();
    }

    /// <inheritdoc/>
    bool IReadOnlyDictionary<RestApiSecurityScheme, IList<string>>.ContainsKey(RestApiSecurityScheme key)
    {
        return this._dictionary.ContainsKey(key);
    }

    /// <inheritdoc/>
#pragma warning disable CS8769 // Nullability of reference types in value of type does not match target type.
    bool IReadOnlyDictionary<RestApiSecurityScheme, IList<string>>.TryGetValue(RestApiSecurityScheme key, [MaybeNullWhen(false)] out IList<string> value)
    {
        return this._dictionary.TryGetValue(key, out value);
    }
#pragma warning restore CS8769 // Nullability of reference types in value of type does not match target type.

    private readonly IDictionary<RestApiSecurityScheme, IList<string>> _dictionary;
    private readonly Freezable _freezable = new();

    #endregion
}


===== Functions.OpenApi\Model\RestApiSecurityScheme.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;

namespace Microsoft.SemanticKernel.Plugins.OpenApi;

/// <summary>
/// REST API Security Scheme.
/// </summary>
public sealed class RestApiSecurityScheme
{
    /// <summary>
    /// REQUIRED. The type of the security scheme. Valid values are "apiKey", "http", "oauth2", "openIdConnect".
    /// </summary>
    public string SecuritySchemeType { get; init; }

    /// <summary>
    /// A short description for security scheme. CommonMark syntax MAY be used for rich text representation.
    /// </summary>
    public string? Description { get; init; }

    /// <summary>
    /// REQUIRED. The name of the header, query or cookie parameter to be used.
    /// </summary>
    public string Name { get; init; }

    /// <summary>
    /// REQUIRED. The location of the API key. Valid values are "query", "header" or "cookie".
    /// </summary>
    public RestApiParameterLocation In { get; init; }

    /// <summary>
    /// REQUIRED. The name of the HTTP Authorization scheme to be used
    /// in the Authorization header as defined in RFC7235.
    /// </summary>
    public string Scheme { get; init; }

    /// <summary>
    /// A hint to the client to identify how the bearer token is formatted.
    /// Bearer tokens are usually generated by an authorization server,
    /// so this information is primarily for documentation purposes.
    /// </summary>
    public string? BearerFormat { get; init; }

    /// <summary>
    /// REQUIRED. An object containing configuration information for the flow types supported.
    /// </summary>
    public RestApiOAuthFlows? Flows { get; init; }

    /// <summary>
    /// REQUIRED. OpenId Connect URL to discover OAuth2 configuration values.
    /// </summary>
    public Uri OpenIdConnectUrl { get; init; }

    /// <summary>
    /// Creates an instance of a <see cref="RestApiSecurityScheme"/> class.
    /// </summary>
#pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider adding the 'required' modifier or declaring as nullable.
    internal RestApiSecurityScheme()
#pragma warning restore CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider adding the 'required' modifier or declaring as nullable.
    {
    }

    internal void Freeze()
    {
        this.Flows?.Freeze();
    }
}


===== Functions.OpenApi\Model\RestApiServer.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Collections.ObjectModel;

namespace Microsoft.SemanticKernel.Plugins.OpenApi;

/// <summary>
/// REST API server.
/// </summary>
public sealed class RestApiServer
{
    /// <summary>
    /// Description of the server.
    /// </summary>
    public string? Description { get; }

    /// <summary>
    /// A URL to the target host. This URL supports Server Variables and MAY be relative,
    /// to indicate that the host location is relative to the location where the OpenAPI document is being served.
    /// Variable substitutions will be made when a variable is named in {brackets}.
    /// </summary>
#pragma warning disable CA1056 // URI-like properties should not be strings
    public string? Url { get; }
#pragma warning restore CA1056 // URI-like properties should not be strings

    /// <summary>
    /// A map between a variable name and its value. The value is used for substitution in the server's URL template.
    /// </summary>
    public IDictionary<string, RestApiServerVariable> Variables { get; private set; }

    /// <summary>
    /// Construct a new <see cref="RestApiServer"/> object.
    /// </summary>
    /// <param name="url">URL to the target host</param>
    /// <param name="variables">Substitution variables for the server's URL template</param>
    /// <param name="description">Description of the server</param>
#pragma warning disable CA1054 // URI-like parameters should not be strings
    internal RestApiServer(string? url = null, IDictionary<string, RestApiServerVariable>? variables = null, string? description = null)
#pragma warning restore CA1054 // URI-like parameters should not be strings
    {
        this.Url = string.IsNullOrEmpty(url) ? null : url;
        this.Variables = variables ?? new Dictionary<string, RestApiServerVariable>();
        this.Description = description;
    }

    /// <summary>
    /// Makes the current instance unmodifiable.
    /// </summary>
    internal void Freeze()
    {
        this.Variables = new ReadOnlyDictionary<string, RestApiServerVariable>(this.Variables);
        foreach (var variable in this.Variables.Values)
        {
            variable.Freeze();
        }
    }
}


===== Functions.OpenApi\Model\RestApiServerVariable.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Collections.ObjectModel;

namespace Microsoft.SemanticKernel.Plugins.OpenApi;

/// <summary>
/// REST API server variable.
/// </summary>
public sealed class RestApiServerVariable
{
    /// <summary>
    /// The variable argument name.
    /// If provided, the argument name will be used to search for the corresponding variable value in function arguments.
    /// If no property value is found using the argument name, the original name represented by the  <see cref="RestApiServer.Variables"/> dictionary key will be used for the search instead.
    /// </summary>
    public string? ArgumentName
    {
        get => this._argumentName;
        set
        {
            this._freezable.ThrowIfFrozen();
            this._argumentName = value;
        }
    }

    /// <summary>
    /// An optional description for the server variable. CommonMark syntax MAY be used for rich text representation.
    /// </summary>
    public string? Description { get; }

    /// <summary>
    /// REQUIRED. The default value to use for substitution, and to send, if an alternate value is not supplied.
    /// Unlike the Schema Object's default, this value MUST be provided by the consumer.
    /// </summary>
    public string Default { get; }

    /// <summary>
    /// An enumeration of string values to be used if the substitution options are from a limited set.
    /// </summary>
    public IList<string>? Enum { get; private set; }

    /// <summary>
    /// Construct a new <see cref="RestApiServerVariable"/> object.
    /// </summary>
    /// <param name="defaultValue">The default value to use for substitution.</param>
    /// <param name="description">An optional description for the server variable.</param>
    /// <param name="enumValues">An enumeration of string values to be used if the substitution options are from a limited set.</param>
    internal RestApiServerVariable(string defaultValue, string? description = null, IList<string>? enumValues = null)
    {
        this.Default = defaultValue;
        this.Description = description;
        this.Enum = enumValues;
    }

    /// <summary>
    /// Return true if the value is valid based on the enumeration of string values to be used.
    /// </summary>
    /// <param name="value">Value to be used as a substitution.</param>
    public bool IsValid(string? value)
    {
        return this.Enum?.Contains(value!) ?? true;
    }

    internal void Freeze()
    {
        this.Enum = this.Enum is not null ? new ReadOnlyCollection<string>(this.Enum) : null;
        this._freezable.Freeze();
    }

    private string? _argumentName;
    private readonly Freezable _freezable = new();
}


===== Functions.OpenApi\Model\RestApiSpecification.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Collections.ObjectModel;

namespace Microsoft.SemanticKernel.Plugins.OpenApi;

/// <summary>
/// REST API specification.
/// </summary>
public sealed class RestApiSpecification
{
    /// <summary>
    /// The REST API information.
    /// </summary>
    public RestApiInfo Info { get; private set; }

    /// <summary>
    /// The REST API security requirements.
    /// </summary>
    public IList<RestApiSecurityRequirement>? SecurityRequirements { get; private set; }

    /// <summary>
    /// The REST API operations.
    /// </summary>
    public IList<RestApiOperation> Operations { get; private set; }

    /// <summary>
    /// Construct an instance of <see cref="RestApiSpecification"/>
    /// </summary>
    /// <param name="info">REST API information.</param>
    /// <param name="securityRequirements">REST API security requirements.</param>
    /// <param name="operations">REST API operations.</param>
    internal RestApiSpecification(RestApiInfo info, List<RestApiSecurityRequirement>? securityRequirements, IList<RestApiOperation> operations)
    {
        this.Info = info;
        this.SecurityRequirements = securityRequirements;
        this.Operations = operations;
    }

    internal void Freeze()
    {
        if (this.SecurityRequirements is not null)
        {
            this.SecurityRequirements = new ReadOnlyCollection<RestApiSecurityRequirement>(this.SecurityRequirements);
            foreach (var securityRequirement in this.SecurityRequirements)
            {
                securityRequirement.Freeze();
            }
        }

        this.Operations = new ReadOnlyCollection<RestApiOperation>(this.Operations);
        foreach (var operation in this.Operations)
        {
            operation.Freeze();
        }
    }
}


===== Functions.OpenApi\OpenApi\OpenApiDocumentParser.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Text;
using System.Text.Json;
using System.Text.Json.Nodes;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.OpenApi.Any;
using Microsoft.OpenApi.Interfaces;
using Microsoft.OpenApi.Models;
using Microsoft.OpenApi.Readers;
using Microsoft.OpenApi.Writers;
using Microsoft.SemanticKernel.Text;

namespace Microsoft.SemanticKernel.Plugins.OpenApi;

/// <summary>
/// Parser for OpenAPI documents.
/// </summary>
public sealed class OpenApiDocumentParser(ILoggerFactory? loggerFactory = null)
{
    /// <summary>
    /// Parses OpenAPI document.
    /// </summary>
    /// <param name="stream">Stream containing OpenAPI document to parse.</param>
    /// <param name="options">Options for parsing OpenAPI document.</param>
    /// <param name="cancellationToken">The cancellation token.</param>
    /// <returns>Specification of the REST API.</returns>
    public async Task<RestApiSpecification> ParseAsync(Stream stream, OpenApiDocumentParserOptions? options = null, CancellationToken cancellationToken = default)
    {
        var jsonObject = await this.DowngradeDocumentVersionToSupportedOneAsync(stream, cancellationToken).ConfigureAwait(false);

        using var memoryStream = new MemoryStream(JsonSerializer.SerializeToUtf8Bytes(jsonObject, JsonOptionsCache.WriteIndented));

        var result = await this._openApiReader.ReadAsync(memoryStream, cancellationToken).ConfigureAwait(false);

        this.AssertReadingSuccessful(result, options?.IgnoreNonCompliantErrors ?? false);

        return new(
            ExtractRestApiInfo(result.OpenApiDocument),
            CreateRestApiOperationSecurityRequirements(result.OpenApiDocument.SecurityRequirements),
            ExtractRestApiOperations(result.OpenApiDocument, options, this._logger));
    }

    #region private

    /// <summary>
    /// Max depth to traverse down OpenAPI schema to discover payload properties.
    /// </summary>
    private const int PayloadPropertiesHierarchyMaxDepth = 10;

    /// <summary>
    /// Name of property that contains OpenAPI document version.
    /// </summary>
    private const string OpenApiVersionPropertyName = "openapi";

    /// <summary>
    /// Latest supported version of OpenAPI document.
    /// </summary>
    private static readonly Version s_latestSupportedVersion = new(3, 0, 1);

    /// <summary>
    /// List of supported Media Types.
    /// </summary>
    private static readonly List<string> s_supportedMediaTypes =
    [
        "application/json",
        "text/plain"
    ];

    private readonly OpenApiStreamReader _openApiReader = new();
    private readonly ILogger _logger = loggerFactory?.CreateLogger(typeof(OpenApiDocumentParser)) ?? NullLogger.Instance;

    /// <summary>
    /// Downgrades the version of an OpenAPI document to the latest supported one - 3.0.1.
    /// This class relies on Microsoft.OpenAPI.NET library to work with OpenAPI documents.
    /// The library, at the moment, does not support 3.1 spec, and the latest supported version is 3.0.1.
    /// There's an open issue tracking the support progress - https://github.com/microsoft/OpenAPI.NET/issues/795
    /// This method should be removed/revised as soon the support is added.
    /// </summary>
    /// <param name="stream">The original OpenAPI document stream.</param>
    /// <param name="cancellationToken">The cancellation token.</param>
    /// <returns>OpenAPI document with downgraded document version.</returns>
    private async Task<JsonObject> DowngradeDocumentVersionToSupportedOneAsync(Stream stream, CancellationToken cancellationToken)
    {
        var jsonObject = await ConvertContentToJsonAsync(stream, cancellationToken).ConfigureAwait(false) ?? throw new KernelException("Parsing of OpenAPI document failed.");
        if (!jsonObject.TryGetPropertyValue(OpenApiVersionPropertyName, out var propertyNode))
        {
            // The document is either malformed or has 2.x version that specifies document version in the 'swagger' property rather than in the 'openapi' one.
            return jsonObject;
        }

        if (propertyNode is not JsonValue value)
        {
            // The 'openapi' property has unexpected type.
            return jsonObject;
        }

        if (!Version.TryParse(value.ToString(), out var version))
        {
            // The 'openapi' property is malformed.
            return jsonObject;
        }

        if (version > s_latestSupportedVersion)
        {
            jsonObject[OpenApiVersionPropertyName] = s_latestSupportedVersion.ToString();
        }

        return jsonObject;
    }

    /// <summary>
    /// Converts YAML content to JSON content.
    /// The method uses SharpYaml library that comes as a not-direct dependency of Microsoft.OpenAPI.NET library.
    /// Should be replaced later when there's more convenient way to convert YAML content to JSON one.
    /// </summary>
    /// <param name="stream">The YAML/JSON content stream.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>JSON content stream.</returns>
    private static async Task<JsonObject?> ConvertContentToJsonAsync(Stream stream, CancellationToken cancellationToken = default)
    {
        var serializer = new SharpYaml.Serialization.Serializer();

        var obj = serializer.Deserialize(stream);

        using var memoryStream = new MemoryStream(Encoding.UTF8.GetBytes(JsonSerializer.Serialize(obj)));

        return await JsonSerializer.DeserializeAsync<JsonObject>(memoryStream, cancellationToken: cancellationToken).ConfigureAwait(false);
    }

    /// <summary>
    /// Parses an OpenAPI document and extracts REST API information.
    /// </summary>
    /// <param name="document">The OpenAPI document.</param>
    /// <returns>Rest API information.</returns>
    internal static RestApiInfo ExtractRestApiInfo(OpenApiDocument document)
    {
        return new()
        {
            Title = document.Info.Title,
            Description = document.Info.Description,
            Version = document.Info.Version,
        };
    }

    /// <summary>
    /// Parses an OpenAPI document and extracts REST API operations.
    /// </summary>
    /// <param name="document">The OpenAPI document.</param>
    /// <param name="options">Options for parsing OpenAPI document.</param>
    /// <param name="logger">Used to perform logging.</param>
    /// <returns>List of Rest operations.</returns>
    private static List<RestApiOperation> ExtractRestApiOperations(OpenApiDocument document, OpenApiDocumentParserOptions? options, ILogger logger)
    {
        var result = new List<RestApiOperation>();

        foreach (var pathPair in document.Paths)
        {
            var operations = CreateRestApiOperations(document, pathPair.Key, pathPair.Value, options, logger);
            result.AddRange(operations);
        }

        return result;
    }

    /// <summary>
    /// Creates REST API operation.
    /// </summary>
    /// <param name="document">The OpenAPI document.</param>
    /// <param name="path">Rest resource path.</param>
    /// <param name="pathItem">Rest resource metadata.</param>
    /// <param name="options">Options for parsing OpenAPI document.</param>
    /// <param name="logger">Used to perform logging.</param>
    /// <returns>Rest operation.</returns>
    internal static List<RestApiOperation> CreateRestApiOperations(OpenApiDocument document, string path, OpenApiPathItem pathItem, OpenApiDocumentParserOptions? options, ILogger logger)
    {
        try
        {
            var operations = new List<RestApiOperation>();
            var globalServers = CreateRestApiOperationServers(document.Servers);
            var pathServers = CreateRestApiOperationServers(pathItem.Servers);

            foreach (var operationPair in pathItem.Operations)
            {
                var method = operationPair.Key.ToString();
                var operationItem = operationPair.Value;
                var operationServers = CreateRestApiOperationServers(operationItem.Servers);

                // Skip the operation parsing and don't add it to the result operations list if it's explicitly excluded by the predicate.
                if (!options?.OperationSelectionPredicate?.Invoke(new OperationSelectionPredicateContext(operationItem.OperationId, path, method, operationItem.Description)) ?? false)
                {
                    continue;
                }

                try
                {
                    var operation = new RestApiOperation(
                        id: operationItem.OperationId,
                        servers: globalServers,
                        pathServers: pathServers,
                        operationServers: operationServers,
                        path: path,
                        method: new HttpMethod(method),
                        description: string.IsNullOrEmpty(operationItem.Description) ? operationItem.Summary : operationItem.Description,
                        parameters: CreateRestApiOperationParameters(operationItem.OperationId, operationItem.Parameters.Union(pathItem.Parameters, s_parameterNameAndLocationComparer)),
                        payload: CreateRestApiOperationPayload(operationItem.OperationId, operationItem.RequestBody),
                        responses: CreateRestApiOperationExpectedResponses(operationItem.Responses).ToDictionary(static item => item.Item1, static item => item.Item2),
                        securityRequirements: CreateRestApiOperationSecurityRequirements(operationItem.Security)
                    )
                    {
                        Extensions = CreateRestApiOperationExtensions(operationItem.Extensions, logger),
                        Summary = operationItem.Summary
                    };

                    operations.Add(operation);
                }
                catch (KernelException ke)
                {
                    logger.LogWarning(ke, "Error occurred creating REST API operation for {OperationId}. Operation will be ignored.", operationItem.OperationId);
                }
            }

            return operations;
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "Fatal error occurred during REST API operation creation.");
            throw;
        }
    }

    private static readonly ParameterNameAndLocationComparer s_parameterNameAndLocationComparer = new();

    /// <summary>
    /// Compares two <see cref="OpenApiParameter"/> objects by their name and location.
    /// </summary>
    private sealed class ParameterNameAndLocationComparer : IEqualityComparer<OpenApiParameter>
    {
        public bool Equals(OpenApiParameter? x, OpenApiParameter? y)
        {
            if (x is null || y is null)
            {
                return x == y;
            }
            return this.GetHashCode(x) == this.GetHashCode(y);
        }
        public int GetHashCode([DisallowNull] OpenApiParameter obj)
        {
            return HashCode.Combine(obj.Name, obj.In);
        }
    }

    /// <summary>
    /// Build a list of <see cref="RestApiServer"/> objects from the given list of <see cref="OpenApiServer"/> objects.
    /// </summary>
    /// <param name="servers">Represents servers which hosts the REST API.</param>
    private static List<RestApiServer> CreateRestApiOperationServers(IList<OpenApiServer> servers)
    {
        if (servers == null || servers.Count == 0)
        {
            return new List<RestApiServer>();
        }

        var result = new List<RestApiServer>(servers.Count);
        foreach (var server in servers)
        {
            var variables = server.Variables.ToDictionary(item => item.Key, item => new RestApiServerVariable(item.Value.Default, item.Value.Description, item.Value.Enum));
            result.Add(new RestApiServer(server.Url, variables, server.Description));
        }

        return result;
    }

    /// <summary>
    /// Build a <see cref="RestApiSecurityScheme"/> objects from the given <see cref="OpenApiSecurityScheme"/> object.
    /// </summary>
    /// <param name="securityScheme">The REST API security scheme.</param>
    private static RestApiSecurityScheme CreateRestApiSecurityScheme(OpenApiSecurityScheme securityScheme)
    {
        return new RestApiSecurityScheme()
        {
            SecuritySchemeType = securityScheme.Type.ToString(),
            Description = securityScheme.Description,
            Name = securityScheme.Name,
            In = (RestApiParameterLocation)Enum.Parse(typeof(RestApiParameterLocation), securityScheme.In.ToString()!),
            Scheme = securityScheme.Scheme,
            BearerFormat = securityScheme.BearerFormat,
            Flows = CreateRestApiOAuthFlows(securityScheme.Flows),
            OpenIdConnectUrl = securityScheme.OpenIdConnectUrl
        };
    }

    /// <summary>
    /// Build a <see cref="RestApiOAuthFlows"/> object from the given <see cref="OpenApiOAuthFlows"/> object.
    /// </summary>
    /// <param name="flows">The REST API OAuth flows.</param>
    private static RestApiOAuthFlows? CreateRestApiOAuthFlows(OpenApiOAuthFlows? flows)
    {
        return flows is not null ? new RestApiOAuthFlows()
        {
            Implicit = CreateRestApiOAuthFlow(flows.Implicit),
            Password = CreateRestApiOAuthFlow(flows.Password),
            ClientCredentials = CreateRestApiOAuthFlow(flows.ClientCredentials),
            AuthorizationCode = CreateRestApiOAuthFlow(flows.AuthorizationCode),
        } : null;
    }

    /// <summary>
    /// Build a <see cref="RestApiOAuthFlow"/> object from the given <see cref="OpenApiOAuthFlow"/> object.
    /// </summary>
    /// <param name="flow">The REST API OAuth flow.</param>
    private static RestApiOAuthFlow? CreateRestApiOAuthFlow(OpenApiOAuthFlow? flow)
    {
        return flow is not null ? new RestApiOAuthFlow()
        {
            AuthorizationUrl = flow.AuthorizationUrl,
            TokenUrl = flow.TokenUrl,
            RefreshUrl = flow.RefreshUrl,
            Scopes = new ReadOnlyDictionary<string, string>(flow.Scopes ?? new Dictionary<string, string>())
        } : null;
    }

    /// <summary>
    /// Build a list of <see cref="RestApiSecurityRequirement"/> objects from the given <see cref="OpenApiSecurityRequirement"/> objects.
    /// </summary>
    /// <param name="security">The REST API security.</param>
    internal static List<RestApiSecurityRequirement> CreateRestApiOperationSecurityRequirements(IList<OpenApiSecurityRequirement>? security)
    {
        var operationRequirements = new List<RestApiSecurityRequirement>();

        if (security is not null)
        {
            foreach (var item in security)
            {
                foreach (var keyValuePair in item)
                {
                    if (keyValuePair.Key is not OpenApiSecurityScheme openApiSecurityScheme)
                    {
                        throw new KernelException("The security scheme is not supported.");
                    }

                    operationRequirements.Add(new RestApiSecurityRequirement(new Dictionary<RestApiSecurityScheme, IList<string>> { { CreateRestApiSecurityScheme(openApiSecurityScheme), keyValuePair.Value } }));
                }
            }
        }

        return operationRequirements;
    }

    /// <summary>
    /// Build a dictionary of extension key value pairs from the given open api extension model, where the key is the extension name
    /// and the value is either the actual value in the case of primitive types like string, int, date, etc, or a json string in the
    /// case of complex types.
    /// </summary>
    /// <param name="extensions">The dictionary of extension properties in the open api model.</param>
    /// <param name="logger">Used to perform logging.</param>
    /// <returns>The dictionary of extension properties using a simplified model that doesn't use any open api models.</returns>
    /// <exception cref="KernelException">Thrown when any extension data types are encountered that are not supported.</exception>
    private static Dictionary<string, object?> CreateRestApiOperationExtensions(IDictionary<string, IOpenApiExtension> extensions, ILogger logger)
    {
        var result = new Dictionary<string, object?>();

        // Map each extension property.
        foreach (var extension in extensions)
        {
            if (extension.Value is IOpenApiPrimitive primitive)
            {
                // Set primitive values directly into the dictionary.
                object? extensionValueObj = GetParameterValue(primitive, "extension property", extension.Key);
                result.Add(extension.Key, extensionValueObj);
            }
            else if (extension.Value is IOpenApiAny any)
            {
                // Serialize complex objects and set as json strings.
                // The only remaining type not referenced here is null, but the default value of extensionValueObj
                // is null, so if we just continue that will handle the null case.
                if (any.AnyType is AnyType.Array or AnyType.Object)
                {
                    var schemaBuilder = new StringBuilder();
                    var jsonWriter = new OpenApiJsonWriter(new StringWriter(schemaBuilder, CultureInfo.InvariantCulture), new OpenApiJsonWriterSettings() { Terse = true });
                    extension.Value.Write(jsonWriter, Microsoft.OpenApi.OpenApiSpecVersion.OpenApi3_0);
                    object? extensionValueObj = schemaBuilder.ToString();
                    result.Add(extension.Key, extensionValueObj);
                }
            }
            else
            {
                logger.LogWarning("The type of extension property '{ExtensionPropertyName}' is not supported while trying to consume the OpenApi schema.", extension.Key);
            }
        }

        return result;
    }

    /// <summary>
    /// Creates REST API parameters.
    /// </summary>
    /// <param name="operationId">The operation id.</param>
    /// <param name="parameters">The OpenAPI parameters.</param>
    /// <returns>The parameters.</returns>
    private static List<RestApiParameter> CreateRestApiOperationParameters(string operationId, IEnumerable<OpenApiParameter> parameters)
    {
        var result = new List<RestApiParameter>();

        foreach (var parameter in parameters)
        {
            if (parameter.In is null)
            {
                throw new KernelException($"Parameter location of {parameter.Name} parameter of {operationId} operation is undefined.");
            }

            if (parameter.Style is null)
            {
                throw new KernelException($"Parameter style of {parameter.Name} parameter of {operationId} operation is undefined.");
            }

            var restParameter = new RestApiParameter(
                parameter.Name,
                parameter.Schema.Type,
                parameter.Required,
                parameter.Explode,
                (RestApiParameterLocation)Enum.Parse(typeof(RestApiParameterLocation), parameter.In.ToString()!),
                (RestApiParameterStyle)Enum.Parse(typeof(RestApiParameterStyle), parameter.Style.ToString()!),
                parameter.Schema.Items?.Type,
                GetParameterValue(parameter.Schema.Default, "parameter", parameter.Name),
                parameter.Description,
                parameter.Schema.Format,
                parameter.Schema.ToJsonSchema()
            );

            result.Add(restParameter);
        }

        return result;
    }

    /// <summary>
    /// Creates REST API payload.
    /// </summary>
    /// <param name="operationId">The operation id.</param>
    /// <param name="requestBody">The OpenAPI request body.</param>
    /// <returns>The REST API payload.</returns>
    private static RestApiPayload? CreateRestApiOperationPayload(string operationId, OpenApiRequestBody requestBody)
    {
        if (requestBody?.Content is null)
        {
            return null;
        }

        var mediaType = GetMediaType(requestBody.Content) ?? throw new KernelException($"Neither of the media types of {operationId} is supported.");
        var mediaTypeMetadata = requestBody.Content[mediaType];

        var payloadProperties = GetPayloadProperties(operationId, mediaTypeMetadata.Schema);

        return new RestApiPayload(mediaType, payloadProperties, requestBody.Description, mediaTypeMetadata?.Schema?.ToJsonSchema());
    }

    /// <summary>
    /// Returns the first supported media type. If none of the media types are supported, an exception is thrown.
    /// </summary>
    /// <remarks>
    /// Handles the case when the media type contains additional parameters e.g. application/json; x-api-version=2.0.
    /// </remarks>
    /// <param name="content">The OpenAPI request body content.</param>
    /// <returns>The first support ed media type.</returns>
    /// <exception cref="KernelException"></exception>
    private static string? GetMediaType(IDictionary<string, OpenApiMediaType> content)
    {
        foreach (var mediaType in s_supportedMediaTypes)
        {
            foreach (var key in content.Keys)
            {
                var keyParts = key.Split(';');
                if (keyParts[0].Equals(mediaType, StringComparison.OrdinalIgnoreCase))
                {
                    return key;
                }
            }
        }
        return null;
    }

    /// <summary>
    /// Create collection of expected responses for the REST API operation for the supported media types.
    /// </summary>
    /// <param name="responses">Responses from the OpenAPI endpoint.</param>
    private static IEnumerable<(string, RestApiExpectedResponse)> CreateRestApiOperationExpectedResponses(OpenApiResponses responses)
    {
        foreach (var response in responses)
        {
            var mediaType = GetMediaType(response.Value.Content);
            if (mediaType is not null)
            {
                var matchingSchema = response.Value.Content[mediaType].Schema;
                var description = response.Value.Description ?? matchingSchema?.Description ?? string.Empty;

                yield return (response.Key, new RestApiExpectedResponse(description, mediaType, matchingSchema?.ToJsonSchema()));
            }
        }
    }

    /// <summary>
    /// Returns REST API payload properties.
    /// </summary>
    /// <param name="operationId">The operation id.</param>
    /// <param name="schema">An OpenAPI document schema representing request body properties.</param>
    /// <param name="level">Current level in OpenAPI schema.</param>
    /// <returns>The REST API payload properties.</returns>
    private static List<RestApiPayloadProperty> GetPayloadProperties(string operationId, OpenApiSchema? schema, int level = 0)
    {
        if (schema is null)
        {
            return [];
        }

        if (level > PayloadPropertiesHierarchyMaxDepth)
        {
            throw new KernelException($"Max level {PayloadPropertiesHierarchyMaxDepth} of traversing payload properties of {operationId} operation is exceeded.");
        }

        var result = new List<RestApiPayloadProperty>();

        foreach (var propertyPair in schema.Properties)
        {
            var propertyName = propertyPair.Key;

            var propertySchema = propertyPair.Value;

            var property = new RestApiPayloadProperty(
                propertyName,
                propertySchema.Type,
                schema.Required.Contains(propertyName),
                GetPayloadProperties(operationId, propertySchema, level + 1),
                propertySchema.Description,
                propertySchema.Format,
                propertySchema.ToJsonSchema(),
                GetParameterValue(propertySchema.Default, "payload property", propertyName));

            result.Add(property);
        }

        return result;
    }

    /// <summary>
    /// Returns parameter value.
    /// </summary>
    /// <param name="valueMetadata">The value metadata.</param>
    /// <param name="entityDescription">A description of the type of entity we are trying to get a value for.</param>
    /// <param name="entityName">The name of the entity that we are trying to get the value for.</param>
    /// <returns>The parameter value.</returns>
    private static object? GetParameterValue(IOpenApiAny valueMetadata, string entityDescription, string entityName)
    {
        if (valueMetadata is not IOpenApiPrimitive value)
        {
            return null;
        }

        return value.PrimitiveType switch
        {
            PrimitiveType.Integer => ((OpenApiInteger)value).Value,
            PrimitiveType.Long => ((OpenApiLong)value).Value,
            PrimitiveType.Float => ((OpenApiFloat)value).Value,
            PrimitiveType.Double => ((OpenApiDouble)value).Value,
            PrimitiveType.String => ((OpenApiString)value).Value,
            PrimitiveType.Byte => ((OpenApiByte)value).Value,
            PrimitiveType.Binary => ((OpenApiBinary)value).Value,
            PrimitiveType.Boolean => ((OpenApiBoolean)value).Value,
            PrimitiveType.Date => ((OpenApiDate)value).Value,
            PrimitiveType.DateTime => ((OpenApiDateTime)value).Value,
            PrimitiveType.Password => ((OpenApiPassword)value).Value,
            _ => throw new KernelException($"The value type '{value.PrimitiveType}' of {entityDescription} '{entityName}' is not supported."),
        };
    }

    /// <summary>
    /// Asserts the successful reading of OpenAPI document.
    /// </summary>
    /// <param name="readResult">The reading results to be checked.</param>
    /// <param name="ignoreNonCompliantErrors">Flag indicating whether to ignore non-compliant errors.
    /// If set to true, the parser will not throw exceptions for non-compliant documents.
    /// Please note that enabling this option may result in incomplete or inaccurate parsing results.
    /// </param>
    private void AssertReadingSuccessful(ReadResult readResult, bool ignoreNonCompliantErrors)
    {
        if (readResult.OpenApiDiagnostic.Errors.Any())
        {
            var title = readResult.OpenApiDocument.Info?.Title;
            var errors = string.Join(";", readResult.OpenApiDiagnostic.Errors);

            if (!ignoreNonCompliantErrors)
            {
                var exception = new KernelException($"Parsing of '{title}' OpenAPI document complete with the following errors: {errors}");
                this._logger.LogError(exception, "Parsing of '{Title}' OpenAPI document complete with the following errors: {Errors}", title, errors);
                throw exception;
            }

            this._logger.LogWarning("Parsing of '{Title}' OpenAPI document complete with the following errors: {Errors}", title, errors);
        }
    }

    #endregion
}


===== Functions.OpenApi\OpenApi\OpenApiDocumentParserOptions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;

namespace Microsoft.SemanticKernel.Plugins.OpenApi;

/// <summary>
/// Options for OpenAPI document parser.
/// </summary>
public sealed class OpenApiDocumentParserOptions
{
    /// <summary>
    /// Flag indicating whether to ignore non-compliant errors in the OpenAPI document during parsing.
    /// If set to true, the parser will not throw exceptions for non-compliant documents.
    /// Please note that enabling this option may result in incomplete or inaccurate parsing results.
    /// </summary>
    public bool IgnoreNonCompliantErrors { set; get; } = false;

    /// <summary>
    /// Operation selection predicate to apply to all OpenAPI document operations.
    /// If set, the predicate will be applied to each operation in the document.
    /// If the predicate returns true, the operation will be parsed; otherwise, it will be skipped.
    /// This can be used to filter out operations that should not be imported for various reasons.
    /// </summary>
    public Func<OperationSelectionPredicateContext, bool>? OperationSelectionPredicate { get; set; }
}


===== Functions.OpenApi\OpenApi\OperationSelectionPredicateContext.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;

namespace Microsoft.SemanticKernel.Plugins.OpenApi;

/// <summary>
/// Represents the context for an operation selection predicate.
/// </summary>
public readonly struct OperationSelectionPredicateContext : IEquatable<OperationSelectionPredicateContext>
{
    /// <summary>
    /// Initializes a new instance of the <see cref="OperationSelectionPredicateContext"/> struct.
    /// </summary>
    /// <param name="Id">The identifier for the operation.</param>
    /// <param name="Path">The path of the operation.</param>
    /// <param name="Method">The HTTP method (GET, POST, etc.) of the operation.</param>
    /// <param name="Description">The description of the operation.</param>
    internal OperationSelectionPredicateContext(string? Id, string Path, string Method, string? Description)
    {
        this.Id = Id;
        this.Path = Path;
        this.Method = Method;
        this.Description = Description;
    }

    /// <summary>
    /// The identifier for the operation.
    /// </summary>
    public string? Id { get; }

    /// <summary>
    /// The path of the operation.
    /// </summary>
    public string Path { get; }

    /// <summary>
    /// The HTTP method (GET, POST, etc.) of the operation.
    /// </summary>
    public string Method { get; }

    /// <summary>
    /// The description of the operation.
    /// </summary>
    public string? Description { get; }

    /// <inheritdoc />
    public override bool Equals(object? obj)
    {
        return obj is OperationSelectionPredicateContext other && this.Equals(other);
    }

    /// <inheritdoc />
    public override int GetHashCode()
    {
        // Using a tuple to create a hash code based on the properties  
        return HashCode.Combine(this.Id, this.Path, this.Method, this.Description);
    }

    /// <inheritdoc />
    public static bool operator ==(OperationSelectionPredicateContext left, OperationSelectionPredicateContext right)
    {
        return left.Equals(right);
    }

    /// <inheritdoc />
    public static bool operator !=(OperationSelectionPredicateContext left, OperationSelectionPredicateContext right)
    {
        return !(left == right);
    }

    /// <inheritdoc />
    public bool Equals(OperationSelectionPredicateContext other)
    {
        return this.Id == other.Id &&
               this.Path == other.Path &&
               this.Method == other.Method &&
               this.Description == other.Description;
    }
}


===== Functions.OpenApi\OpenApiKernelFunctionContext.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Net.Http;

namespace Microsoft.SemanticKernel.Plugins.OpenApi;

/// <summary>
/// Class with data related to an Open API <see cref="KernelFunction"/> invocation.
/// </summary>
public sealed class OpenApiKernelFunctionContext
{
    /// <summary>
    /// Key to access the <see cref="OpenApiKernelFunctionContext"/> in the <see cref="HttpRequestMessage"/>.
    /// </summary>
#if NET5_0_OR_GREATER
    public static readonly HttpRequestOptionsKey<OpenApiKernelFunctionContext> KernelFunctionContextKey = new("KernelFunctionContext");
#else
    public static readonly string KernelFunctionContextKey = "KernelFunctionContext";
#endif

    /// <summary>
    /// Initializes a new instance of the <see cref="OpenApiKernelFunctionContext"/> class.
    /// </summary>
    /// <param name="kernel">The <see cref="Kernel"/> associated with this context.</param>
    /// <param name="function">The <see cref="KernelFunction"/> associated with this context.</param>
    /// <param name="arguments">The <see cref="KernelArguments"/> associated with this context.</param>
    internal OpenApiKernelFunctionContext(Kernel? kernel, KernelFunction? function, KernelArguments? arguments)
    {
        this.Kernel = kernel;
        this.Function = function;
        this.Arguments = arguments;
    }

    /// <summary>
    /// Gets the <see cref="Kernel"/>.
    /// </summary>
    public Kernel? Kernel { get; }

    /// <summary>
    /// Gets the <see cref="KernelFunction"/>.
    /// </summary>
    public KernelFunction? Function { get; }

    /// <summary>
    /// Gets the <see cref="KernelArguments"/>.
    /// </summary>
    public KernelArguments? Arguments { get; }
}


===== Functions.OpenApi\OpenApiKernelPluginFactory.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Text;
using System.Text.Json;
using System.Text.Json.Nodes;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.SemanticKernel.Http;

namespace Microsoft.SemanticKernel.Plugins.OpenApi;

/// <summary>
/// Provides static factory methods for creating KernelPlugins from OpenAPI specifications.
/// </summary>
public static partial class OpenApiKernelPluginFactory
{
    /// <summary>
    /// Creates <see cref="KernelPlugin"/> from an OpenAPI specification.
    /// </summary>
    /// <param name="pluginName">The plugin name.</param>
    /// <param name="filePath">The file path to the OpenAPI specification.</param>
    /// <param name="executionParameters">The OpenAPI specification parsing and function execution parameters.</param>
    /// <param name="cancellationToken">The cancellation token.</param>
    /// <returns>A <see cref="KernelPlugin"/> instance that contains functions corresponding to the operations defined in the OpenAPI specification.</returns>
    public static async Task<KernelPlugin> CreateFromOpenApiAsync(
        string pluginName,
        string filePath,
        OpenApiFunctionExecutionParameters? executionParameters = null,
        CancellationToken cancellationToken = default)
    {
        KernelVerify.ValidPluginName(pluginName);

#pragma warning disable CA2000 // Dispose objects before losing scope. No need to dispose the Http client here. It can either be an internal client using NonDisposableHttpClientHandler or an external client managed by the calling code, which should handle its disposal.
        var httpClient = HttpClientProvider.GetHttpClient(executionParameters?.HttpClient);
#pragma warning restore CA2000

        var loggerFactory = executionParameters?.LoggerFactory;
        var logger = loggerFactory?.CreateLogger(typeof(OpenApiKernelExtensions)) ?? NullLogger.Instance;

        var openApiSpec = await DocumentLoader.LoadDocumentFromFilePathAsync(
            filePath,
            logger,
            cancellationToken).ConfigureAwait(false);

        return await CreateOpenApiPluginAsync(
            pluginName,
            executionParameters,
            httpClient,
            openApiSpec,
            loggerFactory: loggerFactory,
            cancellationToken: cancellationToken).ConfigureAwait(false);
    }

    /// <summary>
    /// Creates <see cref="KernelPlugin"/> from an OpenAPI specification.
    /// </summary>
    /// <param name="pluginName">The plugin name.</param>
    /// <param name="uri">A URI referencing the OpenAPI specification.</param>
    /// <param name="executionParameters">The OpenAPI specification parsing and function execution parameters.</param>
    /// <param name="cancellationToken">The cancellation token.</param>
    /// <returns>A <see cref="KernelPlugin"/> instance that contains functions corresponding to the operations defined in the OpenAPI specification.</returns>
    public static async Task<KernelPlugin> CreateFromOpenApiAsync(
        string pluginName,
        Uri uri,
        OpenApiFunctionExecutionParameters? executionParameters = null,
        CancellationToken cancellationToken = default)
    {
        KernelVerify.ValidPluginName(pluginName);

#pragma warning disable CA2000 // Dispose objects before losing scope. No need to dispose the Http client here. It can either be an internal client using NonDisposableHttpClientHandler or an external client managed by the calling code, which should handle its disposal.
        var httpClient = HttpClientProvider.GetHttpClient(executionParameters?.HttpClient);
#pragma warning restore CA2000

        var loggerFactory = executionParameters?.LoggerFactory;
        var logger = loggerFactory?.CreateLogger(typeof(OpenApiKernelExtensions)) ?? NullLogger.Instance;

        var openApiSpec = await DocumentLoader.LoadDocumentFromUriAsync(
            uri,
            logger,
            httpClient,
            executionParameters?.AuthCallback,
            executionParameters?.UserAgent,
            cancellationToken).ConfigureAwait(false);

        return await CreateOpenApiPluginAsync(
            pluginName,
            executionParameters,
            httpClient,
            openApiSpec,
            uri,
            loggerFactory,
            cancellationToken: cancellationToken).ConfigureAwait(false);
    }

    /// <summary>
    /// Creates <see cref="KernelPlugin"/> from an OpenAPI specification.
    /// </summary>
    /// <param name="pluginName">The plugin name.</param>
    /// <param name="stream">A stream representing the OpenAPI specification.</param>
    /// <param name="executionParameters">The OpenAPI specification parsing and function execution parameters.</param>
    /// <param name="cancellationToken">The cancellation token.</param>
    /// <returns>A <see cref="KernelPlugin"/> instance that contains functions corresponding to the operations defined in the OpenAPI specification.</returns>
    public static async Task<KernelPlugin> CreateFromOpenApiAsync(
        string pluginName,
        Stream stream,
        OpenApiFunctionExecutionParameters? executionParameters = null,
        CancellationToken cancellationToken = default)
    {
        KernelVerify.ValidPluginName(pluginName);

#pragma warning disable CA2000 // Dispose objects before losing scope. No need to dispose the Http client here. It can either be an internal client using NonDisposableHttpClientHandler or an external client managed by the calling code, which should handle its disposal.
        var httpClient = HttpClientProvider.GetHttpClient(executionParameters?.HttpClient);
#pragma warning restore CA2000

        var openApiSpec = await DocumentLoader.LoadDocumentFromStreamAsync(stream, cancellationToken).ConfigureAwait(false);

        return await CreateOpenApiPluginAsync(
            pluginName,
            executionParameters,
            httpClient,
            openApiSpec,
            loggerFactory: executionParameters?.LoggerFactory,
            cancellationToken: cancellationToken).ConfigureAwait(false);
    }

    /// <summary>
    /// Creates <see cref="KernelPlugin"/> from an OpenAPI specification.
    /// </summary>
    /// <param name="pluginName">The plugin name.</param>
    /// <param name="specification">The specification model.</param>
    /// <param name="executionParameters">The OpenAPI specification parsing and function execution parameters.</param>
    /// <returns>A <see cref="KernelPlugin"/> instance that contains functions corresponding to the operations defined in the OpenAPI specification.</returns>
    public static KernelPlugin CreateFromOpenApi(
        string pluginName,
        RestApiSpecification specification,
        OpenApiFunctionExecutionParameters? executionParameters = null)
    {
        KernelVerify.ValidPluginName(pluginName);

#pragma warning disable CA2000 // Dispose objects before losing scope. No need to dispose the Http client here. It can either be an internal client using NonDisposableHttpClientHandler or an external client managed by the calling code, which should handle its disposal.
        var httpClient = HttpClientProvider.GetHttpClient(executionParameters?.HttpClient);
#pragma warning restore CA2000

        return CreateOpenApiPlugin(
            pluginName: pluginName,
            executionParameters: executionParameters,
            httpClient: httpClient,
            specification: specification);
    }

    /// <summary>
    /// Creates a plugin from an OpenAPI specification.
    /// </summary>
    internal static async Task<KernelPlugin> CreateOpenApiPluginAsync(
        string pluginName,
        OpenApiFunctionExecutionParameters? executionParameters,
        HttpClient httpClient,
        string pluginJson,
        Uri? documentUri = null,
        ILoggerFactory? loggerFactory = null,
        CancellationToken cancellationToken = default)
    {
        using var documentStream = new MemoryStream(System.Text.Encoding.UTF8.GetBytes(pluginJson));

        loggerFactory ??= NullLoggerFactory.Instance;

        var parser = new OpenApiDocumentParser(loggerFactory);

        var restApi = await parser.ParseAsync(
            stream: documentStream,
            options: new OpenApiDocumentParserOptions
            {
                IgnoreNonCompliantErrors = executionParameters?.IgnoreNonCompliantErrors ?? false,
                OperationSelectionPredicate = (context) => SelectOperations(context, executionParameters)
            },
            cancellationToken: cancellationToken).ConfigureAwait(false);

        return CreateOpenApiPlugin(
            pluginName: pluginName,
            executionParameters: executionParameters,
            httpClient: httpClient,
            specification: restApi,
            documentUri: documentUri,
            loggerFactory: loggerFactory);
    }

    /// <summary>
    /// Creates a plugin from an OpenAPI specification.
    /// </summary>
    internal static KernelPlugin CreateOpenApiPlugin(
        string pluginName,
        OpenApiFunctionExecutionParameters? executionParameters,
        HttpClient httpClient,
        RestApiSpecification specification,
        Uri? documentUri = null,
        ILoggerFactory? loggerFactory = null)
    {
        loggerFactory ??= NullLoggerFactory.Instance;

        var runner = new RestApiOperationRunner(
            httpClient,
            executionParameters?.AuthCallback,
            executionParameters?.UserAgent,
            executionParameters?.EnableDynamicPayload ?? true,
            executionParameters?.EnablePayloadNamespacing ?? false,
            executionParameters?.HttpResponseContentReader,
            executionParameters?.RestApiOperationResponseFactory);

        var functions = new List<KernelFunction>();
        ILogger logger = loggerFactory.CreateLogger(typeof(OpenApiKernelExtensions)) ?? NullLogger.Instance;
        foreach (var operation in specification.Operations)
        {
            try
            {
                logger.LogTrace("Registering Rest function {PluginName}.{OperationId}", pluginName, operation.Id);
                functions.Add(CreateRestApiFunction(pluginName, runner, specification.Info, specification.SecurityRequirements, operation, executionParameters, documentUri, loggerFactory));
            }
            catch (Exception ex) when (!ex.IsCriticalException())
            {
                // Logging the exception and keep registering other Rest functions
                logger.LogWarning(ex, "Something went wrong while rendering the Rest function. Function: {PluginName}.{OperationId}. Error: {Message}",
                    pluginName, operation.Id, ex.Message);
            }
        }

        specification.Freeze();

        return KernelPluginFactory.CreateFromFunctions(pluginName, specification.Info.Description, functions);
    }

    /// <summary>
    /// Registers <see cref="KernelFunctionFactory"/>> for a REST API operation.
    /// </summary>
    /// <param name="pluginName">Plugin name.</param>
    /// <param name="runner">The REST API operation runner.</param>
    /// <param name="info">The REST API info.</param>
    /// <param name="security">The REST API security requirements.</param>
    /// <param name="operation">The REST API operation.</param>
    /// <param name="executionParameters">Function execution parameters.</param>
    /// <param name="documentUri">The URI of OpenAPI document.</param>
    /// <param name="loggerFactory">The logger factory.</param>
    /// <returns>An instance of <see cref="KernelFunctionFromPrompt"/> class.</returns>
    internal static KernelFunction CreateRestApiFunction(
        string pluginName,
        RestApiOperationRunner runner,
        RestApiInfo info,
        IList<RestApiSecurityRequirement>? security,
        RestApiOperation operation,
        OpenApiFunctionExecutionParameters? executionParameters,
        Uri? documentUri = null,
        ILoggerFactory? loggerFactory = null)
    {
        IReadOnlyList<RestApiParameter> restOperationParameters = operation.GetParameters(
            executionParameters?.EnableDynamicPayload ?? true,
            executionParameters?.EnablePayloadNamespacing ?? false,
            executionParameters?.ParameterFilter
        );

        var logger = loggerFactory?.CreateLogger(typeof(OpenApiKernelExtensions)) ?? NullLogger.Instance;

        async Task<RestApiOperationResponse> ExecuteAsync(Kernel kernel, KernelFunction function, KernelArguments variables, CancellationToken cancellationToken)
        {
            try
            {
                var options = new RestApiOperationRunOptions
                {
                    Kernel = kernel,
                    KernelFunction = function,
                    KernelArguments = variables,
                    ServerUrlOverride = executionParameters?.ServerUrlOverride,
                    ApiHostUrl = documentUri is not null ? new Uri(documentUri.GetLeftPart(UriPartial.Authority)) : null
                };

                return await runner.RunAsync(operation, variables, options, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception ex) when (!ex.IsCriticalException())
            {
                logger!.LogError(ex, "RestAPI function {Plugin}.{OperationId} execution failed with error {Error}", pluginName, operation.Id, ex.Message);
                throw;
            }
        }

        var parameters = restOperationParameters
            .Select(p => new KernelParameterMetadata(p.ArgumentName ?? p.Name)
            {
                Description = $"{p.Description ?? p.Name}",
                DefaultValue = p.DefaultValue ?? string.Empty,
                IsRequired = p.IsRequired,
                ParameterType = ConvertParameterDataType(p),
                Schema = GetSchema(p)
            })
            .ToList();

        var returnParameter = operation.GetDefaultReturnParameter();

        // Add unstructured metadata, specific to Open API, to the metadata property bag.
        var additionalMetadata = new Dictionary<string, object?>
        {
            { OpenApiKernelPluginFactory.OperationExtensionsMethodKey, operation.Method.ToString().ToUpperInvariant() },
            { OpenApiKernelPluginFactory.OperationExtensionsOperationKey, operation },
            { OpenApiKernelPluginFactory.OperationExtensionsInfoKey, info },
            { OpenApiKernelPluginFactory.OperationExtensionsSecurityKey, security },
            { OpenApiKernelPluginFactory.OperationExtensionsServerUrlsKey, operation.Servers is { Count: > 0 } servers && !string.IsNullOrEmpty(servers[0].Url) ? [servers[0].Url! ] : Array.Empty<string>() }
        };

        if (operation.Extensions is { Count: > 0 })
        {
            additionalMetadata.Add(OpenApiKernelPluginFactory.OperationExtensionsMetadataKey, operation.Extensions);
        }

        return KernelFunctionFactory.CreateFromMethod(
            method: ExecuteAsync,
            new KernelFunctionFromMethodOptions
            {
                FunctionName = ConvertOperationToValidFunctionName(operation, logger),
                Description = operation.Description,
                Parameters = parameters,
                ReturnParameter = returnParameter,
                LoggerFactory = loggerFactory,
                AdditionalMetadata = new ReadOnlyDictionary<string, object?>(additionalMetadata),
            });
    }

    private static KernelJsonSchema? GetSchema(RestApiParameter p)
    {
        // Add description to the schema.
        if (p.Schema is not null && !string.IsNullOrEmpty(p.Description))
        {
            const string DescriptionPropertyName = "description";

            // If the schema does not already have a description, add it.
            if (!p.Schema.RootElement.TryGetProperty(DescriptionPropertyName, out var _))
            {
                var originalSchema = JsonSerializer.Serialize(p.Schema.RootElement);
                if (JsonNode.Parse(originalSchema) is JsonObject obj)
                {
                    obj.Add(DescriptionPropertyName, p.Description);
                    p.Schema = KernelJsonSchema.Parse(obj.ToString());
                }
            }
        }

        return p.Schema ?? (p.Type is null ? null : KernelJsonSchema.Parse($$"""{"type":"{{p.Type}}"}"""));
    }

    #region private

    /// <summary>The metadata property bag key to use when storing the method of an operation.</summary>
    private const string OperationExtensionsMethodKey = "method";

    /// <summary>The metadata property bag key to use when storing the operation.</summary>
    private const string OperationExtensionsOperationKey = "operation";

    /// <summary>The metadata property bag key to use when storing the API information.</summary>
    private const string OperationExtensionsInfoKey = "info";

    /// <summary>The metadata property bag key to use when storing the security requirements.</summary>
    private const string OperationExtensionsSecurityKey = "security";

    /// <summary>The metadata property bag key to use when storing the server of an operation.</summary>
    private const string OperationExtensionsServerUrlsKey = "server-urls";

    /// <summary>The metadata property bag key to use for the list of extension values provided in the swagger file at the operation level.</summary>
    private const string OperationExtensionsMetadataKey = "operation-extensions";

    /// <summary>
    /// Converts operation id to valid <see cref="KernelFunction"/> name.
    /// A function name can contain only ASCII letters, digits, and underscores.
    /// </summary>
    /// <param name="operation">The REST API operation.</param>
    /// <param name="logger">The logger.</param>
    /// <returns>Valid <see cref="KernelFunction"/>> name.</returns>
    private static string ConvertOperationToValidFunctionName(RestApiOperation operation, ILogger logger)
    {
        if (!string.IsNullOrWhiteSpace(operation.Id))
        {
            return ConvertOperationIdToValidFunctionName(operationId: operation.Id!, logger: logger);
        }

        // Tokenize operation path on forward and back slashes
        string[] tokens = operation.Path.Split('/', '\\');
        StringBuilder result = new();
        result.Append(CultureInfo.CurrentCulture.TextInfo.ToTitleCase(operation.Method.ToString()));

        foreach (string token in tokens)
        {
            // Removes all characters that are not ASCII letters, digits, and underscores.
            string formattedToken = RemoveInvalidCharsRegex().Replace(token, "");
            result.Append(CultureInfo.CurrentCulture.TextInfo.ToTitleCase(formattedToken.ToLower(CultureInfo.CurrentCulture)));
        }

        logger.LogInformation("""Operation method "{Method}" with path "{Path}" converted to "{Result}" to comply with SK Function name requirements. Use "{Result}" when invoking function.""", operation.Method, operation.Path, result, result);

        return result.ToString();
    }

    /// <summary>
    /// Converts operation id to valid <see cref="KernelFunction"/> name.
    /// A function name can contain only ASCII letters, digits, and underscores.
    /// </summary>
    /// <param name="operationId">The operation id.</param>
    /// <param name="logger">The logger.</param>
    /// <returns>Valid <see cref="KernelFunction"/> name.</returns>
    private static string ConvertOperationIdToValidFunctionName(string operationId, ILogger logger)
    {
        try
        {
            KernelVerify.ValidFunctionName(operationId);
            return operationId;
        }
        catch (ArgumentException)
        {
            // The exception indicates that the operationId is not a valid function name.
            // To comply with the KernelFunction name requirements, it needs to be converted or sanitized.
            // Therefore, it should not be re-thrown, but rather swallowed to allow the conversion below.
        }

        // Tokenize operation id on forward and back slashes
        string[] tokens = operationId.Split('/', '\\');
        string result = string.Empty;

        foreach (string token in tokens)
        {
            // Removes all characters that are not ASCII letters, digits, and underscores.
            string formattedToken = RemoveInvalidCharsRegex().Replace(token, "");
            result += CultureInfo.CurrentCulture.TextInfo.ToTitleCase(formattedToken.ToLower(CultureInfo.CurrentCulture));
        }

        logger.LogInformation("""Operation name "{OperationId}" converted to "{Result}" to comply with SK Function name requirements. Use "{Result}" when invoking function.""", operationId, result, result);

        return result;
    }

    /// <summary>
    /// Selects operations to parse and import.
    /// </summary>
    /// <param name="context">Operation selection context.</param>
    /// <param name="executionParameters">Execution parameters.</param>
    /// <returns>True if the operation should be selected; otherwise, false.</returns>
    private static bool SelectOperations(OperationSelectionPredicateContext context, OpenApiFunctionExecutionParameters? executionParameters)
    {
#pragma warning disable CS0618 // Type or member is obsolete
        if (executionParameters?.OperationSelectionPredicate is not null && executionParameters?.OperationsToExclude is { Count: > 0 })
        {
            throw new ArgumentException($"{nameof(executionParameters.OperationSelectionPredicate)} and {nameof(executionParameters.OperationsToExclude)} cannot be used together.");
        }

        if (executionParameters?.OperationSelectionPredicate is { } predicate)
        {
            return predicate(context);
        }

        return !executionParameters?.OperationsToExclude.Contains(context.Id ?? string.Empty) ?? true;
#pragma warning restore CS0618 // Type or member is obsolete
    }

    /// <summary>
    /// Converts the parameter type to a C# <see cref="Type"/> object.
    /// </summary>
    /// <param name="parameter">The REST API parameter.</param>
    private static Type? ConvertParameterDataType(RestApiParameter parameter)
    {
        return parameter.Type switch
        {
            "string" => typeof(string),
            "boolean" => typeof(bool),
            "number" => parameter.Format switch
            {
                "float" => typeof(float),
                "double" => typeof(double),
                _ => typeof(double)
            },
            "integer" => parameter.Format switch
            {
                "int32" => typeof(int),
                "int64" => typeof(long),
                _ => typeof(long)
            },
            "object" => typeof(object),
            _ => null
        };
    }

    /// <summary>
    /// Used to convert operationId to SK function names.
    /// </summary>
#if NET
    [GeneratedRegex("[^0-9A-Za-z_]")]
    private static partial Regex RemoveInvalidCharsRegex();
#else
    private static Regex RemoveInvalidCharsRegex() => s_removeInvalidCharsRegex;
    private static readonly Regex s_removeInvalidCharsRegex = new("[^0-9A-Za-z_./-/{/}]", RegexOptions.Compiled);
#endif

    #endregion
}


===== Functions.OpenApi\RestApiOperationResponseFactory.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Threading;
using System.Threading.Tasks;

namespace Microsoft.SemanticKernel.Plugins.OpenApi;

/// <summary>
/// Represents a factory for creating instances of the <see cref="RestApiOperationResponse"/>.
/// </summary>
/// <param name="context">The context that contains the operation details.</param>
/// <param name="cancellationToken">The cancellation token used to signal cancellation.</param>
/// <returns>A task that represents the asynchronous operation, containing an instance of <see cref="RestApiOperationResponse"/>.</returns>
public delegate Task<RestApiOperationResponse> RestApiOperationResponseFactory(RestApiOperationResponseFactoryContext context, CancellationToken cancellationToken = default);


===== Functions.OpenApi\RestApiOperationResponseFactoryContext.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Net.Http;

namespace Microsoft.SemanticKernel.Plugins.OpenApi;

/// <summary>
/// Represents the context for the <see cref="RestApiOperationResponseFactory"/>."/>
/// </summary>
public sealed class RestApiOperationResponseFactoryContext
{
    /// <summary>
    /// Initializes a new instance of the <see cref="RestApiOperationResponseFactoryContext"/> class.
    /// </summary>
    /// <param name="operation">The REST API operation.</param>
    /// <param name="request">The HTTP request message.</param>
    /// <param name="response">The HTTP response message.</param>
    /// <param name="internalFactory">The internal factory to create instances of the <see cref="RestApiOperationResponse"/>.</param>
    internal RestApiOperationResponseFactoryContext(RestApiOperation operation, HttpRequestMessage request, HttpResponseMessage response, RestApiOperationResponseFactory internalFactory)
    {
        this.InternalFactory = internalFactory;
        this.Operation = operation;
        this.Request = request;
        this.Response = response;
    }

    /// <summary>
    /// The REST API operation.
    /// </summary>
    public RestApiOperation Operation { get; }

    /// <summary>
    /// The HTTP request message.
    /// </summary>
    public HttpRequestMessage Request { get; }

    /// <summary>
    /// The HTTP response message.
    /// </summary>
    public HttpResponseMessage Response { get; }

    /// <summary>
    /// The internal factory to create instances of the <see cref="RestApiOperationResponse"/>.
    /// </summary>
    public RestApiOperationResponseFactory InternalFactory { get; }
}


===== Functions.OpenApi\RestApiOperationRunner.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Text;
using System.Text.Json.Nodes;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.SemanticKernel.Http;

#pragma warning disable CA1859 // Use concrete types when possible for improved performance

namespace Microsoft.SemanticKernel.Plugins.OpenApi;

/// <summary>
/// Runs REST API operation represented by RestApiOperation model class.
/// </summary>
internal sealed class RestApiOperationRunner
{
    private const string MediaTypeApplicationJson = "application/json";
    private const string MediaTypeTextPlain = "text/plain";

    private const string DefaultResponseKey = "default";

    /// <summary>
    /// HTTP request method.
    /// </summary>
    private const string HttpRequestMethod = "http.request.method";

    /// <summary>
    /// The HTTP request payload body.
    /// </summary>
    private const string HttpRequestBody = "http.request.body";

    /// <summary>
    /// The HTTP request options.
    /// </summary>
    private const string HttpRequestOptions = "http.request.options";

    /// <summary>
    /// Absolute URL describing a network resource according to RFC3986.
    /// </summary>
    private const string UrlFull = "url.full";

    /// <summary>
    /// List of payload builders/factories.
    /// </summary>
    private readonly Dictionary<string, HttpContentFactory> _payloadFactoryByMediaType;

    /// <summary>
    /// A dictionary containing the content type as the key and the corresponding content reader as the value.
    /// </summary>
    private static readonly Dictionary<string, HttpResponseContentReader> s_contentReaderByContentType = new()
    {
        { "image", async (context, cancellationToken) => await context.Response.Content.ReadAsByteArrayAndTranslateExceptionAsync(cancellationToken).ConfigureAwait(false) },
        { "text", async (context, cancellationToken) => await context.Response.Content.ReadAsStringWithExceptionMappingAsync(cancellationToken).ConfigureAwait(false) },
        { "application/json", async (context, cancellationToken) => await context.Response.Content.ReadAsStringWithExceptionMappingAsync(cancellationToken).ConfigureAwait(false)},
        { "application/xml", async (context, cancellationToken) => await context.Response.Content.ReadAsStringWithExceptionMappingAsync(cancellationToken).ConfigureAwait(false)}
    };

    /// <summary>
    /// An instance of the HttpClient class.
    /// </summary>
    private readonly HttpClient _httpClient;

    /// <summary>
    /// Delegate for authorizing the HTTP request.
    /// </summary>
    private readonly AuthenticateRequestAsyncCallback _authCallback;

    /// <summary>
    /// Request-header field containing information about the user agent originating the request
    /// </summary>
    private readonly string? _userAgent;

    /// <summary>
    /// Determines whether the operation payload is constructed dynamically based on operation payload metadata.
    /// If false, the operation payload must be provided via the 'payload' property.
    /// </summary>
    private readonly bool _enableDynamicPayload;

    /// <summary>
    /// Determines whether payload parameters are resolved from the arguments by
    /// full name (parameter name prefixed with the parent property name).
    /// </summary>
    private readonly bool _enablePayloadNamespacing;

    /// <summary>
    /// Custom HTTP response content reader.
    /// </summary>
    private readonly HttpResponseContentReader? _httpResponseContentReader;

    /// <summary>
    /// The external response factory for creating <see cref="RestApiOperationResponse"/>.
    /// </summary>
    private readonly RestApiOperationResponseFactory? _responseFactory;

    /// <summary>
    /// The external URL factory to use if provided, instead of the default one.
    /// </summary>
    private readonly RestApiOperationUrlFactory? _urlFactory;

    /// <summary>
    /// The external header factory to use if provided, instead of the default one.
    /// </summary>
    private readonly RestApiOperationHeadersFactory? _headersFactory;

    /// <summary>
    /// The external payload factory to use if provided, instead of the default one.
    /// </summary>
    private readonly RestApiOperationPayloadFactory? _payloadFactory;

    /// <summary>
    /// Creates an instance of the <see cref="RestApiOperationRunner"/> class.
    /// </summary>
    /// <param name="httpClient">An instance of the HttpClient class.</param>
    /// <param name="authCallback">Optional callback for adding auth data to the API requests.</param>
    /// <param name="userAgent">Optional request-header field containing information about the user agent originating the request.</param>
    /// <param name="enableDynamicPayload">Determines whether the operation payload is constructed dynamically based on operation payload metadata.
    /// If false, the operation payload must be provided via the 'payload' property.
    /// </param>
    /// <param name="enablePayloadNamespacing">Determines whether payload parameters are resolved from the arguments by
    /// full name (parameter name prefixed with the parent property name).</param>
    /// <param name="httpResponseContentReader">Custom HTTP response content reader.</param>
    /// <param name="responseFactory">The external response factory for creating <see cref="RestApiOperationResponse"/>.</param>
    /// <param name="urlFactory">The external URL factory to use if provided if provided instead of the default one.</param>
    /// <param name="headersFactory">The external headers factory to use if provided instead of the default one.</param>
    /// <param name="payloadFactory">The external payload factory to use if provided instead of the default one.</param>
    public RestApiOperationRunner(
        HttpClient httpClient,
        AuthenticateRequestAsyncCallback? authCallback = null,
        string? userAgent = null,
        bool enableDynamicPayload = false,
        bool enablePayloadNamespacing = false,
        HttpResponseContentReader? httpResponseContentReader = null,
        RestApiOperationResponseFactory? responseFactory = null,
        RestApiOperationUrlFactory? urlFactory = null,
        RestApiOperationHeadersFactory? headersFactory = null,
        RestApiOperationPayloadFactory? payloadFactory = null)
    {
        this._httpClient = httpClient;
        this._userAgent = userAgent ?? HttpHeaderConstant.Values.UserAgent;
        this._enableDynamicPayload = enableDynamicPayload;
        this._enablePayloadNamespacing = enablePayloadNamespacing;
        this._httpResponseContentReader = httpResponseContentReader;
        this._responseFactory = responseFactory;
        this._urlFactory = urlFactory;
        this._headersFactory = headersFactory;
        this._payloadFactory = payloadFactory;

        // If no auth callback provided, use empty function
        if (authCallback is null)
        {
            this._authCallback = (_, __) => Task.CompletedTask;
        }
        else
        {
            this._authCallback = authCallback;
        }

        this._payloadFactoryByMediaType = new()
        {
            { MediaTypeApplicationJson, this.BuildJsonPayload },
            { MediaTypeTextPlain, this.BuildPlainTextPayload }
        };
    }

    /// <summary>
    /// Executes the specified <paramref name="operation"/> asynchronously, using the provided <paramref name="arguments"/>.
    /// </summary>
    /// <param name="operation">The REST API operation to execute.</param>
    /// <param name="arguments">The dictionary of arguments to be passed to the operation.</param>
    /// <param name="options">Options for REST API operation run.</param>
    /// <param name="cancellationToken">The cancellation token.</param>
    /// <returns>The task execution result.</returns>
    public Task<RestApiOperationResponse> RunAsync(
        RestApiOperation operation,
        KernelArguments arguments,
        RestApiOperationRunOptions? options = null,
        CancellationToken cancellationToken = default)
    {
        var url = this._urlFactory?.Invoke(operation, arguments, options) ?? this.BuildsOperationUrl(operation, arguments, options?.ServerUrlOverride, options?.ApiHostUrl);

        var headers = this._headersFactory?.Invoke(operation, arguments, options) ?? operation.BuildHeaders(arguments);

        var (Payload, Content) = this._payloadFactory?.Invoke(operation, arguments, this._enableDynamicPayload, this._enablePayloadNamespacing, options) ?? this.BuildOperationPayload(operation, arguments);

        return this.SendAsync(operation, url, headers, Payload, Content, options, cancellationToken);
    }

    #region private

    /// <summary>
    /// Sends an HTTP request.
    /// </summary>
    /// <param name="operation">The REST API operation.</param>
    /// <param name="url">The url to send request to.</param>
    /// <param name="headers">Headers to include into the HTTP request.</param>
    /// <param name="payload">HTTP request payload.</param>
    /// <param name="requestContent">HTTP request content.</param>
    /// <param name="options">Options for REST API operation run.</param>
    /// <param name="cancellationToken">The cancellation token.</param>
    /// <returns>Response content and content type</returns>
    private async Task<RestApiOperationResponse> SendAsync(
        RestApiOperation operation,
        Uri url,
        IDictionary<string, string>? headers = null,
        object? payload = null,
        HttpContent? requestContent = null,
        RestApiOperationRunOptions? options = null,
        CancellationToken cancellationToken = default)
    {
        using var requestMessage = new HttpRequestMessage(operation.Method, url);

#if NET5_0_OR_GREATER
        requestMessage.Options.Set(OpenApiKernelFunctionContext.KernelFunctionContextKey, new OpenApiKernelFunctionContext(options?.Kernel, options?.KernelFunction, options?.KernelArguments));
#else
        requestMessage.Properties.Add(OpenApiKernelFunctionContext.KernelFunctionContextKey, new OpenApiKernelFunctionContext(options?.Kernel, options?.KernelFunction, options?.KernelArguments));
#endif

        await this._authCallback(requestMessage, cancellationToken).ConfigureAwait(false);

        if (requestContent is not null)
        {
            requestMessage.Content = requestContent;
        }

        requestMessage.Headers.Add("User-Agent", !string.IsNullOrWhiteSpace(this._userAgent)
            ? this._userAgent
            : HttpHeaderConstant.Values.UserAgent);
        requestMessage.Headers.Add(HttpHeaderConstant.Names.SemanticKernelVersion, HttpHeaderConstant.Values.GetAssemblyVersion(typeof(RestApiOperationRunner)));

        if (headers is not null)
        {
            foreach (var header in headers)
            {
                requestMessage.Headers.Add(header.Key, header.Value);
            }
        }

        RestApiOperationResponse? response = null;
        HttpResponseMessage? responseMessage = null;

        try
        {
            responseMessage = await this._httpClient.SendWithSuccessCheckAsync(requestMessage, HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);

            response = await this.BuildResponseAsync(operation, requestMessage, responseMessage, payload, cancellationToken).ConfigureAwait(false);

            return response;
        }
        catch (HttpRequestException ex)
        {
            var exception = new HttpOperationException(message: ex.Message, innerException: ex);
            exception.Data.Add(HttpRequestMethod, requestMessage.Method.Method);
            exception.Data.Add(UrlFull, requestMessage.RequestUri?.ToString());
            exception.Data.Add(HttpRequestBody, payload);
            AddRequestOptions(exception, requestMessage);

            throw exception;
        }
        catch (HttpOperationException ex)
        {
#pragma warning disable CS0618 // Type or member is obsolete
            ex.RequestMethod = requestMessage.Method.Method;
            ex.RequestUri = requestMessage.RequestUri;
            ex.RequestPayload = payload;
#pragma warning restore CS0618 // Type or member is obsolete

            ex.Data.Add(HttpRequestMethod, requestMessage.Method.Method);
            ex.Data.Add(UrlFull, requestMessage.RequestUri?.ToString());
            ex.Data.Add(HttpRequestBody, payload);
            AddRequestOptions(ex, requestMessage);

            throw;
        }
        catch (OperationCanceledException ex)
        {
            ex.Data.Add(HttpRequestMethod, requestMessage.Method.Method);
            ex.Data.Add(UrlFull, requestMessage.RequestUri?.ToString());
            ex.Data.Add(HttpRequestBody, payload);
            AddRequestOptions(ex, requestMessage);

            throw;
        }
        catch (KernelException ex)
        {
            ex.Data.Add(HttpRequestMethod, requestMessage.Method.Method);
            ex.Data.Add(UrlFull, requestMessage.RequestUri?.ToString());
            ex.Data.Add(HttpRequestBody, payload);
            AddRequestOptions(ex, requestMessage);

            throw;
        }
        finally
        {
            // Dispose the response message if the content is not a stream.
            // Otherwise, the caller is responsible for disposing of both the stream content and the response message.
            if (response?.Content is not HttpResponseStream)
            {
                responseMessage?.Dispose();
            }
        }
    }

    /// <summary>
    /// Reads the response content of an HTTP request and creates an operation response.
    /// </summary>
    /// <param name="requestMessage">The HTTP request message.</param>
    /// <param name="responseMessage">The HTTP response message.</param>
    /// <param name="payload">The payload sent in the HTTP request.</param>
    /// <param name="cancellationToken">The cancellation token.</param>
    /// <returns>The operation response.</returns>
    private async Task<RestApiOperationResponse> ReadContentAndCreateOperationResponseAsync(HttpRequestMessage requestMessage, HttpResponseMessage responseMessage, object? payload, CancellationToken cancellationToken)
    {
        if (responseMessage.StatusCode == HttpStatusCode.NoContent ||
         (string.IsNullOrEmpty(responseMessage.Content.Headers.ContentType?.MediaType) &&
            (responseMessage.StatusCode is HttpStatusCode.Accepted or HttpStatusCode.Created)))
        {
            return new RestApiOperationResponse(null, null)
            {
                RequestMethod = requestMessage.Method.Method,
                RequestUri = requestMessage.RequestUri,
                RequestPayload = payload,
            };
        }

        var contentType = responseMessage.Content.Headers.ContentType;

        var mediaType = contentType?.MediaType ?? throw new KernelException("No media type available.");

        var content = await this.ReadHttpContentAsync(requestMessage, responseMessage, mediaType, cancellationToken).ConfigureAwait(false);

        return new RestApiOperationResponse(content, contentType.ToString())
        {
            RequestMethod = requestMessage.Method.Method,
            RequestUri = requestMessage.RequestUri,
            RequestPayload = payload,
        };
    }

    /// <summary>
    /// Builds operation payload.
    /// </summary>
    /// <param name="operation">The operation.</param>
    /// <param name="arguments">The operation payload arguments.</param>
    /// <returns>The raw operation payload and the corresponding HttpContent.</returns>
    private (object? Payload, HttpContent? Content) BuildOperationPayload(RestApiOperation operation, IDictionary<string, object?> arguments)
    {
        if (operation.Payload is null && !arguments.ContainsKey(RestApiOperation.PayloadArgumentName))
        {
            return (null, null);
        }

        var mediaType = operation.Payload?.MediaType;
        if (string.IsNullOrEmpty(mediaType))
        {
            if (!arguments.TryGetValue(RestApiOperation.ContentTypeArgumentName, out object? fallback) || fallback is not string mediaTypeFallback)
            {
                throw new KernelException($"No media type is provided for the {operation.Id} operation.");
            }

            mediaType = mediaTypeFallback;
        }

        // Remove media type parameters, such as x-api-version, from the "text/plain; x-api-version=2.0" media type string.
        mediaType = mediaType!.Split(';').First();

        // Normalize the media type to lowercase and remove trailing whitespaces.
#pragma warning disable CA1308 // Normalize strings to uppercase
        mediaType = mediaType!.ToLowerInvariant().Trim();
#pragma warning restore CA1308 // Normalize strings to uppercase

        if (!this._payloadFactoryByMediaType.TryGetValue(mediaType, out var payloadFactory))
        {
            throw new KernelException($"The media type {mediaType} of the {operation.Id} operation is not supported by {nameof(RestApiOperationRunner)}.");
        }

        return payloadFactory.Invoke(operation.Payload, arguments);
    }

    /// <summary>
    /// Builds "application/json" payload.
    /// </summary>
    /// <param name="payloadMetadata">The payload meta-data.</param>
    /// <param name="arguments">The payload arguments.</param>
    /// <returns>The JSON payload the corresponding HttpContent.</returns>
    private (object Payload, HttpContent Content) BuildJsonPayload(RestApiPayload? payloadMetadata, IDictionary<string, object?> arguments)
    {
        // Build operation payload dynamically
        if (this._enableDynamicPayload)
        {
            if (payloadMetadata is null)
            {
                throw new KernelException("Payload can't be built dynamically due to the missing payload metadata.");
            }

            var payload = this.BuildJsonObject(payloadMetadata.Properties, arguments);

            return (payload, new StringContent(payload.ToJsonString(), Encoding.UTF8, MediaTypeApplicationJson));
        }

        // Get operation payload content from the 'payload' argument if dynamic payload building is not required.
        if (!arguments.TryGetValue(RestApiOperation.PayloadArgumentName, out object? argument) || argument is not string content)
        {
            throw new KernelException($"No payload is provided by the argument '{RestApiOperation.PayloadArgumentName}'.");
        }

        return (content, new StringContent(content, Encoding.UTF8, MediaTypeApplicationJson));
    }

    /// <summary>
    /// Builds a JSON object from a list of RestAPI operation payload properties.
    /// </summary>
    /// <param name="properties">The properties.</param>
    /// <param name="arguments">The arguments.</param>
    /// <param name="propertyNamespace">The namespace to add to the property name.</param>
    /// <returns>The JSON object.</returns>
    private JsonObject BuildJsonObject(IList<RestApiPayloadProperty> properties, IDictionary<string, object?> arguments, string? propertyNamespace = null)
    {
        var result = new JsonObject();

        foreach (var propertyMetadata in properties)
        {
            var argumentName = this.GetArgumentNameForPayload(propertyMetadata.Name, propertyNamespace);

            if (propertyMetadata.Type == "object")
            {
                var node = this.BuildJsonObject(propertyMetadata.Properties, arguments, argumentName);
                result.Add(propertyMetadata.Name, node);
                continue;
            }

            // Use property argument name to look up the property value
            if (!string.IsNullOrEmpty(propertyMetadata.ArgumentName) && arguments.TryGetValue(propertyMetadata.ArgumentName!, out object? argument) && argument is not null)
            {
                result.Add(propertyMetadata.Name, OpenApiTypeConverter.Convert(propertyMetadata.Name, propertyMetadata.Type, argument, propertyMetadata.Schema));
                continue;
            }
            // Use property name to look up the property value
            else if (arguments.TryGetValue(argumentName, out argument) && argument is not null)
            {
                result.Add(propertyMetadata.Name, OpenApiTypeConverter.Convert(propertyMetadata.Name, propertyMetadata.Type, argument, propertyMetadata.Schema));
                continue;
            }

            if (propertyMetadata.IsRequired)
            {
                throw new KernelException($"No argument is found for the '{propertyMetadata.Name}' payload property.");
            }
        }

        return result;
    }

    /// <summary>
    /// Gets the expected schema for the specified status code.
    /// </summary>
    /// <param name="expectedSchemas">The dictionary of expected response schemas.</param>
    /// <param name="statusCode">The status code.</param>
    /// <returns>The expected schema for the given status code.</returns>
    private static KernelJsonSchema? GetExpectedSchema(IDictionary<string, KernelJsonSchema?>? expectedSchemas, HttpStatusCode statusCode)
    {
        KernelJsonSchema? matchingResponse = null;
        if (expectedSchemas is not null)
        {
            var statusCodeKey = ((int)statusCode).ToString(CultureInfo.InvariantCulture);

            // Exact Match
            matchingResponse = expectedSchemas.FirstOrDefault(r => r.Key == statusCodeKey).Value;

            // Wildcard match e.g. 2XX
            matchingResponse ??= expectedSchemas.FirstOrDefault(r => r.Key is { Length: 3 } key && key[0] == statusCodeKey[0] && key[1] == 'X' && key[2] == 'X').Value;

            // Default
            matchingResponse ??= expectedSchemas.FirstOrDefault(r => r.Key == DefaultResponseKey).Value;
        }

        return matchingResponse;
    }

    /// <summary>
    /// Builds "text/plain" payload.
    /// </summary>
    /// <param name="payloadMetadata">The payload meta-data.</param>
    /// <param name="arguments">The payload arguments.</param>
    /// <returns>The text payload and corresponding HttpContent.</returns>
    private (object Payload, HttpContent Content) BuildPlainTextPayload(RestApiPayload? payloadMetadata, IDictionary<string, object?> arguments)
    {
        if (!arguments.TryGetValue(RestApiOperation.PayloadArgumentName, out object? argument) || argument is not string payload)
        {
            throw new KernelException($"No argument is found for the '{RestApiOperation.PayloadArgumentName}' payload content.");
        }

        return (payload, new StringContent(payload, Encoding.UTF8, MediaTypeTextPlain));
    }

    /// <summary>
    /// Retrieves the argument name for a payload property.
    /// </summary>
    /// <param name="propertyName">The name of the property.</param>
    /// <param name="propertyNamespace">The namespace to add to the property name (optional).</param>
    /// <returns>The argument name for the payload property.</returns>
    private string GetArgumentNameForPayload(string propertyName, string? propertyNamespace)
    {
        if (!this._enablePayloadNamespacing)
        {
            return propertyName;
        }

        return string.IsNullOrEmpty(propertyNamespace) ? propertyName : $"{propertyNamespace}.{propertyName}";
    }

    /// <summary>
    /// Builds operation Url.
    /// </summary>
    /// <param name="operation">The REST API operation.</param>
    /// <param name="arguments">The operation arguments.</param>
    /// <param name="serverUrlOverride">Override for REST API operation server url.</param>
    /// <param name="apiHostUrl">The URL of REST API host.</param>
    /// <returns>The operation Url.</returns>
    private Uri BuildsOperationUrl(RestApiOperation operation, IDictionary<string, object?> arguments, Uri? serverUrlOverride = null, Uri? apiHostUrl = null)
    {
        var url = operation.BuildOperationUrl(arguments, serverUrlOverride, apiHostUrl);

        return new UriBuilder(url) { Query = operation.BuildQueryString(arguments) }.Uri;
    }

    /// <summary>
    /// Reads the HTTP content.
    /// </summary>
    /// <param name="requestMessage">The HTTP request message.</param>
    /// <param name="responseMessage">The HTTP response message.</param>
    /// <param name="mediaType">The media type of the content.</param>
    /// <param name="cancellationToken">The cancellation token.</param>
    /// <returns>The HTTP content.</returns>
    private async Task<object?> ReadHttpContentAsync(HttpRequestMessage requestMessage, HttpResponseMessage responseMessage, string mediaType, CancellationToken cancellationToken)
    {
        object? content = null;

        // Read content using the custom reader if provided.
        if (this._httpResponseContentReader is not null)
        {
            content = await this._httpResponseContentReader.Invoke(new(requestMessage, responseMessage), cancellationToken).ConfigureAwait(false);
        }

        // If no custom reader is provided or the custom reader did not return any content, read the content using the default readers.
        if (content is null)
        {
            // Obtain the content reader by media type (e.g., text/plain, application/json, image/jpg)
            if (!s_contentReaderByContentType.TryGetValue(mediaType, out var reader))
            {
                // Split the media type into a primary-type and a sub-type
                var mediaTypeParts = mediaType.Split('/');
                if (mediaTypeParts.Length != 2)
                {
                    throw new KernelException($"The string `{mediaType}` is not a valid media type.");
                }

                var primaryMediaType = mediaTypeParts.First();

                // Try to obtain the content reader by the primary type (e.g., text, application, image)
                if (!s_contentReaderByContentType.TryGetValue(primaryMediaType, out reader))
                {
                    throw new KernelException($"The content type `{mediaType}` is not supported.");
                }
            }

            content = await reader.Invoke(new(requestMessage, responseMessage), cancellationToken).ConfigureAwait(false);
        }

        // Handling the case when the content is a stream
        if (content is Stream stream)
        {
#pragma warning disable CA2000 // Dispose objects before losing scope.
            // Wrap the stream content to capture the HTTP response message, delegating its disposal to the caller.
            content = new HttpResponseStream(stream, responseMessage);
#pragma warning restore CA2000 // Dispose objects before losing scope.
        }

        return content;
    }

    /// <summary>
    /// Builds the operation response.
    /// </summary>
    /// <param name="operation">The REST API operation.</param>
    /// <param name="requestMessage">The HTTP request message.</param>
    /// <param name="responseMessage">The HTTP response message.</param>
    /// <param name="payload">The payload sent in the HTTP request.</param>
    /// <param name="cancellationToken">The cancellation token.</param>
    /// <returns>The operation response.</returns>
    private async Task<RestApiOperationResponse> BuildResponseAsync(RestApiOperation operation, HttpRequestMessage requestMessage, HttpResponseMessage responseMessage, object? payload, CancellationToken cancellationToken)
    {
        async Task<RestApiOperationResponse> Build(RestApiOperationResponseFactoryContext context, CancellationToken ct)
        {
            var response = await this.ReadContentAndCreateOperationResponseAsync(context.Request, context.Response, payload, ct).ConfigureAwait(false);

            response.ExpectedSchema ??= GetExpectedSchema(context.Operation.Responses.ToDictionary(item => item.Key, item => item.Value.Schema), context.Response.StatusCode);

            return response;
        }

        // Delegate the response building to the custom response factory if provided.
        if (this._responseFactory is not null)
        {
            var response = await this._responseFactory(new(operation: operation, request: requestMessage, response: responseMessage, internalFactory: Build), cancellationToken).ConfigureAwait(false);

            // Handling the case when the content is a stream
            if (response.Content is Stream stream and not HttpResponseStream)
            {
                // Wrap the stream content to capture the HTTP response message, delegating its disposal to the caller.
                response.Content = new HttpResponseStream(stream, responseMessage);
            }

            return response;
        }

        return await Build(new(operation: operation, request: requestMessage, response: responseMessage, internalFactory: null!), cancellationToken).ConfigureAwait(false);
    }

    /// <summary>
    /// Adds the request options to the exception Data collection.
    /// </summary>
    /// <param name="exception">The exception.</param>
    /// <param name="requestMessage">The HTTP request message.</param>
    private static void AddRequestOptions(Exception exception, HttpRequestMessage requestMessage)
    {
        IDictionary<string, object?>? requestOptions = null;

#if NET5_0_OR_GREATER
        requestOptions = requestMessage.Options;
#else
        requestOptions = requestMessage.Properties;
#endif

        if (requestOptions is not null)
        {
            exception.Data[HttpRequestOptions] = requestOptions;
        }
    }

    #endregion
}


===== Functions.OpenApi\RestApiParameterFilter.cs =====

// Copyright (c) Microsoft. All rights reserved.

namespace Microsoft.SemanticKernel.Plugins.OpenApi;

/// <summary>
/// Represents a delegate for filtering <see cref="RestApiParameter"/> instances.
/// </summary>
/// <remarks>
/// Implementations of this delegate can either return null which will cause the parameter
/// to be removed from the REST API or return a new instance of <see cref="RestApiParameter"/>
/// which will replace the original parameter.
/// </remarks>
/// <param name="context">Instance of <see cref="RestApiParameterFilterContext"/> containing details of the parameter to filter.</param>
public delegate RestApiParameter? RestApiParameterFilter(RestApiParameterFilterContext context);


===== Functions.OpenApi\RestApiParameterFilterContext.cs =====

// Copyright (c) Microsoft. All rights reserved.

namespace Microsoft.SemanticKernel.Plugins.OpenApi;

/// <summary>
/// Initializes a new instance of the <see cref="RestApiParameterFilterContext"/> class.
/// </summary>
public sealed class RestApiParameterFilterContext
{
    /// <summary>
    /// The instance of <see cref="RestApiOperation"/> this parameter belongs to.
    /// </summary>
    public RestApiOperation Operation { get; set; }

    /// <summary>
    /// The instance of <see cref="RestApiParameter"/> to filter.
    /// </summary>
    public RestApiParameter Parameter { get; set; }

    /// <summary>
    /// The parent object of the parameter, can be either an instance
    /// of <see cref="RestApiPayload"/> or <see cref="RestApiPayloadProperty"/>
    /// null if the parameter belongs to the operation.
    /// </summary>
    public object? Parent { get; set; }

    /// <summary>
    /// Creates a new instance of the <see cref="RestApiParameterFilterContext"/> class.
    /// </summary>
    /// <param name="operation">The REST API operation</param>
    /// <param name="parameter">The REST API parameter to filter.</param>
    internal RestApiParameterFilterContext(RestApiOperation operation, RestApiParameter parameter)
    {
        this.Operation = operation;
        this.Parameter = parameter;
    }
}


===== Functions.OpenApi\Serialization\ArrayParameterValueSerializer.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Text.Json.Nodes;
using System.Web;

namespace Microsoft.SemanticKernel.Plugins.OpenApi;

/// <summary>
/// This class provides methods for serializing values of array parameters.
/// </summary>
internal static class ArrayParameterValueSerializer
{
    /// <summary>
    /// Serializes the items of an array as separate parameters with the same name.
    /// </summary>
    /// <param name="name">The name of the parameter.</param>
    /// <param name="array">The array containing the items to serialize.</param>
    /// <param name="delimiter">The delimiter used to separate parameters.</param>
    /// <returns>A string containing the serialized parameters.</returns>
    public static string SerializeArrayAsSeparateParameters(string name, JsonArray array, string delimiter)
    {
        var segments = new List<string>();

        foreach (var item in array)
        {
            segments.Add($"{name}={HttpUtility.UrlEncode(item?.ToString())}");
        }

        return string.Join(delimiter, segments); //id=1&id=2&id=3
    }

    /// <summary>
    /// Serializes the items of an array as one parameter with delimited values.
    /// </summary>
    /// <param name="array">The array containing the items to serialize.</param>
    /// <param name="delimiter">The delimiter used to separate items.</param>
    /// <param name="encode">Flag specifying whether to encode items or not.</param>
    /// <returns>A string containing the serialized parameter.</returns>
    public static string SerializeArrayAsDelimitedValues(JsonArray array, string delimiter, bool encode = true)
    {
        var values = new List<string?>();

        foreach (var item in array)
        {
            values.Add(encode ? HttpUtility.UrlEncode(item?.ToString()) : item?.ToString());
        }

        return string.Join(delimiter, values);
    }
}


===== Functions.OpenApi\Serialization\FormStyleParameterSerializer.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Text.Json.Nodes;
using System.Web;

namespace Microsoft.SemanticKernel.Plugins.OpenApi;

/// <summary>
/// Serializes REST API parameter of the 'Form' style.
/// </summary>
internal static class FormStyleParameterSerializer
{
    /// <summary>
    /// Serializes a REST API `Form` style parameter.
    /// </summary>
    /// <param name="parameter">The REST API parameter to serialize.</param>
    /// <param name="argument">The parameter argument.</param>
    /// <returns>The serialized parameter.</returns>
    public static string Serialize(RestApiParameter parameter, JsonNode argument)
    {
        const string ArrayType = "array";

        Verify.NotNull(parameter);
        Verify.NotNull(argument);

        var style = parameter.Style ?? RestApiParameterStyle.Form;
        if (style != RestApiParameterStyle.Form)
        {
            throw new NotSupportedException($"Unsupported Rest API parameter style '{parameter.Style}' for parameter '{parameter.Name}'");
        }

        // Handling parameters of array type.
        if (parameter.Type == ArrayType)
        {
            return SerializeArrayParameter(parameter, argument);
        }

        // Handling parameters where the underlying value is already a string.
        if (argument is JsonValue jsonValue && jsonValue.TryGetValue(out string? value))
        {
            return $"{parameter.Name}={HttpUtility.UrlEncode(value)}";
        }

        // Handling parameters of any arbitrary type by using JSON format without enclosing quotes.
        return $"{parameter.Name}={HttpUtility.UrlEncode(argument.ToString().Trim('"'))}";
    }

    /// <summary>
    /// Serializes an array-type parameter.
    /// </summary>
    /// <param name="parameter">The REST API parameter to serialize.</param>
    /// <param name="argument">The argument value.</param>
    /// <returns>The serialized parameter string.</returns>
    private static string SerializeArrayParameter(RestApiParameter parameter, JsonNode argument)
    {
        if (argument is not JsonArray array)
        {
            throw new ArgumentException(parameter.Name, $"Unexpected argument type '{argument.GetType()} with value '{argument}' for parameter type '{parameter.Type}'.");
        }

        if (parameter.Expand)
        {
            return ArrayParameterValueSerializer.SerializeArrayAsSeparateParameters(parameter.Name, array, delimiter: "&"); // id=1&id=2&id=3
        }

        return $"{parameter.Name}={ArrayParameterValueSerializer.SerializeArrayAsDelimitedValues(array, delimiter: ",")}"; // id=1,2,3
    }
}


===== Functions.OpenApi\Serialization\OpenApiTypeConverter.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Globalization;
using System.Text.Json;
using System.Text.Json.Nodes;
using Json.More;
using Json.Schema;

namespace Microsoft.SemanticKernel.Plugins.OpenApi;

/// <summary>
/// Provides functionality for converting OpenApi types - https://swagger.io/docs/specification/data-models/data-types/
/// </summary>
internal static class OpenApiTypeConverter
{
    /// <summary>
    /// Converts the given parameter argument to a JsonNode based on the specified type or schema.
    /// </summary>
    /// <param name="name">The parameter name.</param>
    /// <param name="type">The parameter type.</param>
    /// <param name="argument">The argument to be converted.</param>
    /// <param name="schema">The parameter schema.</param>
    /// <returns>A JsonNode representing the converted value.</returns>
    public static JsonNode Convert(string name, string type, object argument, KernelJsonSchema? schema = null)
    {
        Verify.NotNull(argument);

        try
        {
            JsonNode? node = type switch
            {
                "string" => JsonValue.Create(argument),
                "array" => argument switch
                {
                    string s => JsonArray.Parse(s) as JsonArray,
                    JsonElement jsonElement when jsonElement.ValueKind == JsonValueKind.Array => jsonElement.AsNode(),
                    _ => JsonSerializer.SerializeToNode(argument) as JsonArray
                },
                "integer" => argument switch
                {
                    string stringArgument => JsonValue.Create(long.Parse(stringArgument, CultureInfo.InvariantCulture)),
                    byte or sbyte or short or ushort or int or uint or long or ulong => JsonValue.Create(argument),
                    JsonElement jsonElement when jsonElement.TryGetInt64(out var intValue) => JsonValue.Create(intValue),
                    _ => null
                },
                "boolean" => argument switch
                {
                    bool b => JsonValue.Create(b),
                    string s => JsonValue.Create(bool.Parse(s)),
                    JsonElement jsonElement when jsonElement.ValueKind == JsonValueKind.True || jsonElement.ValueKind == JsonValueKind.False => jsonElement.AsNode(),
                    _ => null
                },
                "number" => argument switch
                {
                    string stringArgument when long.TryParse(stringArgument, out var intValue) => JsonValue.Create(intValue),
                    string stringArgument when double.TryParse(stringArgument, out var doubleValue) => JsonValue.Create(doubleValue),
                    byte or sbyte or short or ushort or int or uint or long or ulong or float or double or decimal => JsonValue.Create(argument),
                    JsonElement jsonElement when jsonElement.TryGetInt64(out var intValue) => JsonValue.Create(intValue),
                    JsonElement jsonElement when jsonElement.TryGetDouble(out var doubleValue) => JsonValue.Create(doubleValue),
                    _ => null
                },
                _ => schema is null
                    ? JsonSerializer.SerializeToNode(argument)
                    : ValidateSchemaAndConvert(name, schema, argument)
            };

            return node ?? throw new ArgumentOutOfRangeException(name, argument, $"Argument type '{argument.GetType()}' is not convertible to parameter type '{type}'.");
        }
        catch (ArgumentException ex)
        {
            throw new ArgumentOutOfRangeException(name, argument, ex.Message);
        }
        catch (FormatException ex)
        {
            throw new ArgumentOutOfRangeException(name, argument, ex.Message);
        }
    }

    /// <summary>
    /// Validates the argument against the parameter schema and converts it to a JsonNode if valid.
    /// </summary>
    /// <param name="parameterName">The parameter name.</param>
    /// <param name="parameterSchema">The parameter schema.</param>
    /// <param name="argument">The argument to be validated and converted.</param>
    /// <returns>A JsonNode representing the converted value.</returns>
    private static JsonNode? ValidateSchemaAndConvert(string parameterName, KernelJsonSchema parameterSchema, object argument)
    {
        var jsonSchema = JsonSchema.FromText(JsonSerializer.Serialize(parameterSchema));

        var node = JsonSerializer.SerializeToNode(argument);

        if (jsonSchema.Evaluate(node).IsValid)
        {
            return node;
        }

        throw new ArgumentOutOfRangeException(parameterName, argument, $"Argument type '{argument.GetType()}' does not match the schema.");
    }
}


===== Functions.OpenApi\Serialization\PipeDelimitedStyleParameterSerializer.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Text.Json.Nodes;

namespace Microsoft.SemanticKernel.Plugins.OpenApi;

/// <summary>
/// Serializes REST API parameter of the 'PipeDelimited' style.
/// </summary>
internal static class PipeDelimitedStyleParameterSerializer
{
    /// <summary>
    /// Serializes a REST API `PipeDelimited` style parameter.
    /// </summary>
    /// <param name="parameter">The REST API parameter to serialize.</param>
    /// <param name="argument">The parameter argument.</param>
    /// <returns>The serialized parameter.</returns>
    public static string Serialize(RestApiParameter parameter, JsonNode argument)
    {
        const string ArrayType = "array";

        Verify.NotNull(parameter);
        Verify.NotNull(argument);

        if (parameter.Style != RestApiParameterStyle.PipeDelimited)
        {
            throw new NotSupportedException($"Unsupported Rest API parameter style '{parameter.Style}' for parameter '{parameter.Name}'");
        }

        if (parameter.Type != ArrayType)
        {
            throw new NotSupportedException($"Unsupported Rest API parameter type '{parameter.Type}' for parameter '{parameter.Name}'");
        }

        return SerializeArrayParameter(parameter, argument);
    }

    /// <summary>
    /// Serializes an array-type parameter.
    /// </summary>
    /// <param name="parameter">The REST API parameter to serialize.</param>
    /// <param name="argument">The argument value.</param>
    /// <returns>The serialized parameter string.</returns>
    private static string SerializeArrayParameter(RestApiParameter parameter, JsonNode argument)
    {
        if (argument is not JsonArray array)
        {
            throw new ArgumentException(parameter.Name, $"Unexpected argument type '{argument.GetType()} with value '{argument}' for parameter type '{parameter.Type}'.");
        }

        if (parameter.Expand)
        {
            return ArrayParameterValueSerializer.SerializeArrayAsSeparateParameters(parameter.Name, array, delimiter: "&"); //id=1&id=2&id=3
        }

        return $"{parameter.Name}={ArrayParameterValueSerializer.SerializeArrayAsDelimitedValues(array, delimiter: "|")}"; //id=1|2|3
    }
}


===== Functions.OpenApi\Serialization\SimpleStyleParameterSerializer.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Text.Json.Nodes;

namespace Microsoft.SemanticKernel.Plugins.OpenApi;

/// <summary>
/// Serializes REST API parameter of the 'Simple' style.
/// </summary>
internal static class SimpleStyleParameterSerializer
{
    /// <summary>
    /// Serializes a REST API `Simple` style parameter.
    /// </summary>
    /// <param name="parameter">The REST API parameter to serialize.</param>
    /// <param name="argument">The parameter argument.</param>
    /// <returns>The serialized parameter.</returns>
    public static string Serialize(RestApiParameter parameter, JsonNode argument)
    {
        const string ArrayType = "array";

        Verify.NotNull(parameter);
        Verify.NotNull(argument);

        var style = parameter.Style ?? RestApiParameterStyle.Simple;
        if (style != RestApiParameterStyle.Simple)
        {
            throw new NotSupportedException($"Unsupported Rest API parameter style '{parameter.Style}' for parameter '{parameter.Name}'");
        }

        // Serializing parameters of array type.
        if (parameter.Type == ArrayType)
        {
            return SerializeArrayParameter(parameter, argument);
        }

        // Handling parameters where the underlying value is already a string.
        if (argument is JsonValue jsonValue && jsonValue.TryGetValue(out string? value))
        {
            return value;
        }

        // Handling parameters of any arbitrary type by using JSON format without enclosing quotes.
        return argument.ToString().Trim('"');
    }

    /// <summary>
    /// Serializes an array-type parameter.
    /// </summary>
    /// <param name="parameter">The REST API parameter to serialize.</param>
    /// <param name="argument">The argument value.</param>
    /// <returns>The serialized parameter string.</returns>
    private static string SerializeArrayParameter(RestApiParameter parameter, object argument)
    {
        if (argument is not JsonArray array)
        {
            throw new ArgumentException(parameter.Name, $"Unexpected argument type '{argument.GetType()} with value '{argument}' for parameter type '{parameter.Type}'.");
        }

        return ArrayParameterValueSerializer.SerializeArrayAsDelimitedValues(array, delimiter: ",", encode: false); //1,2,3
    }
}


===== Functions.OpenApi\Serialization\SpaceDelimitedStyleParameterSerializer.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Text.Json.Nodes;

namespace Microsoft.SemanticKernel.Plugins.OpenApi;

/// <summary>
/// Serializes REST API parameter of the 'SpaceDelimited' style.
/// </summary>
internal static class SpaceDelimitedStyleParameterSerializer
{
    /// <summary>
    /// Serializes a REST API `SpaceDelimited` style parameter.
    /// </summary>
    /// <param name="parameter">The REST API parameter to serialize.</param>
    /// <param name="argument">The parameter argument.</param>
    /// <returns>The serialized parameter.</returns>
    public static string Serialize(RestApiParameter parameter, JsonNode argument)
    {
        const string ArrayType = "array";

        Verify.NotNull(parameter);

        if (parameter.Style != RestApiParameterStyle.SpaceDelimited)
        {
            throw new NotSupportedException($"Unsupported Rest API parameter style '{parameter.Style}' for parameter '{parameter.Name}'");
        }

        if (parameter.Type != ArrayType)
        {
            throw new NotSupportedException($"Unsupported Rest API parameter type '{parameter.Type}' for parameter '{parameter.Name}'");
        }

        return SerializeArrayParameter(parameter, argument);
    }

    /// <summary>
    /// Serializes an array-type parameter.
    /// </summary>
    /// <param name="parameter">The REST API parameter to serialize.</param>
    /// <param name="argument">The argument value.</param>
    /// <returns>The serialized parameter string.</returns>
    private static string SerializeArrayParameter(RestApiParameter parameter, JsonNode argument)
    {
        if (argument is not JsonArray array)
        {
            throw new ArgumentException(parameter.Name, $"Unexpected argument type '{argument.GetType()} with value '{argument}' for parameter type '{parameter.Type}'.");
        }

        if (parameter.Expand)
        {
            return ArrayParameterValueSerializer.SerializeArrayAsSeparateParameters(parameter.Name, array, delimiter: "&"); //id=1&id=2&id=3
        }

        return $"{parameter.Name}={ArrayParameterValueSerializer.SerializeArrayAsDelimitedValues(array, delimiter: "%20")}"; //id=1%202%203
    }
}


===== Functions.Prompty.UnitTests\PromptyTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.FileProviders;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Connectors.OpenAI;
using Microsoft.SemanticKernel.TextGeneration;
using Xunit;

namespace SemanticKernel.Functions.Prompty.UnitTests;

public sealed class PromptyTests
{
    [Fact]
    public void ChatPromptyTest()
    {
        // Arrange
        Kernel kernel = new();
        var chatPromptyPath = Path.Combine("TestData", "chat.prompty");
        var promptyTemplate = File.ReadAllText(chatPromptyPath);

        // Act
        var kernelFunction = kernel.CreateFunctionFromPrompty(promptyTemplate);

        // Assert
        Assert.Equal("Contoso_Chat_Prompt", kernelFunction.Name);
        Assert.Equal("A retail assistant for Contoso Outdoors products retailer.", kernelFunction.Description);

        // chat prompty does contain input parameters
        Assert.Equal(5, kernelFunction.Metadata.Parameters.Count);
    }

    [Fact]
    public void ChatPromptyShouldSupportCreatingOpenAIExecutionSettings()
    {
        // Arrange
        Kernel kernel = new();
        var chatPromptyPath = Path.Combine("TestData", "chat.prompty");

        // Act
        var kernelFunction = kernel.CreateFunctionFromPromptyFile(chatPromptyPath);

        // Assert
        // kernel function created from chat.prompty should have a single execution setting
        Assert.Single(kernelFunction.ExecutionSettings!);
        Assert.True(kernelFunction.ExecutionSettings!.ContainsKey("default"));

        // Arrange
        var defaultExecutionSetting = kernelFunction.ExecutionSettings["default"];

        // Act
        var executionSettings = OpenAIPromptExecutionSettings.FromExecutionSettings(defaultExecutionSetting);

        // Assert
        Assert.NotNull(executionSettings);
        Assert.Equal("gpt-35-turbo", executionSettings.ModelId);
        Assert.Null(executionSettings.Temperature);
        Assert.Null(executionSettings.TopP);
        Assert.Null(executionSettings.StopSequences);
        Assert.Null(executionSettings.ResponseFormat);
        Assert.Null(executionSettings.TokenSelectionBiases);
        Assert.Null(executionSettings.MaxTokens);
        Assert.Null(executionSettings.Seed);
    }

    [Fact]
    public void ChatPromptyShouldSupportCreatingOpenAIExecutionSettingsWithJsonObject()
    {
        // Arrange
        Kernel kernel = new();
        var chatPromptyPath = Path.Combine("TestData", "chatJsonObject.prompty");

        // Act
        var kernelFunction = kernel.CreateFunctionFromPromptyFile(chatPromptyPath);

        // Assert
        // kernel function created from chat.prompty should have a single execution setting
        Assert.Single(kernelFunction.ExecutionSettings!);
        Assert.True(kernelFunction.ExecutionSettings!.ContainsKey("default"));

        // Arrange
        var defaultExecutionSetting = kernelFunction.ExecutionSettings["default"];

        // Act
        var executionSettings = OpenAIPromptExecutionSettings.FromExecutionSettings(defaultExecutionSetting);

        // Assert
        Assert.NotNull(executionSettings);
        Assert.Equal("gpt-4o", executionSettings.ModelId);
        Assert.Equal(0, executionSettings.Temperature);
        Assert.Equal(1.0, executionSettings.TopP);
        Assert.Null(executionSettings.StopSequences);
        Assert.Equal("{\"type\":\"json_object\"}", executionSettings.ResponseFormat?.ToString());
        Assert.Null(executionSettings.TokenSelectionBiases);
        Assert.Equal(3000, executionSettings.MaxTokens);
        Assert.Null(executionSettings.Seed);
    }

    [Fact]
    public void ItShouldCreateFunctionFromPromptYamlWithNoExecutionSettings()
    {
        // Arrange
        Kernel kernel = new();
        var promptyPath = Path.Combine("TestData", "chatNoExecutionSettings.prompty");

        // Act
        var kernelFunction = kernel.CreateFunctionFromPromptyFile(promptyPath);

        // Assert
        Assert.NotNull(kernelFunction);
        Assert.Equal("prompty_with_no_execution_setting", kernelFunction.Name);
        Assert.Equal("prompty without execution setting", kernelFunction.Description);
        Assert.Single(kernelFunction.Metadata.Parameters);
        Assert.Equal("prompt", kernelFunction.Metadata.Parameters[0].Name);
        Assert.Empty(kernelFunction.ExecutionSettings!);
    }

    [Fact]
    public void ItShouldCreateFunctionFromPromptYamlWithEmbeddedFileProvider()
    {
        // Arrange
        Kernel kernel = new();
        var chatPromptyPath = Path.Combine("TestData", "chat.prompty");
        ManifestEmbeddedFileProvider manifestEmbeddedProvider = new(typeof(PromptyTests).Assembly);

        // Act
        var kernelFunction = kernel.CreateFunctionFromPromptyFile(chatPromptyPath,
            fileProvider: manifestEmbeddedProvider);

        // Assert
        Assert.NotNull(kernelFunction);

        var executionSettings = kernelFunction.ExecutionSettings;
        Assert.Single(executionSettings!);
        Assert.True(executionSettings!.ContainsKey("default"));
    }

    [Fact]
    public void ItShouldCreateFunctionFromPromptYamlWithFileProvider()
    {
        // Arrange
        Kernel kernel = new();
        var currentDirectory = Directory.GetCurrentDirectory();
        var chatPromptyPath = Path.Combine("TestData", "chat.prompty");
        using PhysicalFileProvider fileProvider = new(currentDirectory);

        // Act
        var kernelFunction = kernel.CreateFunctionFromPromptyFile(chatPromptyPath,
            fileProvider);

        // Assert
        Assert.NotNull(kernelFunction);

        var executionSettings = kernelFunction.ExecutionSettings;
        Assert.Single(executionSettings!);
        Assert.True(executionSettings!.ContainsKey("default"));
    }

    [Fact]
    public void ItShouldCreateFunctionFromPromptYamlWithFileInfo()
    {
        // Arrange
        Kernel kernel = new();
        var currentDirectory = Directory.GetCurrentDirectory();
        var chatPromptyPath = Path.Combine("TestData", "chat.prompty");
        using PhysicalFileProvider fileProvider = new(currentDirectory);
        var fileInfo = fileProvider.GetFileInfo(chatPromptyPath);

        // Act
        var kernelFunction = kernel.CreateFunctionFromPromptyFile(
            fileInfo: fileInfo);

        // Assert
        Assert.NotNull(kernelFunction);

        var executionSettings = kernelFunction.ExecutionSettings;
        Assert.Single(executionSettings!);
        Assert.True(executionSettings!.ContainsKey("default"));
    }

    [Fact]
    public void ItFailsToParseAnEmptyHeader()
    {
        Kernel kernel = new();

        Assert.NotNull(kernel.CreateFunctionFromPrompty("""
            ---
            name: MyPrompt
            ---
            Hello
            """));

        Assert.Throws<ArgumentException>(() => kernel.CreateFunctionFromPrompty("""
            ---
            ---
            Hello
            """));

        Assert.Throws<ArgumentException>(() => kernel.CreateFunctionFromPrompty("""
            ---



            ---
            Hello
            """));
    }

    [Theory]
    [InlineData("""
         ---
        name: SomePrompt
        ---
        Abc
        """)]
    [InlineData("""
        ---
        name: SomePrompt
         ---
        Abc
        """)]
    [InlineData("""
        ---a
        name: SomePrompt
        ---
        Abc
        """)]
    [InlineData("""
        ---
        name: SomePrompt
        ---b
        Abc
        """)]
    public void ItRequiresStringSeparatorPlacement(string prompt)
    {
        // Arrange
        Kernel kernel = new();

        // Act / Assert
        Assert.Throws<ArgumentException>(() => kernel.CreateFunctionFromPrompty(prompt));
    }

    [Fact]
    public async Task ItSupportsSeparatorInContentAsync()
    {
        // Arrange
        IKernelBuilder builder = Kernel.CreateBuilder();
        builder.Services.AddSingleton<ITextGenerationService>(_ => new EchoTextGenerationService());
        Kernel kernel = builder.Build();

        // Act
        var kernelFunction = kernel.CreateFunctionFromPrompty("""
            ---
            name: SomePrompt
            description: This is the description.
            ---
            Abc---def
            ---
            Efg
            """);

        // Assert
        Assert.NotNull(kernelFunction);
        Assert.Equal("SomePrompt", kernelFunction.Name);
        Assert.Equal("This is the description.", kernelFunction.Description);
        Assert.Equal("""
            Abc---def
            ---
            Efg
            """, await kernelFunction.InvokeAsync<string>(kernel));
    }

    [Fact]
    public void ItCreatesInputVariablesForSimpleVariables()
    {
        // Arrange
        const string Prompty = """
            ---
            name: MyPrompt
            ---
            {{a}} {{b}} {{c}}
            """;
        string[] expectedVariables = ["a", "b", "c"];

        // Act
        var kernelFunction = new Kernel().CreateFunctionFromPrompty(Prompty);

        // Assert
        Assert.NotNull(kernelFunction);
        Assert.Equal(expectedVariables, kernelFunction.Metadata.Parameters.Select(p => p.Name));
    }

    [Theory]
    [InlineData("""
        ---
        name: MyPrompt
        ---
        {{a}}
        {% for item in items %}
        {% endfor %}
        """)]
    [InlineData("""
        ---
        name: MyPrompt
        ---
        {{a}} {{b}} {{c.d}}
        """)]
    [InlineData("""
        ---
        name: MyPrompt
        ---
        {{a.b}}
        """)]
    [InlineData("""
        ---
        name: MyPrompt
        ---
        {{a}} {{b}} {{a.c}}
        """)]
    public void ItAvoidsCreatingInputVariablesIfAnythingComplex(string prompty)
    {
        // Act
        var kernelFunction = new Kernel().CreateFunctionFromPrompty(prompty);

        // Assert
        Assert.NotNull(kernelFunction);
        Assert.Empty(kernelFunction.Metadata.Parameters.Select(p => p.Name));
    }

    [Fact]
    public void ItCreatesInputVariablesOnlyWhenNoneAreExplicitlySet()
    {
        // Arrange
        const string Prompty = """
            ---
            name: MyPrompt
            inputs:
              question:
                description: What is the color of the sky?
            ---
            {{a}} {{b}} {{c}}
            """;
        string[] expectedVariables = ["question"];

        // Act
        var kernelFunction = new Kernel().CreateFunctionFromPrompty(Prompty);

        // Assert
        Assert.NotNull(kernelFunction);
        Assert.Equal(expectedVariables, kernelFunction.Metadata.Parameters.Select(p => p.Name));
    }

    [Fact]
    public void ItShouldLoadExecutionSettings()
    {
        // Arrange
        const string Prompty = """
            ---
            name: SomePrompt
            description: This is the description.
            model:
                api: chat
                connection:
                    type: azure_openai_beta
                options:
                    logprobs: true
                    top_logprobs: 2
                    top_p: 1.0
                    user: Bob
                    stop_sequences:
                      - END
                      - COMPLETE
                    token_selection_biases:
                      1: 2
                      3: 4
            ---
            Abc---def
            """;

        // Act
        var kernelFunction = new Kernel().CreateFunctionFromPrompty(Prompty);
        PromptExecutionSettings executionSettings = kernelFunction.ExecutionSettings!["default"];

        // Assert
        Assert.NotNull(kernelFunction);
        Assert.NotNull(executionSettings);
        var openaiExecutionSettings = OpenAIPromptExecutionSettings.FromExecutionSettings(executionSettings);
        Assert.NotNull(openaiExecutionSettings);
        Assert.True(openaiExecutionSettings.Logprobs);
        Assert.Equal(2, openaiExecutionSettings.TopLogprobs);
        Assert.Equal(1.0, openaiExecutionSettings.TopP);
        Assert.Equal("Bob", openaiExecutionSettings.User);
        Assert.Equal(["END", "COMPLETE"], openaiExecutionSettings.StopSequences);
        Assert.Equal(new Dictionary<int, int>() { { 1, 2 }, { 3, 4 } }, openaiExecutionSettings.TokenSelectionBiases);
    }

    [Fact]
    public void ItShouldCreateFunctionFromPromptYamlContainingRelativeFileReferences()
    {
        // Arrange
        Kernel kernel = new();
        var promptyPath = Path.Combine("TestData", "relativeFileReference.prompty");

        // Act
        var kernelFunction = kernel.CreateFunctionFromPromptyFile(promptyPath);

        // Assert
        Assert.NotNull(kernelFunction);
        var executionSettings = kernelFunction.ExecutionSettings;
        Assert.Single(executionSettings!);
        Assert.True(executionSettings!.ContainsKey("default"));
        var defaultExecutionSetting = executionSettings["default"];
        Assert.Equal("gpt-35-turbo", defaultExecutionSetting.ModelId);
    }

    [Fact]
    public void ItShouldCreateFunctionFromPromptYamlContainingRelativeFileReferencesWithFileProvider()
    {
        // Arrange
        Kernel kernel = new();
        var currentDirectory = Directory.GetCurrentDirectory();
        var promptyPath = Path.Combine("TestData", "relativeFileReference.prompty");
        using PhysicalFileProvider fileProvider = new(currentDirectory);

        // Act
        var kernelFunction = kernel.CreateFunctionFromPromptyFile(promptyPath,
            fileProvider);

        // Assert
        Assert.NotNull(kernelFunction);
        var executionSettings = kernelFunction.ExecutionSettings;
        Assert.Single(executionSettings!);
        Assert.True(executionSettings!.ContainsKey("default"));
        var defaultExecutionSetting = executionSettings["default"];
        Assert.Equal("gpt-35-turbo", defaultExecutionSetting.ModelId);
    }

    [Fact]
    public void JsonSchemaTest()
    {
        // Arrange
        Kernel kernel = new();
        var chatPromptyPath = Path.Combine("TestData", "chat.prompty");
        var promptyTemplate = File.ReadAllText(chatPromptyPath);

        // Act
        var kernelFunction = kernel.CreateFunctionFromPrompty(promptyTemplate);

        // Assert
        var firstName = kernelFunction.Metadata.Parameters.First(p => p.Name == "firstName");
        Assert.NotNull(firstName);
        Assert.NotNull(firstName.Schema);
        Assert.Equal("{\"type\":\"string\"}", firstName.Schema.ToString());
        var answer = kernelFunction.Metadata.Parameters.First(p => p.Name == "answer");
        Assert.NotNull(answer);
        Assert.NotNull(answer.Schema);
        Assert.Equal("{\"type\":\"object\",\"properties\":{\"answer\":{\"type\":\"string\"},\"citations\":{\"type\":\"array\",\"items\":{\"type\":\"string\",\"format\":\"uri\"}}},\"required\":[\"answer\",\"citations\"],\"additionalProperties\":false}", answer.Schema.ToString());
        var other = kernelFunction.Metadata.Parameters.First(p => p.Name == "other");
        Assert.NotNull(other);
        Assert.NotNull(other.Schema);
        Assert.Equal("{\"type\":\"object\",\"properties\":{\"answer\":{\"type\":\"string\"},\"citations\":{\"type\":\"array\",\"items\":{\"type\":\"string\",\"format\":\"uri\"}}},\"required\":[\"answer\",\"citations\"],\"additionalProperties\":\"false\"}", other.Schema.ToString());
    }

    private sealed class EchoTextGenerationService : ITextGenerationService
    {
        public IReadOnlyDictionary<string, object?> Attributes { get; } = new Dictionary<string, object?>();

        public Task<IReadOnlyList<TextContent>> GetTextContentsAsync(string prompt, PromptExecutionSettings? executionSettings = null, Kernel? kernel = null, CancellationToken cancellationToken = default) =>
            Task.FromResult<IReadOnlyList<TextContent>>([new TextContent(prompt)]);

        public async IAsyncEnumerable<StreamingTextContent> GetStreamingTextContentsAsync(string prompt, PromptExecutionSettings? executionSettings = null, Kernel? kernel = null, [EnumeratorCancellation] CancellationToken cancellationToken = default)
        {
            await Task.Delay(0, cancellationToken);
            yield return new StreamingTextContent(prompt);
        }
    }
}


===== Functions.Prompty\AssemblyInfo.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Diagnostics.CodeAnalysis;

// This assembly is currently experimental.
[assembly: Experimental("SKEXP0040")]


===== Functions.Prompty\Extensions\PromptyKernelExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.IO;
using Microsoft.Extensions.FileProviders;
using Microsoft.SemanticKernel.Prompty;

namespace Microsoft.SemanticKernel;

/// <summary>
/// Provides extension methods for creating <see cref="KernelFunction"/>s from the Prompty template format.
/// </summary>
public static class PromptyKernelExtensions
{
    /// <summary>
    /// Create a <see cref="KernelFunction"/> from a prompty template file.
    /// </summary>
    /// <param name="kernel">The <see cref="Kernel"/> containing services, plugins, and other state for use throughout the operation.</param>
    /// <param name="promptyFilePath">Path to the file containing the Prompty representation of a prompt based <see cref="KernelFunction"/>.</param>
    /// <param name="promptTemplateFactory">
    /// The <see cref="IPromptTemplateFactory"/> to use when interpreting the prompt template configuration into a <see cref="IPromptTemplate"/>.
    /// If null, a <see cref="AggregatorPromptTemplateFactory"/> will be used with support for Liquid and Handlebars prompt templates.
    /// </param>
    /// <returns>The created <see cref="KernelFunction"/>.</returns>
    /// <exception cref="ArgumentNullException"><paramref name="kernel"/> is null.</exception>
    /// <exception cref="ArgumentNullException"><paramref name="promptyFilePath"/> is null.</exception>
    /// <exception cref="ArgumentException"><paramref name="promptyFilePath"/> is empty or composed entirely of whitespace.</exception>
    public static KernelFunction CreateFunctionFromPromptyFile(
        this Kernel kernel,
        string promptyFilePath,
        IPromptTemplateFactory? promptTemplateFactory = null)
    {
        Verify.NotNull(kernel);
        Verify.NotNullOrWhiteSpace(promptyFilePath);

        var promptyTemplate = File.ReadAllText(promptyFilePath);
        return kernel.CreateFunctionFromPrompty(promptyTemplate, promptTemplateFactory, promptyFilePath);
    }

    /// <summary>
    /// Create a <see cref="KernelFunction"/> from a prompty template.
    /// </summary>
    /// <param name="kernel">The <see cref="Kernel"/> containing services, plugins, and other state for use throughout the operation.</param>
    /// <param name="promptyTemplate">Prompty representation of a prompt-based <see cref="KernelFunction"/>.</param>
    /// <param name="promptTemplateFactory">
    /// The <see cref="IPromptTemplateFactory"/> to use when interpreting the prompt template configuration into a <see cref="IPromptTemplate"/>.
    /// If null, a <see cref="AggregatorPromptTemplateFactory"/> will be used with support for Liquid and Handlebars prompt templates.
    /// </param>
    /// <param name="promptyFilePath">Optional: File path to the prompty file.</param>
    /// <returns>The created <see cref="KernelFunction"/>.</returns>
    /// <exception cref="ArgumentNullException"><paramref name="kernel"/> is null.</exception>
    /// <exception cref="ArgumentNullException"><paramref name="promptyTemplate"/> is null.</exception>
    /// <exception cref="ArgumentException"><paramref name="promptyTemplate"/> is empty or composed entirely of whitespace.</exception>
    public static KernelFunction CreateFunctionFromPrompty(
        this Kernel kernel,
        string promptyTemplate,
        IPromptTemplateFactory? promptTemplateFactory = null,
        string? promptyFilePath = null)
    {
        Verify.NotNull(kernel);
        Verify.NotNullOrWhiteSpace(promptyTemplate);

        var promptTemplateConfig = KernelFunctionPrompty.ToPromptTemplateConfig(promptyTemplate, promptyFilePath);

        return KernelFunctionFactory.CreateFromPrompt(
            promptTemplateConfig,
            promptTemplateFactory ?? KernelFunctionPrompty.s_defaultTemplateFactory,
            kernel.LoggerFactory);
    }

    /// <summary>
    /// Create a <see cref="KernelFunction"/> from a prompty template file.
    /// </summary>
    /// <param name="kernel">The <see cref="Kernel"/> containing services, plugins, and other state for use throughout the operation.</param>
    /// <param name="promptyFilePath">Path to the file containing the Prompty representation of a prompt based <see cref="KernelFunction"/>.</param>
    /// <param name="fileProvider">The representation of the file system to use to retrieve the prompty file. Defaults to <see cref="PhysicalFileProvider"/> scoped to the current directory.</param>
    /// <param name="promptTemplateFactory">
    /// The <see cref="IPromptTemplateFactory"/> to use when interpreting the prompt template configuration into a <see cref="IPromptTemplate"/>.
    /// If null, a <see cref="AggregatorPromptTemplateFactory"/> will be used with support for Liquid and Handlebars prompt templates.
    /// </param>
    /// <returns>The created <see cref="KernelFunction"/>.</returns>
    /// <exception cref="ArgumentNullException"><paramref name="kernel"/> is null.</exception>
    /// <exception cref="ArgumentNullException"><paramref name="promptyFilePath"/> is null.</exception>
    /// <exception cref="ArgumentException"><paramref name="promptyFilePath"/> is empty or composed entirely of whitespace.</exception>
    public static KernelFunction CreateFunctionFromPromptyFile(
        this Kernel kernel,
        string promptyFilePath,
        IFileProvider fileProvider,
        IPromptTemplateFactory? promptTemplateFactory = null)
    {
        Verify.NotNull(kernel);
        Verify.NotNullOrWhiteSpace(promptyFilePath);
        Verify.NotNull(fileProvider);

        var fileInfo = fileProvider.GetFileInfo(promptyFilePath);
        return CreateFunctionFromPromptyFile(kernel, fileInfo, promptTemplateFactory);
    }

    /// <summary>
    /// Create a <see cref="KernelFunction"/> from a prompty template file.
    /// </summary>
    /// <param name="kernel">The <see cref="Kernel"/> containing services, plugins, and other state for use throughout the operation.</param>
    /// <param name="fileInfo">The file containing the Prompty representation of a prompt based <see cref="KernelFunction"/>.</param>
    /// <param name="promptTemplateFactory">
    /// The <see cref="IPromptTemplateFactory"/> to use when interpreting the prompt template configuration into a <see cref="IPromptTemplate"/>.
    /// If null, a <see cref="AggregatorPromptTemplateFactory"/> will be used with support for Liquid and Handlebars prompt templates.
    /// </param>
    /// <returns>The created <see cref="KernelFunction"/>.</returns>
    /// <exception cref="ArgumentNullException"><paramref name="kernel"/> is null.</exception>
    /// <exception cref="ArgumentNullException"><paramref name="fileInfo"/> is null.</exception>
    /// <exception cref="ArgumentException"><paramref name="fileInfo"/> path is not found.</exception>
    public static KernelFunction CreateFunctionFromPromptyFile(
        this Kernel kernel,
        IFileInfo fileInfo,
        IPromptTemplateFactory? promptTemplateFactory = null)
    {
        Verify.NotNull(kernel);
        Verify.NotNull(fileInfo);
        Verify.True(fileInfo.Exists, $"The file '{fileInfo.PhysicalPath}' doesn't exist.");

        using StreamReader reader = new(fileInfo.CreateReadStream());
        var promptyTemplate = reader.ReadToEnd();
        return kernel.CreateFunctionFromPrompty(promptyTemplate, promptTemplateFactory, fileInfo.PhysicalPath);
    }
}


===== Functions.Prompty\KernelFunctionPrompty.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.Json;
using Microsoft.Extensions.Logging;
using Microsoft.SemanticKernel.PromptTemplates.Handlebars;
using Microsoft.SemanticKernel.PromptTemplates.Liquid;
using PromptyCore = Prompty.Core;

namespace Microsoft.SemanticKernel.Prompty;

/// <summary>
/// Factory methods for creating <seealso cref="KernelFunction"/> instances.
/// </summary>
public static class KernelFunctionPrompty
{
    /// <summary>Default template factory to use when none is provided.</summary>
    internal static readonly AggregatorPromptTemplateFactory s_defaultTemplateFactory =
        new(new LiquidPromptTemplateFactory(), new HandlebarsPromptTemplateFactory(), new KernelPromptTemplateFactory());

    /// <summary>
    /// Creates a <see cref="KernelFunction"/> instance for a prompt function using the specified markdown text.
    /// </summary>
    /// <param name="text">YAML representation of the <see cref="PromptTemplateConfig"/> to use to create the prompt function.</param>
    /// <param name="promptTemplateFactory">
    /// The <see cref="IPromptTemplateFactory"/> to use when interpreting the prompt template configuration into a <see cref="IPromptTemplate"/>.
    /// If null, a default factory will be used.
    /// </param>
    /// <param name="loggerFactory">The <see cref="ILoggerFactory"/> to use for logging. If null, no logging will be performed.</param>
    /// <returns>The created <see cref="KernelFunction"/>.</returns>
    public static KernelFunction FromPrompty(
        string text,
        IPromptTemplateFactory? promptTemplateFactory = null,
        ILoggerFactory? loggerFactory = null)
    {
        PromptTemplateConfig promptTemplateConfig = ToPromptTemplateConfig(text);

        return KernelFunctionFactory.CreateFromPrompt(
            promptTemplateConfig,
            promptTemplateFactory ?? s_defaultTemplateFactory,
            loggerFactory);
    }

    /// <summary>
    /// Create a <see cref="PromptTemplateConfig"/> from a prompty template.
    /// </summary>
    /// <param name="promptyTemplate">Prompty representation of a prompt-based <see cref="KernelFunction"/>.</param>
    /// <param name="promptyFilePath">Optional: File path to the prompty file.</param>
    /// <returns>The created <see cref="PromptTemplateConfig"/>.</returns>
    /// <exception cref="ArgumentNullException"><paramref name="promptyTemplate"/> is null.</exception>
    /// <exception cref="ArgumentException"><paramref name="promptyTemplate"/> is empty or composed entirely of whitespace.</exception>
    public static PromptTemplateConfig ToPromptTemplateConfig(string promptyTemplate, string? promptyFilePath = null)
    {
        Verify.NotNullOrWhiteSpace(promptyTemplate);

        Dictionary<string, object> globalConfig = [];
        PromptyCore.Prompty prompty = PromptyCore.Prompty.Load(promptyTemplate, globalConfig, promptyFilePath);

        var promptTemplateConfig = new PromptTemplateConfig
        {
            Name = prompty.Name,
            Description = prompty.Description,
            Template = prompty.Content.ToString() ?? string.Empty,
        };

        PromptExecutionSettings? defaultExecutionSetting = null;
        if (prompty.Model?.Id is not null || prompty.Model?.Connection?.ServiceId is not null || prompty.Model?.Options?.Count > 0)
        {
            defaultExecutionSetting = new PromptExecutionSettings()
            {
                ModelId = prompty.Model.Id,
                ServiceId = prompty.Model.Connection?.ServiceId,
                ExtensionData = prompty.Model.Options,
            };
            promptTemplateConfig.AddExecutionSettings(defaultExecutionSetting);
        }

        // Add input and output variables.
        if (prompty.Inputs is not null)
        {
            foreach (var kvp in prompty.Inputs)
            {
                var input = kvp.Value;
                promptTemplateConfig.InputVariables.Add(new()
                {
                    Name = kvp.Key,
                    Default = input.Default,
                    IsRequired = input.Required,
                    Description = input.Description,
                    AllowDangerouslySetContent = !input.Strict,
                    JsonSchema = ToJsonSchema(input.JsonSchema),
                });
            }
        }
        if (prompty.Outputs is not null)
        {
            // PromptTemplateConfig supports only a single output variable. If the prompty template
            // contains one and only one, use it. Otherwise, ignore any outputs.
            if (prompty.Outputs.Count == 1)
            {
                var output = prompty.Outputs.Values.First();
                promptTemplateConfig.OutputVariable = new()
                {
                    Description = output.Description,
                    JsonSchema = ToJsonSchema(output.JsonSchema),
                };
            }
        }

        // Update template format. If not provided, use Liquid as default.
        promptTemplateConfig.TemplateFormat = prompty.Template?.Format ?? LiquidPromptTemplateFactory.LiquidTemplateFormat;

        return promptTemplateConfig;
    }

    #region private
    private static string? ToJsonSchema(object? input)
    {
        if (input is null)
        {
            return null;
        }

        if (input is string str)
        {
            return str;
        }

        return JsonSerializer.Serialize(input);
    }
    #endregion
}


===== Functions.UnitTests\Grpc\Extensions\GrpcOperationExtensionsTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Linq;
using Microsoft.SemanticKernel.Plugins.Grpc.Model;
using Xunit;

namespace SemanticKernel.Functions.UnitTests.Grpc;

public class GrpcOperationExtensionsTests
{
    private readonly GrpcOperationDataContractType _request;

    private readonly GrpcOperationDataContractType _response;

    private readonly GrpcOperation _operation;

    public GrpcOperationExtensionsTests()
    {
        this._request = new GrpcOperationDataContractType("fake-name", []);

        this._response = new GrpcOperationDataContractType("fake-name", []);

        this._operation = new GrpcOperation("fake-service-name", "fake-operation-name", this._response, this._response);
    }

    [Fact]
    public void ThereShouldBeAddressParameter()
    {
        // Act
        var parameters = GrpcOperation.CreateParameters();

        // Assert
        Assert.NotNull(parameters);
        Assert.NotEmpty(parameters);

        var addressParameter = parameters.SingleOrDefault(p => p.Name == "address");
        Assert.NotNull(addressParameter);
        Assert.Equal("Address for gRPC channel to use.", addressParameter.Description);
    }

    [Fact]
    public void ThereShouldBePayloadParameter()
    {
        // Act
        var parameters = GrpcOperation.CreateParameters();

        // Assert
        Assert.NotNull(parameters);
        Assert.NotEmpty(parameters);

        var payloadParameter = parameters.SingleOrDefault(p => p.Name == "payload");
        Assert.NotNull(payloadParameter);
        Assert.Equal("gRPC request message.", payloadParameter.Description);
    }
}


===== Functions.UnitTests\Grpc\GrpcRunnerTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Net.Mime;
using System.Text;
using System.Text.Json;
using System.Text.Json.Nodes;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Plugins.Grpc;
using Microsoft.SemanticKernel.Plugins.Grpc.Model;
using Xunit;

namespace SemanticKernel.Functions.UnitTests.Grpc;

public sealed class GrpcRunnerTests : IDisposable
{
    /// <summary>
    /// An instance of HttpMessageHandlerStub class used to get access to various properties of HttpRequestMessage sent by HTTP client.
    /// </summary>
    private readonly HttpMessageHandlerStub _httpMessageHandlerStub;

    /// <summary>
    /// An instance of HttpClient class used by the tests.
    /// </summary>
    private readonly HttpClient _httpClient;

    /// <summary>
    /// Creates an instance of a <see cref="GrpcRunnerTests"/> class.
    /// </summary>
    public GrpcRunnerTests()
    {
        this._httpMessageHandlerStub = new HttpMessageHandlerStub();

        this._httpClient = new HttpClient(this._httpMessageHandlerStub);
    }

    [Fact]
    public async Task ShouldUseAddressProvidedInGrpcOperationAsync()
    {
        // Arrange
        this._httpMessageHandlerStub.ResponseToReturn.Version = new Version(2, 0);
        this._httpMessageHandlerStub.ResponseToReturn.Content = new ByteArrayContent([0, 0, 0, 0, 14, 10, 12, 72, 101, 108, 108, 111, 32, 97, 117, 116, 104, 111, 114]);
        this._httpMessageHandlerStub.ResponseToReturn.Content.Headers.Add("Content-Type", "application/grpc");
        this._httpMessageHandlerStub.ResponseToReturn.TrailingHeaders.Add("grpc-status", "0");

        var requestMetadata = new GrpcOperationDataContractType("greet.HelloRequest", [new("name", 1, "TYPE_STRING")]);

        var responseMetadata = new GrpcOperationDataContractType("greet.HelloReply", [new("message", 1, "TYPE_STRING")]);

        var sut = new GrpcOperationRunner(this._httpClient);

        var operation = new GrpcOperation("Greeter", "SayHello", requestMetadata, responseMetadata)
        {
            Package = "greet",
            Address = "https://fake-random-test-host"
        };

        var arguments = new KernelArguments
        {
            { "payload", JsonSerializer.Serialize(new { name = "author" }) }
        };

        // Act
        var result = await sut.RunAsync(operation, arguments);

        // Assert
        Assert.NotNull(this._httpMessageHandlerStub.RequestUri);
        Assert.Equal("https://fake-random-test-host/greet.Greeter/SayHello", this._httpMessageHandlerStub.RequestUri.AbsoluteUri);
    }

    [Fact]
    public async Task ShouldUseAddressOverrideFromArgumentsAsync()
    {
        // Arrange
        this._httpMessageHandlerStub.ResponseToReturn.Version = new Version(2, 0);
        this._httpMessageHandlerStub.ResponseToReturn.Content = new ByteArrayContent([0, 0, 0, 0, 14, 10, 12, 72, 101, 108, 108, 111, 32, 97, 117, 116, 104, 111, 114]);
        this._httpMessageHandlerStub.ResponseToReturn.Content.Headers.Add("Content-Type", "application/grpc");
        this._httpMessageHandlerStub.ResponseToReturn.TrailingHeaders.Add("grpc-status", "0");

        var requestMetadata = new GrpcOperationDataContractType("greet.HelloRequest", [new("name", 1, "TYPE_STRING")]);

        var responseMetadata = new GrpcOperationDataContractType("greet.HelloReply", [new("message", 1, "TYPE_STRING")]);

        var sut = new GrpcOperationRunner(this._httpClient);

        var operation = new GrpcOperation("Greeter", "SayHello", requestMetadata, responseMetadata)
        {
            Package = "greet",
            Address = "https://fake-random-test-host"
        };

        var arguments = new KernelArguments
        {
            { "payload", JsonSerializer.Serialize(new { name = "author" }) },
            { "address", "https://fake-random-test-host-from-args" }
        };

        // Act
        var result = await sut.RunAsync(operation, arguments);

        // Assert
        Assert.NotNull(this._httpMessageHandlerStub.RequestUri);
        Assert.Equal("https://fake-random-test-host-from-args/greet.Greeter/SayHello", this._httpMessageHandlerStub.RequestUri.AbsoluteUri);
    }

    [Fact]
    public async Task ShouldRunOperationsWithSimpleDataContractAsync()
    {
        // Arrange

        //The byte array is copied from intercepted gRPC call to a local gPRC service created using this guide - https://learn.microsoft.com/en-us/aspnet/core/tutorials/grpc/grpc-start?view=aspnetcore-7.0&tabs=visual-studio
        //since there's no simple way to obtain/create serialized content of gRPC response.
        this._httpMessageHandlerStub.ResponseToReturn.Content = new ByteArrayContent([0, 0, 0, 0, 14, 10, 12, 72, 101, 108, 108, 111, 32, 97, 117, 116, 104, 111, 114]);
        this._httpMessageHandlerStub.ResponseToReturn.Version = new Version(2, 0);
        this._httpMessageHandlerStub.ResponseToReturn.Content.Headers.Add("Content-Type", "application/grpc");
        this._httpMessageHandlerStub.ResponseToReturn.TrailingHeaders.Add("grpc-status", "0");

        var requestMetadata = new GrpcOperationDataContractType("greet.HelloRequest", [new("name", 1, "TYPE_STRING")]);

        var responseMetadata = new GrpcOperationDataContractType("greet.HelloReply", [new("message", 1, "TYPE_STRING")]);

        var sut = new GrpcOperationRunner(this._httpClient);

        var operation = new GrpcOperation("Greeter", "SayHello", requestMetadata, responseMetadata)
        {
            Package = "greet",
            Address = "https://fake-random-test-host"
        };

        var arguments = new KernelArguments
        {
            { "payload", JsonSerializer.Serialize(new { name = "author" }) }
        };

        // Act
        var result = await sut.RunAsync(operation, arguments);

        // Assert
        Assert.NotNull(result);

        var contentProperty = result["content"]?.ToString();
        Assert.NotNull(contentProperty);

        var jsonContent = JsonNode.Parse(contentProperty);
        Assert.NotNull(jsonContent);

        var messageProperty = jsonContent["message"]?.ToString();
        Assert.Equal("Hello author", messageProperty);

        var contentTypeProperty = result["contentType"]?.ToString();
        Assert.Equal("application/json; charset=utf-8", contentTypeProperty);

        //The byte array is copied from intercepted gRPC call to a local gPRC service created using this guide - https://learn.microsoft.com/en-us/aspnet/core/tutorials/grpc/grpc-start?view=aspnetcore-7.0&tabs=visual-studio
        //since there's no simple way to obtain/create serialized content of gRPC request.
        Assert.Equal(new byte[] { 0, 0, 0, 0, 8, 10, 6, 97, 117, 116, 104, 111, 114 }, this._httpMessageHandlerStub.RequestContent);
    }

    /// <summary>
    /// Disposes resources used by this class.
    /// </summary>
    public void Dispose()
    {
        this._httpMessageHandlerStub.Dispose();

        this._httpClient.Dispose();
    }

    private sealed class HttpMessageHandlerStub : DelegatingHandler
    {
        public HttpRequestHeaders? RequestHeaders { get; private set; }

        public HttpContentHeaders? ContentHeaders { get; private set; }

        public byte[]? RequestContent { get; private set; }

        public Uri? RequestUri { get; private set; }

        public HttpMethod? Method { get; private set; }

        public HttpResponseMessage ResponseToReturn { get; set; }

        public HttpMessageHandlerStub()
        {
            this.ResponseToReturn = new HttpResponseMessage(System.Net.HttpStatusCode.OK)
            {
                Content = new StringContent("{}", Encoding.UTF8, MediaTypeNames.Application.Json)
            };
        }

        protected override async Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
        {
            this.Method = request.Method;
            this.RequestUri = request.RequestUri;
            this.RequestHeaders = request.Headers;
            this.RequestContent = request.Content is null ? null : await request.Content.ReadAsByteArrayAsync(cancellationToken);
            this.ContentHeaders = request.Content?.Headers;

            return await Task.FromResult(this.ResponseToReturn);
        }
    }
}


===== Functions.UnitTests\Grpc\Protobuf\ProtoDocumentParserV30Tests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.IO;
using System.Linq;
using Microsoft.SemanticKernel.Plugins.Grpc.Protobuf;
using SemanticKernel.Functions.UnitTests.Grpc.Protobuf.TestPlugins;
using Xunit;

namespace SemanticKernel.Functions.UnitTests.Grpc.Protobuf;

public sealed class ProtoDocumentParserV30Tests
{
    /// <summary>
    /// System under test - an instance of ProtoDocumentParser class.
    /// </summary>
    private readonly ProtoDocumentParser _sut;

    /// <summary>
    /// .proto document stream.
    /// </summary>
    private readonly Stream _protoDocument;

    /// <summary>
    /// Creates an instance of a <see cref="ProtoDocumentParserV30Tests"/> class.
    /// </summary>
    public ProtoDocumentParserV30Tests()
    {
        this._protoDocument = ResourcePluginsProvider.LoadFromResource("protoV3.proto");

        this._sut = new ProtoDocumentParser();
    }

    [Fact]
    public void ShouldCreateOperationsForAllServicesInProtoDocument()
    {
        // Act
        var operations = this._sut.Parse(this._protoDocument, "fake_name");

        // Assert
        Assert.NotNull(operations);
        Assert.Equal(2, operations.Count);

        var greeterServiceOperations = operations.Where(o => o.ServiceName == "Greeter");
        Assert.NotNull(greeterServiceOperations);
        Assert.Contains(greeterServiceOperations, o => o.Name == "SayHello");

        var farewellerServiceOperations = operations.Where(o => o.ServiceName == "Fareweller");
        Assert.NotNull(farewellerServiceOperations);
        Assert.Contains(farewellerServiceOperations, o => o.Name == "SayGoodbye");
    }

    [Fact]
    public void ShouldParseSimpleOperationRequestDataContract()
    {
        // Act
        var operations = this._sut.Parse(this._protoDocument, "fake_name");

        // Assert
        Assert.NotNull(operations);

        var greeterServiceOperations = operations.Where(o => o.ServiceName == "Greeter");
        Assert.NotNull(greeterServiceOperations);

        var sayHelloOperation = greeterServiceOperations.SingleOrDefault(o => o.Name == "SayHello");
        Assert.NotNull(sayHelloOperation);

        var request = sayHelloOperation.Request;
        Assert.NotNull(request);

        Assert.Equal("greet.HelloRequest", request.Name);
        Assert.NotNull(request.Fields);

        var nameField = request.Fields.SingleOrDefault(f => f.Name == "name");
        Assert.NotNull(nameField);

        Assert.Equal(1, nameField.Number);
        Assert.Equal("TYPE_STRING", nameField.TypeName);
    }

    [Fact]
    public void ShouldParseSimpleOperationResponseDataContract()
    {
        // Act
        var operations = this._sut.Parse(this._protoDocument, "fake_name");

        // Assert
        Assert.NotNull(operations);

        var greeterServiceOperations = operations.Where(o => o.ServiceName == "Greeter");
        Assert.NotNull(greeterServiceOperations);

        var sayHelloOperation = greeterServiceOperations.SingleOrDefault(o => o.Name == "SayHello");
        Assert.NotNull(sayHelloOperation);

        var response = sayHelloOperation.Response;
        Assert.NotNull(response);

        Assert.Equal("greet.HelloReply", response.Name);
        Assert.NotNull(response.Fields);

        var messageField = response.Fields.SingleOrDefault(f => f.Name == "message");
        Assert.NotNull(messageField);

        Assert.Equal(1, messageField.Number);
        Assert.Equal("TYPE_STRING", messageField.TypeName);
    }
}


===== Functions.UnitTests\Grpc\Protobuf\TestPlugins\ResourcePluginsProvider.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.IO;
using System.Resources;

namespace SemanticKernel.Functions.UnitTests.Grpc.Protobuf.TestPlugins;

internal static class ResourcePluginsProvider
{
    /// <summary>
    /// Loads .proto file from assembly resource.
    /// </summary>
    /// <param name="resourceName">The resource name.</param>
    /// <returns>The OpenAPI document resource stream.</returns>
    public static Stream LoadFromResource(string resourceName)
    {
        var type = typeof(ResourcePluginsProvider);

        return type.Assembly.GetManifestResourceStream(type, resourceName) ??
            throw new MissingManifestResourceException($"Unable to load gRPC plugin from assembly resource '{resourceName}'.");
    }
}


===== Functions.UnitTests\OpenApi\Extensions\CopilotAgentPluginKernelExtensionsTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.IO;
using System.Threading.Tasks;
using Microsoft.SemanticKernel;
using Xunit;

namespace SemanticKernel.Functions.UnitTests.OpenApi;

public sealed class CopilotAgentPluginKernelExtensionsTests
{
    [Fact]
    public async Task ItCanImportPluginFromCopilotAgentPluginAsync()
    {
        // Act
        var kernel = new Kernel();
        var testPluginsDir = Path.Combine(Directory.GetCurrentDirectory(), "OpenApi", "TestPlugins");
        var manifestFilePath = Path.Combine(testPluginsDir, "messages-apiplugin.json");

        // Arrange
        var plugin = await kernel.ImportPluginFromCopilotAgentPluginAsync("MessagesPlugin", manifestFilePath);

        // Assert
        Assert.NotNull(plugin);
        Assert.Equal(2, plugin.FunctionCount);
        Assert.Equal(411, plugin["me_sendMail"].Description.Length);
        Assert.Equal(1000, plugin["me_ListMessages"].Description.Length);
    }
}


===== Functions.UnitTests\OpenApi\Extensions\OpenApiKernelExtensionsTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Net.Mime;
using System.Text;
using System.Threading.Tasks;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Plugins.OpenApi;
using SemanticKernel.Functions.UnitTests.OpenApi.TestPlugins;
using Xunit;

namespace SemanticKernel.Functions.UnitTests.OpenApi;

public sealed class OpenApiKernelExtensionsTests : IDisposable
{
    /// <summary>
    /// System under test - an instance of OpenApiDocumentParser class.
    /// </summary>
    private readonly OpenApiDocumentParser _sut;

    /// <summary>
    /// OpenAPI function execution parameters.
    /// </summary>
    private readonly OpenApiFunctionExecutionParameters _executionParameters;

    /// <summary>
    /// OpenAPI document stream.
    /// </summary>
    private readonly Stream _openApiDocument;

    /// <summary>
    /// Kernel instance.
    /// </summary>
    private readonly Kernel _kernel;

    /// <summary>
    /// Creates an instance of a <see cref="OpenApiKernelExtensionsTests"/> class.
    /// </summary>
    public OpenApiKernelExtensionsTests()
    {
        this._kernel = new Kernel();

        this._executionParameters = new OpenApiFunctionExecutionParameters() { EnableDynamicPayload = false };

        this._openApiDocument = ResourcePluginsProvider.LoadFromResource("documentV2_0.json");

        this._sut = new OpenApiDocumentParser();
    }

    [Fact]
    public async Task ItCanIncludeOpenApiOperationParameterTypesIntoFunctionParametersViewAsync()
    {
        // Act
        var plugin = await this._kernel.ImportPluginFromOpenApiAsync("fakePlugin", this._openApiDocument, this._executionParameters);

        // Assert
        var setSecretFunction = plugin["SetSecret"];
        Assert.NotNull(setSecretFunction);

        var functionView = setSecretFunction.Metadata;
        Assert.NotNull(functionView);

        var secretNameParameter = functionView.Parameters.First(p => p.Name == "secret_name");
        Assert.NotNull(secretNameParameter.Schema);
        Assert.Equal("string", secretNameParameter.Schema!.RootElement.GetProperty("type").GetString());

        var apiVersionParameter = functionView.Parameters.First(p => p.Name == "api_version");
        Assert.Equal("string", apiVersionParameter.Schema!.RootElement.GetProperty("type").GetString());

        var payloadParameter = functionView.Parameters.First(p => p.Name == "payload");
        Assert.NotNull(payloadParameter.Schema);
        Assert.Equal("object", payloadParameter.Schema!.RootElement.GetProperty("type").GetString());
    }

    [Theory]
    [InlineData(true)]
    [InlineData(false)]
    public async Task ItUsesServerUrlOverrideIfProvidedAsync(bool removeServersProperty)
    {
        // Arrange
        const string DocumentUri = "http://localhost:3001/openapi.json";
        const string ServerUrlOverride = "https://server-override.com/";

        var openApiDocument = ResourcePluginsProvider.LoadFromResource("documentV3_0.json");

        if (removeServersProperty)
        {
            openApiDocument = OpenApiTestHelper.ModifyOpenApiDocument(openApiDocument, (doc) =>
            {
                doc.Remove("servers");
            });
        }

        using var messageHandlerStub = new HttpMessageHandlerStub(openApiDocument);
        using var httpClient = new HttpClient(messageHandlerStub, false);

        this._executionParameters.HttpClient = httpClient;
        this._executionParameters.ServerUrlOverride = new Uri(ServerUrlOverride);

        var arguments = this.GetFakeFunctionArguments();

        // Act
        var plugin = await this._kernel.ImportPluginFromOpenApiAsync("fakePlugin", new Uri(DocumentUri), this._executionParameters);
        var setSecretFunction = plugin["SetSecret"];

        messageHandlerStub.ResetResponse();

        var result = await this._kernel.InvokeAsync(setSecretFunction, arguments);

        // Assert
        Assert.NotNull(messageHandlerStub.RequestUri);
        Assert.StartsWith(ServerUrlOverride, messageHandlerStub.RequestUri.AbsoluteUri, StringComparison.Ordinal);
    }

    [Theory]
    [InlineData("documentV2_0.json")]
    [InlineData("documentV3_0.json")]
    public async Task ItUsesServerUrlFromOpenApiDocumentAsync(string documentFileName)
    {
        // Arrange
        const string DocumentUri = "http://localhost:3001/openapi.json";
        const string ServerUrlFromDocument = "https://my-key-vault.vault.azure.net/";

        var openApiDocument = ResourcePluginsProvider.LoadFromResource(documentFileName);

        using var messageHandlerStub = new HttpMessageHandlerStub(openApiDocument);
        using var httpClient = new HttpClient(messageHandlerStub, false);

        this._executionParameters.HttpClient = httpClient;

        var arguments = this.GetFakeFunctionArguments();

        // Act
        var plugin = await this._kernel.ImportPluginFromOpenApiAsync("fakePlugin", new Uri(DocumentUri), this._executionParameters);
        var setSecretFunction = plugin["SetSecret"];

        messageHandlerStub.ResetResponse();

        var result = await this._kernel.InvokeAsync(setSecretFunction, arguments);

        // Assert
        Assert.NotNull(messageHandlerStub.RequestUri);
        Assert.StartsWith(ServerUrlFromDocument, messageHandlerStub.RequestUri.AbsoluteUri, StringComparison.Ordinal);
    }

    [Theory]
    [InlineData("http://localhost:3001/openapi.json", "http://localhost:3001/", "documentV2_0.json")]
    [InlineData("http://localhost:3001/openapi.json", "http://localhost:3001/", "documentV3_0.json")]
    [InlineData("https://api.example.com/openapi.json", "https://api.example.com/", "documentV2_0.json")]
    [InlineData("https://api.example.com/openapi.json", "https://api.example.com/", "documentV3_0.json")]
    [SuppressMessage("Design", "CA1054:URI-like parameters should not be strings", Justification = "Required for test data.")]
    public async Task ItUsesOpenApiDocumentHostUrlWhenServerUrlIsNotProvidedAsync(string documentUri, string expectedServerUrl, string documentFileName)
    {
        // Arrange
        var openApiDocument = ResourcePluginsProvider.LoadFromResource(documentFileName);

        using var content = OpenApiTestHelper.ModifyOpenApiDocument(openApiDocument, (doc) =>
        {
            doc.Remove("servers");
            doc.Remove("host");
            doc.Remove("schemes");
        });

        using var messageHandlerStub = new HttpMessageHandlerStub(content);
        using var httpClient = new HttpClient(messageHandlerStub, false);

        this._executionParameters.HttpClient = httpClient;

        var arguments = this.GetFakeFunctionArguments();

        // Act
        var plugin = await this._kernel.ImportPluginFromOpenApiAsync("fakePlugin", new Uri(documentUri), this._executionParameters);
        var setSecretFunction = plugin["SetSecret"];

        messageHandlerStub.ResetResponse();

        var result = await this._kernel.InvokeAsync(setSecretFunction, arguments);

        // Assert
        Assert.NotNull(messageHandlerStub.RequestUri);
        Assert.StartsWith(expectedServerUrl, messageHandlerStub.RequestUri.AbsoluteUri, StringComparison.Ordinal);
    }

    [Fact]
    public async Task ItShouldRespectRunAsyncCancellationTokenOnExecutionAsync()
    {
        // Arrange
        using var messageHandlerStub = new HttpMessageHandlerStub();
        messageHandlerStub.ResponseToReturn.Content = new StringContent("fake-content", Encoding.UTF8, MediaTypeNames.Application.Json);

        using var httpClient = new HttpClient(messageHandlerStub, false);

        this._executionParameters.HttpClient = httpClient;

        using var registerCancellationToken = new System.Threading.CancellationTokenSource();
        using var executeCancellationToken = new System.Threading.CancellationTokenSource();

        var openApiPlugin = await this._kernel.ImportPluginFromOpenApiAsync("fakePlugin", this._openApiDocument, this._executionParameters, registerCancellationToken.Token);

        var kernel = new Kernel();

        var arguments = new KernelArguments
        {
            { "secret-name", "fake-secret-name" },
            { "api-version", "fake-api-version" }
        };

        // Act
        registerCancellationToken.Cancel();
        var result = await kernel.InvokeAsync(openApiPlugin["GetSecret"], arguments, executeCancellationToken.Token);

        // Assert
        Assert.NotNull(result);

        var response = result.GetValue<RestApiOperationResponse>();

        //Check original response
        Assert.NotNull(response);
        Assert.Equal("fake-content", response.Content);
    }

    [Fact]
    public async Task ItShouldSanitizeOperationNameAsync()
    {
        // Arrange
        var openApiDocument = ResourcePluginsProvider.LoadFromResource("documentV3_0.json");

        using var content = OpenApiTestHelper.ModifyOpenApiDocument(openApiDocument, (doc) =>
        {
            doc["paths"]!["/secrets/{secret-name}"]!["get"]!["operationId"] = "issues/create-mile.stone";
        });

        // Act
        var plugin = await this._kernel.ImportPluginFromOpenApiAsync("fakePlugin", content, this._executionParameters);

        // Assert
        Assert.True(plugin.TryGetFunction("IssuesCreatemilestone", out var _));
    }

    [Fact]
    public async Task ItCanIncludeOpenApiDeleteAndPatchOperationsAsync()
    {
        // Arrange
        var openApiDocument = ResourcePluginsProvider.LoadFromResource("repair-service.json");

        // Act
        var plugin = await this._kernel.ImportPluginFromOpenApiAsync("repairServicePlugin", openApiDocument, this._executionParameters);

        // Assert
        Assert.NotNull(plugin);
        var functionsMetadata = plugin.GetFunctionsMetadata();
        Assert.Equal(4, functionsMetadata.Count);
        AssertPayloadParameters(plugin, "updateRepair");
        AssertPayloadParameters(plugin, "deleteRepair");
    }

    [Theory]
    [InlineData("documentV2_0.json")]
    [InlineData("documentV3_0.json")]
    [InlineData("documentV3_1.yaml")]
    public async Task ItShouldReplicateMetadataToOperationAsync(string documentFileName)
    {
        // Arrange
        var openApiDocument = ResourcePluginsProvider.LoadFromResource(documentFileName);

        // Act
        var plugin = await this._kernel.ImportPluginFromOpenApiAsync("fakePlugin", openApiDocument, this._executionParameters);

        // Assert Metadata Keys and Values
        Assert.True(plugin.TryGetFunction("OpenApiExtensions", out var function));
        var additionalProperties = function.Metadata.AdditionalProperties;
        Assert.Equal(6, additionalProperties.Count);

        Assert.Contains("method", additionalProperties.Keys);
        Assert.Contains("operation", additionalProperties.Keys);
        Assert.Contains("info", additionalProperties.Keys);
        Assert.Contains("security", additionalProperties.Keys);
        Assert.Contains("server-urls", additionalProperties.Keys);
        Assert.Contains("operation-extensions", additionalProperties.Keys);

        var operation = additionalProperties["operation"] as RestApiOperation;
        Assert.NotNull(operation);
        Assert.Equal("GET", additionalProperties["method"]);
        Assert.Equal("/api-with-open-api-extensions", operation.Path);
        Assert.Equal("Get API with open-api specification extensions", operation.Summary);
        var serverUrls = additionalProperties["server-urls"] as string[];
        Assert.NotNull(serverUrls);
        Assert.Equal(["https://my-key-vault.vault.azure.net"], serverUrls);
        var info = additionalProperties["info"] as RestApiInfo;
        Assert.NotNull(info);
        var security = additionalProperties["security"] as List<RestApiSecurityRequirement>;
        Assert.NotNull(security);

        // Assert Operation Extension keys
        var operationExtensions = additionalProperties["operation-extensions"] as Dictionary<string, object?>;
        Assert.NotNull(operationExtensions);
        Dictionary<string, object?> nonNullOperationExtensions = operationExtensions;

        Assert.Equal(8, nonNullOperationExtensions.Count);
        Assert.Contains("x-boolean-extension", nonNullOperationExtensions.Keys);
        Assert.Contains("x-double-extension", nonNullOperationExtensions.Keys);
        Assert.Contains("x-integer-extension", nonNullOperationExtensions.Keys);
        Assert.Contains("x-string-extension", nonNullOperationExtensions.Keys);
        Assert.Contains("x-date-extension", nonNullOperationExtensions.Keys);
        Assert.Contains("x-datetime-extension", nonNullOperationExtensions.Keys);
        Assert.Contains("x-array-extension", nonNullOperationExtensions.Keys);
        Assert.Contains("x-object-extension", nonNullOperationExtensions.Keys);
    }

    [Fact]
    public void ItCreatesPluginFromOpenApiSpecificationModel()
    {
        // Arrange
        var info = new RestApiInfo() { Description = "api-description", Title = "api-title", Version = "7.0" };

        var securityRequirements = new List<RestApiSecurityRequirement>
        {
            new(new Dictionary<RestApiSecurityScheme, IList<string>> { { new RestApiSecurityScheme(), new List<string>() } })
        };

        var operations = new List<RestApiOperation>
        {
            new (
                id: "operation1",
                servers: [],
                path: "path",
                method: HttpMethod.Get,
                description: "operation-description",
                parameters: [],
                responses: new Dictionary<string, RestApiExpectedResponse>(),
                securityRequirements: [],
                payload: null)
        };

        var specification = new RestApiSpecification(info, securityRequirements, operations);

        // Act
        var plugin = this._kernel.CreatePluginFromOpenApi("fakePlugin", specification, this._executionParameters);

        // Assert
        Assert.Single(plugin);
        Assert.Equal("api-description", plugin.Description);
        Assert.Equal("fakePlugin", plugin.Name);

        var function = plugin["operation1"];
        Assert.Equal("operation1", function.Name);
        Assert.Equal("operation-description", function.Description);
        Assert.Same(operations[0], function.Metadata.AdditionalProperties["operation"]);
    }

    [Fact]
    public void ItImportPluginFromOpenApiSpecificationModel()
    {
        // Arrange
        var info = new RestApiInfo() { Description = "api-description", Title = "api-title", Version = "7.0" };

        var securityRequirements = new List<RestApiSecurityRequirement>
        {
            new(new Dictionary<RestApiSecurityScheme, IList<string>> { { new RestApiSecurityScheme(), new List<string>() } })
        };

        var operations = new List<RestApiOperation>
        {
            new (
                id: "operation1",
                servers: [],
                path: "path",
                method: HttpMethod.Get,
                description: "operation-description",
                parameters: [],
                responses: new Dictionary<string, RestApiExpectedResponse>(),
                securityRequirements: [],
                payload: null)
        };

        var specification = new RestApiSpecification(info, securityRequirements, operations);

        // Act
        this._kernel.ImportPluginFromOpenApi("fakePlugin", specification, this._executionParameters);

        // Assert
        var plugin = Assert.Single(this._kernel.Plugins);

        Assert.Single(plugin);
        Assert.Equal("api-description", plugin.Description);
        Assert.Equal("fakePlugin", plugin.Name);

        var function = plugin["operation1"];
        Assert.Equal("operation1", function.Name);
        Assert.Equal("operation-description", function.Description);
        Assert.Same(operations[0], function.Metadata.AdditionalProperties["operation"]);
    }

    public void Dispose()
    {
        this._openApiDocument.Dispose();
    }

    #region private ================================================================================

    private static void AssertPayloadParameters(KernelPlugin plugin, string functionName)
    {
        Assert.True(plugin.TryGetFunction(functionName, out var function));
        Assert.NotNull(function.Metadata.Parameters);
        Assert.Equal(2, function.Metadata.Parameters.Count);
        Assert.Equal("payload", function.Metadata.Parameters[0].Name);
        Assert.Equal("content_type", function.Metadata.Parameters[1].Name);
    }

    private KernelArguments GetFakeFunctionArguments()
    {
        return new KernelArguments
        {
            ["secret-name"] = "fake-secret-name",
            ["api-version"] = "7.0",
            ["X-API-Version"] = 6,
            ["payload"] = "fake-payload"
        };
    }

    #endregion
}


===== Functions.UnitTests\OpenApi\Extensions\OpenApiSchemaExtensionsTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Globalization;
using Microsoft.OpenApi.Any;
using Microsoft.OpenApi.Models;
using Microsoft.SemanticKernel.Plugins.OpenApi;
using Xunit;

namespace SemanticKernel.Functions.UnitTests.OpenApi.Extensions;
public class OpenApiSchemaExtensionsTests
{
    [Fact]
    public void ItShouldConvertOpenApiSchemaUsingInvariantCulture()
    {
        // Arrange
        var schema = new OpenApiSchema
        {
            Type = "object",
            Properties = new Dictionary<string, OpenApiSchema>
            {
                ["property1"] = new OpenApiSchema
                {
                    Type = "number",
                    Format = "double",
                    Default = new OpenApiDouble(12.01)
                }
            }
        };

        var currentCulture = CultureInfo.CurrentCulture; // Backup current culture

        // Act & Assert
        try
        {
            CultureInfo.CurrentCulture = new CultureInfo("fr-FR"); // French culture uses comma as decimal separator

            var result = schema.ToJsonSchema(); // Should use invariant culture

            Assert.True(result.RootElement.TryGetProperty("properties", out var properties));
            Assert.True(properties.TryGetProperty("property1", out var property2));
            Assert.Equal(12.01, property2.GetProperty("default").GetDouble());
        }
        finally
        {
            CultureInfo.CurrentCulture = currentCulture; // Restore current culture
        }
    }
}


===== Functions.UnitTests\OpenApi\Extensions\RestApiOperationExtensionsTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.Http;
using Microsoft.SemanticKernel.Plugins.OpenApi;
using Xunit;

namespace SemanticKernel.Functions.UnitTests.OpenApi;

public class RestApiOperationExtensionsTests
{
    [Theory]
    [InlineData("PUT")]
    [InlineData("POST")]
    public void ItShouldAddPayloadAndContentTypeParametersByDefault(string method)
    {
        //Arrange
        var payload = CreateTestJsonPayload();

        var operation = CreateTestOperation(method, payload);

        //Act
        var parameters = operation.GetParameters(addPayloadParamsFromMetadata: false);

        //Assert
        Assert.NotNull(parameters);

        var payloadParam = parameters.FirstOrDefault(p => p.Name == "payload");
        Assert.NotNull(payloadParam);
        Assert.Equal("object", payloadParam.Type);
        Assert.True(payloadParam.IsRequired);
        Assert.Equal("REST API request body.", payloadParam.Description);

        var contentTypeParam = parameters.FirstOrDefault(p => p.Name == "content-type");
        Assert.NotNull(contentTypeParam);
        Assert.Equal("string", contentTypeParam.Type);
        Assert.False(contentTypeParam.IsRequired);
        Assert.Equal("Content type of REST API request body.", contentTypeParam.Description);
    }

    [Theory]
    [InlineData("PUT")]
    [InlineData("POST")]
    public void ItShouldAddPayloadAndContentTypeParametersWhenSpecified(string method)
    {
        //Arrange
        var payload = CreateTestJsonPayload();

        var operation = CreateTestOperation(method, payload);

        //Act
        var parameters = operation.GetParameters(addPayloadParamsFromMetadata: false);

        //Assert
        Assert.NotNull(parameters);

        var payloadProp = parameters.FirstOrDefault(p => p.Name == "payload");
        Assert.NotNull(payloadProp);
        Assert.Equal("object", payloadProp.Type);
        Assert.True(payloadProp.IsRequired);
        Assert.Equal("REST API request body.", payloadProp.Description);

        var contentTypeProp = parameters.FirstOrDefault(p => p.Name == "content-type");
        Assert.NotNull(contentTypeProp);
        Assert.Equal("string", contentTypeProp.Type);
        Assert.False(contentTypeProp.IsRequired);
        Assert.Equal("Content type of REST API request body.", contentTypeProp.Description);
    }

    [Theory]
    [InlineData("PUT")]
    [InlineData("POST")]
    public void ItShouldAddPayloadAndContentTypePropertiesForPlainTextContentType(string method)
    {
        //Arrange
        var payload = CreateTestTextPayload();

        var operation = CreateTestOperation(method, payload);

        //Act
        var parameters = operation.GetParameters(addPayloadParamsFromMetadata: false);

        //Assert
        Assert.NotNull(parameters);

        var payloadParam = parameters.FirstOrDefault(p => p.Name == "payload");
        Assert.NotNull(payloadParam);
        Assert.Equal("string", payloadParam.Type);
        Assert.True(payloadParam.IsRequired);
        Assert.Equal("REST API request body.", payloadParam.Description);

        var contentTypeParam = parameters.FirstOrDefault(p => p.Name == "content-type");
        Assert.NotNull(contentTypeParam);
        Assert.Equal("string", contentTypeParam.Type);
        Assert.False(contentTypeParam.IsRequired);
        Assert.Equal("Content type of REST API request body.", contentTypeParam.Description);
    }

    [Theory]
    [InlineData("PUT")]
    [InlineData("POST")]
    public void ItShouldAddPayloadAndContentTypePropertiesIfParametersFromPayloadMetadataAreNotRequired(string method)
    {
        //Arrange
        var payload = CreateTestJsonPayload();

        var operation = CreateTestOperation(method, payload);

        //Act
        var parameters = operation.GetParameters(addPayloadParamsFromMetadata: false);

        //Assert
        Assert.NotNull(parameters);

        var payloadParam = parameters.FirstOrDefault(p => p.Name == "payload");
        Assert.NotNull(payloadParam);
        Assert.Equal("object", payloadParam.Type);
        Assert.True(payloadParam.IsRequired);
        Assert.Equal("REST API request body.", payloadParam.Description);

        var contentTypeParam = parameters.FirstOrDefault(p => p.Name == "content-type");
        Assert.NotNull(contentTypeParam);
        Assert.Equal("string", contentTypeParam.Type);
        Assert.False(contentTypeParam.IsRequired);
        Assert.Equal("Content type of REST API request body.", contentTypeParam.Description);
    }

    [Theory]
    [InlineData("PUT")]
    [InlineData("POST")]
    public void ItShouldAddParametersDeclaredInPayloadMetadata(string method)
    {
        //Arrange
        var payload = CreateTestJsonPayload();

        var operation = CreateTestOperation(method, payload);

        //Act
        var parameters = operation.GetParameters(addPayloadParamsFromMetadata: true);

        //Assert
        Assert.NotNull(parameters);

        Assert.Equal(5, parameters.Count); //5 props from payload

        var name = parameters.FirstOrDefault(p => p.Name == "name");
        Assert.NotNull(name);
        Assert.Equal("string", name.Type);
        Assert.True(name.IsRequired);
        Assert.Equal("The name.", name.Description);

        var landmarks = parameters.FirstOrDefault(p => p.Name == "landmarks");
        Assert.NotNull(landmarks);
        Assert.Equal("array", landmarks.Type);
        Assert.False(landmarks.IsRequired);
        Assert.Equal("The landmarks.", landmarks.Description);

        var leader = parameters.FirstOrDefault(p => p.Name == "leader");
        Assert.NotNull(leader);
        Assert.Equal("string", leader.Type);
        Assert.True(leader.IsRequired);
        Assert.Equal("The leader.", leader.Description);

        var population = parameters.FirstOrDefault(p => p.Name == "population");
        Assert.NotNull(population);
        Assert.Equal("integer", population.Type);
        Assert.True(population.IsRequired);
        Assert.Equal("The population.", population.Description);

        var hasMagicWards = parameters.FirstOrDefault(p => p.Name == "hasMagicWards");
        Assert.NotNull(hasMagicWards);
        Assert.Equal("boolean", hasMagicWards.Type);
        Assert.False(hasMagicWards.IsRequired);
        Assert.Null(hasMagicWards.Description);
    }

    [Theory]
    [InlineData("PUT")]
    [InlineData("POST")]
    public void ItShouldAddNamespaceToParametersDeclaredInPayloadMetadata(string method)
    {
        //Arrange
        var payload = CreateTestJsonPayload();

        var operation = CreateTestOperation(method, payload);

        //Act
        var parameters = operation.GetParameters(addPayloadParamsFromMetadata: true, enablePayloadNamespacing: true);

        //Assert
        Assert.NotNull(parameters);

        Assert.Equal(5, parameters.Count); //5 props from payload

        var name = parameters.FirstOrDefault(p => p.Name == "name");
        Assert.NotNull(name);
        Assert.Equal("string", name.Type);
        Assert.True(name.IsRequired);
        Assert.Equal("The name.", name.Description);

        var landmarks = parameters.FirstOrDefault(p => p.Name == "location.landmarks");
        Assert.NotNull(landmarks);
        Assert.Equal("array", landmarks.Type);
        Assert.False(landmarks.IsRequired);
        Assert.Equal("The landmarks.", landmarks.Description);

        var leader = parameters.FirstOrDefault(p => p.Name == "rulingCouncil.leader");
        Assert.NotNull(leader);
        Assert.Equal("string", leader.Type);
        Assert.True(leader.IsRequired);
        Assert.Equal("The leader.", leader.Description);

        var population = parameters.FirstOrDefault(p => p.Name == "population");
        Assert.NotNull(population);
        Assert.Equal("integer", population.Type);
        Assert.True(population.IsRequired);
        Assert.Equal("The population.", population.Description);

        var hasMagicWards = parameters.FirstOrDefault(p => p.Name == "hasMagicWards");
        Assert.NotNull(hasMagicWards);
        Assert.Equal("boolean", hasMagicWards.Type);
        Assert.False(hasMagicWards.IsRequired);
        Assert.Null(hasMagicWards.Description);
    }

    [Theory]
    [InlineData("PUT")]
    [InlineData("POST")]
    public void ItShouldSetArgumentNameToPayloadParameters(string method)
    {
        //Arrange
        var latitude = new RestApiPayloadProperty("location.latitude", "number", false, []);
        var place = new RestApiPayloadProperty("place", "string", true, []);

        var payload = new RestApiPayload("application/json", [place, latitude]);

        var operation = CreateTestOperation(method, payload);

        //Act
        var parameters = operation.GetParameters(addPayloadParamsFromMetadata: true);

        //Assert
        Assert.NotNull(parameters);

        var placeProp = parameters.FirstOrDefault(p => p.Name == "place");
        Assert.NotNull(placeProp);
        Assert.Equal("place", placeProp.ArgumentName);

        var personNameProp = parameters.FirstOrDefault(p => p.Name == "location.latitude");
        Assert.NotNull(personNameProp);
        Assert.Equal("location_latitude", personNameProp.ArgumentName);
    }

    [Theory]
    [InlineData("PUT")]
    [InlineData("POST")]
    public void ItShouldNotSetArgumentNameToPayloadParametersIfItIsAlreadyProvided(string method)
    {
        //Arrange
        var latitude = new RestApiPayloadProperty("location.latitude", "number", false, []) { ArgumentName = "alt.location.latitude" };
        var place = new RestApiPayloadProperty("place", "string", true, []) { ArgumentName = "alt+place" };

        var payload = new RestApiPayload("application/json", [place, latitude]);

        var operation = CreateTestOperation(method, payload);

        //Act
        var parameters = operation.GetParameters(addPayloadParamsFromMetadata: true);

        //Assert
        Assert.NotNull(parameters);

        var placeProp = parameters.FirstOrDefault(p => p.Name == "place");
        Assert.NotNull(placeProp);
        Assert.Equal("alt+place", placeProp.ArgumentName);

        var personNameProp = parameters.FirstOrDefault(p => p.Name == "location.latitude");
        Assert.NotNull(personNameProp);
        Assert.Equal("alt.location.latitude", personNameProp.ArgumentName);
    }

    [Fact]
    public void ItShouldSetArgumentNameToNonPayloadParameters()
    {
        //Arrange
        List<RestApiParameter> parameters = [
            new RestApiParameter("p-1", "number", false, false, RestApiParameterLocation.Path),
            new RestApiParameter("p$2", "string", false, false, RestApiParameterLocation.Query),
            new RestApiParameter("p3", "number", false, false, RestApiParameterLocation.Header)
        ];

        var operation = CreateTestOperation("GET", parameters: parameters);

        //Act
        var processedParameters = operation.GetParameters();

        //Assert
        Assert.NotNull(processedParameters);

        var pathParameter = processedParameters.Single(p => p.Name == "p-1");
        Assert.NotNull(pathParameter);
        Assert.Equal("p_1", pathParameter.ArgumentName);

        var queryStringParameter = processedParameters.Single(p => p.Name == "p$2");
        Assert.NotNull(queryStringParameter);
        Assert.Equal("p_2", queryStringParameter.ArgumentName);

        var headerParameter = processedParameters.Single(p => p.Name == "p3");
        Assert.NotNull(headerParameter);
        Assert.Equal("p3", headerParameter.ArgumentName);
    }

    [Fact]
    public void ItShouldNotSetArgumentNameToNonPayloadParametersIfItIsAlreadyProvided()
    {
        //Arrange
        List<RestApiParameter> parameters = [
            new RestApiParameter("p-1", "number", false, false, RestApiParameterLocation.Path) { ArgumentName = "alt.p1" },
            new RestApiParameter("p$2", "string", false, false, RestApiParameterLocation.Query) { ArgumentName = "alt.p2" },
            new RestApiParameter("p3", "number", false, false, RestApiParameterLocation.Header) { ArgumentName = "alt.p3" }
        ];

        var operation = CreateTestOperation("GET", parameters: parameters);

        //Act
        var processedParameters = operation.GetParameters();

        //Assert
        Assert.NotNull(processedParameters);

        var pathParameter = processedParameters.Single(p => p.Name == "p-1");
        Assert.NotNull(pathParameter);
        Assert.Equal("alt.p1", pathParameter.ArgumentName);

        var queryStringParameter = processedParameters.Single(p => p.Name == "p$2");
        Assert.NotNull(queryStringParameter);
        Assert.Equal("alt.p2", queryStringParameter.ArgumentName);

        var headerParameter = processedParameters.Single(p => p.Name == "p3");
        Assert.NotNull(headerParameter);
        Assert.Equal("alt.p3", headerParameter.ArgumentName);
    }

    private static RestApiOperation CreateTestOperation(string method, RestApiPayload? payload = null, Uri? url = null, List<RestApiParameter>? parameters = null)
    {
        return new RestApiOperation(
            id: "fake-id",
            servers: [new(url?.AbsoluteUri)],
            path: "fake-path",
            method: new HttpMethod(method),
            description: "fake-description",
            parameters: parameters ?? [],
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            securityRequirements: [],
            payload: payload);
    }

    private static RestApiPayload CreateTestJsonPayload()
    {
        var name = new RestApiPayloadProperty(
            name: "name",
            type: "string",
            isRequired: true,
            properties: [],
            description: "The name.");

        var leader = new RestApiPayloadProperty(
            name: "leader",
            type: "string",
            isRequired: true,
            properties: [],
            description: "The leader.");

        var landmarks = new RestApiPayloadProperty(
            name: "landmarks",
            type: "array",
            isRequired: false,
            properties: [],
            description: "The landmarks.");

        var location = new RestApiPayloadProperty(
            name: "location",
            type: "object",
            isRequired: true,
            properties: [landmarks],
            description: "The location.");

        var rulingCouncil = new RestApiPayloadProperty(
            name: "rulingCouncil",
            type: "object",
            isRequired: true,
            properties: [leader],
            description: "The ruling council.");

        var population = new RestApiPayloadProperty(
            name: "population",
            type: "integer",
            isRequired: true,
            properties: [],
            description: "The population.");

        var hasMagicWards = new RestApiPayloadProperty(
            name: "hasMagicWards",
            type: "boolean",
            isRequired: false,
            properties: []);

        return new RestApiPayload("application/json", [name, location, rulingCouncil, population, hasMagicWards]);
    }

    private static RestApiPayload CreateTestTextPayload()
    {
        return new RestApiPayload("text/plain", []);
    }
}


===== Functions.UnitTests\OpenApi\HttpMessageHandlerStub.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.IO;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Net.Mime;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace SemanticKernel.Functions.UnitTests.OpenApi;

internal sealed class HttpMessageHandlerStub : DelegatingHandler
{
    public HttpRequestHeaders? RequestHeaders { get; private set; }

    public HttpContentHeaders? ContentHeaders { get; private set; }

    public byte[]? RequestContent { get; private set; }

    public Uri? RequestUri { get; private set; }

    public HttpMethod? Method { get; private set; }

    public HttpResponseMessage ResponseToReturn { get; set; }

    public HttpMessageHandlerStub()
    {
        this.ResponseToReturn = new HttpResponseMessage(System.Net.HttpStatusCode.OK)
        {
            Content = new StringContent("{}", Encoding.UTF8, MediaTypeNames.Application.Json)
        };
    }

    public HttpMessageHandlerStub(Stream responseToReturn)
    {
        this.ResponseToReturn = new HttpResponseMessage(System.Net.HttpStatusCode.OK)
        {
            Content = new StreamContent(responseToReturn)
        };
    }

    public void ResetResponse()
    {
        this.ResponseToReturn = new HttpResponseMessage(System.Net.HttpStatusCode.OK)
        {
            Content = new StringContent("{}", Encoding.UTF8, MediaTypeNames.Application.Json)
        };
    }

    protected override async Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
    {
        this.Method = request.Method;
        this.RequestUri = request.RequestUri;
        this.RequestHeaders = request.Headers;
        this.RequestContent = request.Content is null ? null : await request.Content.ReadAsByteArrayAsync(cancellationToken);
        this.ContentHeaders = request.Content?.Headers;

        return await Task.FromResult(this.ResponseToReturn);
    }
}


===== Functions.UnitTests\OpenApi\OpenApiDocumentParserExtensionsTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Globalization;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.SemanticKernel.Plugins.OpenApi;
using SemanticKernel.Functions.UnitTests.OpenApi.TestPlugins;
using Xunit;

namespace SemanticKernel.Functions.UnitTests.OpenApi;

/// <summary>
/// Contains tests for the open api schema extensions functionality of the <see cref="OpenApiDocumentParser"/> class.
/// See https://swagger.io/docs/specification/openapi-extensions/
/// </summary>
public class OpenApiDocumentParserExtensionsTests
{
    /// <summary>
    /// System under test - an instance of OpenApiDocumentParser class.
    /// </summary>
    private readonly OpenApiDocumentParser _sut;

    /// <summary>
    /// Creates an instance of a <see cref="OpenApiDocumentParserV31Tests"/> class.
    /// </summary>
    public OpenApiDocumentParserExtensionsTests()
    {
        this._sut = new OpenApiDocumentParser();
    }

    [Theory]
    [InlineData("documentV2_0.json")]
    [InlineData("documentV3_0.json")]
    [InlineData("documentV3_1.yaml")]
    public async Task ItCanExtractExtensionsOfAllTypesAsync(string documentName)
    {
        // Arrange.
        using var openApiDocument = ResourcePluginsProvider.LoadFromResource(documentName);

        // Act.
        var restApi = await this._sut.ParseAsync(openApiDocument);

        // Assert.
        Assert.NotNull(restApi.Operations);
        Assert.True(restApi.Operations.Any());

        var operation = restApi.Operations.Single(o => o.Id == "OpenApiExtensions");
        Assert.NotNull(operation);

        // Check the different extension types.
        // No need to test float, since the parser does not differentiate between floats and doubles, and will always return a double.
        // No need to test byte, since the parser does not differentiate between byte and string, and will always return a string.
        // No need to test binary, since the parser does not differentiate between binary and string, and will always return a string.

        Assert.True(operation.Extensions.TryGetValue("x-boolean-extension", out var booleanValue));
        Assert.Equal(true, booleanValue);

        Assert.True(operation.Extensions.TryGetValue("x-double-extension", out var doubleValue));
        Assert.Equal(1.2345d, doubleValue);

        Assert.True(operation.Extensions.TryGetValue("x-integer-extension", out var integerValue));
        Assert.Equal(12345, integerValue);

        Assert.True(operation.Extensions.TryGetValue("x-string-extension", out var stringValue));
        Assert.Equal("value1", stringValue);

        Assert.True(operation.Extensions.TryGetValue("x-date-extension", out var dateValue));
        Assert.Equal(DateTime.Parse("2024-04-16T00:00:00.0000000", CultureInfo.InvariantCulture), dateValue);

        Assert.True(operation.Extensions.TryGetValue("x-datetime-extension", out var datetimeValue));
        Assert.Equal(DateTimeOffset.Parse("2024-04-16T18:37:12.1214643+00:00", CultureInfo.InvariantCulture), datetimeValue);

        Assert.True(operation.Extensions.TryGetValue("x-array-extension", out var arrayValue));
        Assert.Equal("[\"value1\",\"value2\"]", arrayValue);

        Assert.True(operation.Extensions.TryGetValue("x-object-extension", out var objectValue));
        Assert.Equal("{\"key1\":\"value1\",\"key2\":\"value2\"}", objectValue);
    }

    [Theory]
    [InlineData("documentV3_0.json")]
    [InlineData("documentV3_1.yaml")]
    public async Task ItCanParseMediaTypeAsync(string documentName)
    {
        // Arrange.
        using var openApiDocument = ResourcePluginsProvider.LoadFromResource(documentName);

        // Act.
        var restApi = await this._sut.ParseAsync(openApiDocument);

        // Assert.
        Assert.NotNull(restApi.Operations);
        Assert.Equal(8, restApi.Operations.Count);
        var operation = restApi.Operations.Single(o => o.Id == "Joke");
        Assert.NotNull(operation);
        Assert.Equal("application/json; x-api-version=2.0", operation.Payload?.MediaType);
    }
}


===== Functions.UnitTests\OpenApi\OpenApiDocumentParserV20Tests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Plugins.OpenApi;
using SemanticKernel.Functions.UnitTests.OpenApi.TestPlugins;
using Xunit;

namespace SemanticKernel.Functions.UnitTests.OpenApi;

public sealed class OpenApiDocumentParserV20Tests : IDisposable
{
    /// <summary>
    /// System under test - an instance of OpenApiDocumentParser class.
    /// </summary>
    private readonly OpenApiDocumentParser _sut;

    /// <summary>
    /// OpenAPI document stream.
    /// </summary>
    private readonly Stream _openApiDocument;

    /// <summary>
    /// Creates an instance of a <see cref="OpenApiDocumentParserV20Tests"/> class.
    /// </summary>
    public OpenApiDocumentParserV20Tests()
    {
        this._openApiDocument = ResourcePluginsProvider.LoadFromResource("documentV2_0.json");

        this._sut = new OpenApiDocumentParser();
    }

    [Fact]
    public async Task ItCanParsePutOperationBodySuccessfullyAsync()
    {
        // Act
        var restApi = await this._sut.ParseAsync(this._openApiDocument);

        // Assert
        Assert.NotNull(restApi.Operations);
        Assert.True(restApi.Operations.Any());

        var putOperation = restApi.Operations.Single(o => o.Id == "SetSecret");
        Assert.NotNull(putOperation);

        var payload = putOperation.Payload;
        Assert.NotNull(payload);
        Assert.Equal("application/json", payload.MediaType);

        var properties = payload.Properties;
        Assert.NotNull(properties);
        Assert.Equal(2, properties.Count);

        var valueProperty = properties.FirstOrDefault(p => p.Name == "value");
        Assert.NotNull(valueProperty);
        Assert.True(valueProperty.IsRequired);
        Assert.Equal("The value of the secret.", valueProperty.Description);
        Assert.Equal("string", valueProperty.Type);
        Assert.NotNull(valueProperty.Properties);
        Assert.False(valueProperty.Properties.Any());
        Assert.NotNull(valueProperty.Schema);
        Assert.Equal("string", valueProperty.Schema.RootElement.GetProperty("type").GetString());
        Assert.Equal("The value of the secret.", valueProperty.Schema.RootElement.GetProperty("description").GetString());

        var attributesProperty = properties.FirstOrDefault(p => p.Name == "attributes");
        Assert.NotNull(attributesProperty);
        Assert.False(attributesProperty.IsRequired);
        Assert.Equal("attributes", attributesProperty.Description);
        Assert.Equal("object", attributesProperty.Type);
        Assert.NotNull(attributesProperty.Properties);
        Assert.True(attributesProperty.Properties.Any());
        Assert.NotNull(attributesProperty.Schema);
        Assert.Equal("object", attributesProperty.Schema.RootElement.GetProperty("type").GetString());
        Assert.Equal("attributes", attributesProperty.Schema.RootElement.GetProperty("description").GetString());

        var enabledProperty = attributesProperty.Properties.FirstOrDefault(p => p.Name == "enabled");
        Assert.NotNull(enabledProperty);
        Assert.True(enabledProperty.IsRequired);
        Assert.Equal("Determines whether the object is enabled.", enabledProperty.Description);
        Assert.Equal("boolean", enabledProperty.Type);
        Assert.False(enabledProperty.Properties?.Any());
        Assert.NotNull(enabledProperty.Schema);
        Assert.Equal("boolean", enabledProperty.Schema.RootElement.GetProperty("type").GetString());
        Assert.Equal("Determines whether the object is enabled.", enabledProperty.Schema.RootElement.GetProperty("description").GetString());

        var encryptedProperty = attributesProperty.Properties.FirstOrDefault(p => p.Name == "encrypted");
        Assert.NotNull(encryptedProperty);
        Assert.False(encryptedProperty.IsRequired);
        Assert.Equal("Determines whether the object is encrypted.", encryptedProperty.Description);
        Assert.Equal("boolean", encryptedProperty.Type);
        Assert.False(encryptedProperty.Properties?.Any());
        Assert.NotNull(encryptedProperty.Schema);
        Assert.Equal("boolean", encryptedProperty.Schema.RootElement.GetProperty("type").GetString());
        Assert.Equal("Determines whether the object is encrypted.", encryptedProperty.Schema.RootElement.GetProperty("description").GetString());
    }

    [Fact]
    public async Task ItCanParsePutOperationMetadataSuccessfullyAsync()
    {
        // Act
        var restApi = await this._sut.ParseAsync(this._openApiDocument);

        // Assert
        Assert.NotNull(restApi.Operations);
        Assert.True(restApi.Operations.Any());

        var putOperation = restApi.Operations.Single(o => o.Id == "SetSecret");
        Assert.NotNull(putOperation);
        Assert.Equal("Sets a secret in a specified key vault.", putOperation.Description);
        Assert.Equal("Create or update secret value", putOperation.Summary);
        Assert.Equal("https://my-key-vault.vault.azure.net", putOperation.Servers[0].Url);
        Assert.Equal(HttpMethod.Put, putOperation.Method);
        Assert.Equal("/secrets/{secret-name}", putOperation.Path);

        var parameters = putOperation.GetParameters(addPayloadParamsFromMetadata: false);
        Assert.NotNull(parameters);
        Assert.True(parameters.Count >= 5);

        var pathParameter = parameters.Single(p => p.Name == "secret-name"); //'secret-name' path parameter.
        Assert.True(pathParameter.IsRequired);
        Assert.Equal(RestApiParameterLocation.Path, pathParameter.Location);
        Assert.Null(pathParameter.DefaultValue);
        Assert.NotNull(pathParameter.Schema);
        Assert.Equal("string", pathParameter.Schema.RootElement.GetProperty("type").GetString());

        var apiVersionParameter = parameters.Single(p => p.Name == "api-version"); //'api-version' query string parameter.
        Assert.True(apiVersionParameter.IsRequired);
        Assert.Equal(RestApiParameterLocation.Query, apiVersionParameter.Location);
        Assert.Equal("7.0", apiVersionParameter.DefaultValue);
        Assert.NotNull(apiVersionParameter.Schema);
        Assert.Equal("string", apiVersionParameter.Schema.RootElement.GetProperty("type").GetString());
        Assert.Equal("7.0", apiVersionParameter.Schema.RootElement.GetProperty("default").GetString());

        var payloadParameter = parameters.Single(p => p.Name == "payload"); //'payload' artificial parameter.
        Assert.True(payloadParameter.IsRequired);
        Assert.Equal(RestApiParameterLocation.Body, payloadParameter.Location);
        Assert.Null(payloadParameter.DefaultValue);
        Assert.Equal("REST API request body.", payloadParameter.Description);
        Assert.NotNull(payloadParameter.Schema);
        Assert.Equal("object", payloadParameter.Schema.RootElement.GetProperty("type").GetString());

        var contentTypeParameter = parameters.Single(p => p.Name == "content-type"); //'content-type' artificial parameter.
        Assert.False(contentTypeParameter.IsRequired);
        Assert.Equal(RestApiParameterLocation.Body, contentTypeParameter.Location);
        Assert.Null(contentTypeParameter.DefaultValue);
        Assert.Equal("Content type of REST API request body.", contentTypeParameter.Description);
        Assert.Null(contentTypeParameter.Schema);
    }

    [Fact]
    public async Task ItCanUseOperationSummaryAsync()
    {
        // Act
        var restApi = await this._sut.ParseAsync(this._openApiDocument);

        // Assert
        Assert.NotNull(restApi.Operations);
        Assert.True(restApi.Operations.Any());

        var operation = restApi.Operations.Single(o => o.Id == "Excuses");
        Assert.NotNull(operation);
        Assert.Equal("Turn a scenario into a creative or humorous excuse to send your boss", operation.Description);
        Assert.Equal("Turn a scenario into a creative or humorous excuse to send your boss", operation.Summary);
    }

    [Fact]
    public async Task ItCanExtractSimpleTypeHeaderParameterMetadataSuccessfullyAsync()
    {
        // Act
        var restApi = await this._sut.ParseAsync(this._openApiDocument);

        //Assert string header parameter metadata
        var accept = GetParameterMetadata(restApi.Operations, "SetSecret", RestApiParameterLocation.Header, "Accept");

        Assert.Equal("string", accept.Type);
        Assert.Equal("application/json", accept.DefaultValue);
        Assert.Equal("Indicates which content types, expressed as MIME types, the client is able to understand.", accept.Description);
        Assert.False(accept.IsRequired);

        //Assert integer header parameter metadata
        var apiVersion = GetParameterMetadata(restApi.Operations, "SetSecret", RestApiParameterLocation.Header, "X-API-Version");

        Assert.Equal("integer", apiVersion.Type);
        Assert.Equal(10, apiVersion.DefaultValue);
        Assert.Equal("Requested API version.", apiVersion.Description);
        Assert.True(apiVersion.IsRequired);
    }

    [Fact]
    public async Task ItCanExtractCsvStyleHeaderParameterMetadataSuccessfullyAsync()
    {
        // Act
        var restApi = await this._sut.ParseAsync(this._openApiDocument);

        //Assert header parameters metadata
        var acceptParameter = GetParameterMetadata(restApi.Operations, "SetSecret", RestApiParameterLocation.Header, "X-Operation-Csv-Ids");

        Assert.Null(acceptParameter.DefaultValue);
        Assert.False(acceptParameter.IsRequired);
        Assert.Equal("array", acceptParameter.Type);
        Assert.Equal(RestApiParameterStyle.Simple, acceptParameter.Style);
        Assert.Equal("The comma separated list of operation ids.", acceptParameter.Description);
        Assert.Equal("string", acceptParameter.ArrayItemType);
    }

    [Fact]
    public async Task ItCanExtractHeadersSuccessfullyAsync()
    {
        // Act
        var restApi = await this._sut.ParseAsync(this._openApiDocument);

        // Assert
        Assert.True(restApi.Operations.Any());

        var operation = restApi.Operations.Single(o => o.Id == "SetSecret");

        var headerParameters = operation.Parameters.Where(p => p.Location == RestApiParameterLocation.Header);

        Assert.NotNull(headerParameters);
        Assert.Equal(3, headerParameters.Count());

        Assert.Contains(headerParameters, (p) => p.Name == "Accept");
        Assert.Contains(headerParameters, (p) => p.Name == "X-API-Version");
        Assert.Contains(headerParameters, (p) => p.Name == "X-Operation-Csv-Ids");
    }

    [Fact]
    public async Task ItCanExtractAllPathsAsOperationsAsync()
    {
        // Act
        var restApi = await this._sut.ParseAsync(this._openApiDocument);

        // Assert
        Assert.Equal(7, restApi.Operations.Count);
    }

    [Fact]
    public async Task ItCanParseOperationHavingTextPlainBodySuccessfullyAsync()
    {
        // Act
        var restApi = await this._sut.ParseAsync(this._openApiDocument);

        // Assert
        Assert.NotNull(restApi.Operations);
        Assert.True(restApi.Operations.Any());

        var operation = restApi.Operations.Single(o => o.Id == "Excuses");
        Assert.NotNull(operation);

        var payload = operation.Payload;
        Assert.NotNull(payload);
        Assert.Equal("text/plain", payload.MediaType);
        Assert.Equal("excuse event", payload.Description);
        Assert.NotNull(payload.Schema);

        var properties = payload.Properties;
        Assert.NotNull(properties);
        Assert.Empty(properties);
    }

    [Fact]
    public async Task ItCanWorkWithDocumentsWithoutHostAndSchemaAttributesAsync()
    {
        //Arrange
        using var stream = OpenApiTestHelper.ModifyOpenApiDocument(this._openApiDocument, (doc) =>
        {
            doc.Remove("host");
            doc.Remove("schemes");
        });

        //Act
        var restApi = await this._sut.ParseAsync(stream);

        //Assert
        Assert.All(restApi.Operations, (op) => Assert.Null(op.Servers[0].Url));
    }

    [Fact]
    public async Task ItCanParseResponsesSuccessfullyAsync()
    {
        //Act
        var restApi = await this._sut.ParseAsync(this._openApiDocument);

        //Assert
        Assert.NotNull(restApi.Operations);
        Assert.True(restApi.Operations.Any());

        var operation = restApi.Operations.Single(o => o.Id == "Excuses");
        Assert.NotNull(operation);

        operation.Responses.TryGetValue("200", out var response);
        Assert.NotNull(response);
        Assert.Equal("text/plain", response.MediaType);
        Assert.Equal("The OK response", response.Description);
        Assert.NotNull(response.Schema);
        Assert.Equal("string", response.Schema.RootElement.GetProperty("type").GetString());
        Assert.Equal(
            JsonSerializer.Serialize(KernelJsonSchema.Parse("""{"type": "string"}""")),
            JsonSerializer.Serialize(response.Schema));
    }

    [Fact]
    public async Task ItCanWorkWithDefaultParametersOfVariousTypesAsync()
    {
        //Act
        var restApi = await this._sut.ParseAsync(this._openApiDocument);

        //Assert
        Assert.NotNull(restApi.Operations);
        Assert.True(restApi.Operations.Any());

        var operation = restApi.Operations.Single(o => o.Id == "TestDefaultValues");
        Assert.NotNull(operation);

        var parameters = operation.GetParameters();
        Assert.Equal(11, parameters.Count);

        var stringParameter = parameters.Single(p => p.Name == "string-parameter");
        Assert.Equal("string-value", stringParameter.DefaultValue);

        var booleanParameter = parameters.Single(p => p.Name == "boolean-parameter");
        Assert.True(booleanParameter.DefaultValue is bool value);

        var integerParameter = parameters.Single(p => p.Name == "integer-parameter");
        Assert.True(integerParameter.DefaultValue is int);
        Assert.Equal(281, integerParameter.DefaultValue);

        var longParameter = parameters.Single(p => p.Name == "long-parameter");
        Assert.True(longParameter.DefaultValue is long);
        Assert.Equal((long)-2814, longParameter.DefaultValue);

        var floatParameter = parameters.Single(p => p.Name == "float-parameter");
        Assert.True(floatParameter.DefaultValue is float);
        Assert.Equal((float)12.01, floatParameter.DefaultValue);

        var doubleParameter = parameters.Single(p => p.Name == "double-parameter");
        Assert.True(doubleParameter.DefaultValue is double);
        Assert.Equal((double)-12.01, doubleParameter.DefaultValue);

        var encodedCharactersParameter = parameters.Single(p => p.Name == "encoded-characters-parameter");
        Assert.True(encodedCharactersParameter.DefaultValue is byte[]);
        Assert.Equal(new byte[] { 1, 2, 3, 4, 5 }, encodedCharactersParameter.DefaultValue);

        var binaryDataParameter = parameters.Single(p => p.Name == "binary-data-parameter");
        Assert.True(binaryDataParameter.DefaultValue is byte[]);
        Assert.Equal("23456"u8.ToArray(), binaryDataParameter.DefaultValue);

        var dateParameter = parameters.Single(p => p.Name == "date-parameter");
        Assert.True(dateParameter.DefaultValue is DateTime);
        Assert.Equal(new DateTime(2017, 07, 21), dateParameter.DefaultValue);

        var dateTimeParameter = parameters.Single(p => p.Name == "date-time-parameter");
        Assert.True(dateTimeParameter.DefaultValue is DateTimeOffset);
        Assert.Equal(new DateTimeOffset(2017, 07, 21, 17, 32, 28, TimeSpan.Zero), dateTimeParameter.DefaultValue);

        var passwordParameter = parameters.Single(p => p.Name == "password-parameter");
        Assert.True(passwordParameter.DefaultValue is string);
        Assert.Equal("password-value", passwordParameter.DefaultValue);
    }

    [Fact]
    public async Task ItCanParseRestApiInfoAsync()
    {
        //Act
        var restApi = await this._sut.ParseAsync(this._openApiDocument);

        //Assert
        Assert.NotNull(restApi.Info);
        Assert.NotNull(restApi.Info.Title);
        Assert.NotEmpty(restApi.Info.Title);
        Assert.NotNull(restApi.Info.Description);
        Assert.NotEmpty(restApi.Info.Description);
    }

    [Theory]
    [InlineData("string-parameter", "string", null)]
    [InlineData("boolean-parameter", "boolean", null)]
    [InlineData("number-parameter", "number", null)]
    [InlineData("float-parameter", "number", "float")]
    [InlineData("double-parameter", "number", "double")]
    [InlineData("integer-parameter", "integer", null)]
    [InlineData("int32-parameter", "integer", "int32")]
    [InlineData("int64-parameter", "integer", "int64")]
    public async Task ItCanParseParametersOfPrimitiveDataTypeAsync(string name, string type, string? format)
    {
        // Arrange & Act
        var restApiSpec = await this._sut.ParseAsync(this._openApiDocument);

        // Assert
        var parameters = restApiSpec.Operations.Single(o => o.Id == "TestParameterDataTypes").GetParameters();

        var parameter = parameters.FirstOrDefault(p => p.Name == name);
        Assert.NotNull(parameter);

        Assert.Equal(type, parameter.Type);
        Assert.Equal(format, parameter.Format);
    }

    [Fact]
    public async Task ItCanParsePropertiesOfObjectDataTypeAsync()
    {
        // Arrange & Act
        var restApiSpec = await this._sut.ParseAsync(this._openApiDocument);

        // Assert
        var properties = restApiSpec.Operations.Single(o => o.Id == "TestParameterDataTypes").Payload!.Properties;

        var property = properties.Single(p => p.Name == "attributes");
        Assert.Equal("object", property.Type);
        Assert.Null(property.Format);
    }

    [Fact]
    public async Task ItCanFilterOutSpecifiedOperationsAsync()
    {
        // Arrange
        string[] operationsToExclude = ["Excuses", "TestDefaultValues", "OpenApiExtensions", "TestParameterDataTypes", "TestParameterNamesSanitization"];

        var options = new OpenApiDocumentParserOptions
        {
            OperationSelectionPredicate = (context) => !operationsToExclude.Contains(context.Id)
        };

        // Act
        var restApiSpec = await this._sut.ParseAsync(this._openApiDocument, options);

        // Assert
        Assert.Equal(2, restApiSpec.Operations.Count);

        Assert.Contains(restApiSpec.Operations, o => o.Id == "SetSecret");
        Assert.Contains(restApiSpec.Operations, o => o.Id == "GetSecret");
    }

    [Fact]
    public async Task ItCanParsePathItemPathParametersAsync()
    {
        var document =
        """
        {
            "swagger": "2.0",
            "info": {
                "title": "Test API",
                "version": "1.0.0"
            },
            "paths": {
                "/items/{itemId}/{format}": {
                    "parameters": [
                        {
                            "name": "itemId",
                            "in": "path",
                            "required": true,
                            "type": "string"
                        }
                    ],
                    "get": {
                        "parameters": [
                            {
                                "name": "format",
                                "in": "path",
                                "required": true,
                                "type": "string"
                            }
                        ],
                        "summary": "Get an item by ID",
                        "responses": {
                            "200": {
                                "description": "Successful response"
                            }
                        }
                    }
                }
            }
        }
        """;

        await using var steam = new MemoryStream(Encoding.UTF8.GetBytes(document));
        var restApi = await this._sut.ParseAsync(steam);

        Assert.NotNull(restApi);
        Assert.NotNull(restApi.Operations);
        Assert.NotEmpty(restApi.Operations);

        var firstOperation = restApi.Operations[0];

        Assert.NotNull(firstOperation);
        Assert.Equal("Get an item by ID", firstOperation.Description);
        Assert.Equal("/items/{itemId}/{format}", firstOperation.Path);

        var parameters = firstOperation.GetParameters();
        Assert.NotNull(parameters);
        Assert.Equal(2, parameters.Count);

        var pathParameter = parameters.Single(static p => "itemId".Equals(p.Name, StringComparison.OrdinalIgnoreCase));
        Assert.NotNull(pathParameter);
        Assert.True(pathParameter.IsRequired);
        Assert.Equal(RestApiParameterLocation.Path, pathParameter.Location);
        Assert.Null(pathParameter.DefaultValue);
        Assert.NotNull(pathParameter.Schema);
        Assert.Equal("string", pathParameter.Schema.RootElement.GetProperty("type").GetString());

        var formatParameter = parameters.Single(static p => "format".Equals(p.Name, StringComparison.OrdinalIgnoreCase));
        Assert.NotNull(formatParameter);
        Assert.True(formatParameter.IsRequired);
        Assert.Equal(RestApiParameterLocation.Path, formatParameter.Location);
        Assert.Null(formatParameter.DefaultValue);
        Assert.NotNull(formatParameter.Schema);
        Assert.Equal("string", formatParameter.Schema.RootElement.GetProperty("type").GetString());
    }

    [Fact]
    public async Task ItCanParsePathItemPathParametersAndOverridesAsync()
    {
        var document =
        """
        {
            "swagger": "2.0",
            "info": {
                "title": "Test API",
                "version": "1.0.0"
            },
            "paths": {
                "/items/{itemId}/{format}": {
                    "parameters": [
                        {
                            "name": "itemId",
                            "in": "path",
                            "required": true,
                            "type": "string"
                        }
                    ],
                    "get": {
                        "parameters": [
                            {
                                "name": "format",
                                "in": "path",
                                "required": true,
                                "type": "string"
                            },
                            {
                                "name": "itemId",
                                "in": "path",
                                "description": "item ID override",
                                "required": true,
                                "type": "string"
                            }
                        ],
                        "summary": "Get an item by ID",
                        "responses": {
                            "200": {
                                "description": "Successful response"
                            }
                        }
                    }
                }
            }
        }
        """;

        await using var steam = new MemoryStream(Encoding.UTF8.GetBytes(document));
        var restApi = await this._sut.ParseAsync(steam);

        Assert.NotNull(restApi);
        Assert.NotNull(restApi.Operations);
        Assert.NotEmpty(restApi.Operations);

        var firstOperation = restApi.Operations[0];

        Assert.NotNull(firstOperation);
        Assert.Equal("Get an item by ID", firstOperation.Description);
        Assert.Equal("/items/{itemId}/{format}", firstOperation.Path);

        var parameters = firstOperation.GetParameters();
        Assert.NotNull(parameters);
        Assert.Equal(2, parameters.Count);

        var pathParameter = parameters.Single(static p => "itemId".Equals(p.Name, StringComparison.OrdinalIgnoreCase));
        Assert.NotNull(pathParameter);
        Assert.True(pathParameter.IsRequired);
        Assert.Equal(RestApiParameterLocation.Path, pathParameter.Location);
        Assert.Null(pathParameter.DefaultValue);
        Assert.NotNull(pathParameter.Schema);
        Assert.Equal("string", pathParameter.Schema.RootElement.GetProperty("type").GetString());
        Assert.Equal("item ID override", pathParameter.Description);

        var formatParameter = parameters.Single(static p => "format".Equals(p.Name, StringComparison.OrdinalIgnoreCase));
        Assert.NotNull(formatParameter);
        Assert.True(formatParameter.IsRequired);
        Assert.Equal(RestApiParameterLocation.Path, formatParameter.Location);
        Assert.Null(formatParameter.DefaultValue);
        Assert.NotNull(formatParameter.Schema);
        Assert.Equal("string", formatParameter.Schema.RootElement.GetProperty("type").GetString());
    }

    private static RestApiParameter GetParameterMetadata(IList<RestApiOperation> operations, string operationId,
        RestApiParameterLocation location, string name)
    {
        Assert.True(operations.Any());

        var operation = operations.Single(o => o.Id == operationId);
        Assert.NotNull(operation.Parameters);
        Assert.True(operation.Parameters.Any());

        var parameters = operation.Parameters.Where(p => p.Location == location);

        var parameter = parameters.Single(p => p.Name == name);
        Assert.NotNull(parameter);

        return parameter;
    }

    public void Dispose()
    {
        this._openApiDocument.Dispose();
    }
}


===== Functions.UnitTests\OpenApi\OpenApiDocumentParserV30FeatureTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.IO;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.SemanticKernel.Plugins.OpenApi;
using SemanticKernel.Functions.UnitTests.OpenApi.TestPlugins;
using Xunit;

namespace SemanticKernel.Functions.UnitTests.OpenApi;

public class OpenApiDocumentParserV30FeatureTests
{
    /// <summary>
    /// OpenAPI document stream.
    /// </summary>
    private readonly Stream _openApiDocument;

    /// <summary>
    /// System under test - an instance of OpenApiDocumentParser class.
    /// </summary>
    private readonly OpenApiDocumentParser _parser;

    public OpenApiDocumentParserV30FeatureTests()
    {
        this._openApiDocument = ResourcePluginsProvider.LoadFromResource("openapi_feature_testsV3_0.json");
        this._parser = new OpenApiDocumentParser();
    }

    [Fact]
    public async Task ItCanParseAllOfAsync()
    {
        var spec = await this._parser.ParseAsync(this._openApiDocument);

        Assert.NotEmpty(spec.Operations);
        var op0 = spec.Operations.Single(static x => x.Id == "allOfGet");
        Assert.NotEmpty(op0.Responses);
        var res200 = op0.Responses["200"];
        Assert.NotNull(res200.Schema);
        var foo = res200.Schema.RootElement.GetProperty("allOf")[0];
        Assert.Equal("object", foo.GetProperty("type").GetString());
        var bar = res200.Schema.RootElement.GetProperty("allOf")[1];
        Assert.Equal("object", bar.GetProperty("type").GetString());
    }

    [Fact]
    public async Task ItCanParseAnyOfAsync()
    {
        var spec = await this._parser.ParseAsync(this._openApiDocument);

        Assert.NotEmpty(spec.Operations);
        var op0 = spec.Operations.Single(static x => x.Id == "anyOfGet");
        Assert.NotEmpty(op0.Responses);
        var res200 = op0.Responses["200"];
        Assert.NotNull(res200.Schema);
        var foo = res200.Schema.RootElement.GetProperty("anyOf")[0];
        Assert.Equal("object", foo.GetProperty("type").GetString());
        var bar = res200.Schema.RootElement.GetProperty("anyOf")[1];
        Assert.Equal("string", bar.GetProperty("type").GetString());
    }

    [Fact]
    public async Task ItCanParseOneOfAsync()
    {
        var spec = await this._parser.ParseAsync(this._openApiDocument);

        Assert.NotEmpty(spec.Operations);
        var op0 = spec.Operations.Single(static x => x.Id == "oneOfGet");
        Assert.NotEmpty(op0.Responses);
        var res200 = op0.Responses["200"];
        Assert.NotNull(res200.Schema);
        var foo = res200.Schema.RootElement.GetProperty("oneOf")[0];
        Assert.Equal("object", foo.GetProperty("type").GetString());
        var bar = res200.Schema.RootElement.GetProperty("oneOf")[1];
        Assert.Equal("string", bar.GetProperty("type").GetString());
    }
}


===== Functions.UnitTests\OpenApi\OpenApiDocumentParserV30Tests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Text;
using System.Text.Json;
using System.Text.Json.Nodes;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.OpenApi.Models;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Plugins.OpenApi;
using SemanticKernel.Functions.UnitTests.OpenApi.TestPlugins;
using Xunit;

namespace SemanticKernel.Functions.UnitTests.OpenApi;

public sealed class OpenApiDocumentParserV30Tests : IDisposable
{
    /// <summary>
    /// System under test - an instance of OpenApiDocumentParser class.
    /// </summary>
    private readonly OpenApiDocumentParser _sut;

    /// <summary>
    /// OpenAPI document stream.
    /// </summary>
    private readonly Stream _openApiDocument;

    /// <summary>
    /// Logger instance.
    /// </summary>
    private readonly ILogger _logger = new LoggerFactory().CreateLogger<OpenApiDocumentParserV30Tests>();

    /// <summary>
    /// Creates an instance of a <see cref="OpenApiDocumentParserV30Tests"/> class.
    /// </summary>
    public OpenApiDocumentParserV30Tests()
    {
        this._openApiDocument = ResourcePluginsProvider.LoadFromResource("documentV3_0.json");

        this._sut = new OpenApiDocumentParser();
    }

    [Fact]
    public async Task ItCanParsePutOperationBodySuccessfullyAsync()
    {
        // Act
        var restApi = await this._sut.ParseAsync(this._openApiDocument);

        // Assert
        Assert.NotNull(restApi.Operations);
        Assert.True(restApi.Operations.Any());

        var putOperation = restApi.Operations.Single(o => o.Id == "SetSecret");
        Assert.NotNull(putOperation);

        var payload = putOperation.Payload;
        Assert.NotNull(payload);
        Assert.Equal("application/json", payload.MediaType);

        var properties = payload.Properties;
        Assert.NotNull(properties);
        Assert.Equal(2, properties.Count);

        var valueProperty = properties.FirstOrDefault(p => p.Name == "value");
        Assert.NotNull(valueProperty);
        Assert.True(valueProperty.IsRequired);
        Assert.Equal("The value of the secret.", valueProperty.Description);
        Assert.Equal("string", valueProperty.Type);
        Assert.NotNull(valueProperty.Properties);
        Assert.False(valueProperty.Properties.Any());
        Assert.NotNull(valueProperty.Schema);
        Assert.Equal("string", valueProperty.Schema.RootElement.GetProperty("type").GetString());
        Assert.Equal("The value of the secret.", valueProperty.Schema.RootElement.GetProperty("description").GetString());

        var attributesProperty = properties.FirstOrDefault(p => p.Name == "attributes");
        Assert.NotNull(attributesProperty);
        Assert.False(attributesProperty.IsRequired);
        Assert.Equal("attributes", attributesProperty.Description);
        Assert.Equal("object", attributesProperty.Type);
        Assert.NotNull(attributesProperty.Properties);
        Assert.True(attributesProperty.Properties.Any());
        Assert.NotNull(attributesProperty.Schema);
        Assert.Equal("object", attributesProperty.Schema.RootElement.GetProperty("type").GetString());
        Assert.Equal("attributes", attributesProperty.Schema.RootElement.GetProperty("description").GetString());

        var enabledProperty = attributesProperty.Properties.FirstOrDefault(p => p.Name == "enabled");
        Assert.NotNull(enabledProperty);
        Assert.True(enabledProperty.IsRequired);
        Assert.Equal("Determines whether the object is enabled.", enabledProperty.Description);
        Assert.Equal("boolean", enabledProperty.Type);
        Assert.False(enabledProperty.Properties?.Any());
        Assert.NotNull(enabledProperty.Schema);
        Assert.Equal("boolean", enabledProperty.Schema.RootElement.GetProperty("type").GetString());
        Assert.Equal("Determines whether the object is enabled.", enabledProperty.Schema.RootElement.GetProperty("description").GetString());

        var encryptedProperty = attributesProperty.Properties.FirstOrDefault(p => p.Name == "encrypted");
        Assert.NotNull(encryptedProperty);
        Assert.False(encryptedProperty.IsRequired);
        Assert.Equal("Determines whether the object is encrypted.", encryptedProperty.Description);
        Assert.Equal("boolean", encryptedProperty.Type);
        Assert.False(encryptedProperty.Properties?.Any());
        Assert.NotNull(encryptedProperty.Schema);
        Assert.Equal("boolean", encryptedProperty.Schema.RootElement.GetProperty("type").GetString());
        Assert.Equal("Determines whether the object is encrypted.", encryptedProperty.Schema.RootElement.GetProperty("description").GetString());
    }

    [Fact]
    public async Task ItCanParsePutOperationMetadataSuccessfullyAsync()
    {
        // Act
        var restApi = await this._sut.ParseAsync(this._openApiDocument);

        // Assert
        Assert.NotNull(restApi.Operations);
        Assert.True(restApi.Operations.Any());

        var putOperation = restApi.Operations.Single(o => o.Id == "SetSecret");
        Assert.NotNull(putOperation);
        Assert.Equal("Sets a secret in a specified key vault.", putOperation.Description);
        Assert.Equal("Create or update secret value", putOperation.Summary);
        Assert.Equal("https://my-key-vault.vault.azure.net", putOperation.Servers[0].Url);
        Assert.Equal(HttpMethod.Put, putOperation.Method);
        Assert.Equal("/secrets/{secret-name}", putOperation.Path);

        var parameters = putOperation.GetParameters(addPayloadParamsFromMetadata: false);
        Assert.NotNull(parameters);
        Assert.True(parameters.Count >= 5);

        var pathParameter = parameters.Single(p => p.Name == "secret-name"); //'secret-name' path parameter.
        Assert.True(pathParameter.IsRequired);
        Assert.Equal(RestApiParameterLocation.Path, pathParameter.Location);
        Assert.Null(pathParameter.DefaultValue);
        Assert.NotNull(pathParameter.Schema);
        Assert.Equal("string", pathParameter.Schema.RootElement.GetProperty("type").GetString());

        var apiVersionParameter = parameters.Single(p => p.Name == "api-version"); //'api-version' query string parameter.
        Assert.True(apiVersionParameter.IsRequired);
        Assert.Equal(RestApiParameterLocation.Query, apiVersionParameter.Location);
        Assert.Equal("7.0", apiVersionParameter.DefaultValue);
        Assert.NotNull(apiVersionParameter.Schema);
        Assert.Equal("string", apiVersionParameter.Schema.RootElement.GetProperty("type").GetString());
        Assert.Equal("7.0", apiVersionParameter.Schema.RootElement.GetProperty("default").GetString());

        var payloadParameter = parameters.Single(p => p.Name == "payload"); //'payload' artificial parameter.
        Assert.True(payloadParameter.IsRequired);
        Assert.Equal(RestApiParameterLocation.Body, payloadParameter.Location);
        Assert.Null(payloadParameter.DefaultValue);
        Assert.Equal("REST API request body.", payloadParameter.Description);
        Assert.NotNull(payloadParameter.Schema);
        Assert.Equal("object", payloadParameter.Schema.RootElement.GetProperty("type").GetString());

        var contentTypeParameter = parameters.Single(p => p.Name == "content-type"); //'content-type' artificial parameter.
        Assert.False(contentTypeParameter.IsRequired);
        Assert.Equal(RestApiParameterLocation.Body, contentTypeParameter.Location);
        Assert.Null(contentTypeParameter.DefaultValue);
        Assert.Equal("Content type of REST API request body.", contentTypeParameter.Description);
        Assert.Null(contentTypeParameter.Schema);
    }

    [Fact]
    public async Task ItCanExtractSimpleTypeHeaderParameterMetadataSuccessfullyAsync()
    {
        // Act
        var restApi = await this._sut.ParseAsync(this._openApiDocument);

        //Assert string header parameter metadata
        var accept = GetParameterMetadata(restApi.Operations, "SetSecret", RestApiParameterLocation.Header, "Accept");

        Assert.Equal("string", accept.Type);
        Assert.Equal("application/json", accept.DefaultValue);
        Assert.Equal("Indicates which content types, expressed as MIME types, the client is able to understand.", accept.Description);
        Assert.False(accept.IsRequired);

        //Assert integer header parameter metadata
        var apiVersion = GetParameterMetadata(restApi.Operations, "SetSecret", RestApiParameterLocation.Header, "X-API-Version");

        Assert.Equal("integer", apiVersion.Type);
        Assert.Equal(10, apiVersion.DefaultValue);
        Assert.Equal("Requested API version.", apiVersion.Description);
        Assert.True(apiVersion.IsRequired);
    }

    [Fact]
    public async Task ItCanUseOperationSummaryAsync()
    {
        // Act
        var restApi = await this._sut.ParseAsync(this._openApiDocument);

        // Assert
        Assert.NotNull(restApi.Operations);
        Assert.True(restApi.Operations.Any());

        var operation = restApi.Operations.Single(o => o.Id == "Excuses");
        Assert.NotNull(operation);
        Assert.Equal("Turn a scenario into a creative or humorous excuse to send your boss", operation.Description);
        Assert.Equal("Turn a scenario into a creative or humorous excuse to send your boss", operation.Summary);
    }

    [Fact]
    public async Task ItCanExtractCsvStyleHeaderParameterMetadataSuccessfullyAsync()
    {
        // Act
        var restApi = await this._sut.ParseAsync(this._openApiDocument);

        //Assert header parameters metadata
        var acceptParameter = GetParameterMetadata(restApi.Operations, "SetSecret", RestApiParameterLocation.Header, "X-Operation-Csv-Ids");

        Assert.Null(acceptParameter.DefaultValue);
        Assert.False(acceptParameter.IsRequired);
        Assert.Equal("array", acceptParameter.Type);
        Assert.Equal(RestApiParameterStyle.Simple, acceptParameter.Style);
        Assert.Equal("The comma separated list of operation ids.", acceptParameter.Description);
        Assert.Equal("string", acceptParameter.ArrayItemType);
    }

    [Fact]
    public async Task ItCanExtractHeadersSuccessfullyAsync()
    {
        // Act
        var restApi = await this._sut.ParseAsync(this._openApiDocument);

        // Assert
        Assert.True(restApi.Operations.Any());

        var operation = restApi.Operations.Single(o => o.Id == "SetSecret");

        var headerParameters = operation.Parameters.Where(p => p.Location == RestApiParameterLocation.Header);

        Assert.NotNull(headerParameters);
        Assert.Equal(3, headerParameters.Count());

        Assert.Contains(headerParameters, (p) => p.Name == "Accept");
        Assert.Contains(headerParameters, (p) => p.Name == "X-API-Version");
        Assert.Contains(headerParameters, (p) => p.Name == "X-Operation-Csv-Ids");
    }

    [Fact]
    public async Task ItCanExtractAllPathsAsOperationsAsync()
    {
        // Act
        var restApi = await this._sut.ParseAsync(this._openApiDocument);

        // Assert
        Assert.Equal(8, restApi.Operations.Count);
    }

    [Fact]
    public async Task ItCanParseOperationHavingTextPlainBodySuccessfullyAsync()
    {
        // Act
        var restApi = await this._sut.ParseAsync(this._openApiDocument);

        // Assert
        Assert.NotNull(restApi.Operations);
        Assert.True(restApi.Operations.Any());

        var operation = restApi.Operations.Single(o => o.Id == "Excuses");
        Assert.NotNull(operation);

        var payload = operation.Payload;
        Assert.NotNull(payload);
        Assert.Equal("text/plain", payload.MediaType);
        Assert.Equal("excuse event", payload.Description);
        Assert.NotNull(payload.Schema);

        var properties = payload.Properties;
        Assert.NotNull(properties);
        Assert.Empty(properties);
    }

    [Fact]
    public async Task ItShouldThrowExceptionForNonCompliantDocumentAsync()
    {
        // Arrange
        var nonComplaintOpenApiDocument = ResourcePluginsProvider.LoadFromResource("nonCompliant_documentV3_0.json");

        // Act and Assert
        await Assert.ThrowsAsync<KernelException>(async () => await this._sut.ParseAsync(nonComplaintOpenApiDocument));
    }

    [Fact]
    public async Task ItShouldWorkWithNonCompliantDocumentIfAllowedAsync()
    {
        // Arrange
        var nonComplaintOpenApiDocument = ResourcePluginsProvider.LoadFromResource("nonCompliant_documentV3_0.json");

        // Act
        await this._sut.ParseAsync(nonComplaintOpenApiDocument, new OpenApiDocumentParserOptions() { IgnoreNonCompliantErrors = true });

        // Assert
        // The absence of any thrown exceptions serves as evidence of the functionality's success.
    }

    [Fact]
    public async Task ItCanWorkWithDocumentsWithoutServersAttributeAsync()
    {
        //Arrange
        using var stream = ModifyOpenApiDocument(this._openApiDocument, (doc) =>
        {
            doc.Remove("servers");
        });

        //Act
        var restApi = await this._sut.ParseAsync(stream);

        //Assert
        Assert.All(restApi.Operations, (op) => Assert.Empty(op.Servers));
    }

    [Fact]
    public async Task ItCanWorkWithDocumentsWithEmptyServersAttributeAsync()
    {
        //Arrange
        using var stream = ModifyOpenApiDocument(this._openApiDocument, (doc) =>
        {
            doc["servers"] = new JsonArray();
        });

        //Act
        var restApi = await this._sut.ParseAsync(stream);

        //Assert
        Assert.All(restApi.Operations, (op) => Assert.Empty(op.Servers));
    }

    [Theory]
    [InlineData("explodeFormParam")]
    [InlineData("anotherExplodeFormParam")]
    public async Task ItShouldSupportsAmpersandSeparatedParametersForFormStyleArrayQueryStringParametersAsync(string parameterName)
    {
        //Act
        var restApi = await this._sut.ParseAsync(this._openApiDocument);

        //Assert
        Assert.True(restApi.Operations.Any());

        var operation = restApi.Operations.Single(o => o.Id == "GetSecret");

        var explodeFormParam = operation.Parameters.Single(p => p.Name == parameterName);

        Assert.True(explodeFormParam.Expand);
    }

    [Fact]
    public async Task ItShouldSupportsCommaSeparatedValuesForFormStyleArrayQueryStringParametersAsync()
    {
        //Act
        var restApi = await this._sut.ParseAsync(this._openApiDocument);

        //Assert
        Assert.True(restApi.Operations.Any());

        var operation = restApi.Operations.Single(o => o.Id == "GetSecret");

        var explodeFormParam = operation.Parameters.Single(p => p.Name == "nonExplodeFormParam");

        Assert.False(explodeFormParam.Expand);
    }

    [Fact]
    public async Task ItCanParseResponsesSuccessfullyAsync()
    {
        //Act
        var restApi = await this._sut.ParseAsync(this._openApiDocument);

        //Assert
        Assert.NotNull(restApi.Operations);
        Assert.True(restApi.Operations.Any());

        var operation = restApi.Operations.Single(o => o.Id == "Excuses");
        Assert.NotNull(operation);

        operation.Responses.TryGetValue("200", out var response);
        Assert.NotNull(response);
        Assert.Equal("text/plain", response.MediaType);
        Assert.Equal("The OK response", response.Description);
        Assert.NotNull(response.Schema);
        Assert.Equal("string", response.Schema.RootElement.GetProperty("type").GetString());
        Assert.Equal(
            JsonSerializer.Serialize(KernelJsonSchema.Parse("""{"type": "string"}""")),
            JsonSerializer.Serialize(response.Schema));
    }

    [Fact]
    public async Task ItCanWorkWithDefaultParametersOfVariousTypesAsync()
    {
        //Act
        var restApi = await this._sut.ParseAsync(this._openApiDocument);

        //Assert
        Assert.NotNull(restApi.Operations);
        Assert.True(restApi.Operations.Any());

        var operation = restApi.Operations.Single(o => o.Id == "TestDefaultValues");
        Assert.NotNull(operation);

        var parameters = operation.GetParameters();
        Assert.Equal(11, parameters.Count);

        var stringParameter = parameters.Single(p => p.Name == "string-parameter");
        Assert.Equal("string-value", stringParameter.DefaultValue);

        var booleanParameter = parameters.Single(p => p.Name == "boolean-parameter");
        Assert.True(booleanParameter.DefaultValue is bool value);

        var integerParameter = parameters.Single(p => p.Name == "integer-parameter");
        Assert.True(integerParameter.DefaultValue is int);
        Assert.Equal(281, integerParameter.DefaultValue);

        var longParameter = parameters.Single(p => p.Name == "long-parameter");
        Assert.True(longParameter.DefaultValue is long);
        Assert.Equal((long)-2814, longParameter.DefaultValue);

        var floatParameter = parameters.Single(p => p.Name == "float-parameter");
        Assert.True(floatParameter.DefaultValue is float);
        Assert.Equal((float)12.01, floatParameter.DefaultValue);

        var doubleParameter = parameters.Single(p => p.Name == "double-parameter");
        Assert.True(doubleParameter.DefaultValue is double);
        Assert.Equal((double)-12.01, doubleParameter.DefaultValue);

        var encodedCharactersParameter = parameters.Single(p => p.Name == "encoded-characters-parameter");
        Assert.True(encodedCharactersParameter.DefaultValue is byte[]);
        Assert.Equal(new byte[] { 1, 2, 3, 4, 5 }, encodedCharactersParameter.DefaultValue);

        var binaryDataParameter = parameters.Single(p => p.Name == "binary-data-parameter");
        Assert.True(binaryDataParameter.DefaultValue is byte[]);
        Assert.Equal("23456"u8.ToArray(), binaryDataParameter.DefaultValue);

        var dateParameter = parameters.Single(p => p.Name == "date-parameter");
        Assert.True(dateParameter.DefaultValue is DateTime);
        Assert.Equal(new DateTime(2017, 07, 21), dateParameter.DefaultValue);

        var dateTimeParameter = parameters.Single(p => p.Name == "date-time-parameter");
        Assert.True(dateTimeParameter.DefaultValue is DateTimeOffset);
        Assert.Equal(new DateTimeOffset(2017, 07, 21, 17, 32, 28, TimeSpan.Zero), dateTimeParameter.DefaultValue);

        var passwordParameter = parameters.Single(p => p.Name == "password-parameter");
        Assert.True(passwordParameter.DefaultValue is string);
        Assert.Equal("password-value", passwordParameter.DefaultValue);
    }

    [Fact]
    public async Task ItCanParseRestApiInfoAsync()
    {
        //Act
        var restApi = await this._sut.ParseAsync(this._openApiDocument);

        //Assert
        Assert.NotNull(restApi.Info);
        Assert.NotNull(restApi.Info.Title);
        Assert.NotEmpty(restApi.Info.Title);
        Assert.NotNull(restApi.Info.Description);
        Assert.NotEmpty(restApi.Info.Description);
    }

    [Theory]
    [InlineData("string-parameter", "string", null)]
    [InlineData("boolean-parameter", "boolean", null)]
    [InlineData("number-parameter", "number", null)]
    [InlineData("float-parameter", "number", "float")]
    [InlineData("double-parameter", "number", "double")]
    [InlineData("integer-parameter", "integer", null)]
    [InlineData("int32-parameter", "integer", "int32")]
    [InlineData("int64-parameter", "integer", "int64")]
    public async Task ItCanParseParametersOfPrimitiveDataTypeAsync(string name, string type, string? format)
    {
        // Arrange & Act
        var restApiSpec = await this._sut.ParseAsync(this._openApiDocument);

        // Assert
        var parameters = restApiSpec.Operations.Single(o => o.Id == "TestParameterDataTypes").GetParameters();

        var parameter = parameters.FirstOrDefault(p => p.Name == name);
        Assert.NotNull(parameter);

        Assert.Equal(type, parameter.Type);
        Assert.Equal(format, parameter.Format);
    }

    [Fact]
    public async Task ItCanParsePropertiesOfObjectDataTypeAsync()
    {
        // Arrange & Act
        var restApiSpec = await this._sut.ParseAsync(this._openApiDocument);

        // Assert
        var properties = restApiSpec.Operations.Single(o => o.Id == "TestParameterDataTypes").Payload!.Properties;

        var property = properties.Single(p => p.Name == "attributes");
        Assert.Equal("object", property.Type);
        Assert.Null(property.Format);
    }

    [Fact]
    public async Task ItCanParseDocumentWithMultipleServersAsync()
    {
        // Act
        var restApi = await this._sut.ParseAsync(this._openApiDocument);

        // Assert
        Assert.All(restApi.Operations, (operation) => Assert.Equal(2, operation.Servers.Count));

        Assert.Equal("https://my-key-vault.vault.azure.net", restApi.Operations[0].Servers[0].Url);
        Assert.Equal("https://ppe.my-key-vault.vault.azure.net", restApi.Operations[0].Servers[1].Url);
    }

    [Fact]
    public async Task ItCanParsePathItemPathParametersAsync()
    {
        var document =
        """
        {
            "openapi": "3.0.0",
            "info": {
                "title": "Test API",
                "version": "1.0.0"
            },
            "paths": {
                "/items/{itemId}/{format}": {
                    "parameters": [
                        {
                            "name": "itemId",
                            "in": "path",
                            "required": true,
                            "schema": {
                                "type": "string"
                            }
                        }
                    ],
                    "get": {
                        "parameters": [
                            {
                                "name": "format",
                                "in": "path",
                                "required": true,
                                "schema": {
                                    "type": "string"
                                }
                            }
                        ],
                        "summary": "Get an item by ID",
                        "responses": {
                            "200": {
                                "description": "Successful response"
                            }
                        }
                    }
                }
            }
        }
        """;

        await using var steam = new MemoryStream(Encoding.UTF8.GetBytes(document));
        var restApi = await this._sut.ParseAsync(steam);

        Assert.NotNull(restApi);
        Assert.NotNull(restApi.Operations);
        Assert.NotEmpty(restApi.Operations);

        var firstOperation = restApi.Operations[0];

        Assert.NotNull(firstOperation);
        Assert.Equal("Get an item by ID", firstOperation.Description);
        Assert.Equal("/items/{itemId}/{format}", firstOperation.Path);

        var parameters = firstOperation.GetParameters();
        Assert.NotNull(parameters);
        Assert.Equal(2, parameters.Count);

        var pathParameter = parameters.Single(static p => "itemId".Equals(p.Name, StringComparison.OrdinalIgnoreCase));
        Assert.NotNull(pathParameter);
        Assert.True(pathParameter.IsRequired);
        Assert.Equal(RestApiParameterLocation.Path, pathParameter.Location);
        Assert.Null(pathParameter.DefaultValue);
        Assert.NotNull(pathParameter.Schema);
        Assert.Equal("string", pathParameter.Schema.RootElement.GetProperty("type").GetString());

        var formatParameter = parameters.Single(static p => "format".Equals(p.Name, StringComparison.OrdinalIgnoreCase));
        Assert.NotNull(formatParameter);
        Assert.True(formatParameter.IsRequired);
        Assert.Equal(RestApiParameterLocation.Path, formatParameter.Location);
        Assert.Null(formatParameter.DefaultValue);
        Assert.NotNull(formatParameter.Schema);
        Assert.Equal("string", formatParameter.Schema.RootElement.GetProperty("type").GetString());
    }

    [Fact]
    public async Task ItCanParsePathItemPathParametersAndOverridesAsync()
    {
        var document =
        """
        {
            "openapi": "3.0.0",
            "info": {
                "title": "Test API",
                "version": "1.0.0"
            },
            "paths": {
                "/items/{itemId}/{format}": {
                    "parameters": [
                        {
                            "name": "itemId",
                            "in": "path",
                            "required": true,
                            "schema": {
                                "type": "string"
                            }
                        }
                    ],
                    "get": {
                        "parameters": [
                            {
                                "name": "format",
                                "in": "path",
                                "required": true,
                                "schema": {
                                    "type": "string"
                                }
                            },
                            {
                                "name": "itemId",
                                "in": "path",
                                "description": "item ID override",
                                "required": true,
                                "schema": {
                                    "type": "string"
                                }
                            }
                        ],
                        "summary": "Get an item by ID",
                        "responses": {
                            "200": {
                                "description": "Successful response"
                            }
                        }
                    }
                }
            }
        }
        """;

        await using var steam = new MemoryStream(Encoding.UTF8.GetBytes(document));
        var restApi = await this._sut.ParseAsync(steam);

        Assert.NotNull(restApi);
        Assert.NotNull(restApi.Operations);
        Assert.NotEmpty(restApi.Operations);

        var firstOperation = restApi.Operations[0];

        Assert.NotNull(firstOperation);
        Assert.Equal("Get an item by ID", firstOperation.Description);
        Assert.Equal("/items/{itemId}/{format}", firstOperation.Path);

        var parameters = firstOperation.GetParameters();
        Assert.NotNull(parameters);
        Assert.Equal(2, parameters.Count);

        var pathParameter = parameters.Single(static p => "itemId".Equals(p.Name, StringComparison.OrdinalIgnoreCase));
        Assert.NotNull(pathParameter);
        Assert.True(pathParameter.IsRequired);
        Assert.Equal(RestApiParameterLocation.Path, pathParameter.Location);
        Assert.Null(pathParameter.DefaultValue);
        Assert.NotNull(pathParameter.Schema);
        Assert.Equal("string", pathParameter.Schema.RootElement.GetProperty("type").GetString());
        Assert.Equal("item ID override", pathParameter.Description);

        var formatParameter = parameters.Single(static p => "format".Equals(p.Name, StringComparison.OrdinalIgnoreCase));
        Assert.NotNull(formatParameter);
        Assert.True(formatParameter.IsRequired);
        Assert.Equal(RestApiParameterLocation.Path, formatParameter.Location);
        Assert.Null(formatParameter.DefaultValue);
        Assert.NotNull(formatParameter.Schema);
        Assert.Equal("string", formatParameter.Schema.RootElement.GetProperty("type").GetString());
    }

    [Fact]
    public void ItCanVerifyAllServerLevelsAreStoredCorrectly()
    {
        // Arrange
        var document = new OpenApiDocument
        {
            Servers = new List<OpenApiServer>
        {
            new() { Url = "https://global-server.com", Description = "Global server" }
        }
        };

        var pathItem = new OpenApiPathItem
        {
            Servers = new List<OpenApiServer>
        {
            new() { Url = "https://path-server.com", Description = "Path server" }
        },
            Operations = new Dictionary<OperationType, OpenApiOperation>
            {
                [OperationType.Get] = new OpenApiOperation
                {
                    OperationId = "GetTest",
                    Servers = new List<OpenApiServer>
                {
                    new() { Url = "https://operation-server.com", Description = "Operation server" }
                },
                    Responses = new OpenApiResponses()
                }
            }
        };

        // Act
        var operations = OpenApiDocumentParser.CreateRestApiOperations(document, "/test", pathItem, null, this._logger);
        var operation = operations[0];

        // Assert
        // Verify servers
        Assert.Single(operation.Servers);
        Assert.Equal("https://global-server.com", operation.Servers[0].Url);
        Assert.Equal("Global server", operation.Servers[0].Description);

        // Verify path servers
        Assert.Single(operation.PathServers);
        Assert.Equal("https://path-server.com", operation.PathServers[0].Url);
        Assert.Equal("Path server", operation.PathServers[0].Description);

        // Verify operation servers
        Assert.Single(operation.OperationServers);
        Assert.Equal("https://operation-server.com", operation.OperationServers[0].Url);
        Assert.Equal("Operation server", operation.OperationServers[0].Description);
    }

    private static MemoryStream ModifyOpenApiDocument(Stream openApiDocument, Action<JsonObject> transformer)
    {
        var json = JsonSerializer.Deserialize<JsonObject>(openApiDocument);

        transformer(json!);

        var stream = new MemoryStream();

        JsonSerializer.Serialize(stream, json);

        stream.Seek(0, SeekOrigin.Begin);

        return stream;
    }

    private static RestApiParameter GetParameterMetadata(IList<RestApiOperation> operations, string operationId,
        RestApiParameterLocation location, string name)
    {
        Assert.True(operations.Any());

        var operation = operations.Single(o => o.Id == operationId);
        Assert.NotNull(operation.Parameters);
        Assert.True(operation.Parameters.Any());

        var parameters = operation.Parameters.Where(p => p.Location == location);

        var parameter = parameters.Single(p => p.Name == name);
        Assert.NotNull(parameter);

        return parameter;
    }

    public void Dispose()
    {
        this._openApiDocument.Dispose();
    }
}


===== Functions.UnitTests\OpenApi\OpenApiDocumentParserV31Tests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Dynamic;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.OpenApi.Models;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Plugins.OpenApi;
using SemanticKernel.Functions.UnitTests.OpenApi.TestPlugins;
using Xunit;

namespace SemanticKernel.Functions.UnitTests.OpenApi;

public sealed class OpenApiDocumentParserV31Tests : IDisposable
{
    /// <summary>
    /// System under test - an instance of OpenApiDocumentParser class.
    /// </summary>
    private readonly OpenApiDocumentParser _sut;

    /// <summary>
    /// OpenAPI document stream.
    /// </summary>
    private readonly Stream _openApiDocument;

    /// <summary>
    /// Logger instance.
    /// </summary>
    private readonly ILogger _logger = new LoggerFactory().CreateLogger<OpenApiDocumentParserV30Tests>();

    /// <summary>
    /// Creates an instance of a <see cref="OpenApiDocumentParserV31Tests"/> class.
    /// </summary>
    public OpenApiDocumentParserV31Tests()
    {
        this._openApiDocument = ResourcePluginsProvider.LoadFromResource("documentV3_1.yaml");

        this._sut = new OpenApiDocumentParser();
    }

    [Fact]
    public async Task ItCanParsePutOperationBodySuccessfullyAsync()
    {
        // Act
        var restApi = await this._sut.ParseAsync(this._openApiDocument);

        // Assert
        Assert.NotNull(restApi.Operations);
        Assert.True(restApi.Operations.Any());

        var putOperation = restApi.Operations.Single(o => o.Id == "SetSecret");
        Assert.NotNull(putOperation);

        var payload = putOperation.Payload;
        Assert.NotNull(payload);
        Assert.Equal("application/json", payload.MediaType);

        var properties = payload.Properties;
        Assert.NotNull(properties);
        Assert.Equal(2, properties.Count);

        var valueProperty = properties.FirstOrDefault(p => p.Name == "value");
        Assert.NotNull(valueProperty);
        Assert.True(valueProperty.IsRequired);
        Assert.Equal("The value of the secret.", valueProperty.Description);
        Assert.Equal("string", valueProperty.Type);
        Assert.NotNull(valueProperty.Properties);
        Assert.False(valueProperty.Properties.Any());
        Assert.NotNull(valueProperty.Schema);
        Assert.Equal("string", valueProperty.Schema.RootElement.GetProperty("type").GetString());
        Assert.Equal("The value of the secret.", valueProperty.Schema.RootElement.GetProperty("description").GetString());

        var attributesProperty = properties.FirstOrDefault(p => p.Name == "attributes");
        Assert.NotNull(attributesProperty);
        Assert.False(attributesProperty.IsRequired);
        Assert.Equal("attributes", attributesProperty.Description);
        Assert.Equal("object", attributesProperty.Type);
        Assert.NotNull(attributesProperty.Properties);
        Assert.True(attributesProperty.Properties.Any());
        Assert.NotNull(attributesProperty.Schema);
        Assert.Equal("object", attributesProperty.Schema.RootElement.GetProperty("type").GetString());
        Assert.Equal("attributes", attributesProperty.Schema.RootElement.GetProperty("description").GetString());

        var enabledProperty = attributesProperty.Properties.FirstOrDefault(p => p.Name == "enabled");
        Assert.NotNull(enabledProperty);
        Assert.True(enabledProperty.IsRequired);
        Assert.Equal("Determines whether the object is enabled.", enabledProperty.Description);
        Assert.Equal("boolean", enabledProperty.Type);
        Assert.False(enabledProperty.Properties?.Any());
        Assert.NotNull(enabledProperty.Schema);
        Assert.Equal("boolean", enabledProperty.Schema.RootElement.GetProperty("type").GetString());
        Assert.Equal("Determines whether the object is enabled.", enabledProperty.Schema.RootElement.GetProperty("description").GetString());

        var encryptedProperty = attributesProperty.Properties.FirstOrDefault(p => p.Name == "encrypted");
        Assert.NotNull(encryptedProperty);
        Assert.False(encryptedProperty.IsRequired);
        Assert.Equal("Determines whether the object is encrypted.", encryptedProperty.Description);
        Assert.Equal("boolean", encryptedProperty.Type);
        Assert.False(encryptedProperty.Properties?.Any());
        Assert.NotNull(encryptedProperty.Schema);
        Assert.Equal("boolean", encryptedProperty.Schema.RootElement.GetProperty("type").GetString());
        Assert.Equal("Determines whether the object is encrypted.", encryptedProperty.Schema.RootElement.GetProperty("description").GetString());
    }

    [Fact]
    public async Task ItCanParsePutOperationMetadataSuccessfullyAsync()
    {
        // Act
        var restApi = await this._sut.ParseAsync(this._openApiDocument);

        // Assert
        Assert.NotNull(restApi.Operations);
        Assert.True(restApi.Operations.Any());

        var putOperation = restApi.Operations.Single(o => o.Id == "SetSecret");
        Assert.NotNull(putOperation);
        Assert.Equal("Sets a secret in a specified key vault.", putOperation.Description);
        Assert.Equal("Create or update secret value", putOperation.Summary);
        Assert.Equal("https://my-key-vault.vault.azure.net", putOperation.Servers[0].Url);
        Assert.Equal(HttpMethod.Put, putOperation.Method);
        Assert.Equal("/secrets/{secret-name}", putOperation.Path);

        var parameters = putOperation.GetParameters(addPayloadParamsFromMetadata: false);
        Assert.NotNull(parameters);
        Assert.True(parameters.Count >= 5);

        var pathParameter = parameters.Single(p => p.Name == "secret-name"); //'secret-name' path parameter.
        Assert.True(pathParameter.IsRequired);
        Assert.Equal(RestApiParameterLocation.Path, pathParameter.Location);
        Assert.Null(pathParameter.DefaultValue);
        Assert.NotNull(pathParameter.Schema);
        Assert.Equal("string", pathParameter.Schema.RootElement.GetProperty("type").GetString());

        var apiVersionParameter = parameters.Single(p => p.Name == "api-version"); //'api-version' query string parameter.
        Assert.True(apiVersionParameter.IsRequired);
        Assert.Equal(RestApiParameterLocation.Query, apiVersionParameter.Location);
        Assert.Equal("7.0", apiVersionParameter.DefaultValue);
        Assert.NotNull(apiVersionParameter.Schema);
        Assert.Equal("string", apiVersionParameter.Schema.RootElement.GetProperty("type").GetString());
        Assert.Equal("7.0", apiVersionParameter.Schema.RootElement.GetProperty("default").GetString());

        var payloadParameter = parameters.Single(p => p.Name == "payload"); //'payload' artificial parameter.
        Assert.True(payloadParameter.IsRequired);
        Assert.Equal(RestApiParameterLocation.Body, payloadParameter.Location);
        Assert.Null(payloadParameter.DefaultValue);
        Assert.Equal("REST API request body.", payloadParameter.Description);
        Assert.NotNull(payloadParameter.Schema);
        Assert.Equal("object", payloadParameter.Schema.RootElement.GetProperty("type").GetString());

        var contentTypeParameter = parameters.Single(p => p.Name == "content-type"); //'content-type' artificial parameter.
        Assert.False(contentTypeParameter.IsRequired);
        Assert.Equal(RestApiParameterLocation.Body, contentTypeParameter.Location);
        Assert.Null(contentTypeParameter.DefaultValue);
        Assert.Equal("Content type of REST API request body.", contentTypeParameter.Description);
        Assert.Null(contentTypeParameter.Schema);
    }

    [Fact]
    public async Task ItCanUseOperationSummaryAsync()
    {
        // Act
        var restApi = await this._sut.ParseAsync(this._openApiDocument);

        // Assert
        Assert.NotNull(restApi.Operations);
        Assert.True(restApi.Operations.Any());

        var operation = restApi.Operations.Single(o => o.Id == "Excuses");
        Assert.NotNull(operation);
        Assert.Equal("Turn a scenario into a creative or humorous excuse to send your boss", operation.Description);
        Assert.Equal("Turn a scenario into a creative or humorous excuse to send your boss", operation.Summary);
    }

    [Fact]
    public async Task ItCanExtractSimpleTypeHeaderParameterMetadataSuccessfullyAsync()
    {
        // Act
        var restApi = await this._sut.ParseAsync(this._openApiDocument);

        //Assert string header parameter metadata
        var accept = GetParameterMetadata(restApi.Operations, "SetSecret", RestApiParameterLocation.Header, "Accept");

        Assert.Equal("string", accept.Type);
        Assert.Equal("application/json", accept.DefaultValue);
        Assert.Equal("Indicates which content types, expressed as MIME types, the client is able to understand.", accept.Description);
        Assert.False(accept.IsRequired);

        //Assert integer header parameter metadata
        var apiVersion = GetParameterMetadata(restApi.Operations, "SetSecret", RestApiParameterLocation.Header, "X-API-Version");

        Assert.Equal("integer", apiVersion.Type);
        Assert.Equal(10, apiVersion.DefaultValue);
        Assert.Equal("Requested API version.", apiVersion.Description);
        Assert.True(apiVersion.IsRequired);
    }

    [Fact]
    public async Task ItCanExtractCsvStyleHeaderParameterMetadataSuccessfullyAsync()
    {
        // Act
        var restApi = await this._sut.ParseAsync(this._openApiDocument);

        //Assert header parameters metadata
        var acceptParameter = GetParameterMetadata(restApi.Operations, "SetSecret", RestApiParameterLocation.Header, "X-Operation-Csv-Ids");

        Assert.Null(acceptParameter.DefaultValue);
        Assert.False(acceptParameter.IsRequired);
        Assert.Equal("array", acceptParameter.Type);
        Assert.Equal(RestApiParameterStyle.Simple, acceptParameter.Style);
        Assert.Equal("The comma separated list of operation ids.", acceptParameter.Description);
        Assert.Equal("string", acceptParameter.ArrayItemType);
    }

    [Fact]
    public async Task ItCanExtractHeadersSuccessfullyAsync()
    {
        // Act
        var restApi = await this._sut.ParseAsync(this._openApiDocument);

        // Assert
        Assert.True(restApi.Operations.Any());

        var operation = restApi.Operations.Single(o => o.Id == "SetSecret");

        var headerParameters = operation.Parameters.Where(p => p.Location == RestApiParameterLocation.Header);

        Assert.NotNull(headerParameters);
        Assert.Equal(3, headerParameters.Count());

        Assert.Contains(headerParameters, (p) => p.Name == "Accept");
        Assert.Contains(headerParameters, (p) => p.Name == "X-API-Version");
        Assert.Contains(headerParameters, (p) => p.Name == "X-Operation-Csv-Ids");
    }

    [Fact]
    public async Task ItCanExtractAllPathsAsOperationsAsync()
    {
        // Act
        var restApi = await this._sut.ParseAsync(this._openApiDocument);

        // Assert
        Assert.Equal(8, restApi.Operations.Count);
    }

    [Fact]
    public async Task ItCanParseOperationHavingTextPlainBodySuccessfullyAsync()
    {
        // Act
        var restApi = await this._sut.ParseAsync(this._openApiDocument);

        // Assert
        Assert.NotNull(restApi.Operations);
        Assert.True(restApi.Operations.Any());

        var operation = restApi.Operations.Single(o => o.Id == "Excuses");
        Assert.NotNull(operation);

        var payload = operation.Payload;
        Assert.NotNull(payload);
        Assert.Equal("text/plain", payload.MediaType);
        Assert.Equal("excuse event", payload.Description);
        Assert.NotNull(payload.Schema);

        var properties = payload.Properties;
        Assert.NotNull(properties);
        Assert.Empty(properties);
    }

    [Fact]
    public async Task ItCanWorkWithDocumentsWithoutServersAttributeAsync()
    {
        //Arrange
        using var stream = ModifyOpenApiDocument(this._openApiDocument, (yaml) =>
        {
            yaml.Remove("servers");
        });

        //Act
        var restApi = await this._sut.ParseAsync(stream);

        //Assert
        Assert.All(restApi.Operations, (op) => Assert.Empty(op.Servers));
    }

    [Fact]
    public async Task ItCanWorkWithDocumentsWithEmptyServersAttributeAsync()
    {
        //Arrange
        using var stream = ModifyOpenApiDocument(this._openApiDocument, (yaml) =>
        {
            yaml["servers"] = Array.Empty<string>();
        });

        //Act
        var restApi = await this._sut.ParseAsync(stream);

        //Assert
        Assert.All(restApi.Operations, (op) => Assert.Empty(op.Servers));
    }

    [Theory]
    [InlineData("explodeFormParam")]
    [InlineData("anotherExplodeFormParam")]
    public async Task ItShouldSupportsAmpersandSeparatedParametersForFormStyleArrayQueryStringParametersAsync(string parameterName)
    {
        //Act
        var restApi = await this._sut.ParseAsync(this._openApiDocument);

        //Assert
        Assert.True(restApi.Operations.Any());

        var operation = restApi.Operations.Single(o => o.Id == "GetSecret");

        var explodeFormParam = operation.Parameters.Single(p => p.Name == parameterName);

        Assert.True(explodeFormParam.Expand);
    }

    [Fact]
    public async Task ItShouldSupportsCommaSeparatedValuesForFormStyleArrayQueryStringParametersAsync()
    {
        //Act
        var restApi = await this._sut.ParseAsync(this._openApiDocument);

        //Assert
        Assert.True(restApi.Operations.Any());

        var operation = restApi.Operations.Single(o => o.Id == "GetSecret");

        var explodeFormParam = operation.Parameters.Single(p => p.Name == "nonExplodeFormParam");

        Assert.False(explodeFormParam.Expand);
    }

    [Fact]
    public async Task ItCanParseResponsesSuccessfullyAsync()
    {
        //Act
        var restApi = await this._sut.ParseAsync(this._openApiDocument);

        //Assert
        Assert.NotNull(restApi.Operations);
        Assert.True(restApi.Operations.Any());

        var operation = restApi.Operations.Single(o => o.Id == "Excuses");
        Assert.NotNull(operation);

        operation.Responses.TryGetValue("200", out var response);
        Assert.NotNull(response);
        Assert.Equal("text/plain", response.MediaType);
        Assert.Equal("The OK response", response.Description);
        Assert.NotNull(response.Schema);
        Assert.Equal("string", response.Schema.RootElement.GetProperty("type").GetString());
        Assert.Equal(
            JsonSerializer.Serialize(KernelJsonSchema.Parse("""{"type": "string"}""")),
            JsonSerializer.Serialize(response.Schema));
    }

    [Fact]
    public async Task ItCanWorkWithDefaultParametersOfVariousTypesAsync()
    {
        //Act
        var restApi = await this._sut.ParseAsync(this._openApiDocument);

        //Assert
        Assert.NotNull(restApi.Operations);
        Assert.True(restApi.Operations.Any());

        var operation = restApi.Operations.Single(o => o.Id == "TestDefaultValues");
        Assert.NotNull(operation);

        var parameters = operation.GetParameters();
        Assert.Equal(11, parameters.Count);

        var stringParameter = parameters.Single(p => p.Name == "string-parameter");
        Assert.Equal("string-value", stringParameter.DefaultValue);

        var booleanParameter = parameters.Single(p => p.Name == "boolean-parameter");
        Assert.True(booleanParameter.DefaultValue is bool value);

        var integerParameter = parameters.Single(p => p.Name == "integer-parameter");
        Assert.True(integerParameter.DefaultValue is int);
        Assert.Equal(281, integerParameter.DefaultValue);

        var longParameter = parameters.Single(p => p.Name == "long-parameter");
        Assert.True(longParameter.DefaultValue is long);
        Assert.Equal((long)-2814, longParameter.DefaultValue);

        var floatParameter = parameters.Single(p => p.Name == "float-parameter");
        Assert.True(floatParameter.DefaultValue is float);
        Assert.Equal((float)12.01, floatParameter.DefaultValue);

        var doubleParameter = parameters.Single(p => p.Name == "double-parameter");
        Assert.True(doubleParameter.DefaultValue is double);
        Assert.Equal((double)-12.01, doubleParameter.DefaultValue);

        var encodedCharactersParameter = parameters.Single(p => p.Name == "encoded-characters-parameter");
        Assert.True(encodedCharactersParameter.DefaultValue is byte[]);
        Assert.Equal(new byte[] { 1, 2, 3, 4, 5 }, encodedCharactersParameter.DefaultValue);

        var binaryDataParameter = parameters.Single(p => p.Name == "binary-data-parameter");
        Assert.True(binaryDataParameter.DefaultValue is byte[]);
        Assert.Equal("23456"u8.ToArray(), binaryDataParameter.DefaultValue);

        var dateParameter = parameters.Single(p => p.Name == "date-parameter");
        Assert.True(dateParameter.DefaultValue is DateTime);
        Assert.Equal(new DateTime(2017, 07, 21), dateParameter.DefaultValue);

        var dateTimeParameter = parameters.Single(p => p.Name == "date-time-parameter");
        Assert.True(dateTimeParameter.DefaultValue is DateTimeOffset);
        Assert.Equal(new DateTimeOffset(2017, 07, 21, 17, 32, 28, TimeSpan.Zero), dateTimeParameter.DefaultValue);

        var passwordParameter = parameters.Single(p => p.Name == "password-parameter");
        Assert.True(passwordParameter.DefaultValue is string);
        Assert.Equal("password-value", passwordParameter.DefaultValue);
    }

    [Fact]
    public async Task ItCanParseRestApiInfoAsync()
    {
        //Act
        var restApi = await this._sut.ParseAsync(this._openApiDocument);

        //Assert
        Assert.NotNull(restApi.Info);
        Assert.NotNull(restApi.Info.Title);
        Assert.NotEmpty(restApi.Info.Title);
        Assert.NotNull(restApi.Info.Description);
        Assert.NotEmpty(restApi.Info.Description);
    }

    [Theory]
    [InlineData("string-parameter", "string", null)]
    [InlineData("boolean-parameter", "boolean", null)]
    [InlineData("number-parameter", "number", null)]
    [InlineData("float-parameter", "number", "float")]
    [InlineData("double-parameter", "number", "double")]
    [InlineData("integer-parameter", "integer", null)]
    [InlineData("int32-parameter", "integer", "int32")]
    [InlineData("int64-parameter", "integer", "int64")]
    public async Task ItCanParseParametersOfPrimitiveDataTypeAsync(string name, string type, string? format)
    {
        // Arrange & Act
        var restApiSpec = await this._sut.ParseAsync(this._openApiDocument);

        // Assert
        var parameters = restApiSpec.Operations.Single(o => o.Id == "TestParameterDataTypes").GetParameters();

        var parameter = parameters.FirstOrDefault(p => p.Name == name);
        Assert.NotNull(parameter);

        Assert.Equal(type, parameter.Type);
        Assert.Equal(format, parameter.Format);
    }

    [Fact]
    public async Task ItCanParsePropertiesOfObjectDataTypeAsync()
    {
        // Arrange & Act
        var restApiSpec = await this._sut.ParseAsync(this._openApiDocument);

        // Assert
        var properties = restApiSpec.Operations.Single(o => o.Id == "TestParameterDataTypes").Payload!.Properties;

        var property = properties.Single(p => p.Name == "attributes");
        Assert.Equal("object", property.Type);
        Assert.Null(property.Format);
    }

    [Fact]
    public async Task ItCanParseDocumentWithMultipleServersAsync()
    {
        // Act
        var restApi = await this._sut.ParseAsync(this._openApiDocument);

        // Assert
        Assert.All(restApi.Operations, (operation) => Assert.Equal(2, operation.Servers.Count));

        Assert.Equal("https://my-key-vault.vault.azure.net", restApi.Operations[0].Servers[0].Url);
        Assert.Equal("https://ppe.my-key-vault.vault.azure.net", restApi.Operations[0].Servers[1].Url);
    }

    [Fact]
    public async Task ItCanParsePathItemPathParametersAsync()
    {//TODO update the document version when upgrading Microsoft.OpenAPI to v2
        var document =
        """
        {
            "openapi": "3.0.0",
            "info": {
                "title": "Test API",
                "version": "1.0.0"
            },
            "paths": {
                "/items/{itemId}/{format}": {
                    "parameters": [
                        {
                            "name": "itemId",
                            "in": "path",
                            "required": true,
                            "schema": {
                                "type": "string"
                            }
                        }
                    ],
                    "get": {
                        "parameters": [
                            {
                                "name": "format",
                                "in": "path",
                                "required": true,
                                "schema": {
                                    "type": "string"
                                }
                            }
                        ],
                        "summary": "Get an item by ID",
                        "responses": {
                            "200": {
                                "description": "Successful response"
                            }
                        }
                    }
                }
            }
        }
        """;

        await using var steam = new MemoryStream(Encoding.UTF8.GetBytes(document));
        var restApi = await this._sut.ParseAsync(steam);

        Assert.NotNull(restApi);
        Assert.NotNull(restApi.Operations);
        Assert.NotEmpty(restApi.Operations);

        var firstOperation = restApi.Operations[0];

        Assert.NotNull(firstOperation);
        Assert.Equal("Get an item by ID", firstOperation.Description);
        Assert.Equal("/items/{itemId}/{format}", firstOperation.Path);

        var parameters = firstOperation.GetParameters();
        Assert.NotNull(parameters);
        Assert.Equal(2, parameters.Count);

        var pathParameter = parameters.Single(static p => "itemId".Equals(p.Name, StringComparison.OrdinalIgnoreCase));
        Assert.NotNull(pathParameter);
        Assert.True(pathParameter.IsRequired);
        Assert.Equal(RestApiParameterLocation.Path, pathParameter.Location);
        Assert.Null(pathParameter.DefaultValue);
        Assert.NotNull(pathParameter.Schema);
        Assert.Equal("string", pathParameter.Schema.RootElement.GetProperty("type").GetString());

        var formatParameter = parameters.Single(static p => "format".Equals(p.Name, StringComparison.OrdinalIgnoreCase));
        Assert.NotNull(formatParameter);
        Assert.True(formatParameter.IsRequired);
        Assert.Equal(RestApiParameterLocation.Path, formatParameter.Location);
        Assert.Null(formatParameter.DefaultValue);
        Assert.NotNull(formatParameter.Schema);
        Assert.Equal("string", formatParameter.Schema.RootElement.GetProperty("type").GetString());
    }

    [Fact]
    public async Task ItCanParsePathItemPathParametersAndOverridesAsync()
    {//TODO update the document version when upgrading Microsoft.OpenAPI to v2
        var document =
        """
        {
            "openapi": "3.0.0",
            "info": {
                "title": "Test API",
                "version": "1.0.0"
            },
            "paths": {
                "/items/{itemId}/{format}": {
                    "parameters": [
                        {
                            "name": "itemId",
                            "in": "path",
                            "required": true,
                            "schema": {
                                "type": "string"
                            }
                        }
                    ],
                    "get": {
                        "parameters": [
                            {
                                "name": "format",
                                "in": "path",
                                "required": true,
                                "schema": {
                                    "type": "string"
                                }
                            },
                            {
                                "name": "itemId",
                                "in": "path",
                                "description": "item ID override",
                                "required": true,
                                "schema": {
                                    "type": "string"
                                }
                            }
                        ],
                        "summary": "Get an item by ID",
                        "responses": {
                            "200": {
                                "description": "Successful response"
                            }
                        }
                    }
                }
            }
        }
        """;

        await using var steam = new MemoryStream(Encoding.UTF8.GetBytes(document));
        var restApi = await this._sut.ParseAsync(steam);

        Assert.NotNull(restApi);
        Assert.NotNull(restApi.Operations);
        Assert.NotEmpty(restApi.Operations);

        var firstOperation = restApi.Operations[0];

        Assert.NotNull(firstOperation);
        Assert.Equal("Get an item by ID", firstOperation.Description);
        Assert.Equal("/items/{itemId}/{format}", firstOperation.Path);

        var parameters = firstOperation.GetParameters();
        Assert.NotNull(parameters);
        Assert.Equal(2, parameters.Count);

        var pathParameter = parameters.Single(static p => "itemId".Equals(p.Name, StringComparison.OrdinalIgnoreCase));
        Assert.NotNull(pathParameter);
        Assert.True(pathParameter.IsRequired);
        Assert.Equal(RestApiParameterLocation.Path, pathParameter.Location);
        Assert.Null(pathParameter.DefaultValue);
        Assert.NotNull(pathParameter.Schema);
        Assert.Equal("string", pathParameter.Schema.RootElement.GetProperty("type").GetString());
        Assert.Equal("item ID override", pathParameter.Description);

        var formatParameter = parameters.Single(static p => "format".Equals(p.Name, StringComparison.OrdinalIgnoreCase));
        Assert.NotNull(formatParameter);
        Assert.True(formatParameter.IsRequired);
        Assert.Equal(RestApiParameterLocation.Path, formatParameter.Location);
        Assert.Null(formatParameter.DefaultValue);
        Assert.NotNull(formatParameter.Schema);
        Assert.Equal("string", formatParameter.Schema.RootElement.GetProperty("type").GetString());
    }

    [Fact]
    public void ItCanVerifyAllServerLevelsAreStoredCorrectly()
    {
        // Arrange
        var document = new OpenApiDocument
        {
            Servers = new List<OpenApiServer>
        {
            new() { Url = "https://global-server.com", Description = "Global server" }
        }
        };

        var pathItem = new OpenApiPathItem
        {
            Servers = new List<OpenApiServer>
        {
            new() { Url = "https://path-server.com", Description = "Path server" }
        },
            Operations = new Dictionary<OperationType, OpenApiOperation>
            {
                [OperationType.Get] = new OpenApiOperation
                {
                    OperationId = "GetTest",
                    Servers = new List<OpenApiServer>
                {
                    new() { Url = "https://operation-server.com", Description = "Operation server" }
                },
                    Responses = new OpenApiResponses()
                }
            }
        };

        // Act
        var operations = OpenApiDocumentParser.CreateRestApiOperations(document, "/test", pathItem, null, this._logger);
        var operation = operations[0];

        // Assert
        // Verify servers
        Assert.Single(operation.Servers);
        Assert.Equal("https://global-server.com", operation.Servers[0].Url);
        Assert.Equal("Global server", operation.Servers[0].Description);

        // Verify path servers
        Assert.Single(operation.PathServers);
        Assert.Equal("https://path-server.com", operation.PathServers[0].Url);
        Assert.Equal("Path server", operation.PathServers[0].Description);

        // Verify operation servers
        Assert.Single(operation.OperationServers);
        Assert.Equal("https://operation-server.com", operation.OperationServers[0].Url);
        Assert.Equal("Operation server", operation.OperationServers[0].Description);
    }

    private static MemoryStream ModifyOpenApiDocument(Stream openApiDocument, Action<IDictionary<string, object>> transformer)
    {
        var serializer = new SharpYaml.Serialization.Serializer();

        //Deserialize yaml
        var yaml = serializer.Deserialize<ExpandoObject>(openApiDocument);

        //Modify yaml
        transformer(yaml!);

        //Serialize yaml
        var stream = new MemoryStream();

        serializer.Serialize(stream, yaml);

        stream.Seek(0, SeekOrigin.Begin);

        return stream;
    }

    private static RestApiParameter GetParameterMetadata(IList<RestApiOperation> operations, string operationId, RestApiParameterLocation location, string name)
    {
        Assert.True(operations.Any());

        var operation = operations.Single(o => o.Id == operationId);
        Assert.NotNull(operation.Parameters);
        Assert.True(operation.Parameters.Any());

        var parameters = operation.Parameters.Where(p => p.Location == location);

        var parameter = parameters.Single(p => p.Name == name);
        Assert.NotNull(parameter);

        return parameter;
    }

    public void Dispose()
    {
        this._openApiDocument.Dispose();
    }
}


===== Functions.UnitTests\OpenApi\OpenApiKernelPluginFactoryFeatureTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Linq;
using System.Text.Json;
using System.Threading.Tasks;
using Microsoft.SemanticKernel.Plugins.OpenApi;
using SemanticKernel.Functions.UnitTests.OpenApi.TestPlugins;
using Xunit;

namespace SemanticKernel.Functions.UnitTests.OpenApi;

public class OpenApiKernelPluginFactoryFeatureTests
{
    [Fact]
    public async Task ItShouldCreatePluginWithOperationPayloadForAnyOfSchemaAsync()
    {
        await using var openApiDocument = ResourcePluginsProvider.LoadFromResource("openapi_feature_testsV3_0.json");

        var plugin = await OpenApiKernelPluginFactory.CreateFromOpenApiAsync("fakePlugin", openApiDocument, executionParameters: new OpenApiFunctionExecutionParameters { EnableDynamicPayload = false });

        var postFoobarFunction = plugin["AnyOfPost"];
        Assert.NotNull(postFoobarFunction);

        var functionView = postFoobarFunction.Metadata;
        Assert.NotNull(functionView);

        var payloadParameter = functionView.Parameters.First(p => p.Name == "payload");
        Assert.NotNull(payloadParameter.Schema);
        Assert.Equal(JsonValueKind.Array, payloadParameter.Schema!.RootElement.GetProperty("anyOf").ValueKind);
    }

    [Fact]
    public async Task ItShouldCreatePluginWithOperationPayloadForAllOfSchemaAsync()
    {
        await using var openApiDocument = ResourcePluginsProvider.LoadFromResource("openapi_feature_testsV3_0.json");
        var plugin = await OpenApiKernelPluginFactory.CreateFromOpenApiAsync("fakePlugin", openApiDocument, executionParameters: new OpenApiFunctionExecutionParameters { EnableDynamicPayload = false });

        var postFoobarFunction = plugin["AllOfPost"];
        Assert.NotNull(postFoobarFunction);

        var functionView = postFoobarFunction.Metadata;
        Assert.NotNull(functionView);

        var payloadParameter = functionView.Parameters.First(p => p.Name == "payload");
        Assert.NotNull(payloadParameter.Schema);
        Assert.Equal(JsonValueKind.Array, payloadParameter.Schema!.RootElement.GetProperty("allOf").ValueKind);
    }

    [Fact]
    public async Task ItShouldCreatePluginWithOperationPayloadForOneOfSchemaAsync()
    {
        await using var openApiDocument = ResourcePluginsProvider.LoadFromResource("openapi_feature_testsV3_0.json");

        var plugin = await OpenApiKernelPluginFactory.CreateFromOpenApiAsync("fakePlugin", openApiDocument, executionParameters: new OpenApiFunctionExecutionParameters { EnableDynamicPayload = false });

        var postFoobarFunction = plugin["OneOfPost"];
        Assert.NotNull(postFoobarFunction);

        var functionView = postFoobarFunction.Metadata;
        Assert.NotNull(functionView);

        var payloadParameter = functionView.Parameters.First(p => p.Name == "payload");
        Assert.NotNull(payloadParameter.Schema);
        Assert.Equal(JsonValueKind.Array, payloadParameter.Schema!.RootElement.GetProperty("oneOf").ValueKind);
    }
}


===== Functions.UnitTests\OpenApi\OpenApiKernelPluginFactoryTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Net.Mime;
using System.Text;
using System.Text.Json.Nodes;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Plugins.OpenApi;
using SemanticKernel.Functions.UnitTests.OpenApi.TestPlugins;
using Xunit;

namespace SemanticKernel.Functions.UnitTests.OpenApi;
public sealed class OpenApiKernelPluginFactoryTests
{
    /// <summary>
    /// OpenAPI function execution parameters.
    /// </summary>
    private readonly OpenApiFunctionExecutionParameters _executionParameters;

    /// <summary>
    /// OpenAPI document stream.
    /// </summary>
    private readonly Stream _openApiDocument;

    /// <summary>
    /// Creates an instance of a <see cref="OpenApiKernelExtensionsTests"/> class.
    /// </summary>
    public OpenApiKernelPluginFactoryTests()
    {
        this._executionParameters = new OpenApiFunctionExecutionParameters() { EnableDynamicPayload = false };

        this._openApiDocument = ResourcePluginsProvider.LoadFromResource("documentV2_0.json");
    }

    [Fact]
    public async Task ItCanIncludeOpenApiOperationParameterTypesIntoFunctionParametersViewAsync()
    {
        // Act
        var plugin = await OpenApiKernelPluginFactory.CreateFromOpenApiAsync("fakePlugin", this._openApiDocument, this._executionParameters);

        // Assert
        var setSecretFunction = plugin["SetSecret"];
        Assert.NotNull(setSecretFunction);

        var functionView = setSecretFunction.Metadata;
        Assert.NotNull(functionView);

        var secretNameParameter = functionView.Parameters.First(p => p.Name == "secret_name");
        Assert.NotNull(secretNameParameter.Schema);
        Assert.Equal("string", secretNameParameter.Schema!.RootElement.GetProperty("type").GetString());

        var apiVersionParameter = functionView.Parameters.First(p => p.Name == "api_version");
        Assert.Equal("string", apiVersionParameter.Schema!.RootElement.GetProperty("type").GetString());

        var payloadParameter = functionView.Parameters.First(p => p.Name == "payload");
        Assert.NotNull(payloadParameter.Schema);
        Assert.Equal("object", payloadParameter.Schema!.RootElement.GetProperty("type").GetString());
    }

    [Theory]
    [InlineData(true)]
    [InlineData(false)]
    public async Task ItUsesServerUrlOverrideIfProvidedAsync(bool removeServersProperty)
    {
        // Arrange
        const string DocumentUri = "http://localhost:3001/openapi.json";
        const string ServerUrlOverride = "https://server-override.com/";

        var openApiDocument = ResourcePluginsProvider.LoadFromResource("documentV3_0.json");

        if (removeServersProperty)
        {
            openApiDocument = OpenApiTestHelper.ModifyOpenApiDocument(openApiDocument, (doc) =>
            {
                doc.Remove("servers");
            });
        }

        using var messageHandlerStub = new HttpMessageHandlerStub(openApiDocument);
        using var httpClient = new HttpClient(messageHandlerStub, false);

        this._executionParameters.HttpClient = httpClient;
        this._executionParameters.ServerUrlOverride = new Uri(ServerUrlOverride);

        var arguments = new KernelArguments
        {
            ["secret-name"] = "fake-secret-name",
            ["api-version"] = "7.0",
            ["X-API-Version"] = 6,
            ["payload"] = "fake-payload"
        };

        var kernel = new Kernel();

        // Act
        var plugin = await OpenApiKernelPluginFactory.CreateFromOpenApiAsync("fakePlugin", new Uri(DocumentUri), this._executionParameters);
        var setSecretFunction = plugin["SetSecret"];

        messageHandlerStub.ResetResponse();

        var result = await kernel.InvokeAsync(setSecretFunction, arguments);

        // Assert
        Assert.NotNull(messageHandlerStub.RequestUri);
        Assert.StartsWith(ServerUrlOverride, messageHandlerStub.RequestUri.AbsoluteUri, StringComparison.Ordinal);
    }

    [Theory]
    [InlineData("documentV2_0.json")]
    [InlineData("documentV3_0.json")]
    public async Task ItUsesServerUrlFromOpenApiDocumentAsync(string documentFileName)
    {
        // Arrange
        const string DocumentUri = "http://localhost:3001/openapi.json";
        const string ServerUrlFromDocument = "https://my-key-vault.vault.azure.net/";

        var openApiDocument = ResourcePluginsProvider.LoadFromResource(documentFileName);

        using var messageHandlerStub = new HttpMessageHandlerStub(openApiDocument);
        using var httpClient = new HttpClient(messageHandlerStub, false);

        this._executionParameters.HttpClient = httpClient;

        var arguments = new KernelArguments
        {
            ["secret-name"] = "fake-secret-name",
            ["api-version"] = "7.0",
            ["X-API-Version"] = 6,
            ["payload"] = "fake-payload"
        };

        var kernel = new Kernel();

        // Act
        var plugin = await OpenApiKernelPluginFactory.CreateFromOpenApiAsync("fakePlugin", new Uri(DocumentUri), this._executionParameters);
        var setSecretFunction = plugin["SetSecret"];

        messageHandlerStub.ResetResponse();

        var result = await kernel.InvokeAsync(setSecretFunction, arguments);

        // Assert
        Assert.NotNull(messageHandlerStub.RequestUri);
        Assert.StartsWith(ServerUrlFromDocument, messageHandlerStub.RequestUri.AbsoluteUri, StringComparison.Ordinal);
    }

    [Theory]
    [InlineData("http://localhost:3001/openapi.json", "http://localhost:3001/", "documentV2_0.json")]
    [InlineData("http://localhost:3001/openapi.json", "http://localhost:3001/", "documentV3_0.json")]
    [InlineData("https://api.example.com/openapi.json", "https://api.example.com/", "documentV2_0.json")]
    [InlineData("https://api.example.com/openapi.json", "https://api.example.com/", "documentV3_0.json")]
    [SuppressMessage("Design", "CA1054:URI-like parameters should not be strings", Justification = "Required for test data.")]
    public async Task ItUsesOpenApiDocumentHostUrlWhenServerUrlIsNotProvidedAsync(string documentUri, string expectedServerUrl, string documentFileName)
    {
        // Arrange
        var openApiDocument = ResourcePluginsProvider.LoadFromResource(documentFileName);

        using var content = OpenApiTestHelper.ModifyOpenApiDocument(openApiDocument, (doc) =>
        {
            doc.Remove("servers");
            doc.Remove("host");
            doc.Remove("schemes");
        });

        using var messageHandlerStub = new HttpMessageHandlerStub(content);
        using var httpClient = new HttpClient(messageHandlerStub, false);

        this._executionParameters.HttpClient = httpClient;

        var arguments = new KernelArguments
        {
            ["secret-name"] = "fake-secret-name",
            ["api-version"] = "7.0",
            ["X-API-Version"] = 6,
            ["payload"] = "fake-payload"
        };

        var kernel = new Kernel();

        // Act
        var plugin = await OpenApiKernelPluginFactory.CreateFromOpenApiAsync("fakePlugin", new Uri(documentUri), this._executionParameters);
        var setSecretFunction = plugin["SetSecret"];

        messageHandlerStub.ResetResponse();

        var result = await kernel.InvokeAsync(setSecretFunction, arguments);

        // Assert
        Assert.NotNull(messageHandlerStub.RequestUri);
        Assert.StartsWith(expectedServerUrl, messageHandlerStub.RequestUri.AbsoluteUri, StringComparison.Ordinal);
    }

    [Fact]
    public async Task ItShouldRespectRunAsyncCancellationTokenOnExecutionAsync()
    {
        // Arrange
        using var messageHandlerStub = new HttpMessageHandlerStub();
        messageHandlerStub.ResponseToReturn.Content = new StringContent("fake-content", Encoding.UTF8, MediaTypeNames.Application.Json);

        using var httpClient = new HttpClient(messageHandlerStub, false);

        this._executionParameters.HttpClient = httpClient;

        var fakePlugin = new FakePlugin();

        using var registerCancellationToken = new System.Threading.CancellationTokenSource();
        using var executeCancellationToken = new System.Threading.CancellationTokenSource();

        var openApiPlugins = await OpenApiKernelPluginFactory.CreateFromOpenApiAsync("fakePlugin", this._openApiDocument, this._executionParameters, registerCancellationToken.Token);

        var kernel = new Kernel();

        var arguments = new KernelArguments
        {
            { "secret-name", "fake-secret-name" },
            { "api-version", "fake-api-version" }
        };

        // Act
        registerCancellationToken.Cancel();
        var result = await kernel.InvokeAsync(openApiPlugins["GetSecret"], arguments, executeCancellationToken.Token);

        // Assert
        Assert.NotNull(result);

        var response = result.GetValue<RestApiOperationResponse>();

        //Check original response
        Assert.NotNull(response);
        Assert.Equal("fake-content", response.Content);
    }

    [Fact]
    public async Task ItShouldSanitizeOperationNameAsync()
    {
        // Arrange
        var openApiDocument = ResourcePluginsProvider.LoadFromResource("documentV3_0.json");

        using var content = OpenApiTestHelper.ModifyOpenApiDocument(openApiDocument, (doc) =>
        {
            doc["paths"]!["/secrets/{secret-name}"]!["get"]!["operationId"] = "issues/create-mile.stone";
        });

        // Act
        var plugin = await OpenApiKernelPluginFactory.CreateFromOpenApiAsync("fakePlugin", content, this._executionParameters);

        // Assert
        Assert.True(plugin.TryGetFunction("IssuesCreatemilestone", out var _));
    }

    [Fact]
    public async Task ItCanIncludeOpenApiDeleteAndPatchOperationsAsync()
    {
        // Arrange
        var openApiDocument = ResourcePluginsProvider.LoadFromResource("repair-service.json");

        // Act
        var plugin = await OpenApiKernelPluginFactory.CreateFromOpenApiAsync("repairServicePlugin", openApiDocument, this._executionParameters);

        // Assert
        Assert.NotNull(plugin);
        var functionsMetadata = plugin.GetFunctionsMetadata();
        Assert.Equal(4, functionsMetadata.Count);
        AssertPayloadParameters(plugin, "updateRepair");
        AssertPayloadParameters(plugin, "deleteRepair");
    }

    [Theory]
    [InlineData("documentV2_0.json")]
    [InlineData("documentV3_0.json")]
    [InlineData("documentV3_1.yaml")]
    public async Task ItShouldReplicateMetadataToOperationAsync(string documentFileName)
    {
        // Arrange
        var openApiDocument = ResourcePluginsProvider.LoadFromResource(documentFileName);

        // Act
        var plugin = await OpenApiKernelPluginFactory.CreateFromOpenApiAsync("fakePlugin", openApiDocument, this._executionParameters);

        // Assert Metadata Keys and Values
        Assert.True(plugin.TryGetFunction("OpenApiExtensions", out var function));
        var additionalProperties = function.Metadata.AdditionalProperties;
        Assert.Equal(6, additionalProperties.Count);

        Assert.Contains("method", additionalProperties.Keys);
        Assert.Contains("operation", additionalProperties.Keys);
        Assert.Contains("info", additionalProperties.Keys);
        Assert.Contains("security", additionalProperties.Keys);
        Assert.Contains("server-urls", additionalProperties.Keys);
        Assert.Contains("operation-extensions", additionalProperties.Keys);

        var operation = additionalProperties["operation"] as RestApiOperation;
        Assert.NotNull(operation);
        Assert.Equal("GET", additionalProperties["method"]);
        Assert.Equal("/api-with-open-api-extensions", operation.Path);
        Assert.Equal("Get API with open-api specification extensions", operation.Summary);
        var serverUrls = additionalProperties["server-urls"] as string[];
        Assert.NotNull(serverUrls);
        Assert.Equal(["https://my-key-vault.vault.azure.net"], serverUrls);
        var info = additionalProperties["info"] as RestApiInfo;
        Assert.NotNull(info);
        var security = additionalProperties["security"] as List<RestApiSecurityRequirement>;
        Assert.NotNull(security);

        // Assert Operation Extension keys
        var operationExtensions = additionalProperties["operation-extensions"] as Dictionary<string, object?>;
        Assert.NotNull(operationExtensions);
        Dictionary<string, object?> nonNullOperationExtensions = operationExtensions;

        Assert.Equal(8, nonNullOperationExtensions.Count);
        Assert.Contains("x-boolean-extension", nonNullOperationExtensions.Keys);
        Assert.Contains("x-double-extension", nonNullOperationExtensions.Keys);
        Assert.Contains("x-integer-extension", nonNullOperationExtensions.Keys);
        Assert.Contains("x-string-extension", nonNullOperationExtensions.Keys);
        Assert.Contains("x-date-extension", nonNullOperationExtensions.Keys);
        Assert.Contains("x-datetime-extension", nonNullOperationExtensions.Keys);
        Assert.Contains("x-array-extension", nonNullOperationExtensions.Keys);
        Assert.Contains("x-object-extension", nonNullOperationExtensions.Keys);
    }

    [Fact]
    public async Task ItShouldFreezeOperationMetadataAsync()
    {
        // Act
        var plugin = await OpenApiKernelPluginFactory.CreateFromOpenApiAsync("fakePlugin", this._openApiDocument, this._executionParameters);

        // Assert
        Assert.True(plugin.TryGetFunction("SetSecret", out var function));

        RestApiOperation additionalProperties = (RestApiOperation)function.Metadata.AdditionalProperties["operation"]!;

        // Assert that operation metadata is frozen
        var secretNameParameter = additionalProperties.Parameters.Single(p => p.Name == "secret-name");
        Assert.Throws<InvalidOperationException>(() => secretNameParameter.ArgumentName = "a new value");
    }

    [Fact]
    public async Task ItShouldHandleEmptyOperationNameAsync()
    {
        // Arrange
        var openApiDocument = ResourcePluginsProvider.LoadFromResource("documentV3_0.json");

        using var content = OpenApiTestHelper.ModifyOpenApiDocument(openApiDocument, (doc) =>
        {
            doc["paths"]!["/secrets/{secret-name}"]!["get"]!["operationId"] = "";
        });

        // Act
        var plugin = await OpenApiKernelPluginFactory.CreateFromOpenApiAsync("fakePlugin", content, this._executionParameters);

        // Assert
        Assert.Equal(8, plugin.Count());
        Assert.True(plugin.TryGetFunction("GetSecretsSecretname", out var _));
    }

    [Fact]
    public async Task ItShouldHandleNullOperationNameAsync()
    {
        // Arrange
        var openApiDocument = ResourcePluginsProvider.LoadFromResource("documentV3_0.json");

        using var content = OpenApiTestHelper.ModifyOpenApiDocument(openApiDocument, (doc) =>
        {
            doc["paths"]!["/secrets/{secret-name}"]!["get"]!.AsObject().Remove("operationId");
        });

        // Act
        var plugin = await OpenApiKernelPluginFactory.CreateFromOpenApiAsync("fakePlugin", content, this._executionParameters);

        // Assert
        Assert.Equal(8, plugin.Count());
        Assert.True(plugin.TryGetFunction("GetSecretsSecretname", out var _));
    }

    [Theory]
    [InlineData("string_parameter", typeof(string))]
    [InlineData("boolean_parameter", typeof(bool))]
    [InlineData("number_parameter", typeof(double))]
    [InlineData("float_parameter", typeof(float))]
    [InlineData("double_parameter", typeof(double))]
    [InlineData("integer_parameter", typeof(long))]
    [InlineData("int32_parameter", typeof(int))]
    [InlineData("int64_parameter", typeof(long))]
    public async Task ItShouldMapPropertiesOfPrimitiveDataTypeToKernelParameterMetadataAsync(string name, Type type)
    {
        // Arrange & Act
        this._executionParameters.EnableDynamicPayload = true;

        var plugin = await OpenApiKernelPluginFactory.CreateFromOpenApiAsync("fakePlugin", this._openApiDocument, this._executionParameters);

        var parametersMetadata = plugin["TestParameterDataTypes"].Metadata.Parameters;

        // Assert
        var parameterMetadata = parametersMetadata.First(p => p.Name == name);

        Assert.Equal(type, parameterMetadata.ParameterType);
    }

    [Fact]
    public async Task ItShouldMapPropertiesOfObjectDataTypeToKernelParameterMetadataAsync()
    {
        // Arrange & Act
        var plugin = await OpenApiKernelPluginFactory.CreateFromOpenApiAsync("fakePlugin", this._openApiDocument, this._executionParameters);

        var parametersMetadata = plugin["TestParameterDataTypes"].Metadata.Parameters;

        // Assert
        var parameterMetadata = parametersMetadata.First(p => p.Name == "payload");

        Assert.Equal(typeof(object), parameterMetadata.ParameterType);
    }

    [Fact]
    public async Task ItShouldUseCustomHttpResponseContentReaderAsync()
    {
        // Arrange
        using var messageHandlerStub = new HttpMessageHandlerStub(this._openApiDocument);
        using var httpClient = new HttpClient(messageHandlerStub, false);

        this._executionParameters.HttpResponseContentReader = async (context, cancellationToken) => await context.Response.Content.ReadAsStreamAsync(cancellationToken);
        this._executionParameters.HttpClient = httpClient;

        var kernel = new Kernel();

        var plugin = await OpenApiKernelPluginFactory.CreateFromOpenApiAsync("fakePlugin", new Uri("http://localhost:3001/openapi.json"), this._executionParameters);

        messageHandlerStub.ResetResponse();

        var arguments = new KernelArguments
        {
            ["secret-name"] = "fake-secret-name",
            ["api-version"] = "7.0",
            ["X-API-Version"] = 6
        };

        // Act
        var result = await kernel.InvokeAsync(plugin["GetSecret"], arguments);

        // Assert
        var response = result.GetValue<RestApiOperationResponse>();
        Assert.NotNull(response);

        Assert.IsAssignableFrom<Stream>(response.Content);
    }

    [Theory]
    [MemberData(nameof(GenerateSecurityMemberData))]
    public async Task ItAddSecurityMetadataToOperationAsync(string documentFileName, IDictionary<string, string[]> securityTypeMap)
    {
        // Arrange
        var openApiDocument = ResourcePluginsProvider.LoadFromResource(documentFileName);

        // Act
        var plugin = await OpenApiKernelPluginFactory.CreateFromOpenApiAsync("fakePlugin", openApiDocument, this._executionParameters);

        // Assert Security Metadata Keys and Values
        foreach (var function in plugin)
        {
            var additionalProperties = function.Metadata.AdditionalProperties;
            Assert.Contains("operation", additionalProperties.Keys);

            var securityTypes = securityTypeMap[function.Name];

            var operation = additionalProperties["operation"] as RestApiOperation;
            Assert.NotNull(operation);
            Assert.NotNull(operation.SecurityRequirements);
            Assert.Equal(securityTypes.Length, operation.SecurityRequirements?.Count);
            foreach (var securityType in securityTypes)
            {
                Assert.Contains(operation.SecurityRequirements!, sr => sr.Keys.Any(k => k.SecuritySchemeType == securityType));
            }
        }
    }

    [Fact]
    public void ItCreatesPluginFromOpenApiSpecificationModel()
    {
        // Arrange
        var info = new RestApiInfo() { Description = "api-description", Title = "api-title", Version = "7.0" };

        var securityRequirements = new List<RestApiSecurityRequirement>
        {
            new(new Dictionary<RestApiSecurityScheme, IList<string>> { { new RestApiSecurityScheme(), new List<string>() } })
        };

        var operations = new List<RestApiOperation>
        {
            new (
                id: "operation1",
                servers: [],
                path: "path",
                method: HttpMethod.Get,
                description: "operation-description",
                parameters: [],
                responses: new Dictionary<string, RestApiExpectedResponse>(),
                securityRequirements: [],
                payload: null)
        };

        var specification = new RestApiSpecification(info, securityRequirements, operations);

        // Act
        var plugin = OpenApiKernelPluginFactory.CreateFromOpenApi("fakePlugin", specification, this._executionParameters);

        // Assert
        Assert.Single(plugin);
        Assert.Equal("api-description", plugin.Description);
        Assert.Equal("fakePlugin", plugin.Name);

        var function = plugin["operation1"];
        Assert.Equal("operation1", function.Name);
        Assert.Equal("operation-description", function.Description);
        Assert.Same(operations[0], function.Metadata.AdditionalProperties["operation"]);
    }

    [Fact]
    public async Task ItShouldResolveArgumentsByParameterNamesAsync()
    {
        // Arrange
        using var messageHandlerStub = new HttpMessageHandlerStub();
        using var httpClient = new HttpClient(messageHandlerStub, false);

        this._executionParameters.EnableDynamicPayload = true;
        this._executionParameters.HttpClient = httpClient;

        var arguments = new KernelArguments
        {
            ["string_parameter"] = "fake-secret-name",
            ["boolean@parameter"] = true,
            ["integer+parameter"] = 6,
            ["float?parameter"] = 23.4f
        };

        var kernel = new Kernel();

        var openApiDocument = ResourcePluginsProvider.LoadFromResource("documentV3_0.json");

        var plugin = await OpenApiKernelPluginFactory.CreateFromOpenApiAsync("fakePlugin", openApiDocument, this._executionParameters);

        // Act
        var result = await kernel.InvokeAsync(plugin["TestParameterNamesSanitization"], arguments);

        // Assert path and query parameters added to the request uri
        Assert.NotNull(messageHandlerStub.RequestUri);
        Assert.Equal("https://my-key-vault.vault.azure.net/test-parameter-names-sanitization/fake-secret-name?boolean@parameter=true", messageHandlerStub.RequestUri.AbsoluteUri);

        // Assert header parameters added to the request
        Assert.Equal("6", messageHandlerStub.RequestHeaders!.GetValues("integer+parameter").First());

        // Assert payload parameters added to the request
        var messageContent = messageHandlerStub.RequestContent;
        Assert.NotNull(messageContent);

        var deserializedPayload = await JsonNode.ParseAsync(new MemoryStream(messageContent));
        Assert.NotNull(deserializedPayload);

        Assert.Equal(23.4f, deserializedPayload["float?parameter"]!.GetValue<float>());
    }

    [Fact]
    public async Task ItShouldResolveArgumentsBySanitizedParameterNamesAsync()
    {
        // Arrange
        using var messageHandlerStub = new HttpMessageHandlerStub();
        using var httpClient = new HttpClient(messageHandlerStub, false);

        this._executionParameters.EnableDynamicPayload = true;
        this._executionParameters.HttpClient = httpClient;

        var arguments = new KernelArguments
        {
            ["string_parameter"] = "fake-secret-name",  // Original parameter name - string-parameter
            ["boolean_parameter"] = true,               // Original parameter name - boolean@parameter
            ["integer_parameter"] = 6,                  // Original parameter name - integer+parameter
            ["float_parameter"] = 23.4f                 // Original parameter name - float?parameter
        };

        var kernel = new Kernel();

        var openApiDocument = ResourcePluginsProvider.LoadFromResource("documentV3_0.json");

        var plugin = await OpenApiKernelPluginFactory.CreateFromOpenApiAsync("fakePlugin", openApiDocument, this._executionParameters);

        // Act
        var result = await kernel.InvokeAsync(plugin["TestParameterNamesSanitization"], arguments);

        // Assert path and query parameters added to the request uri
        Assert.NotNull(messageHandlerStub.RequestUri);
        Assert.Equal("https://my-key-vault.vault.azure.net/test-parameter-names-sanitization/fake-secret-name?boolean@parameter=true", messageHandlerStub.RequestUri.AbsoluteUri);

        // Assert header parameters added to the request
        Assert.Equal("6", messageHandlerStub.RequestHeaders!.GetValues("integer+parameter").First());

        // Assert payload parameters added to the request
        var messageContent = messageHandlerStub.RequestContent;
        Assert.NotNull(messageContent);

        var deserializedPayload = await JsonNode.ParseAsync(new MemoryStream(messageContent));
        Assert.NotNull(deserializedPayload);

        Assert.Equal(23.4f, deserializedPayload["float?parameter"]!.GetValue<float>());
    }

    [Fact]
    public async Task ItShouldPropagateRestApiOperationResponseFactoryToRunnerAsync()
    {
        // Arrange
        bool restApiOperationResponseFactoryIsInvoked = false;

        async Task<RestApiOperationResponse> RestApiOperationResponseFactory(RestApiOperationResponseFactoryContext context, CancellationToken cancellationToken)
        {
            restApiOperationResponseFactoryIsInvoked = true;

            return await context.InternalFactory(context, cancellationToken);
        }

        using var messageHandlerStub = new HttpMessageHandlerStub();
        using var httpClient = new HttpClient(messageHandlerStub, false);

        this._executionParameters.HttpClient = httpClient;
        this._executionParameters.RestApiOperationResponseFactory = RestApiOperationResponseFactory;

        var openApiPlugins = await OpenApiKernelPluginFactory.CreateFromOpenApiAsync("fakePlugin", this._openApiDocument, this._executionParameters);

        var kernel = new Kernel();

        var arguments = new KernelArguments
        {
            { "secret-name", "fake-secret-name" },
            { "api-version", "fake-api-version" }
        };

        // Act
        await kernel.InvokeAsync(openApiPlugins["GetSecret"], arguments);

        // Assert
        Assert.True(restApiOperationResponseFactoryIsInvoked);
    }

    [Fact]
    public async Task ItCanImportSpecifiedOperationsAsync()
    {
        // Arrange
        string[] operationsToInclude = ["GetSecret", "SetSecret"];

        this._executionParameters.OperationSelectionPredicate = (context) => operationsToInclude.Contains(context.Id);

        // Act
        var plugin = await OpenApiKernelPluginFactory.CreateFromOpenApiAsync("fakePlugin", this._openApiDocument, this._executionParameters);

        // Assert
        Assert.Equal(2, plugin.Count());
        Assert.Contains(plugin, p => p.Name == "GetSecret");
        Assert.Contains(plugin, p => p.Name == "SetSecret");
    }

    [Fact]
    public async Task ItCanFilterOutSpecifiedOperationsAsync()
    {
        // Arrange
        this._executionParameters.OperationsToExclude = ["GetSecret", "SetSecret"];

        // Act
        var plugin = await OpenApiKernelPluginFactory.CreateFromOpenApiAsync("fakePlugin", this._openApiDocument, this._executionParameters);

        // Assert
        Assert.True(plugin.Any());
        Assert.DoesNotContain(plugin, p => p.Name == "GetSecret");
        Assert.DoesNotContain(plugin, p => p.Name == "SetSecret");
    }

    /// <summary>
    /// Generate theory data for ItAddSecurityMetadataToOperationAsync
    /// </summary>
    public static TheoryData<string, IDictionary<string, string[]>> GenerateSecurityMemberData() =>
        new()
        {
            { "no-securityV3_0.json", new Dictionary<string, string[]>
                {
                    { "NoSecurity", Array.Empty<string>() },
                    { "Security", new[] { "ApiKey" } },
                    { "SecurityAndScope", new[] { "ApiKey" } }
                }},
            { "apikey-securityV3_0.json", new Dictionary<string, string[]>
                {
                    { "NoSecurity", Array.Empty<string>() },
                    { "Security", new[] { "ApiKey" } },
                    { "SecurityAndScope", new[] { "ApiKey" } }
                }},
            { "oauth-securityV3_0.json", new Dictionary<string, string[]>
                {
                    { "NoSecurity", Array.Empty<string>() },
                    { "Security", new[] { "OAuth2" } },
                    { "SecurityAndScope", new[] { "OAuth2" } }
                }}
        };

    [Fact]
    public async Task ItShouldCreateFunctionWithMultipartFormDataAsync()
    {
        // Arrange
        var openApiDocument = ResourcePluginsProvider.LoadFromResource("multipart-form-data.json");

        // Act
        var plugin = await OpenApiKernelPluginFactory.CreateFromOpenApiAsync("fakePlugin", openApiDocument, this._executionParameters);

        // Assert
        Assert.False(plugin.TryGetFunction("createItem", out var _));
    }

    [Fact]
    public async Task ItCanAddPropertyDescriptionToSchemaAsync()
    {
        // Act
        var plugin = await OpenApiKernelPluginFactory.CreateFromOpenApiAsync("fakePlugin", this._openApiDocument, this._executionParameters);

        // Assert
        var setSecretFunction = plugin["SetSecret"];
        Assert.NotNull(setSecretFunction);

        var functionView = setSecretFunction.Metadata;
        Assert.NotNull(functionView);

        // Check if description is added to the parameter schema
        var secretNameParameter = functionView.Parameters.First(p => p.Name == "secret_name");
        Assert.Equal("The name of the secret", secretNameParameter.Description);

        Assert.True(secretNameParameter.Schema!.RootElement.TryGetProperty("description", out var description));
        Assert.Equal("The name of the secret", description.GetString());
    }

    [Fact]
    public void Dispose()
    {
        this._openApiDocument.Dispose();
    }

    #region private ================================================================================

    private static void AssertPayloadParameters(KernelPlugin plugin, string functionName)
    {
        Assert.True(plugin.TryGetFunction(functionName, out var function));
        Assert.NotNull(function.Metadata.Parameters);
        Assert.Equal(2, function.Metadata.Parameters.Count);
        Assert.Equal("payload", function.Metadata.Parameters[0].Name);
        Assert.Equal("content_type", function.Metadata.Parameters[1].Name);
    }

    private sealed class FakePlugin
    {
        public string? ParameterValueFakeMethodCalledWith { get; private set; }

        [KernelFunction]
        public void DoFakeAction(string parameter)
        {
            this.ParameterValueFakeMethodCalledWith = parameter;
        }
    }

    #endregion
}


===== Functions.UnitTests\OpenApi\OpenApiTestHelper.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.IO;
using System.Text.Json;
using System.Text.Json.Nodes;

namespace SemanticKernel.Functions.UnitTests.OpenApi;

/// <summary>
/// Contains helper methods for OpenAPI related tests.
/// </summary>
internal static class OpenApiTestHelper
{
    /// <summary>
    /// Modifies OpenAPI document for testing different scenarios.
    /// </summary>
    /// <param name="openApiDocument">The OpenAPI document content.</param>
    /// <param name="transformer">Delegate with document modifications.</param>
    internal static MemoryStream ModifyOpenApiDocument(Stream openApiDocument, Action<JsonObject> transformer)
    {
        var json = JsonSerializer.Deserialize<JsonObject>(openApiDocument);

        transformer(json!);

        var stream = new MemoryStream();

        JsonSerializer.Serialize(stream, json);

        stream.Seek(0, SeekOrigin.Begin);

        return stream;
    }
}


===== Functions.UnitTests\OpenApi\OperationSelectionPredicateContextTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using Microsoft.SemanticKernel.Plugins.OpenApi;
using Xunit;

namespace SemanticKernel.Functions.UnitTests.OpenApi;

public class OperationSelectionPredicateContextTests
{
    [Fact]
    public void ItShouldCheckTwoContextsAreEqual()
    {
        // Arrange
        var context1 = new OperationSelectionPredicateContext("id", "path", "method", "description");
        var context2 = new OperationSelectionPredicateContext("id", "path", "method", "description");

        // Act & Assert
        Assert.True(context1 == context2);
    }

    [Fact]
    public void ItShouldCheckTwoContextsAreNotEqual()
    {
        // Arrange
        var context1 = new OperationSelectionPredicateContext("id", "path", "method", "description");
        var context2 = new OperationSelectionPredicateContext("id1", "path1", "method1", "description1");

        // Act & Assert
        Assert.False(context1 == context2);
    }

    [Fact]
    public void ItShouldCheckContextsIsEqualToItself()
    {
        // Arrange
        var context = new OperationSelectionPredicateContext("id", "path", "method", "description");

        // Act & Assert
#pragma warning disable CS1718 // Comparison made to same variable
        Assert.True(context == context);
#pragma warning restore CS1718 // Comparison made to same variable
    }

    [Fact]
    public void ItShouldCheckContextIsNotEqualToNull()
    {
        // Arrange
        var context = new OperationSelectionPredicateContext("id", "path", "method", "description");

        // Act & Assert
        Assert.False(context.Equals(null));
    }
}


===== Functions.UnitTests\OpenApi\RestApiOperationResponseConverterTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using Microsoft.SemanticKernel;
using Xunit;

namespace SemanticKernel.Functions.UnitTests.OpenApi;

public class RestApiOperationResponseConverterTests
{
    private readonly RestApiOperationResponseConverter _sut;

    public RestApiOperationResponseConverterTests()
    {
        this._sut = new RestApiOperationResponseConverter();
    }

    [Fact]
    public void ItShouldConvertStringContentToString()
    {
        //Arrange
        var response = new RestApiOperationResponse("fake-content", "fake-content-type");

        //Act
        var result = this._sut.ConvertToString(response);

        //Assert
        Assert.Equal("fake-content", result);
    }

    [Fact]
    public void ItShouldConvertByteContentToString()
    {
        //Arrange
        var response = new RestApiOperationResponse(new byte[] { 00, 01, 02 }, "fake-content-type");

        //Act
        var result = this._sut.ConvertToString(response);

        //Assert
        Assert.Equal("AAEC", result);
    }
}


===== Functions.UnitTests\OpenApi\RestApiOperationResponseTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using Microsoft.SemanticKernel;
using SemanticKernel.Functions.UnitTests.OpenApi.TestResponses;
using Xunit;

namespace SemanticKernel.Functions.UnitTests.OpenApi;

public class RestApiOperationResponseTests
{
    [Fact]
    public void ItShouldValidateStringContentWithNoSchema()
    {
        //Arrange
        var response = new RestApiOperationResponse("fake-content", "fake-content-type");

        //Act
        var result = response.IsValid();

        //Assert
        Assert.True(result);
    }

    [Fact]
    public void ItShouldValidateByteContentTWithNoSchema()
    {
        //Arrange
        var response = new RestApiOperationResponse(new byte[] { 00, 01, 02 }, "fake-content-type");

        //Act
        var result = response.IsValid();

        //Assert
        Assert.True(result);
    }

    [Theory]
    [InlineData("fake-content", "application/json", "{\"type\": \"string\"}")]
    [InlineData("{\"fake\": \"content\"}", "text/plain", "{\"type\": \"string\"}")]
    [InlineData("{\"fake\": \"content\"}", "application/json", "{\"type\": \"string\"}")]
    [InlineData("{\"fake\": \"content\"}", "application/json; charset=utf-8", "{\"type\": \"string\"}")]
    public void ItShouldFailValidationWithSchema(string content, string contentType, string schemaJson)
    {
        //Arrange
        var response = new RestApiOperationResponse(content, contentType, KernelJsonSchema.Parse(schemaJson));

        //Act
        var result = response.IsValid();

        //Assert
        Assert.False(result);
    }

    [Theory]
    [InlineData("\"fake-content\"", "application/json", "{\"type\": \"string\"}")]
    [InlineData("fake-content", "text/plain", "{\"type\": \"string\"}")]
    [InlineData("fake-content", "application/xml", "{\"type\": \"string\"}")]
    [InlineData("fake-content", "image", "{\"type\": \"string\"}")]
    [InlineData("\"fake-content\"", "application/json; charset=utf-8", "{\"type\": \"string\"}")]
    public void ItShouldPassValidationWithSchema(string content, string contentType, string schemaJson)
    {
        //Arrange
        var response = new RestApiOperationResponse(content, contentType, KernelJsonSchema.Parse(schemaJson));

        //Act
        var result = response.IsValid();

        //Assert
        Assert.True(result);
    }

    [Theory]
    [InlineData("ValidProductContent.json", "application/json", "ObjectResponseSchema.json")]
    [InlineData("ValidProductContent.json", "application/json", "ProductResponseSchema.json")]
    public void IsValidShouldBeTrue(string contentFileName, string contentType, string schemaJsonFilename)
    {
        //Arrange
        var contentText = ResourceResponseProvider.LoadFromResource(contentFileName);
        var productJson = ResourceResponseProvider.LoadFromResource(schemaJsonFilename);
        var response = new RestApiOperationResponse(contentText, contentType, KernelJsonSchema.Parse(productJson));

        //Act
        var result = response.IsValid();

        //Assert
        Assert.True(result);
    }

    [Theory]
    [InlineData("NotProductContent.json", "application/json", "ProductResponseSchema.json")]
    [InlineData("InvalidProductContent.json", "application/json", "ProductResponseSchema.json")]
    public void IsValidShouldBeFalse(string contentFileName, string contentType, string schemaJsonFilename)
    {
        //Arrange
        var contentText = ResourceResponseProvider.LoadFromResource(contentFileName);
        var productJson = ResourceResponseProvider.LoadFromResource(schemaJsonFilename);
        var response = new RestApiOperationResponse(contentText, contentType, KernelJsonSchema.Parse(productJson));

        //Act
        var result = response.IsValid();

        //Assert
        Assert.False(result);
    }

    [Theory]
    [InlineData(null, "")]
    [InlineData("content", "content")]
    public void ToStringReturnsString(object? content, string expectedContent)
    {
        // Arrange
        var response = new RestApiOperationResponse(content!, "application/json");

        // Act
        var result = response.ToString();

        // Assert
        Assert.Equal(expectedContent, result);
    }
}


===== Functions.UnitTests\OpenApi\RestApiOperationRunnerTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Net.Mime;
using System.Text;
using System.Text.Json;
using System.Text.Json.Nodes;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Http;
using Microsoft.SemanticKernel.Plugins.OpenApi;
using Moq;
using SemanticKernel.Functions.UnitTests.OpenApi.TestResponses;
using Xunit;

namespace SemanticKernel.Functions.UnitTests.OpenApi;

public sealed class RestApiOperationRunnerTests : IDisposable
{
    /// <summary>
    /// A mock instance of the authentication callback.
    /// </summary>
    private readonly Mock<AuthenticateRequestAsyncCallback> _authenticationHandlerMock;

    /// <summary>
    /// An instance of HttpMessageHandlerStub class used to get access to various properties of HttpRequestMessage sent by HTTP client.
    /// </summary>
    private readonly HttpMessageHandlerStub _httpMessageHandlerStub;

    /// <summary>
    /// An instance of HttpClient class used by the tests.
    /// </summary>
    private readonly HttpClient _httpClient;

    /// <summary>
    /// Creates an instance of a <see cref="RestApiOperationRunnerTests"/> class.
    /// </summary>
    public RestApiOperationRunnerTests()
    {
        this._authenticationHandlerMock = new Mock<AuthenticateRequestAsyncCallback>();

        this._httpMessageHandlerStub = new HttpMessageHandlerStub();

        this._httpClient = new HttpClient(this._httpMessageHandlerStub);
    }

    [Theory]
    [InlineData("POST")]
    [InlineData("PUT")]
    [InlineData("PATCH")]
    [InlineData("DELETE")]
    [InlineData("GET")]
    public async Task ItCanRunCreateAndUpdateOperationsWithJsonPayloadSuccessfullyAsync(string method)
    {
        // Arrange
        this._httpMessageHandlerStub.ResponseToReturn.Content = new StringContent("fake-content", Encoding.UTF8, MediaTypeNames.Application.Json);

        var httpMethod = new HttpMethod(method);

        var operation = new RestApiOperation(
            id: "fake-id",
            servers: [new RestApiServer("https://fake-random-test-host")],
            path: "fake-path",
            method: httpMethod,
            description: "fake-description",
            parameters: [],
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            securityRequirements: []
        );

        var payload = new
        {
            value = "fake-value",
            attributes = new
            {
                enabled = true
            }
        };

        var arguments = new KernelArguments
        {
            { "payload", JsonSerializer.Serialize(payload) },
            { "content-type", "application/json" }
        };

        var sut = new RestApiOperationRunner(this._httpClient, this._authenticationHandlerMock.Object);

        // Act
        var result = await sut.RunAsync(operation, arguments);

        // Assert
        Assert.NotNull(this._httpMessageHandlerStub.RequestUri);
        Assert.Equal("https://fake-random-test-host/fake-path", this._httpMessageHandlerStub.RequestUri.AbsoluteUri);

        Assert.Equal(httpMethod, this._httpMessageHandlerStub.Method);

        Assert.NotNull(this._httpMessageHandlerStub.ContentHeaders);
        Assert.Contains(this._httpMessageHandlerStub.ContentHeaders, h => h.Key == "Content-Type" && h.Value.Contains("application/json; charset=utf-8"));

        var messageContent = this._httpMessageHandlerStub.RequestContent;
        Assert.NotNull(messageContent);
        Assert.NotEmpty(messageContent);

        var deserializedPayload = await JsonNode.ParseAsync(new MemoryStream(messageContent));
        Assert.NotNull(deserializedPayload);

        var valueProperty = deserializedPayload["value"]?.ToString();
        Assert.Equal("fake-value", valueProperty);

        var attributesProperty = deserializedPayload["attributes"];
        Assert.NotNull(attributesProperty);

        var enabledProperty = attributesProperty["enabled"]?.AsValue();
        Assert.NotNull(enabledProperty);
        Assert.Equal("true", enabledProperty.ToString());

        Assert.NotNull(result);

        Assert.Equal("fake-content", result.Content);

        Assert.Equal("application/json; charset=utf-8", result.ContentType);

        this._authenticationHandlerMock.Verify(x => x(It.IsAny<HttpRequestMessage>(), It.IsAny<CancellationToken>()), Times.Once);
    }

    [Theory]
    [InlineData("POST")]
    [InlineData("PUT")]
    [InlineData("PATCH")]
    [InlineData("DELETE")]
    [InlineData("GET")]
    public async Task ItCanRunCreateAndUpdateOperationsWithPlainTextPayloadSuccessfullyAsync(string method)
    {
        // Arrange
        this._httpMessageHandlerStub.ResponseToReturn.Content = new StringContent("fake-content", Encoding.UTF8, MediaTypeNames.Text.Plain);

        var httpMethod = new HttpMethod(method);

        var operation = new RestApiOperation(
            id: "fake-id",
            servers: [new RestApiServer("https://fake-random-test-host")],
            path: "fake-path",
            method: httpMethod,
            description: "fake-description",
            parameters: [],
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            securityRequirements: []
        );

        var arguments = new KernelArguments
        {
            { "payload", "fake-input-value" },
            { "content-type", "text/plain"}
        };

        var sut = new RestApiOperationRunner(this._httpClient, this._authenticationHandlerMock.Object);

        // Act
        var result = await sut.RunAsync(operation, arguments);

        // Assert
        Assert.NotNull(this._httpMessageHandlerStub.RequestUri);
        Assert.Equal("https://fake-random-test-host/fake-path", this._httpMessageHandlerStub.RequestUri.AbsoluteUri);

        Assert.Equal(httpMethod, this._httpMessageHandlerStub.Method);

        Assert.NotNull(this._httpMessageHandlerStub.ContentHeaders);
        Assert.Contains(this._httpMessageHandlerStub.ContentHeaders, h => h.Key == "Content-Type" && h.Value.Contains("text/plain; charset=utf-8"));

        var messageContent = this._httpMessageHandlerStub.RequestContent;
        Assert.NotNull(messageContent);
        Assert.NotEmpty(messageContent);

        var payloadText = Encoding.UTF8.GetString(messageContent, 0, messageContent.Length);
        Assert.Equal("fake-input-value", payloadText);

        Assert.NotNull(result);

        Assert.Equal("fake-content", result.Content);

        Assert.Equal("text/plain; charset=utf-8", result.ContentType);

        this._authenticationHandlerMock.Verify(x => x(It.IsAny<HttpRequestMessage>(), It.IsAny<CancellationToken>()), Times.Once);
    }

    [Fact]
    public async Task ItShouldAddHeadersToHttpRequestAsync()
    {
        // Arrange
        var parameters = new List<RestApiParameter>
        {
            new(name: "X-HS-1", type: "string", isRequired: true, expand: false, location: RestApiParameterLocation.Header, style: RestApiParameterStyle.Simple),
            new(name: "X-HA-1", type: "array", isRequired: true, expand: false, location: RestApiParameterLocation.Header, style: RestApiParameterStyle.Simple),
            new(name: "X-HA-2", type: "array", isRequired: true, expand: false, location: RestApiParameterLocation.Header, style: RestApiParameterStyle.Simple),
            new(name: "X-HB-1", type: "boolean", isRequired: true, expand: false, location: RestApiParameterLocation.Header, style: RestApiParameterStyle.Simple),
            new(name: "X-HB-2", type: "boolean", isRequired: true, expand: false, location: RestApiParameterLocation.Header, style: RestApiParameterStyle.Simple),
            new(name: "X-HI-1", type: "integer", isRequired: true, expand: false, location: RestApiParameterLocation.Header, style: RestApiParameterStyle.Simple),
            new(name: "X-HI-2", type: "integer", isRequired: true, expand: false, location: RestApiParameterLocation.Header, style: RestApiParameterStyle.Simple),
            new(name: "X-HN-1", type: "number", isRequired: true, expand: false, location: RestApiParameterLocation.Header, style: RestApiParameterStyle.Simple),
            new(name: "X-HN-2", type: "number", isRequired: true, expand: false, location: RestApiParameterLocation.Header, style: RestApiParameterStyle.Simple),
            new(name: "X-HD-1", type: "string", isRequired: true, expand: false, location: RestApiParameterLocation.Header, style: RestApiParameterStyle.Simple),
            new(name: "X-HD-2", type: "string", isRequired: true, expand: false, location: RestApiParameterLocation.Header, style: RestApiParameterStyle.Simple),
            new(name: "X-HD-3", type: "string", isRequired: true, expand: false, location: RestApiParameterLocation.Header, style: RestApiParameterStyle.Simple),
        };

        var operation = new RestApiOperation(
            id: "fake-id",
            servers: [new RestApiServer("https://fake-random-test-host")],
            path: "fake-path",
            method: HttpMethod.Get,
            description: "fake-description",
            parameters: parameters,
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            securityRequirements: []
        );

        var arguments = new KernelArguments
        {
            ["X-HS-1"] = "fake-header-value",
            ["X-HA-1"] = "[1,2,3]",
            ["X-HA-2"] = new Collection<string>() { "3", "4", "5" },
            ["X-HB-1"] = "true",
            ["X-HB-2"] = false,
            ["X-HI-1"] = "10",
            ["X-HI-2"] = 20,
            ["X-HN-1"] = 5698.4567,
            ["X-HN-2"] = "5698.4567",
            ["X-HD-1"] = "2023-12-06T11:53:36Z",
            ["X-HD-2"] = new DateTime(2023, 12, 06, 11, 53, 36, DateTimeKind.Utc),
            ["X-HD-3"] = new DateTimeOffset(2023, 12, 06, 11, 53, 36, TimeSpan.FromHours(-2)),
        };

        var sut = new RestApiOperationRunner(this._httpClient, this._authenticationHandlerMock.Object, userAgent: "fake-agent");

        // Act
        await sut.RunAsync(operation, arguments);

        // Assert - 13 headers: 12 from the test and the User-Agent added internally
        Assert.NotNull(this._httpMessageHandlerStub.RequestHeaders);
        Assert.Equal(14, this._httpMessageHandlerStub.RequestHeaders.Count());

        Assert.Contains(this._httpMessageHandlerStub.RequestHeaders, h => h.Key == "User-Agent" && h.Value.Contains("fake-agent"));
        Assert.Contains(this._httpMessageHandlerStub.RequestHeaders, h => h.Key == "X-HS-1" && h.Value.Contains("fake-header-value"));
        Assert.Contains(this._httpMessageHandlerStub.RequestHeaders, h => h.Key == "X-HA-1" && h.Value.Contains("1,2,3"));
        Assert.Contains(this._httpMessageHandlerStub.RequestHeaders, h => h.Key == "X-HA-2" && h.Value.Contains("3,4,5"));
        Assert.Contains(this._httpMessageHandlerStub.RequestHeaders, h => h.Key == "X-HB-1" && h.Value.Contains("true"));
        Assert.Contains(this._httpMessageHandlerStub.RequestHeaders, h => h.Key == "X-HB-2" && h.Value.Contains("false"));
        Assert.Contains(this._httpMessageHandlerStub.RequestHeaders, h => h.Key == "X-HI-1" && h.Value.Contains("10"));
        Assert.Contains(this._httpMessageHandlerStub.RequestHeaders, h => h.Key == "X-HI-2" && h.Value.Contains("20"));
        Assert.Contains(this._httpMessageHandlerStub.RequestHeaders, h => h.Key == "X-HN-1" && h.Value.Contains("5698.4567"));
        Assert.Contains(this._httpMessageHandlerStub.RequestHeaders, h => h.Key == "X-HN-2" && h.Value.Contains("5698.4567"));
        Assert.Contains(this._httpMessageHandlerStub.RequestHeaders, h => h.Key == "X-HD-1" && h.Value.Contains("2023-12-06T11:53:36Z"));
        Assert.Contains(this._httpMessageHandlerStub.RequestHeaders, h => h.Key == "X-HD-2" && h.Value.Contains("2023-12-06T11:53:36Z"));
        Assert.Contains(this._httpMessageHandlerStub.RequestHeaders, h => h.Key == "X-HD-3" && h.Value.Contains("2023-12-06T11:53:36-02:00"));
        Assert.Contains(this._httpMessageHandlerStub.RequestHeaders, h => h.Key == "Semantic-Kernel-Version");
    }

    [Fact]
    public async Task ItShouldAddUserAgentHeaderToHttpRequestIfConfiguredAsync()
    {
        // Arrange
        var parameters = new List<RestApiParameter>
        {
            new(
            name: "fake-header",
            type: "string",
            isRequired: true,
            expand: false,
            location: RestApiParameterLocation.Header,
            style: RestApiParameterStyle.Simple)
        };

        var operation = new RestApiOperation(
            id: "fake-id",
            servers: [new RestApiServer("https://fake-random-test-host")],
            path: "fake-path",
            method: HttpMethod.Get,
            description: "fake-description",
            parameters: parameters,
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            securityRequirements: []
        );

        var arguments = new KernelArguments
        {
            { "fake-header", "fake-header-value" }
        };

        var sut = new RestApiOperationRunner(this._httpClient, this._authenticationHandlerMock.Object, "fake-user-agent");

        // Act
        await sut.RunAsync(operation, arguments);

        // Assert
        Assert.NotNull(this._httpMessageHandlerStub.RequestHeaders);
        Assert.Equal(3, this._httpMessageHandlerStub.RequestHeaders.Count());

        Assert.Contains(this._httpMessageHandlerStub.RequestHeaders, h => h.Key == "fake-header" && h.Value.Contains("fake-header-value"));
        Assert.Contains(this._httpMessageHandlerStub.RequestHeaders, h => h.Key == "User-Agent" && h.Value.Contains("fake-user-agent"));
        Assert.Contains(this._httpMessageHandlerStub.RequestHeaders, h => h.Key == "Semantic-Kernel-Version");
    }

    [Fact]
    public async Task ItShouldBuildJsonPayloadDynamicallyAsync()
    {
        // Arrange
        this._httpMessageHandlerStub.ResponseToReturn.Content = new StringContent("fake-content", Encoding.UTF8, MediaTypeNames.Application.Json);

        List<RestApiPayloadProperty> payloadProperties =
        [
            new("name", "string", true, []),
            new("attributes", "object", false,
            [
                new("enabled", "boolean", false, []),
            ])
        ];

        var payload = new RestApiPayload(MediaTypeNames.Application.Json, payloadProperties);

        var operation = new RestApiOperation(
            id: "fake-id",
            servers: [new RestApiServer("https://fake-random-test-host")],
            path: "fake-path",
            method: HttpMethod.Post,
            description: "fake-description",
            parameters: [],
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            securityRequirements: [],
            payload: payload
        );

        var arguments = new KernelArguments
        {
            { "name", "fake-name-value" },
            { "enabled", true }
        };

        var sut = new RestApiOperationRunner(this._httpClient, this._authenticationHandlerMock.Object, enableDynamicPayload: true);

        // Act
        var result = await sut.RunAsync(operation, arguments);

        // Assert
        Assert.NotNull(this._httpMessageHandlerStub.ContentHeaders);
        Assert.Contains(this._httpMessageHandlerStub.ContentHeaders, h => h.Key == "Content-Type" && h.Value.Contains("application/json; charset=utf-8"));

        var messageContent = this._httpMessageHandlerStub.RequestContent;
        Assert.NotNull(messageContent);
        Assert.NotEmpty(messageContent);

        var deserializedPayload = await JsonNode.ParseAsync(new MemoryStream(messageContent));
        Assert.NotNull(deserializedPayload);

        var name = deserializedPayload["name"]?.ToString();
        Assert.Equal("fake-name-value", name);

        var attributes = deserializedPayload["attributes"];
        Assert.NotNull(attributes);

        var enabled = attributes["enabled"]?.ToString();
        Assert.NotNull(enabled);
        Assert.Equal("true", enabled);
    }

    [Fact]
    public async Task ItShouldBuildJsonPayloadDynamicallyUsingPayloadMetadataDataTypesAsync()
    {
        // Arrange
        this._httpMessageHandlerStub.ResponseToReturn.Content = new StringContent("fake-content", Encoding.UTF8, MediaTypeNames.Application.Json);

        List<RestApiPayloadProperty> payloadProperties =
        [
            new("name", "string", true, []),
            new("attributes", "object", false,
            [
                new("enabled", "boolean", false, []),
                new("cardinality", "number", false, []),
                new("coefficient", "number", false, []),
                new("count", "integer", false, []),
                new("params", "array", false, []),
            ])
        ];

        var payload = new RestApiPayload(MediaTypeNames.Application.Json, payloadProperties);

        var operation = new RestApiOperation(
            id: "fake-id",
            servers: [new RestApiServer("https://fake-random-test-host")],
            path: "fake-path",
            method: HttpMethod.Post,
            description: "fake-description",
            parameters: [],
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            securityRequirements: [],
            payload: payload
        );

        var arguments = new KernelArguments
        {
            { "name", "fake-string-value" },
            { "enabled", "true" },
            { "cardinality", 8 },
            { "coefficient", "0.8" },
            { "count", 1 },
            { "params", "[1,2,3]" }
        };

        var sut = new RestApiOperationRunner(this._httpClient, this._authenticationHandlerMock.Object, enableDynamicPayload: true);

        // Act
        var result = await sut.RunAsync(operation, arguments);

        // Assert
        var messageContent = this._httpMessageHandlerStub.RequestContent;
        Assert.NotNull(messageContent);

        var deserializedPayload = await JsonNode.ParseAsync(new MemoryStream(messageContent));
        Assert.NotNull(deserializedPayload);

        var name = deserializedPayload["name"]?.GetValue<JsonElement>();
        Assert.NotNull(name);
        Assert.Equal(JsonValueKind.String, name.Value.ValueKind);
        Assert.Equal("fake-string-value", name.ToString());

        var attributes = deserializedPayload["attributes"];
        Assert.True(attributes is JsonObject);

        var enabled = attributes["enabled"]?.GetValue<JsonElement>();
        Assert.NotNull(enabled);
        Assert.Equal(JsonValueKind.True, enabled.Value.ValueKind);

        var cardinality = attributes["cardinality"]?.GetValue<JsonElement>();
        Assert.NotNull(cardinality);
        Assert.Equal(JsonValueKind.Number, cardinality.Value.ValueKind);
        Assert.Equal("8", cardinality.Value.ToString());

        var coefficient = attributes["coefficient"]?.GetValue<JsonElement>();
        Assert.NotNull(coefficient);
        Assert.Equal(JsonValueKind.Number, coefficient.Value.ValueKind);
        Assert.Equal("0.8", coefficient.Value.ToString());

        var count = attributes["count"]?.GetValue<JsonElement>();
        Assert.NotNull(count);
        Assert.Equal(JsonValueKind.Number, coefficient.Value.ValueKind);
        Assert.Equal("1", count.Value.ToString());

        var parameters = attributes["params"];
        Assert.NotNull(parameters);
        Assert.True(parameters is JsonArray);
    }

    [Fact]
    public async Task ItShouldBuildJsonPayloadDynamicallyResolvingArgumentsByFullNamesAsync()
    {
        // Arrange
        this._httpMessageHandlerStub.ResponseToReturn.Content = new StringContent("fake-content", Encoding.UTF8, MediaTypeNames.Application.Json);

        List<RestApiPayloadProperty> payloadProperties =
        [
            new("upn", "string", true, []),
            new("receiver", "object", false,
            [
                new("upn", "string", false, []),
                new("alternative", "object", false,
                [
                    new("upn", "string", false, []),
                ]),
            ]),
            new("cc", "object", false,
            [
                new("upn", "string", false, []),
            ])
        ];

        var payload = new RestApiPayload(MediaTypeNames.Application.Json, payloadProperties);

        var operation = new RestApiOperation(
            id: "fake-id",
            servers: [new RestApiServer("https://fake-random-test-host")],
            path: "fake-path",
            method: HttpMethod.Post,
            description: "fake-description",
            parameters: [],
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            securityRequirements: [],
            payload: payload
        );

        var arguments = new KernelArguments
        {
            { "upn", "fake-sender-upn" },
            { "receiver.upn", "fake-receiver-upn" },
            { "receiver.alternative.upn", "fake-receiver-alternative-upn" },
            { "cc.upn", "fake-cc-upn" }
        };

        var sut = new RestApiOperationRunner(
            this._httpClient,
            this._authenticationHandlerMock.Object,
            enableDynamicPayload: true,
            enablePayloadNamespacing: true);

        // Act
        var result = await sut.RunAsync(operation, arguments);

        // Assert
        Assert.NotNull(this._httpMessageHandlerStub.ContentHeaders);
        Assert.Contains(this._httpMessageHandlerStub.ContentHeaders, h => h.Key == "Content-Type" && h.Value.Contains("application/json; charset=utf-8"));

        var messageContent = this._httpMessageHandlerStub.RequestContent;
        Assert.NotNull(messageContent);
        Assert.NotEmpty(messageContent);

        var deserializedPayload = await JsonNode.ParseAsync(new MemoryStream(messageContent));
        Assert.NotNull(deserializedPayload);

        //Sender props
        var senderUpn = deserializedPayload["upn"]?.ToString();
        Assert.Equal("fake-sender-upn", senderUpn);

        //Receiver props
        var receiver = deserializedPayload["receiver"];
        Assert.NotNull(receiver);

        var receiverUpn = receiver["upn"]?.AsValue();
        Assert.NotNull(receiverUpn);
        Assert.Equal("fake-receiver-upn", receiverUpn.ToString());

        var alternative = receiver["alternative"];
        Assert.NotNull(alternative);

        var alternativeUpn = alternative["upn"]?.AsValue();
        Assert.NotNull(alternativeUpn);
        Assert.Equal("fake-receiver-alternative-upn", alternativeUpn.ToString());

        //CC props
        var carbonCopy = deserializedPayload["cc"];
        Assert.NotNull(carbonCopy);

        var ccUpn = carbonCopy["upn"]?.AsValue();
        Assert.NotNull(ccUpn);
        Assert.Equal("fake-cc-upn", ccUpn.ToString());
    }

    [Fact]
    public async Task ItShouldThrowExceptionIfPayloadMetadataDoesNotHaveContentTypeAsync()
    {
        // Arrange
        var operation = new RestApiOperation(
            id: "fake-id",
            servers: [new RestApiServer("https://fake-random-test-host")],
            path: "fake-path",
            method: HttpMethod.Post,
            description: "fake-description",
            parameters: [],
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            securityRequirements: [],
            payload: null
        );

        KernelArguments arguments = new() { { RestApiOperation.PayloadArgumentName, "fake-content" } };

        var sut = new RestApiOperationRunner(
            this._httpClient,
            this._authenticationHandlerMock.Object,
            enableDynamicPayload: true);

        // Act
        var exception = await Assert.ThrowsAsync<KernelException>(async () => await sut.RunAsync(operation, arguments));

        Assert.Contains("No media type is provided", exception.Message, StringComparison.InvariantCulture);
    }

    [Fact]
    public async Task ItShouldThrowExceptionIfContentTypeArgumentIsNotProvidedAsync()
    {
        // Arrange
        var operation = new RestApiOperation(
            id: "fake-id",
            servers: [new RestApiServer("https://fake-random-test-host")],
            path: "fake-path",
            method: HttpMethod.Post,
            description: "fake-description",
            parameters: [],
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            securityRequirements: [],
            payload: null
        );

        KernelArguments arguments = new() { { RestApiOperation.PayloadArgumentName, "fake-content" } };

        var sut = new RestApiOperationRunner(
            this._httpClient,
            this._authenticationHandlerMock.Object,
            enableDynamicPayload: false);

        // Act
        var exception = await Assert.ThrowsAsync<KernelException>(async () => await sut.RunAsync(operation, arguments));

        Assert.Contains("No media type is provided", exception.Message, StringComparison.InvariantCulture);
    }

    [Fact]
    public async Task ItShouldUsePayloadArgumentForPlainTextContentTypeWhenBuildingPayloadDynamicallyAsync()
    {
        // Arrange
        this._httpMessageHandlerStub.ResponseToReturn.Content = new StringContent("fake-content", Encoding.UTF8, MediaTypeNames.Text.Plain);

        var payload = new RestApiPayload(MediaTypeNames.Text.Plain, []);

        var operation = new RestApiOperation(
            id: "fake-id",
            servers: [new RestApiServer("https://fake-random-test-host")],
            path: "fake-path",
            method: HttpMethod.Post,
            description: "fake-description",
            parameters: [],
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            securityRequirements: [],
            payload: payload
        );

        var arguments = new KernelArguments
        {
            { "payload", "fake-input-value" },
        };

        var sut = new RestApiOperationRunner(this._httpClient, this._authenticationHandlerMock.Object, enableDynamicPayload: true);

        // Act
        var result = await sut.RunAsync(operation, arguments);

        // Assert
        Assert.NotNull(this._httpMessageHandlerStub.ContentHeaders);
        Assert.Contains(this._httpMessageHandlerStub.ContentHeaders, h => h.Key == "Content-Type" && h.Value.Contains("text/plain; charset=utf-8"));

        var messageContent = this._httpMessageHandlerStub.RequestContent;
        Assert.NotNull(messageContent);
        Assert.NotEmpty(messageContent);

        var payloadText = Encoding.UTF8.GetString(messageContent, 0, messageContent.Length);
        Assert.Equal("fake-input-value", payloadText);
    }

    [Theory]
    [InlineData(MediaTypeNames.Text.Plain)]
    [InlineData(MediaTypeNames.Application.Json)]
    public async Task ItShouldUsePayloadAndContentTypeArgumentsIfDynamicPayloadBuildingIsNotRequiredAsync(string contentType)
    {
        // Arrange
        this._httpMessageHandlerStub.ResponseToReturn.Content = new StringContent("fake-content", Encoding.UTF8, MediaTypeNames.Text.Plain);

        var operation = new RestApiOperation(
            id: "fake-id",
            servers: [new RestApiServer("https://fake-random-test-host")],
            path: "fake-path",
            method: HttpMethod.Post,
            description: "fake-description",
            parameters: [],
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            securityRequirements: [],
            payload: null
        );

        var arguments = new KernelArguments
        {
            { "payload", "fake-input-value" },
            { "content-type", $"{contentType}" },
        };

        var sut = new RestApiOperationRunner(this._httpClient, this._authenticationHandlerMock.Object, enableDynamicPayload: false);

        // Act
        var result = await sut.RunAsync(operation, arguments);

        // Assert
        Assert.NotNull(this._httpMessageHandlerStub.ContentHeaders);
        Assert.Contains(this._httpMessageHandlerStub.ContentHeaders, h => h.Key == "Content-Type" && h.Value.Contains($"{contentType}; charset=utf-8"));

        var messageContent = this._httpMessageHandlerStub.RequestContent;
        Assert.NotNull(messageContent);
        Assert.NotEmpty(messageContent);

        var payloadText = Encoding.UTF8.GetString(messageContent, 0, messageContent.Length);
        Assert.Equal("fake-input-value", payloadText);
    }

    [Fact]
    public async Task ItShouldBuildJsonPayloadDynamicallyExcludingOptionalParametersIfTheirArgumentsNotProvidedAsync()
    {
        // Arrange
        this._httpMessageHandlerStub.ResponseToReturn.Content = new StringContent("fake-content", Encoding.UTF8, MediaTypeNames.Application.Json);

        List<RestApiPayloadProperty> payloadProperties =
        [
            new("upn", "string", false, []),
        ];

        var payload = new RestApiPayload(MediaTypeNames.Application.Json, payloadProperties);

        var operation = new RestApiOperation(
            id: "fake-id",
            servers: [new RestApiServer("https://fake-random-test-host")],
            path: "fake-path",
            method: HttpMethod.Post,
            description: "fake-description",
            parameters: [],
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            securityRequirements: [],
            payload: payload
        );

        var arguments = new KernelArguments();

        var sut = new RestApiOperationRunner(
            this._httpClient,
            this._authenticationHandlerMock.Object,
            enableDynamicPayload: true,
            enablePayloadNamespacing: true);

        // Act
        var result = await sut.RunAsync(operation, arguments);

        // Assert
        var messageContent = this._httpMessageHandlerStub.RequestContent;
        Assert.NotNull(messageContent);
        Assert.NotEmpty(messageContent);

        var deserializedPayload = await JsonNode.ParseAsync(new MemoryStream(messageContent));
        Assert.NotNull(deserializedPayload);

        var senderUpn = deserializedPayload["upn"]?.ToString();
        Assert.Null(senderUpn);
    }

    [Fact]
    public async Task ItShouldBuildJsonPayloadDynamicallyIncludingOptionalParametersIfTheirArgumentsProvidedAsync()
    {
        // Arrange
        this._httpMessageHandlerStub.ResponseToReturn.Content = new StringContent("fake-content", Encoding.UTF8, MediaTypeNames.Application.Json);

        List<RestApiPayloadProperty> payloadProperties =
        [
            new("upn", "string", false, []),
        ];

        var payload = new RestApiPayload(MediaTypeNames.Application.Json, payloadProperties);

        var operation = new RestApiOperation(
            id: "fake-id",
            servers: [new RestApiServer("https://fake-random-test-host")],
            path: "fake-path",
            method: HttpMethod.Post,
            description: "fake-description",
            parameters: [],
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            securityRequirements: [],
            payload: payload
        );

        var arguments = new KernelArguments { ["upn"] = "fake-sender-upn" };

        var sut = new RestApiOperationRunner(
            this._httpClient,
            this._authenticationHandlerMock.Object,
            enableDynamicPayload: true,
            enablePayloadNamespacing: true);

        // Act
        var result = await sut.RunAsync(operation, arguments);

        // Assert
        var messageContent = this._httpMessageHandlerStub.RequestContent;
        Assert.NotNull(messageContent);
        Assert.NotEmpty(messageContent);

        var deserializedPayload = await JsonNode.ParseAsync(new MemoryStream(messageContent));
        Assert.NotNull(deserializedPayload);

        var senderUpn = deserializedPayload["upn"]?.ToString();
        Assert.Equal("fake-sender-upn", senderUpn);
    }

    [Fact]
    public async Task ItShouldAddRequiredQueryStringParametersIfTheirArgumentsProvidedAsync()
    {
        // Arrange
        this._httpMessageHandlerStub.ResponseToReturn.Content = new StringContent("fake-content", Encoding.UTF8, MediaTypeNames.Application.Json);

        var firstParameter = new RestApiParameter(
            "p1",
            "string",
            isRequired: true, //Marking the parameter as required
            false,
            RestApiParameterLocation.Query,
            RestApiParameterStyle.Form);

        var secondParameter = new RestApiParameter(
            "p2",
            "integer",
            isRequired: true, //Marking the parameter as required
            false,
            RestApiParameterLocation.Query,
            RestApiParameterStyle.Form);

        var operation = new RestApiOperation(
            id: "fake-id",
            servers: [new RestApiServer("https://fake-random-test-host")],
            path: "fake-path",
            method: HttpMethod.Get,
            description: "fake-description",
            parameters: [firstParameter, secondParameter],
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            securityRequirements: []
        );

        var arguments = new KernelArguments
        {
            { "p1", "v1" },
            { "p2", 28 },
        };

        var sut = new RestApiOperationRunner(this._httpClient, this._authenticationHandlerMock.Object);

        // Act
        var result = await sut.RunAsync(operation, arguments);

        // Assert
        Assert.NotNull(this._httpMessageHandlerStub.RequestUri);
        Assert.Equal("https://fake-random-test-host/fake-path?p1=v1&p2=28", this._httpMessageHandlerStub.RequestUri.AbsoluteUri);
    }

    [Fact]
    public async Task ItShouldAddNotRequiredQueryStringParametersIfTheirArgumentsProvidedAsync()
    {
        // Arrange
        this._httpMessageHandlerStub.ResponseToReturn.Content = new StringContent("fake-content", Encoding.UTF8, MediaTypeNames.Application.Json);

        var firstParameter = new RestApiParameter(
            "p1",
            "string",
            isRequired: false, //Marking the parameter as not required
            false,
            RestApiParameterLocation.Query,
            RestApiParameterStyle.Form);

        var secondParameter = new RestApiParameter(
            "p2",
            "string",
            isRequired: false, //Marking the parameter as not required
            false,
            RestApiParameterLocation.Query,
            RestApiParameterStyle.Form);

        var operation = new RestApiOperation(
            id: "fake-id",
            servers: [new RestApiServer("https://fake-random-test-host")],
            path: "fake-path",
            method: HttpMethod.Get,
            description: "fake-description",
            parameters: [firstParameter, secondParameter],
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            securityRequirements: []
        );

        var arguments = new KernelArguments
        {
            { "p1", new DateTime(2023, 12, 06, 11, 53, 36, DateTimeKind.Utc) },
            { "p2", "v2" },
        };

        var sut = new RestApiOperationRunner(this._httpClient, this._authenticationHandlerMock.Object);

        // Act
        var result = await sut.RunAsync(operation, arguments);

        // Assert
        Assert.NotNull(this._httpMessageHandlerStub.RequestUri);
        Assert.Equal("https://fake-random-test-host/fake-path?p1=2023-12-06T11%3a53%3a36Z&p2=v2", this._httpMessageHandlerStub.RequestUri.AbsoluteUri);
    }

    [Fact]
    public async Task ItShouldSkipNotRequiredQueryStringParametersIfNoArgumentsProvidedAsync()
    {
        // Arrange
        this._httpMessageHandlerStub.ResponseToReturn.Content = new StringContent("fake-content", Encoding.UTF8, MediaTypeNames.Application.Json);

        var firstParameter = new RestApiParameter(
            "p1",
            "string",
            isRequired: false, //Marking the parameter as not required
            false,
            RestApiParameterLocation.Query,
            RestApiParameterStyle.Form);

        var secondParameter = new RestApiParameter(
            "p2",
            "string",
            isRequired: true, //Marking the parameter as required
            false,
            RestApiParameterLocation.Query,
            RestApiParameterStyle.Form);

        var operation = new RestApiOperation(
            id: "fake-id",
            servers: [new RestApiServer("https://fake-random-test-host")],
            path: "fake-path",
            method: HttpMethod.Get,
            description: "fake-description",
            parameters: [firstParameter, secondParameter],
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            securityRequirements: []
        );

        var arguments = new KernelArguments
        {
            { "p2", "v2" }, //Providing argument for the required parameter only
        };

        var sut = new RestApiOperationRunner(this._httpClient, this._authenticationHandlerMock.Object);

        // Act
        var result = await sut.RunAsync(operation, arguments);

        // Assert
        Assert.NotNull(this._httpMessageHandlerStub.RequestUri);
        Assert.Equal("https://fake-random-test-host/fake-path?p2=v2", this._httpMessageHandlerStub.RequestUri.AbsoluteUri);
    }

    [Fact]
    public async Task ItShouldThrowExceptionIfNoArgumentProvidedForRequiredQueryStringParameterAsync()
    {
        // Arrange
        this._httpMessageHandlerStub.ResponseToReturn.Content = new StringContent("fake-content", Encoding.UTF8, MediaTypeNames.Application.Json);

        var parameter = new RestApiParameter(
            "p1",
            "string",
            isRequired: true, //Marking the parameter as required
            false,
            RestApiParameterLocation.Query,
            RestApiParameterStyle.Form);

        var operation = new RestApiOperation(
            id: "fake-id",
            servers: [new RestApiServer("https://fake-random-test-host")],
            path: "fake-path",
            method: HttpMethod.Get,
            description: "fake-description",
            parameters: [parameter],
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            securityRequirements: []
        );

        var arguments = new KernelArguments(); //Providing no arguments

        var sut = new RestApiOperationRunner(this._httpClient, this._authenticationHandlerMock.Object);

        // Act and Assert
        await Assert.ThrowsAsync<KernelException>(() => sut.RunAsync(operation, arguments));
    }

    [Theory]
    [InlineData(MediaTypeNames.Application.Json)]
    [InlineData(MediaTypeNames.Application.Xml)]
    [InlineData(MediaTypeNames.Text.Plain)]
    [InlineData(MediaTypeNames.Text.Html)]
    [InlineData(MediaTypeNames.Text.Xml)]
    [InlineData("text/csv")]
    [InlineData("text/markdown")]
    public async Task ItShouldReadContentAsStringSuccessfullyAsync(string contentType)
    {
        // Arrange
        this._httpMessageHandlerStub.ResponseToReturn.Content = new StringContent("fake-content", Encoding.UTF8, contentType);

        var operation = new RestApiOperation(
            id: "fake-id",
            servers: [new RestApiServer("https://fake-random-test-host")],
            path: "fake-path",
            method: HttpMethod.Post,
            description: "fake-description",
            parameters: [],
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            securityRequirements: []
        );

        var arguments = new KernelArguments
        {
            { "payload", JsonSerializer.Serialize(new { value = "fake-value" }) },
            { "content-type", "application/json" }
        };

        var sut = new RestApiOperationRunner(this._httpClient, this._authenticationHandlerMock.Object);

        // Act
        var result = await sut.RunAsync(operation, arguments);

        // Assert
        Assert.NotNull(result);

        Assert.Equal("fake-content", result.Content);

        Assert.Equal($"{contentType}; charset=utf-8", result.ContentType);
    }

    [Theory]
    [InlineData("image/jpeg")]
    [InlineData("image/png")]
    [InlineData("image/gif")]
    [InlineData("image/svg+xml")]
    [InlineData("image/bmp")]
    [InlineData("image/x-icon")]
    public async Task ItShouldReadContentAsBytesSuccessfullyAsync(string contentType)
    {
        // Arrange
        this._httpMessageHandlerStub.ResponseToReturn.Content = new ByteArrayContent([00, 01, 02]);
        this._httpMessageHandlerStub.ResponseToReturn.Content.Headers.ContentType = new MediaTypeHeaderValue(contentType);

        var operation = new RestApiOperation(
            id: "fake-id",
            servers: [new RestApiServer("https://fake-random-test-host")],
            path: "fake-path",
            method: HttpMethod.Post,
            description: "fake-description",
            parameters: [],
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            securityRequirements: []
        );

        var arguments = new KernelArguments
        {
            { "payload", JsonSerializer.Serialize(new { value = "fake-value" }) },
            { "content-type", "application/json" }
        };

        var sut = new RestApiOperationRunner(this._httpClient, this._authenticationHandlerMock.Object);

        // Act
        var result = await sut.RunAsync(operation, arguments);

        // Assert
        Assert.NotNull(result);

        Assert.Equal(new byte[] { 00, 01, 02 }, result.Content);

        Assert.Equal($"{contentType}", result.ContentType);
    }

    [Fact]
    public async Task ItShouldThrowExceptionForUnsupportedContentTypeAsync()
    {
        // Arrange
        this._httpMessageHandlerStub.ResponseToReturn.Content = new StringContent("fake-content", Encoding.UTF8, "fake/type");

        var operation = new RestApiOperation(
            id: "fake-id",
            servers: [new RestApiServer("https://fake-random-test-host")],
            path: "fake-path",
            method: HttpMethod.Post,
            description: "fake-description",
            parameters: [],
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            securityRequirements: []
        );

        var arguments = new KernelArguments
        {
            { "payload", JsonSerializer.Serialize(new { value = "fake-value" }) },
            { "content-type", "application/json" }
        };

        var sut = new RestApiOperationRunner(this._httpClient, this._authenticationHandlerMock.Object);

        // Act & Assert
        var kernelException = await Assert.ThrowsAsync<KernelException>(() => sut.RunAsync(operation, arguments));
        Assert.Equal("The content type `fake/type` is not supported.", kernelException.Message);
        Assert.Equal("POST", kernelException.Data["http.request.method"]);
        Assert.Equal("https://fake-random-test-host/fake-path", kernelException.Data["url.full"]);
        Assert.Equal("{\"value\":\"fake-value\"}", kernelException.Data["http.request.body"]);
    }

    [Fact]
    public async Task ItShouldReturnRequestUriAndContentAsync()
    {
        // Arrange
        this._httpMessageHandlerStub.ResponseToReturn.Content = new StringContent("fake-content", Encoding.UTF8, MediaTypeNames.Application.Json);

        List<RestApiPayloadProperty> payloadProperties =
        [
            new("name", "string", true, []),
            new("attributes", "object", false,
            [
                new("enabled", "boolean", false, []),
            ])
        ];

        var payload = new RestApiPayload(MediaTypeNames.Application.Json, payloadProperties);

        var operation = new RestApiOperation(
            id: "fake-id",
            servers: [new RestApiServer("https://fake-random-test-host")],
            path: "fake-path",
            method: HttpMethod.Post,
            description: "fake-description",
            parameters: [],
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            securityRequirements: [],
            payload: payload
        );

        var arguments = new KernelArguments
        {
            { "name", "fake-name-value" },
            { "enabled", true }
        };

        var sut = new RestApiOperationRunner(this._httpClient, this._authenticationHandlerMock.Object, enableDynamicPayload: true);

        // Act
        var result = await sut.RunAsync(operation, arguments);

        // Assert
        Assert.NotNull(result.RequestMethod);
        Assert.Equal(HttpMethod.Post.Method, result.RequestMethod);
        Assert.NotNull(result.RequestUri);
        Assert.Equal("https://fake-random-test-host/fake-path", result.RequestUri.AbsoluteUri);
        Assert.NotNull(result.RequestPayload);
        Assert.IsType<JsonObject>(result.RequestPayload);
        Assert.Equal("{\"name\":\"fake-name-value\",\"attributes\":{\"enabled\":true}}", ((JsonObject)result.RequestPayload).ToJsonString());
    }

    [InlineData(System.Net.HttpStatusCode.NoContent)]
    [InlineData(System.Net.HttpStatusCode.Accepted)]
    [InlineData(System.Net.HttpStatusCode.Created)]
    [Theory]
    public async Task ItShouldHandleNoContentAsync(System.Net.HttpStatusCode statusCode)
    {
        // Arrange
        this._httpMessageHandlerStub!.ResponseToReturn = new HttpResponseMessage(statusCode);

        List<RestApiPayloadProperty> payloadProperties =
        [
            new("name", "string", true, []),
            new("attributes", "object", false,
            [
                new("enabled", "boolean", false, []),
            ])
        ];

        var payload = new RestApiPayload(MediaTypeNames.Application.Json, payloadProperties);

        var operation = new RestApiOperation(
            id: "fake-id",
            servers: [new RestApiServer("https://fake-random-test-host")],
            path: "fake-path",
            method: HttpMethod.Post,
            description: "fake-description",
            parameters: [],
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            securityRequirements: [],
            payload: payload
        );

        var arguments = new KernelArguments
        {
            { "name", "fake-name-value" },
            { "enabled", true }
        };

        var sut = new RestApiOperationRunner(this._httpClient, this._authenticationHandlerMock.Object, enableDynamicPayload: true);

        // Act
        var result = await sut.RunAsync(operation, arguments);

        // Assert
        Assert.NotNull(result.RequestMethod);
        Assert.Equal(HttpMethod.Post.Method, result.RequestMethod);
        Assert.NotNull(result.RequestUri);
        Assert.Equal("https://fake-random-test-host/fake-path", result.RequestUri.AbsoluteUri);
        Assert.NotNull(result.RequestPayload);
        Assert.IsType<JsonObject>(result.RequestPayload);
        Assert.Equal("{\"name\":\"fake-name-value\",\"attributes\":{\"enabled\":true}}", ((JsonObject)result.RequestPayload).ToJsonString());
    }

    [Fact]
    public async Task ItShouldSetHttpRequestMessageOptionsAsync()
    {
        // Arrange
        this._httpMessageHandlerStub.ResponseToReturn.Content = new StringContent("fake-content", Encoding.UTF8, MediaTypeNames.Application.Json);

        List<RestApiPayloadProperty> payloadProperties =
        [
            new("name", "string", true, []),
            new("attributes", "object", false,
            [
                new("enabled", "boolean", false, []),
            ])
        ];

        var payload = new RestApiPayload(MediaTypeNames.Application.Json, payloadProperties);

        var operation = new RestApiOperation(
            id: "fake-id",
            servers: [new RestApiServer("https://fake-random-test-host")],
            path: "fake-path",
            method: HttpMethod.Post,
            description: "fake-description",
            parameters: [],
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            securityRequirements: [],
            payload: payload
        );

        var arguments = new KernelArguments
        {
            { "name", "fake-name-value" },
            { "enabled", true }
        };

        var options = new RestApiOperationRunOptions()
        {
            Kernel = new(),
            KernelFunction = KernelFunctionFactory.CreateFromMethod(() => false),
            KernelArguments = arguments,
        };

        var sut = new RestApiOperationRunner(this._httpClient, this._authenticationHandlerMock.Object, enableDynamicPayload: true);

        // Act
        var result = await sut.RunAsync(operation, arguments, options);

        // Assert
        var requestMessage = this._httpMessageHandlerStub.RequestMessage;
        Assert.NotNull(requestMessage);
        Assert.True(requestMessage.Options.TryGetValue(OpenApiKernelFunctionContext.KernelFunctionContextKey, out var kernelFunctionContext));
        Assert.NotNull(kernelFunctionContext);
        Assert.Equal(options.Kernel, kernelFunctionContext.Kernel);
        Assert.Equal(options.KernelFunction, kernelFunctionContext.Function);
        Assert.Equal(options.KernelArguments, kernelFunctionContext.Arguments);
    }

    [Theory]
    [MemberData(nameof(RestApiOperationRunnerExceptions))]
    public async Task ItShouldIncludeRequestDataWhenOperationExecutionFailsAsync(Type expectedExceptionType, string expectedExceptionMessage, Exception expectedException)
    {
        // Arrange
        this._httpMessageHandlerStub.ExceptionToThrow = expectedException;

        var operation = new RestApiOperation(
            id: "fake-id",
            servers: [new RestApiServer("https://fake-random-test-host")],
            path: "fake-path",
            method: HttpMethod.Post,
            description: "fake-description",
            parameters: [],
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            securityRequirements: []
        );

        var arguments = new KernelArguments
        {
            { "payload", JsonSerializer.Serialize(new { value = "fake-value" }) },
            { "content-type", "application/json" }
        };

        var sut = new RestApiOperationRunner(this._httpClient, this._authenticationHandlerMock.Object);

        // Act & Assert
        var actualException = await Assert.ThrowsAsync(expectedExceptionType, () => sut.RunAsync(operation, arguments));
        Assert.Equal(expectedExceptionMessage, actualException.Message);
        Assert.Equal("POST", actualException.Data["http.request.method"]);
        Assert.Equal("https://fake-random-test-host/fake-path", actualException.Data["url.full"]);
        Assert.Equal("{\"value\":\"fake-value\"}", actualException.Data["http.request.body"]);
        Assert.NotNull(actualException.Data["http.request.options"]);
    }

    /// <summary>
    /// Exceptions to thrown by <see cref="RestApiOperationRunner"/>.
    /// </summary>
    public static TheoryData<Type, string, Exception> RestApiOperationRunnerExceptions => new()
    {
        { typeof(HttpOperationException) , "An error occurred during the HTTP operation.", new HttpOperationException("An error occurred during the HTTP operation.") },
        { typeof(OperationCanceledException) , "The operation was canceled.", new OperationCanceledException("The operation was canceled.") },
        { typeof(KernelException) , "A critical kernel error occurred.", new KernelException("A critical kernel error occurred.") }
    };

    [Fact]
    public async Task ItShouldUseCustomHttpResponseContentReaderAsync()
    {
        // Arrange
        var operation = new RestApiOperation(
            id: "fake-id",
            servers: [new RestApiServer("https://fake-random-test-host")],
            path: "fake-path",
            method: HttpMethod.Get,
            description: "fake-description",
            parameters: [],
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            securityRequirements: []
        );

        var expectedCancellationToken = new CancellationToken();

        async Task<object?> ReadHttpResponseContentAsync(HttpResponseContentReaderContext context, CancellationToken cancellationToken)
        {
            Assert.Equal(expectedCancellationToken, cancellationToken);

            return await context.Response.Content.ReadAsStreamAsync(cancellationToken);
        }

        var sut = new RestApiOperationRunner(this._httpClient, this._authenticationHandlerMock.Object, httpResponseContentReader: ReadHttpResponseContentAsync);

        // Act
        var response = await sut.RunAsync(operation, [], cancellationToken: expectedCancellationToken);

        // Assert
        Assert.IsAssignableFrom<Stream>(response.Content);
    }

    [Fact]
    public async Task ItShouldUseDefaultHttpResponseContentReaderIfCustomDoesNotReturnAnyContentAsync()
    {
        // Arrange
        this._httpMessageHandlerStub.ResponseToReturn.Content = new StringContent("fake-content", Encoding.UTF8, MediaTypeNames.Application.Json);

        var operation = new RestApiOperation(
            id: "fake-id",
            servers: [new RestApiServer("https://fake-random-test-host")],
            path: "fake-path",
            method: HttpMethod.Get,
            description: "fake-description",
            parameters: [],
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            securityRequirements: []
        );

        var readerHasBeenCalled = false;

        Task<object?> ReadHttpResponseContentAsync(HttpResponseContentReaderContext context, CancellationToken cancellationToken)
        {
            readerHasBeenCalled = true;
            return Task.FromResult<object?>(null); // Return null to indicate that no content is returned
        }

        var sut = new RestApiOperationRunner(this._httpClient, this._authenticationHandlerMock.Object, httpResponseContentReader: ReadHttpResponseContentAsync);

        // Act
        var response = await sut.RunAsync(operation, []);

        // Assert
        Assert.True(readerHasBeenCalled);
        Assert.Equal("fake-content", response.Content);
    }

    [Fact]
    public async Task ItShouldDisposeContentStreamAndHttpResponseContentMessageAsync()
    {
        // Arrange
        var operation = new RestApiOperation(
            id: "fake-id",
            servers: [new RestApiServer("https://fake-random-test-host")],
            path: "fake-path",
            method: HttpMethod.Get,
            description: "fake-description",
            parameters: [],
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            securityRequirements: []
        );

        HttpResponseMessage? responseMessage = null;
        Stream? contentStream = null;

        async Task<object?> ReadHttpResponseContentAsync(HttpResponseContentReaderContext context, CancellationToken cancellationToken)
        {
            responseMessage = context.Response;
            contentStream = await context.Response.Content.ReadAsStreamAsync(cancellationToken);
            return contentStream;
        }

        var sut = new RestApiOperationRunner(this._httpClient, this._authenticationHandlerMock.Object, httpResponseContentReader: ReadHttpResponseContentAsync);

        // Act
        var response = await sut.RunAsync(operation, []);

        // Assert
        var stream = Assert.IsAssignableFrom<Stream>(response.Content);
        Assert.True(stream.CanRead);
        Assert.True(stream.CanSeek);

        stream.Dispose();

        // Check that the content stream and the response message are disposed
        Assert.Throws<ObjectDisposedException>(() => responseMessage!.Version = Version.Parse("1.1.1"));
        Assert.False(contentStream!.CanRead);
        Assert.False(contentStream!.CanSeek);
    }

    [Fact]
    public async Task ItShouldUseRestApiOperationPayloadPropertyArgumentNameToLookupArgumentsAsync()
    {
        // Arrange
        this._httpMessageHandlerStub.ResponseToReturn.Content = new StringContent("fake-content", Encoding.UTF8, MediaTypeNames.Application.Json);

        List<RestApiPayloadProperty> payloadProperties =
        [
            new("name", "string", true, []) { ArgumentName = "alt-name" },
            new("attributes", "object", false,
            [
                new("enabled", "boolean", false, []) { ArgumentName = "alt-enabled" },
            ])
        ];

        var payload = new RestApiPayload(MediaTypeNames.Application.Json, payloadProperties);

        var operation = new RestApiOperation(
            id: "fake-id",
            servers: [new RestApiServer("https://fake-random-test-host")],
            path: "fake-path",
            method: HttpMethod.Post,
            description: "fake-description",
            parameters: [],
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            securityRequirements: [],
            payload
        );

        var arguments = new KernelArguments
        {
            { "alt-name", "fake-name-value" },
            { "alt-enabled", true }
        };

        var options = new RestApiOperationRunOptions()
        {
            Kernel = new(),
            KernelFunction = KernelFunctionFactory.CreateFromMethod(() => false),
            KernelArguments = arguments,
        };

        var sut = new RestApiOperationRunner(this._httpClient, this._authenticationHandlerMock.Object, enableDynamicPayload: true);

        // Act
        var result = await sut.RunAsync(operation, arguments, options);

        // Assert
        var requestContent = this._httpMessageHandlerStub.RequestContent;
        Assert.NotNull(requestContent);

        var deserializedPayload = await JsonNode.ParseAsync(new MemoryStream(requestContent));
        Assert.NotNull(deserializedPayload);

        var nameProperty = deserializedPayload["name"]?.ToString();
        Assert.Equal("fake-name-value", nameProperty);

        var attributesProperty = deserializedPayload["attributes"];
        Assert.NotNull(attributesProperty);

        var enabledProperty = attributesProperty["enabled"]?.AsValue();
        Assert.NotNull(enabledProperty);
        Assert.Equal("true", enabledProperty.ToString());
    }

    [Fact]
    public async Task ItShouldUseRestApiOperationPayloadPropertyNameToLookupArgumentsIfNoArgumentNameProvidedAsync()
    {
        // Arrange
        this._httpMessageHandlerStub.ResponseToReturn.Content = new StringContent("fake-content", Encoding.UTF8, MediaTypeNames.Application.Json);

        List<RestApiPayloadProperty> payloadProperties =
        [
            new("name", "string", true, []) { ArgumentName = "alt-name" },
            new("attributes", "object", false,
            [
                new("enabled", "boolean", false, []) { ArgumentName = "alt-enabled" },
            ])
        ];

        var payload = new RestApiPayload(MediaTypeNames.Application.Json, payloadProperties);

        var operation = new RestApiOperation(
            id: "fake-id",
            servers: [new RestApiServer("https://fake-random-test-host")],
            path: "fake-path",
            method: HttpMethod.Post,
            description: "fake-description",
            parameters: [],
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            securityRequirements: [],
            payload: payload
        );

        var arguments = new KernelArguments
        {
            { "name", "fake-name-value" },
            { "enabled", true }
        };

        var options = new RestApiOperationRunOptions()
        {
            Kernel = new(),
            KernelFunction = KernelFunctionFactory.CreateFromMethod(() => false),
            KernelArguments = arguments,
        };

        var sut = new RestApiOperationRunner(this._httpClient, this._authenticationHandlerMock.Object, enableDynamicPayload: true);

        // Act
        var result = await sut.RunAsync(operation, arguments, options);

        // Assert
        var requestContent = this._httpMessageHandlerStub.RequestContent;
        Assert.NotNull(requestContent);

        var deserializedPayload = await JsonNode.ParseAsync(new MemoryStream(requestContent));
        Assert.NotNull(deserializedPayload);

        var nameProperty = deserializedPayload["name"]?.ToString();
        Assert.Equal("fake-name-value", nameProperty);

        var attributesProperty = deserializedPayload["attributes"];
        Assert.NotNull(attributesProperty);

        var enabledProperty = attributesProperty["enabled"]?.AsValue();
        Assert.NotNull(enabledProperty);
        Assert.Equal("true", enabledProperty.ToString());
    }

    [Fact]
    public async Task ItShouldUseUrlHeaderAndPayloadFactoriesIfProvidedAsync()
    {
        // Arrange
        this._httpMessageHandlerStub.ResponseToReturn.Content = new StringContent("fake-content", Encoding.UTF8, MediaTypeNames.Application.Json);

        List<RestApiPayloadProperty> payloadProperties =
        [
            new("name", "string", true, [])
        ];

        var payload = new RestApiPayload(MediaTypeNames.Application.Json, payloadProperties);

        var expectedOperation = new RestApiOperation(
            id: "fake-id",
            servers: [new RestApiServer("https://fake-random-test-host")],
            path: "fake-path",
            method: HttpMethod.Post,
            description: "fake-description",
            parameters: [],
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            securityRequirements: [],
            payload: payload
        );

        var expectedArguments = new KernelArguments();

        var expectedOptions = new RestApiOperationRunOptions()
        {
            Kernel = new(),
            KernelFunction = KernelFunctionFactory.CreateFromMethod(() => false),
            KernelArguments = expectedArguments,
        };

        bool createUrlFactoryCalled = false;
        bool createHeadersFactoryCalled = false;
        bool createPayloadFactoryCalled = false;

        Uri CreateUrl(RestApiOperation operation, IDictionary<string, object?> arguments, RestApiOperationRunOptions? options)
        {
            createUrlFactoryCalled = true;
            Assert.Same(expectedOperation, operation);
            Assert.Same(expectedArguments, arguments);
            Assert.Same(expectedOptions, options);

            return new Uri("https://fake-random-test-host-from-factory/");
        }

        IDictionary<string, string>? CreateHeaders(RestApiOperation operation, IDictionary<string, object?> arguments, RestApiOperationRunOptions? options)
        {
            createHeadersFactoryCalled = true;
            Assert.Same(expectedOperation, operation);
            Assert.Same(expectedArguments, arguments);
            Assert.Same(expectedOptions, options);

            return new Dictionary<string, string>() { ["header-from-factory"] = "value-of-header-from-factory" };
        }

        (object Payload, HttpContent Content)? CreatePayload(RestApiOperation operation, IDictionary<string, object?> arguments, bool enableDynamicPayload, bool enablePayloadNamespacing, RestApiOperationRunOptions? options)
        {
            createPayloadFactoryCalled = true;
            Assert.Same(expectedOperation, operation);
            Assert.Same(expectedArguments, arguments);
            Assert.True(enableDynamicPayload);
            Assert.True(enablePayloadNamespacing);
            Assert.Same(expectedOptions, options);

            var json = """{"name":"fake-name-value"}""";

            return ((JsonObject)JsonObject.Parse(json)!, new StringContent(json, Encoding.UTF8, MediaTypeNames.Application.Json));
        }

        var sut = new RestApiOperationRunner(
            this._httpClient,
            enableDynamicPayload: true,
            enablePayloadNamespacing: true,
            urlFactory: CreateUrl,
            headersFactory: CreateHeaders,
            payloadFactory: CreatePayload);

        // Act
        var result = await sut.RunAsync(expectedOperation, expectedArguments, expectedOptions);

        // Assert
        Assert.True(createUrlFactoryCalled);
        Assert.True(createHeadersFactoryCalled);
        Assert.True(createPayloadFactoryCalled);

        // Assert url factory
        Assert.NotNull(this._httpMessageHandlerStub.RequestUri);
        Assert.Equal("https://fake-random-test-host-from-factory/", this._httpMessageHandlerStub.RequestUri.AbsoluteUri);

        // Assert headers factory
        Assert.NotNull(this._httpMessageHandlerStub.RequestHeaders);
        Assert.Equal(3, this._httpMessageHandlerStub.RequestHeaders.Count());

        Assert.Contains(this._httpMessageHandlerStub.RequestHeaders, h => h.Key == "header-from-factory" && h.Value.Contains("value-of-header-from-factory"));
        Assert.Contains(this._httpMessageHandlerStub.RequestHeaders, h => h.Key == "User-Agent" && h.Value.Contains("Semantic-Kernel"));
        Assert.Contains(this._httpMessageHandlerStub.RequestHeaders, h => h.Key == "Semantic-Kernel-Version");

        // Assert payload factory
        var messageContent = this._httpMessageHandlerStub.RequestContent;
        Assert.NotNull(messageContent);

        var deserializedPayload = await JsonNode.ParseAsync(new MemoryStream(messageContent));
        Assert.NotNull(deserializedPayload);

        var nameProperty = deserializedPayload["name"]?.ToString();
        Assert.Equal("fake-name-value", nameProperty);

        Assert.NotNull(result.RequestPayload);
        Assert.IsType<JsonObject>(result.RequestPayload);
        Assert.Equal("""{"name":"fake-name-value"}""", ((JsonObject)result.RequestPayload).ToJsonString());
    }

    public class SchemaTestData : IEnumerable<object[]>
    {
        public IEnumerator<object[]> GetEnumerator()
        {
            yield return new object[] {
                    "default",
                    new (string, RestApiExpectedResponse)[] {
                        ("400", new RestApiExpectedResponse("fake-content", "fake-content-type", KernelJsonSchema.Parse(ResourceResponseProvider.LoadFromResource("FakeResponseSchema.json")))),
                        ("default", new RestApiExpectedResponse("Default response content", "application/json", KernelJsonSchema.Parse(ResourceResponseProvider.LoadFromResource("DefaultResponseSchema.json")))),
                    },
            };
            yield return new object[] {
                    "200",
                    new (string, RestApiExpectedResponse)[] {
                        ("200", new RestApiExpectedResponse("fake-content", "fake-content-type", KernelJsonSchema.Parse(ResourceResponseProvider.LoadFromResource("FakeResponseSchema.json")))),
                        ("default", new RestApiExpectedResponse("Default response content", "application/json", KernelJsonSchema.Parse(ResourceResponseProvider.LoadFromResource("DefaultResponseSchema.json")))),
                    },
            };
            yield return new object[] {
                    "2XX",
                    new (string, RestApiExpectedResponse)[] {
                        ("2XX", new RestApiExpectedResponse("fake-content", "fake-content-type", KernelJsonSchema.Parse(ResourceResponseProvider.LoadFromResource("FakeResponseSchema.json")))),
                        ("default", new RestApiExpectedResponse("Default response content", "application/json", KernelJsonSchema.Parse(ResourceResponseProvider.LoadFromResource("DefaultResponseSchema.json")))),
                    },
            };
            yield return new object[] {
                    "2XX",
                    new (string, RestApiExpectedResponse)[] {
                        ("2XX", new RestApiExpectedResponse("fake-content", "fake-content-type", KernelJsonSchema.Parse(ResourceResponseProvider.LoadFromResource("FakeResponseSchema.json")))),
                        ("default", new RestApiExpectedResponse("Default response content", "application/json", KernelJsonSchema.Parse(ResourceResponseProvider.LoadFromResource("DefaultResponseSchema.json")))),
                    },
            };
            yield return new object[] {
                    "200",
                    new (string, RestApiExpectedResponse)[] {
                        ("default", new RestApiExpectedResponse("Default response content", "application/json", KernelJsonSchema.Parse(ResourceResponseProvider.LoadFromResource("DefaultResponseSchema.json")))),
                        ("2XX", new RestApiExpectedResponse("fake-content", "fake-content-type", KernelJsonSchema.Parse(ResourceResponseProvider.LoadFromResource("2XXFakeResponseSchema.json")))),
                        ("200", new RestApiExpectedResponse("fake-content", "fake-content-type", KernelJsonSchema.Parse(ResourceResponseProvider.LoadFromResource("200FakeResponseSchema.json")))),
                    },
            };
        }

        IEnumerator IEnumerable.GetEnumerator() => this.GetEnumerator();
    }

    [Theory]
    [ClassData(typeof(SchemaTestData))]
    public async Task ItShouldReturnExpectedSchemaAsync(string expectedStatusCode, params (string, RestApiExpectedResponse)[] responses)
    {
        var operation = new RestApiOperation(
            id: "fake-id",
            servers: [new RestApiServer("https://fake-random-test-host")],
            path: "fake-path",
            method: HttpMethod.Get,
            description: "fake-description",
            parameters: [],
            responses: responses.ToDictionary(item => item.Item1, item => item.Item2),
            securityRequirements: []
        );

        var sut = new RestApiOperationRunner(this._httpClient, this._authenticationHandlerMock.Object);

        // Act
        var result = await sut.RunAsync(operation, []);

        Assert.NotNull(result);
        var expected = responses.First(r => r.Item1 == expectedStatusCode).Item2.Schema;
        Assert.Equal(JsonSerializer.Serialize(expected), JsonSerializer.Serialize(result.ExpectedSchema));
    }

    [Theory]
    [InlineData("application/json;x-api-version=2.0", "application/json")]
    [InlineData("application/json ; x-api-version=2.0", "application/json")]
    [InlineData(" application/JSON; x-api-version=2.0", "application/json")]
    [InlineData(" TEXT/PLAIN ; x-api-version=2.0", "text/plain")]
    public async Task ItShouldNormalizeContentTypeArgumentAsync(string actualContentType, string normalizedContentType)
    {
        // Arrange
        this._httpMessageHandlerStub.ResponseToReturn.Content = new StringContent("fake-content", Encoding.UTF8, MediaTypeNames.Text.Plain);

        var operation = new RestApiOperation(
            id: "fake-id",
            servers: [new RestApiServer("https://fake-random-test-host")],
            path: "fake-path",
            method: HttpMethod.Post,
            description: "fake-description",
            parameters: [],
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            securityRequirements: [],
            payload: null
        );

        var arguments = new KernelArguments
        {
            { "payload", "fake-input-value" },
            { "content-type", actualContentType },
        };

        var sut = new RestApiOperationRunner(this._httpClient, this._authenticationHandlerMock.Object, enableDynamicPayload: false);

        // Act
        var result = await sut.RunAsync(operation, arguments);

        // Assert
        Assert.NotNull(this._httpMessageHandlerStub.ContentHeaders);
        Assert.Contains(this._httpMessageHandlerStub.ContentHeaders, h => h.Key == "Content-Type" && h.Value.Any(h => h.StartsWith(normalizedContentType, StringComparison.InvariantCulture)));
    }

    [Fact]
    public async Task ItShouldProvideValidContextToRestApiOperationResponseFactoryAsync()
    {
        // Arrange
        this._httpMessageHandlerStub.ResponseToReturn.Content = new StringContent("fake-content", Encoding.UTF8, MediaTypeNames.Text.Plain);

        RestApiOperationResponseFactoryContext? factoryContext = null;
        RestApiOperationResponse? factoryInternalResponse = null;
        CancellationToken? factoryCancellationToken = null;

        async Task<RestApiOperationResponse> RestApiOperationResponseFactory(RestApiOperationResponseFactoryContext context, CancellationToken cancellationToken)
        {
            factoryContext = context;
            factoryInternalResponse = await context.InternalFactory(context, cancellationToken);
            factoryCancellationToken = cancellationToken;

            return factoryInternalResponse;
        }

        var operation = new RestApiOperation(
            id: "fake-id",
            servers: [new RestApiServer("https://fake-random-test-host")],
            path: "fake-path",
            method: HttpMethod.Post,
            description: "fake-description",
            parameters: [],
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            securityRequirements: [],
            payload: null
        );

        var arguments = new KernelArguments
        {
            { "payload", "fake-input-value" },
            { "content-type", "text/plain" },
        };

        var sut = new RestApiOperationRunner(this._httpClient, responseFactory: RestApiOperationResponseFactory);

        using var cancellationTokenSource = new CancellationTokenSource();

        var cancellationToken = cancellationTokenSource.Token;

        // Act
        var response = await sut.RunAsync(operation, arguments, cancellationToken: cancellationToken);

        // Assert
        Assert.NotNull(factoryContext);
        Assert.Same(operation, factoryContext.Operation);
        Assert.Same(this._httpMessageHandlerStub.RequestMessage, factoryContext.Request);
        Assert.Same(this._httpMessageHandlerStub.ResponseToReturn, factoryContext.Response);

        Assert.Same(factoryInternalResponse, response);

        Assert.Equal(cancellationToken, factoryCancellationToken);
    }

    [Fact]
    public async Task ItShouldWrapStreamContentIntoHttpResponseStreamAsync()
    {
        // Arrange
        this._httpMessageHandlerStub.ResponseToReturn.Content = new StringContent("fake-content", Encoding.UTF8, MediaTypeNames.Text.Plain);

        var factoryStream = new MemoryStream();

        async Task<RestApiOperationResponse> RestApiOperationResponseFactory(RestApiOperationResponseFactoryContext context, CancellationToken cancellationToken)
        {
            return await Task.FromResult(new RestApiOperationResponse(factoryStream, contentType: MediaTypeNames.Text.Plain));
        }

        var operation = new RestApiOperation(
            id: "fake-id",
            servers: [new RestApiServer("https://fake-random-test-host")],
            path: "fake-path",
            method: HttpMethod.Post,
            description: "fake-description",
            parameters: [],
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            securityRequirements: [],
            payload: null
        );

        var arguments = new KernelArguments
        {
            { "payload", "fake-input-value" },
            { "content-type", "text/plain" },
        };

        var sut = new RestApiOperationRunner(this._httpClient, responseFactory: RestApiOperationResponseFactory);

        // Act
        var response = await sut.RunAsync(operation, arguments);

        // Assert
        var httpResponseStream = Assert.IsType<HttpResponseStream>(response.Content);

        // Assert that neither the HttResponseMessage nor stream returned by factory is disposed
        this._httpMessageHandlerStub.ResponseToReturn!.Version = Version.Parse("1.1.1");
        Assert.True(factoryStream!.CanRead);
        Assert.True(factoryStream!.CanSeek);

        // Dispose the response stream
        httpResponseStream.Dispose();

        // Assert both the stream and the response message are disposed
        Assert.Throws<ObjectDisposedException>(() => this._httpMessageHandlerStub.ResponseToReturn!.Version = Version.Parse("1.1.1"));
        Assert.False(httpResponseStream!.CanRead);
        Assert.False(httpResponseStream!.CanSeek);
    }

    [Fact]
    public async Task ItShouldNotWrapStreamContentIntoHttpResponseStreamIfItIsAlreadyOfHttpResponseStreamTypeAsync()
    {
        // Arrange
        this._httpMessageHandlerStub.ResponseToReturn.Content = new StringContent("fake-content", Encoding.UTF8, MediaTypeNames.Text.Plain);

#pragma warning disable CA2000 // Dispose objects before losing scope
        await using var httpResponseStream = new HttpResponseStream(new MemoryStream(), new HttpResponseMessage());
#pragma warning restore CA2000 // Dispose objects before losing scope

        async Task<RestApiOperationResponse> RestApiOperationResponseFactory(RestApiOperationResponseFactoryContext context, CancellationToken cancellationToken)
        {
            return await Task.FromResult(new RestApiOperationResponse(httpResponseStream, contentType: MediaTypeNames.Text.Plain));
        }

        var operation = new RestApiOperation(
            id: "fake-id",
            servers: [new RestApiServer("https://fake-random-test-host")],
            path: "fake-path",
            method: HttpMethod.Post,
            description: "fake-description",
            parameters: [],
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            securityRequirements: [],
            payload: null
        );

        var arguments = new KernelArguments
        {
            { "payload", "fake-input-value" },
            { "content-type", "text/plain" },
        };

        var sut = new RestApiOperationRunner(this._httpClient, responseFactory: RestApiOperationResponseFactory);

        // Act
        var response = await sut.RunAsync(operation, arguments);

        // Assert
        Assert.Same(httpResponseStream, response.Content);
    }

    /// <summary>
    /// Disposes resources used by this class.
    /// </summary>
    public void Dispose()
    {
        this._httpMessageHandlerStub.Dispose();

        this._httpClient.Dispose();
    }

    private sealed class HttpMessageHandlerStub : DelegatingHandler
    {
        public HttpRequestHeaders? RequestHeaders => this.RequestMessage?.Headers;

        public HttpContentHeaders? ContentHeaders => this.RequestMessage?.Content?.Headers;

        public byte[]? RequestContent { get; private set; }

        public Uri? RequestUri => this.RequestMessage?.RequestUri;

        public HttpMethod? Method => this.RequestMessage?.Method;

        public HttpRequestMessage? RequestMessage { get; private set; }

        public HttpResponseMessage ResponseToReturn { get; set; }

        public Exception? ExceptionToThrow { get; set; }

        public HttpMessageHandlerStub()
        {
            this.ResponseToReturn = new HttpResponseMessage(System.Net.HttpStatusCode.OK)
            {
                Content = new StringContent("{}", Encoding.UTF8, MediaTypeNames.Application.Json)
            };
        }

        protected override async Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
        {
            if (this.ExceptionToThrow is not null)
            {
                throw this.ExceptionToThrow;
            }

            this.RequestMessage = request;
            this.RequestContent = request.Content is null ? null : await request.Content.ReadAsByteArrayAsync(cancellationToken);

            return await Task.FromResult(this.ResponseToReturn);
        }
    }
}


===== Functions.UnitTests\OpenApi\RestApiOperationTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Net.Http;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.ChatCompletion;
using Microsoft.SemanticKernel.Connectors.AzureOpenAI;
using Microsoft.SemanticKernel.Connectors.OpenAI;
using Microsoft.SemanticKernel.Plugins.OpenApi;
using Microsoft.SemanticKernel.TextGeneration;
using Xunit;

namespace SemanticKernel.Functions.UnitTests.OpenApi;

public class RestApiOperationTests
{
    [Fact]
    public void ItShouldUseHostUrlIfNoOverrideProvided()
    {
        // Arrange
        var sut = new RestApiOperation(
            id: "fake_id",
            servers: [new RestApiServer("https://fake-random-test-host")],
            path: "/",
            method: HttpMethod.Get,
            description: "fake_description",
            parameters: [],
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            securityRequirements: []
        );

        var arguments = new Dictionary<string, object?>();

        // Act
        var url = sut.BuildOperationUrl(arguments);

        // Assert
        Assert.Equal("https://fake-random-test-host/", url.OriginalString);
    }

    [Fact]
    public void ItShouldUseHostUrlOverrideIfProvided()
    {
        // Arrange
        var sut = new RestApiOperation(
            id: "fake_id",
            servers: [new RestApiServer("https://fake-random-test-host")],
            path: "/",
            method: HttpMethod.Get,
            description: "fake_description",
            parameters: [],
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            securityRequirements: []
        );

        var fakeHostUrlOverride = "https://fake-random-test-host-override";

        var arguments = new Dictionary<string, object?>();

        // Act
        var url = sut.BuildOperationUrl(arguments, serverUrlOverride: new Uri(fakeHostUrlOverride));

        // Assert
        Assert.Equal(fakeHostUrlOverride, url.OriginalString.TrimEnd('/'));
    }

    [Fact]
    public void ItShouldBuildOperationUrlWithPathParametersFromArguments()
    {
        // Arrange
        var parameters = new List<RestApiParameter> {
            new(
                name: "p1",
                type: "string",
                isRequired: true,
                expand: false,
                location: RestApiParameterLocation.Path,
                style: RestApiParameterStyle.Simple),
            new(
                name: "p2",
                type: "number",
                isRequired: true,
                expand: false,
                location: RestApiParameterLocation.Path,
                style: RestApiParameterStyle.Simple)
        };

        var sut = new RestApiOperation(
            id: "fake_id",
            servers: [new RestApiServer("https://fake-random-test-host")],
            path: "/{p1}/{p2}/other_fake_path_section",
            method: HttpMethod.Get,
            description: "fake_description",
            parameters: parameters,
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            securityRequirements: []
        );

        var arguments = new Dictionary<string, object?>
        {
            { "p1", "v1" },
            { "p2", 34 }
        };

        // Act
        var url = sut.BuildOperationUrl(arguments);

        // Assert
        Assert.Equal("https://fake-random-test-host/v1/34/other_fake_path_section", url.OriginalString);
    }

    [Fact]
    public void ItShouldUseParameterArgumentNameToLookupArgumentsToBuildOperationUrl()
    {
        // Arrange
        var parameters = new List<RestApiParameter> {
            new(
                name: "p1",
                type: "string",
                isRequired: true,
                expand: false,
                location: RestApiParameterLocation.Path,
                style: RestApiParameterStyle.Simple){ ArgumentName = "alt-p1" },
            new(
                name: "p2",
                type: "number",
                isRequired: true,
                expand: false,
                location: RestApiParameterLocation.Path,
                style: RestApiParameterStyle.Simple){ ArgumentName = "alt-p2" }
        };

        var sut = new RestApiOperation(
            "fake_id",
            [new RestApiServer("https://fake-random-test-host")],
            "/{p1}/{p2}/other_fake_path_section",
            HttpMethod.Get,
            "fake_description",
            parameters: parameters,
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            securityRequirements: []
        );

        var arguments = new Dictionary<string, object?>
        {
            { "alt-p1", "v1" },
            { "alt-p2", 34 }
        };

        // Act
        var url = sut.BuildOperationUrl(arguments);

        // Assert
        Assert.Equal("https://fake-random-test-host/v1/34/other_fake_path_section", url.OriginalString);
    }

    [Fact]
    public void ItShouldUseParameterNameToLookupArgumentsToBuildOperationUrlIfNoArgumentsProvidedForArgumentNames()
    {
        // Arrange
        var parameters = new List<RestApiParameter> {
            new(
                name: "p1",
                type: "string",
                isRequired: true,
                expand: false,
                location: RestApiParameterLocation.Path,
                style: RestApiParameterStyle.Simple){ ArgumentName = "alt-p1" },
            new(
                name: "p2",
                type: "number",
                isRequired: true,
                expand: false,
                location: RestApiParameterLocation.Path,
                style: RestApiParameterStyle.Simple){ ArgumentName = "alt-p2" }
        };

        var sut = new RestApiOperation(
            "fake_id",
            [new RestApiServer("https://fake-random-test-host")],
            "/{p1}/{p2}/other_fake_path_section",
            HttpMethod.Get,
            "fake_description",
            parameters: parameters,
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            securityRequirements: []
        );

        var arguments = new Dictionary<string, object?>
        {
            { "p1", "v1" },
            { "p2", 34 }
        };

        // Act
        var url = sut.BuildOperationUrl(arguments);

        // Assert
        Assert.Equal("https://fake-random-test-host/v1/34/other_fake_path_section", url.OriginalString);
    }

    [Fact]
    public void ItShouldBuildOperationUrlWithEncodedArguments()
    {
        // Arrange
        var parameters = new List<RestApiParameter> {
            new(
                name: "p1",
                type: "string",
                isRequired: true,
                expand: false,
                location: RestApiParameterLocation.Path,
                style: RestApiParameterStyle.Simple),
            new(
                name: "p2",
                type: "string",
                isRequired: true,
                expand: false,
                location: RestApiParameterLocation.Path,
                style: RestApiParameterStyle.Simple)
        };

        var sut = new RestApiOperation(
            id: "fake_id",
            servers: [new RestApiServer("https://fake-random-test-host")],
            path: "/{p1}/{p2}/other_fake_path_section",
            method: HttpMethod.Get,
            description: "fake_description",
            parameters: parameters,
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            securityRequirements: []
        );

        var arguments = new Dictionary<string, object?>
        {
            { "p1", "foo:bar" },
            { "p2", "foo/bar" }
        };

        // Act
        var url = sut.BuildOperationUrl(arguments);

        // Assert
        Assert.Equal("https://fake-random-test-host/foo%3abar/foo%2fbar/other_fake_path_section", url.OriginalString);
    }

    [Fact]
    public void ShouldBuildResourceUrlWithoutQueryString()
    {
        // Arrange
        var parameters = new List<RestApiParameter> {
            new(
                name: "p1",
                type: "string",
                isRequired: false,
                expand: false,
                location: RestApiParameterLocation.Query,
                defaultValue: "dv1"),
            new(
                name: "fake-path",
                type: "string",
                isRequired: false,
                expand: false,
                location: RestApiParameterLocation.Path)
        };

        var sut = new RestApiOperation(
            id: "fake_id",
            servers: [new RestApiServer("https://fake-random-test-host")],
            path: "{fake-path}/",
            method: HttpMethod.Get,
            description: "fake_description",
            parameters: parameters,
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            securityRequirements: []
        );

        var fakeHostUrlOverride = "https://fake-random-test-host-override";

        var arguments = new Dictionary<string, object?>
        {
            { "fake-path", "fake-path-value" },
        };

        // Act
        var url = sut.BuildOperationUrl(arguments, serverUrlOverride: new Uri(fakeHostUrlOverride));

        // Assert
        Assert.Equal($"{fakeHostUrlOverride}/fake-path-value/", url.OriginalString);
    }

    [Fact]
    public void ItShouldBuildQueryString()
    {
        // Arrange
        var parameters = new List<RestApiParameter> {
            new(
                name: "since_create_time",
                type: "string",
                isRequired: false,
                expand: false,
                location: RestApiParameterLocation.Query),
            new(
                name: "before_create_time",
                type: "string",
                isRequired: false,
                expand: false,
                location: RestApiParameterLocation.Query),
        };

        var sut = new RestApiOperation(
            id: "fake_id",
            servers: [new RestApiServer("https://fake-random-test-host")],
            path: "fake-path/",
            method: HttpMethod.Get,
            description: "fake_description",
            parameters: parameters,
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            securityRequirements: []
        );

        var arguments = new Dictionary<string, object?>
        {
            { "since_create_time", "2024-01-01T00:00:00+00:00" },
            { "before_create_time", "2024-05-01T00:00:00+00:00" },
        };

        // Act
        var queryString = sut.BuildQueryString(arguments);

        // Assert
        Assert.Equal("since_create_time=2024-01-01T00%3A00%3A00%2B00%3A00&before_create_time=2024-05-01T00%3A00%3A00%2B00%3A00", queryString, ignoreCase: true);
    }

    [Fact]
    public void ItShouldUseParameterArgumentNameToLookupArgumentsToBuildQueryString()
    {
        // Arrange
        var parameters = new List<RestApiParameter> {
            new(
                name: "p1",
                type: "string",
                isRequired: false,
                expand: false,
                location: RestApiParameterLocation.Query) { ArgumentName = "alt_p1" },
            new(
                name: "p2",
                type: "string",
                isRequired: false,
                expand: false,
                location: RestApiParameterLocation.Query)  { ArgumentName = "alt_p2" },
        };

        var sut = new RestApiOperation(
            "fake_id",
            [new RestApiServer("https://fake-random-test-host")],
            "fake-path/",
            HttpMethod.Get,
            "fake_description",
            parameters: parameters,
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            securityRequirements: []
         );

        var arguments = new Dictionary<string, object?>
        {
            { "alt_p1", "v1" },
            { "alt_p2", "v2" },
        };

        // Act
        var queryString = sut.BuildQueryString(arguments);

        // Assert
        Assert.Equal("p1=v1&p2=v2", queryString, ignoreCase: true);
    }

    [Fact]
    public void ItShouldParameterNameToLookupArgumentsToBuildQueryStringIfNoArgumentsProvidedForArgumentNames()
    {
        // Arrange
        var parameters = new List<RestApiParameter> {
            new(
                name: "p1",
                type: "string",
                isRequired: false,
                expand: false,
                location: RestApiParameterLocation.Query) { ArgumentName = "alt_p1" },
            new(
                name: "p2",
                type: "string",
                isRequired: false,
                expand: false,
                location: RestApiParameterLocation.Query)  { ArgumentName = "alt_p2" },
        };

        var sut = new RestApiOperation(
            "fake_id",
            [new RestApiServer("https://fake-random-test-host")],
            "fake-path/",
            HttpMethod.Get,
            "fake_description",
            parameters: parameters,
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            securityRequirements: []
         );

        var arguments = new Dictionary<string, object?>
        {
            { "p1", "v1" },
            { "p2", "v2" },
        };

        // Act
        var queryString = sut.BuildQueryString(arguments);

        // Assert
        Assert.Equal("p1=v1&p2=v2", queryString, ignoreCase: true);
    }

    [Fact]
    public void ItShouldBuildQueryStringWithQuotes()
    {
        // Arrange
        var parameters = new List<RestApiParameter> {
            new(
                name: "has_quotes",
                type: "string",
                isRequired: false,
                expand: false,
                location: RestApiParameterLocation.Query)
        };

        var sut = new RestApiOperation(
            id: "fake_id",
            servers: [new RestApiServer("https://fake-random-test-host")],
            path: "fake-path/",
            method: HttpMethod.Get,
            description: "fake_description",
            parameters: parameters,
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            securityRequirements: []
        );

        var arguments = new Dictionary<string, object?>
        {
            { "has_quotes", "\"Quoted Value\"" },
        };

        // Act
        var queryString = sut.BuildQueryString(arguments);

        // Assert
        Assert.Equal("has_quotes=%22Quoted+Value%22", queryString, ignoreCase: true);
    }

    [Fact]
    public void ItShouldBuildQueryStringForArray()
    {
        // Arrange
        var parameters = new List<RestApiParameter> {
            new(
                name: "times",
                type: "array",
                isRequired: false,
                expand: false,
                location: RestApiParameterLocation.Query),
        };

        var sut = new RestApiOperation(
            id: "fake_id",
            servers: [new RestApiServer("https://fake-random-test-host")],
            path: "fake-path/",
            method: HttpMethod.Get,
            description: "fake_description",
            parameters: parameters,
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            securityRequirements: []
        );

        var arguments = new Dictionary<string, object?>
        {
            { "times", new string[] { "2024-01-01T00:00:00+00:00", "2024-05-01T00:00:00+00:00" } },
        };

        // Act
        var queryString = sut.BuildQueryString(arguments);

        // Assert
        Assert.Equal("times=2024-01-01T00%3A00%3A00%2B00%3A00,2024-05-01T00%3A00%3A00%2B00%3A00", queryString, ignoreCase: true);
    }

    [Fact]
    public void ItShouldRenderHeaderValuesFromArguments()
    {
        // Arrange
        var parameters = new List<RestApiParameter>
        {
            new(
                name: "fake_header_one",
                type: "string",
                isRequired: true,
                expand: false,
                location: RestApiParameterLocation.Header,
                style: RestApiParameterStyle.Simple),

            new(
                name: "fake_header_two",
                type: "string",
                isRequired: true,
                expand: false,
                location: RestApiParameterLocation.Header,
                style: RestApiParameterStyle.Simple)
        };

        var arguments = new Dictionary<string, object?>
        {
            { "fake_header_one", "fake_header_one_value" },
            { "fake_header_two", "fake_header_two_value" }
        };

        var sut = new RestApiOperation(
            id: "fake_id",
            servers: [new RestApiServer("http://fake_url")],
            path: "fake_path",
            method: HttpMethod.Get,
            description: "fake_description",
            parameters: parameters,
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            securityRequirements: []
        );

        // Act
        var headers = sut.BuildHeaders(arguments);

        // Assert
        Assert.Equal(2, headers.Count);

        var headerOne = headers["fake_header_one"];
        Assert.Equal("fake_header_one_value", headerOne);

        var headerTwo = headers["fake_header_two"];
        Assert.Equal("fake_header_two_value", headerTwo);
    }

    [Fact]
    public void ItShouldUseParameterArgumentNameToLookupArgumentsToCreateOperationHeaders()
    {
        // Arrange
        var parameters = new List<RestApiParameter>
        {
            new(
                name: "h1",
                type: "string",
                isRequired: true,
                expand: false,
                location: RestApiParameterLocation.Header,
                style: RestApiParameterStyle.Simple) { ArgumentName = "alt_h1" },

            new(
                name: "h2",
                type: "string",
                isRequired: true,
                expand: false,
                location: RestApiParameterLocation.Header,
                style: RestApiParameterStyle.Simple) { ArgumentName = "alt_h2" }
        };

        var arguments = new Dictionary<string, object?>
        {
            { "alt_h1", "v1" },
            { "alt_h2", "v2" }
        };

        var sut = new RestApiOperation(
            id: "fake_id",
            servers: [new RestApiServer("http://fake_url")],
            path: "fake_path",
            method: HttpMethod.Get,
            description: "fake_description",
            parameters: parameters,
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            securityRequirements: []);

        // Act
        var headers = sut.BuildHeaders(arguments);

        // Assert
        Assert.Equal(2, headers.Count);

        var headerOne = headers["h1"];
        Assert.Equal("v1", headerOne);

        var headerTwo = headers["h2"];
        Assert.Equal("v2", headerTwo);
    }

    [Fact]
    public void ItShouldUseParameterNameToLookupArgumentsToCreateOperationHeadersIfNoArgumentsProvidedForArgumentNames()
    {
        // Arrange
        var parameters = new List<RestApiParameter>
        {
            new(
                name: "h1",
                type: "string",
                isRequired: true,
                expand: false,
                location: RestApiParameterLocation.Header,
                style: RestApiParameterStyle.Simple) { ArgumentName = "alt_h1" },

            new(
                name: "h2",
                type: "string",
                isRequired: true,
                expand: false,
                location: RestApiParameterLocation.Header,
                style: RestApiParameterStyle.Simple) { ArgumentName = "alt_h2" }
        };

        var arguments = new Dictionary<string, object?>
        {
            { "h1", "v1" },
            { "h2", "v2" }
        };

        var sut = new RestApiOperation(
            id: "fake_id",
            servers: [new RestApiServer("http://fake_url")],
            path: "fake_path",
            method: HttpMethod.Get,
            description: "fake_description",
            parameters: parameters,
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            securityRequirements: []
         );

        // Act
        var headers = sut.BuildHeaders(arguments);

        // Assert
        Assert.Equal(2, headers.Count);

        var headerOne = headers["h1"];
        Assert.Equal("v1", headerOne);

        var headerTwo = headers["h2"];
        Assert.Equal("v2", headerTwo);
    }

    [Fact]
    public void ShouldThrowExceptionIfNoValueProvidedForRequiredHeader()
    {
        // Arrange
        var parameters = new List<RestApiParameter>
        {
            new(name: "fake_header_one", type: "string", isRequired: true, expand: false, location: RestApiParameterLocation.Header, style: RestApiParameterStyle.Simple),
            new(name: "fake_header_two", type : "string", isRequired : false, expand : false, location : RestApiParameterLocation.Header, style: RestApiParameterStyle.Simple)
        };

        var sut = new RestApiOperation(
            id: "fake_id",
            servers: [new RestApiServer("http://fake_url")],
            path: "fake_path",
            method: HttpMethod.Get,
            description: "fake_description",
            parameters: parameters,
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            securityRequirements: []
        );

        // Act
        void Act() => sut.BuildHeaders(new Dictionary<string, object?>());

        // Assert
        Assert.Throws<KernelException>(Act);
    }

    [Fact]
    public void ItShouldSkipOptionalHeaderHavingNoValue()
    {
        // Arrange
        var parameters = new List<RestApiParameter>
        {
            new(name: "fake_header_one", type : "string", isRequired : true, expand : false, location : RestApiParameterLocation.Header, style: RestApiParameterStyle.Simple),
            new(name: "fake_header_two", type : "string", isRequired : false, expand : false, location : RestApiParameterLocation.Header, style : RestApiParameterStyle.Simple)
        };

        var arguments = new Dictionary<string, object?>
        {
            ["fake_header_one"] = "fake_header_one_value"
        };

        var sut = new RestApiOperation(
            id: "fake_id",
            servers: [new RestApiServer("http://fake_url")],
            path: "fake_path",
            method: HttpMethod.Get,
            description: "fake_description",
            parameters: parameters,
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            securityRequirements: []
        );

        // Act
        var headers = sut.BuildHeaders(arguments);

        // Assert
        Assert.Single(headers);

        var headerOne = headers["fake_header_one"];
        Assert.Equal("fake_header_one_value", headerOne);
    }

    [Fact]
    public void ItShouldCreateHeaderWithCommaSeparatedValues()
    {
        // Arrange
        var parameters = new List<RestApiParameter>
        {
            new( name: "h1", type: "array", isRequired: false, expand: false, location: RestApiParameterLocation.Header, style: RestApiParameterStyle.Simple, arrayItemType: "string"),
            new( name: "h2", type: "array", isRequired: false, expand: false, location: RestApiParameterLocation.Header, style: RestApiParameterStyle.Simple, arrayItemType: "integer")
        };

        var arguments = new Dictionary<string, object?>
        {
            ["h1"] = "[\"a\",\"b\",\"c\"]",
            ["h2"] = "[1,2,3]"
        };

        var sut = new RestApiOperation(
            id: "fake_id",
            servers: [new RestApiServer("https://fake-random-test-host")],
            path: "fake_path",
            method: HttpMethod.Get,
            description: "fake_description",
            parameters: parameters,
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            securityRequirements: []
        );

        // Act
        var headers = sut.BuildHeaders(arguments);

        // Assert
        Assert.NotNull(headers);
        Assert.Equal(2, headers.Count);

        Assert.Equal("a,b,c", headers["h1"]);
        Assert.Equal("1,2,3", headers["h2"]);
    }

    [Fact]
    public void ItShouldCreateHeaderWithPrimitiveValue()
    {
        // Arrange
        var parameters = new List<RestApiParameter>
        {
            new( name: "h1", type: "string", isRequired: false, expand: false, location: RestApiParameterLocation.Header, style: RestApiParameterStyle.Simple),
            new( name: "h2", type: "boolean", isRequired: false, expand: false, location: RestApiParameterLocation.Header, style: RestApiParameterStyle.Simple)
        };

        var arguments = new Dictionary<string, object?>
        {
            ["h1"] = "v1",
            ["h2"] = true
        };

        var sut = new RestApiOperation(
            id: "fake_id",
            servers: [new RestApiServer("https://fake-random-test-host")],
            path: "fake_path",
            method: HttpMethod.Get,
            description: "fake_description",
            parameters: parameters,
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            securityRequirements: []
        );

        // Act
        var headers = sut.BuildHeaders(arguments);

        // Assert
        Assert.NotNull(headers);
        Assert.Equal(2, headers.Count);

        Assert.Equal("v1", headers["h1"]);
        Assert.Equal("true", headers["h2"]);
    }

    [Fact]
    public void ItShouldMixAndMatchHeadersOfDifferentValueTypes()
    {
        // Arrange
        var parameters = new List<RestApiParameter>
        {
            new(name: "h1", type: "array", isRequired: true, expand: false, location: RestApiParameterLocation.Header, style: RestApiParameterStyle.Simple),
            new(name: "h2", type: "boolean", isRequired: true, expand: false, location: RestApiParameterLocation.Header, style: RestApiParameterStyle.Simple),
        };

        var arguments = new Dictionary<string, object?>
        {
            ["h1"] = new List<string> { "a", "b" },
            ["h2"] = "false"
        };

        var sut = new RestApiOperation(
            id: "fake_id",
            servers: [new RestApiServer("https://fake-random-test-host")],
            path: "fake_path",
            method: HttpMethod.Get,
            description: "fake_description",
            parameters: parameters,
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            securityRequirements: []
        );

        // Act
        var headers = sut.BuildHeaders(arguments);

        // Assert
        Assert.NotNull(headers);
        Assert.Equal(2, headers.Count);

        Assert.Equal("a,b", headers["h1"]);
        Assert.Equal("false", headers["h2"]);
    }

    [Fact]
    public void ItCreatesNewKernelsOnEachBuild()
    {
        IKernelBuilder builder = Kernel.CreateBuilder();
        Assert.NotSame(builder.Build(), builder.Build());
    }

    [Fact]
    public void ItHasIdempotentServicesAndPlugins()
    {
        IKernelBuilder builder = Kernel.CreateBuilder();

        Assert.NotNull(builder.Services);
        Assert.NotNull(builder.Plugins);

        IServiceCollection services = builder.Services;
        IKernelBuilderPlugins plugins = builder.Plugins;

        for (int i = 0; i < 3; i++)
        {
            Assert.Same(services, builder.Services);
            Assert.Same(plugins, builder.Plugins);
            Assert.NotNull(builder.Build());
        }
    }

    [Fact]
    public void ItDefaultsDataToAnEmptyDictionary()
    {
        Kernel kernel = Kernel.CreateBuilder().Build();
        Assert.Empty(kernel.Data);
    }

    [Fact]
    public void ItDefaultsServiceSelectorToSingleton()
    {
        Kernel kernel = Kernel.CreateBuilder().Build();
        Assert.Null(kernel.Services.GetService<IAIServiceSelector>());
        Assert.NotNull(kernel.ServiceSelector);
        Assert.Same(kernel.ServiceSelector, kernel.ServiceSelector);
        Assert.Throws<KernelException>(() => kernel.GetRequiredService<IAIServiceSelector>());

        kernel = new Kernel();
        Assert.Null(kernel.Services.GetService<IAIServiceSelector>());
        Assert.NotNull(kernel.ServiceSelector);
        Assert.Same(kernel.ServiceSelector, kernel.ServiceSelector);
        Assert.Throws<KernelException>(() => kernel.GetRequiredService<IAIServiceSelector>());

        NopServiceSelector selector = new();

        IKernelBuilder builder = Kernel.CreateBuilder();
        builder.Services.AddSingleton<IAIServiceSelector>(selector);
        kernel = builder.Build();
        Assert.Same(selector, kernel.Services.GetService<IAIServiceSelector>());
        Assert.Same(selector, kernel.ServiceSelector);
        Assert.Same(selector, kernel.GetRequiredService<IAIServiceSelector>());
    }

    private sealed class NopServiceSelector : IAIServiceSelector
    {
#pragma warning disable CS8769 // Nullability of reference types in type of parameter doesn't match implemented member (possibly because of nullability attributes).
        bool IAIServiceSelector.TrySelectAIService<T>(
#pragma warning restore CS8769
            Kernel kernel, KernelFunction function, KernelArguments arguments, out T? service, out PromptExecutionSettings? serviceSettings) where T : class =>
            throw new NotImplementedException();
    }

    [Fact]
    public void ItPropagatesPluginsToBuiltKernel()
    {
        KernelPlugin plugin1 = KernelPluginFactory.CreateFromFunctions("plugin1");
        KernelPlugin plugin2 = KernelPluginFactory.CreateFromFunctions("plugin2");

        IKernelBuilder builder = Kernel.CreateBuilder();
        builder.Plugins.Add(plugin1);
        builder.Plugins.Add(plugin2);
        Kernel kernel = builder.Build();

        Assert.Contains(plugin1, kernel.Plugins);
        Assert.Contains(plugin2, kernel.Plugins);
    }

    [Fact]
    public void ItSuppliesServicesCollectionToPluginsBuilder()
    {
        IKernelBuilder builder = Kernel.CreateBuilder();
        Assert.Same(builder.Services, builder.Plugins.Services);
    }

    [Fact]
    public void ItBuildsServicesIntoKernel()
    {
        var builder = Kernel.CreateBuilder()
            .AddOpenAIChatCompletion(modelId: "abcd", apiKey: "efg", serviceId: "openai")
            .AddAzureOpenAIChatCompletion(deploymentName: "hijk", modelId: "qrs", endpoint: "https://lmnop", apiKey: "tuv", serviceId: "azureopenai");

        builder.Services.AddSingleton<IFormatProvider>(CultureInfo.InvariantCulture);
        builder.Services.AddSingleton<IFormatProvider>(CultureInfo.CurrentCulture);
        builder.Services.AddSingleton<IFormatProvider>(new CultureInfo("en-US"));

        Kernel kernel = builder.Build();

        Assert.IsType<OpenAIChatCompletionService>(kernel.GetRequiredService<IChatCompletionService>("openai"));
        Assert.IsType<AzureOpenAIChatCompletionService>(kernel.GetRequiredService<IChatCompletionService>("azureopenai"));

        Assert.Equal(2, kernel.GetAllServices<ITextGenerationService>().Count());
        Assert.Equal(2, kernel.GetAllServices<IChatCompletionService>().Count());

        Assert.Equal(3, kernel.GetAllServices<IFormatProvider>().Count());
    }

    [Fact]
    public void ItSupportsMultipleEqualNamedServices()
    {
        Kernel kernel = Kernel.CreateBuilder()
            .AddOpenAIChatCompletion(modelId: "abcd", apiKey: "efg", serviceId: "openai")
            .AddOpenAIChatCompletion(modelId: "abcd", apiKey: "efg", serviceId: "openai")
            .AddOpenAIChatCompletion(modelId: "abcd", apiKey: "efg", serviceId: "openai")
            .AddOpenAIChatCompletion(modelId: "abcd", apiKey: "efg", serviceId: "openai")
            .AddAzureOpenAIChatCompletion(deploymentName: "hijk", modelId: "lmnop", endpoint: "https://qrs", apiKey: "tuv", serviceId: "openai")
            .AddAzureOpenAIChatCompletion(deploymentName: "hijk", modelId: "lmnop", endpoint: "https://qrs", apiKey: "tuv", serviceId: "openai")
            .AddAzureOpenAIChatCompletion(deploymentName: "hijk", modelId: "lmnop", endpoint: "https://qrs", apiKey: "tuv", serviceId: "openai")
            .AddAzureOpenAIChatCompletion(deploymentName: "hijk", modelId: "lmnop", endpoint: "https://qrs", apiKey: "tuv", serviceId: "openai")
            .Build();

        Assert.Equal(8, kernel.GetAllServices<IChatCompletionService>().Count());
    }

    [Fact]
    public void ItIsntNeededInDIContexts()
    {
        KernelPluginCollection plugins = [KernelPluginFactory.CreateFromFunctions("plugin1")];

        var serviceCollection = new ServiceCollection();
        serviceCollection.AddAzureOpenAIChatCompletion(deploymentName: "abcd", modelId: "efg", endpoint: "https://hijk", apiKey: "lmnop");
        serviceCollection.AddAzureOpenAIChatCompletion(deploymentName: "abcd", modelId: "efg", endpoint: "https://hijk", apiKey: "lmnop");
        serviceCollection.AddAzureOpenAIChatCompletion(deploymentName: "abcd", modelId: "efg", endpoint: "https://hijk", apiKey: "lmnop", serviceId: "azureopenai1");
        serviceCollection.AddAzureOpenAIChatCompletion(deploymentName: "abcd", modelId: "efg", endpoint: "https://hijk", apiKey: "lmnop", serviceId: "azureopenai2");
        serviceCollection.AddSingleton(plugins);
        serviceCollection.AddSingleton<Kernel>();

        Kernel k = serviceCollection.BuildServiceProvider().GetService<Kernel>()!;

        Assert.NotNull(k);
        Assert.Same(plugins, k.Plugins);
        Assert.IsAssignableFrom<IChatCompletionService>(k.GetRequiredService<IChatCompletionService>("azureopenai1"));
        Assert.IsAssignableFrom<IChatCompletionService>(k.GetRequiredService<IChatCompletionService>("azureopenai2"));

        // This should be 4, not 2. However, there is currently a limitation with Microsoft.Extensions.DependencyInjection
        // that prevents GetAllServices from enumerating named services. KernelBuilder works around this,
        // but when just using DI directly, it will only find unnamed services. Once that issue is fixed and SK
        // brings in the new version, it can update the GetAllServices implementation to remove the workaround,
        // and then this test should be updated accordingly.
        Assert.Equal(2, k.GetAllServices<IChatCompletionService>().Count());

        // It's possible to explicitly use the same workaround outside of KernelBuilder to get all services,
        // but it's not recommended.

        //** WORKAROUND
        Dictionary<Type, HashSet<object?>> mapping = [];
        foreach (var descriptor in serviceCollection)
        {
            if (!mapping.TryGetValue(descriptor.ServiceType, out HashSet<object?>? keys))
            {
                mapping[descriptor.ServiceType] = keys = [];
            }
            keys.Add(descriptor.ServiceKey);
        }
        serviceCollection.AddKeyedSingleton<Dictionary<Type, HashSet<object?>>>("KernelServiceTypeToKeyMappings", mapping);
        //**

        k = serviceCollection.BuildServiceProvider().GetService<Kernel>()!;
        Assert.Equal(4, k.GetAllServices<IChatCompletionService>().Count()); // now this is 4 as expected
    }

    [Fact]
    public void ItFindsAllPluginsToPopulatePluginsCollection()
    {
        KernelPlugin plugin1 = KernelPluginFactory.CreateFromFunctions("plugin1");
        KernelPlugin plugin2 = KernelPluginFactory.CreateFromFunctions("plugin2");
        KernelPlugin plugin3 = KernelPluginFactory.CreateFromFunctions("plugin3");

        IKernelBuilder builder = Kernel.CreateBuilder();
        builder.Services.AddSingleton(plugin1);
        builder.Services.AddSingleton(plugin2);
        builder.Services.AddSingleton(plugin3);
        Kernel kernel = builder.Build();

        Assert.Equal(3, kernel.Plugins.Count);
    }

    [Fact]
    public void ItFindsPluginCollectionToUse()
    {
        KernelPlugin plugin1 = KernelPluginFactory.CreateFromFunctions("plugin1");
        KernelPlugin plugin2 = KernelPluginFactory.CreateFromFunctions("plugin2");
        KernelPlugin plugin3 = KernelPluginFactory.CreateFromFunctions("plugin3");

        IKernelBuilder builder = Kernel.CreateBuilder();
        builder.Services.AddTransient<KernelPluginCollection>(_ => new([plugin1, plugin2, plugin3]));

        Kernel kernel1 = builder.Build();
        Assert.Equal(3, kernel1.Plugins.Count);

        Kernel kernel2 = builder.Build();
        Assert.Equal(3, kernel2.Plugins.Count);

        Assert.NotSame(kernel1.Plugins, kernel2.Plugins);
    }

    [Fact]
    public void ItAddsTheRightTypesInAddKernel()
    {
        IServiceCollection sc = new ServiceCollection();

        IKernelBuilder builder = sc.AddKernel();
        Assert.NotNull(builder);
        Assert.Throws<InvalidOperationException>(builder.Build);

        builder.Services.AddSingleton<Dictionary<string, string>>([]);

        IServiceProvider provider = sc.BuildServiceProvider();

        Assert.NotNull(provider.GetService<Dictionary<string, string>>());
        Assert.NotNull(provider.GetService<KernelPluginCollection>());
        Assert.NotNull(provider.GetService<Kernel>());
    }

    [Fact]
    public void ItShouldUseDefaultServerVariableIfNoOverrideProvided()
    {
        // Arrange
        var sut = new RestApiOperation(
            id: "fake_id",
            servers: [
                new RestApiServer("https://example.com/{version}", new Dictionary<string, RestApiServerVariable> { { "version", new RestApiServerVariable("v2") } }),
                new RestApiServer("https://ppe.example.com/{version}", new Dictionary<string, RestApiServerVariable> { { "version", new RestApiServerVariable("v2") } })
            ],
            path: "/items",
            method: HttpMethod.Get,
            description: "fake_description",
            parameters: [],
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            securityRequirements: []
        );

        var arguments = new Dictionary<string, object?>();

        // Act
        var url = sut.BuildOperationUrl(arguments);

        // Assert
        Assert.Equal("https://example.com/v2/items", url.OriginalString);
    }

    [Fact]
    public void ItShouldUseDefaultServerVariableIfInvalidOverrideProvided()
    {
        // Arrange
        var version = new RestApiServerVariable("v2", null, ["v1", "v2"]);
        var sut = new RestApiOperation(
            id: "fake_id",
            servers: [
                new RestApiServer("https://example.com/{version}", new Dictionary<string, RestApiServerVariable> { { "version", version } }),
                new RestApiServer("https://ppe.example.com/{version}", new Dictionary<string, RestApiServerVariable> { { "version", new RestApiServerVariable("v2") } })
            ],
            path: "/items",
            method: HttpMethod.Get,
            description: "fake_description",
            parameters: [],
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            securityRequirements: []
        );

        var arguments = new Dictionary<string, object?>() { { "version", "v3" } };

        // Act
        var url = sut.BuildOperationUrl(arguments);

        // Assert
        Assert.Equal("https://example.com/v2/items", url.OriginalString);
    }

    [Fact]
    public void ItShouldUseServerVariableOverrideIfProvided()
    {
        // Arrange
        var version = new RestApiServerVariable("v2", null, ["v1", "v2", "v3"]);
        var sut = new RestApiOperation(
            id: "fake_id",
            servers: [
                new RestApiServer("https://example.com/{version}", new Dictionary<string, RestApiServerVariable> { { "version", version } }),
                new RestApiServer("https://ppe.example.com/{version}", new Dictionary<string, RestApiServerVariable> { { "version", new RestApiServerVariable("v2") } })
            ],
            path: "/items",
            method: HttpMethod.Get,
            description: "fake_description",
            parameters: [],
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            securityRequirements: []
        );

        var arguments = new Dictionary<string, object?>() { { "version", "v3" } };

        // Act
        var url = sut.BuildOperationUrl(arguments);

        // Assert
        Assert.Equal("https://example.com/v3/items", url.OriginalString);
    }

    [Fact]
    public void ItShouldUseVariableArgumentNameToLookupArgumentsToBuildServerUrl()
    {
        // Arrange
        var version = new RestApiServerVariable("v1") { ArgumentName = "alt_version" };
        var sut = new RestApiOperation(
            id: "fake_id",
            servers: [
                new RestApiServer("https://example.com/{version}", new Dictionary<string, RestApiServerVariable> { { "version", version } }),
            ],
            path: "/items",
            method: HttpMethod.Get,
            description: "fake_description",
            parameters: [],
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            securityRequirements: []
        );

        var arguments = new Dictionary<string, object?>() { { "alt_version", "v3" } };

        // Act
        var url = sut.BuildOperationUrl(arguments);

        // Assert
        Assert.Equal("https://example.com/v3/items", url.OriginalString);
    }

    [Fact]
    public void ItShouldUseVariableNameToLookupArgumentsToBuildServerUrlIfNoArgumentsProvidedForArgumentNames()
    {
        // Arrange
        var version = new RestApiServerVariable("v1") { ArgumentName = "alt_version" };
        var sut = new RestApiOperation(
            id: "fake_id",
            servers: [
                new RestApiServer("https://example.com/{version}", new Dictionary<string, RestApiServerVariable> { { "version", version } }),
            ],
            path: "/items",
            method: HttpMethod.Get,
            description: "fake_description",
            parameters: [],
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            securityRequirements: []
        );

        var arguments = new Dictionary<string, object?>() { { "version", "v3" } };

        // Act
        var url = sut.BuildOperationUrl(arguments);

        // Assert
        Assert.Equal("https://example.com/v3/items", url.OriginalString);
    }

    [Fact]
    public void ItShouldAllowModifyProperties()
    {
        // Arrange
        var securityScheme = new RestApiSecurityScheme() { Flows = new RestApiOAuthFlows() };

        var sut = new RestApiOperation(
            id: "fake_id",
            servers: [
                new RestApiServer("https://example.com/{p1}", new Dictionary<string, RestApiServerVariable> { { "p1", new RestApiServerVariable("v1", "d1", ["ev1"]) } }),
            ],
            path: "/items",
            method: HttpMethod.Get,
            description: "fake_description",
            parameters: [
                new RestApiParameter(
                    name: "p2",
                    type: "string",
                    isRequired: false,
                    expand: false,
                    location: RestApiParameterLocation.Query),
            ],
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            payload: new RestApiPayload(
                mediaType: "application/json",
                properties: new List<RestApiPayloadProperty> { { new RestApiPayloadProperty (
                    name: "p3",
                    type: "string",
                    isRequired: false,
                    properties: []
                ) } }
            ),
            securityRequirements: [new RestApiSecurityRequirement(new Dictionary<RestApiSecurityScheme, IList<string>>() { [securityScheme] = ["scope"] })]
        );

        // Act & Assert
        sut.Servers[0].Variables.Add("p2", new RestApiServerVariable("v2"));
        sut.Servers[0].Variables["p1"].ArgumentName = "a value";
        sut.Servers[0].Variables["p1"].Enum!.Add("ev2");

        sut.Payload!.Properties.Single(p => p.Name == "p3").ArgumentName = "a value";
        sut.Payload!.Properties.Single(p => p.Name == "p3").Properties.Add(new RestApiPayloadProperty("p4", "string", false, []));

        sut.Parameters.Single(p => p.Name == "p2").ArgumentName = "a value";

        sut.SecurityRequirements.Add(new RestApiSecurityRequirement(new Dictionary<RestApiSecurityScheme, IList<string>>()
        {
            [new RestApiSecurityScheme() { Flows = new RestApiOAuthFlows() }] = ["scope2"]
        }));

        sut.SecurityRequirements[0].Add(new RestApiSecurityScheme() { Flows = new RestApiOAuthFlows() }, ["scope3"]);
        sut.SecurityRequirements[0][securityScheme] = ["scope4"];
        sut.SecurityRequirements[0][securityScheme][0] = "scope5";

        sut.Responses.Add("200", new RestApiExpectedResponse("fake_description", "fake_media_type"));

        sut.Extensions.Add("x-fake", "fake_value");
    }

    [Fact]
    public void ItShouldFreezeModifiableProperties()
    {
        // Arrange
        var securityScheme = new RestApiSecurityScheme() { Flows = new RestApiOAuthFlows() };

        var sut = new RestApiOperation(
            id: "fake_id",
            servers: [
                new RestApiServer("https://example.com/{p1}", new Dictionary<string, RestApiServerVariable> { { "p1", new RestApiServerVariable("v1", "d1", ["ev1"]) } }),
            ],
            path: "/items",
            method: HttpMethod.Get,
            description: "fake_description",
            parameters: [
                new RestApiParameter(
                    name: "p2",
                    type: "string",
                    isRequired: false,
                    expand: false,
                    location: RestApiParameterLocation.Query),
            ],
            responses: new Dictionary<string, RestApiExpectedResponse>(),
            payload: new RestApiPayload(
                mediaType: "application/json",
                properties: new List<RestApiPayloadProperty> { { new RestApiPayloadProperty (
                    name: "p3",
                    type: "string",
                    isRequired: false,
                    properties: []
                ) } }
            ),
            securityRequirements: [new RestApiSecurityRequirement(new Dictionary<RestApiSecurityScheme, IList<string>>() { [securityScheme] = ["scope"] })]
        );

        // Act
        sut.Freeze();

        // Act & Assert
        Assert.Throws<NotSupportedException>(() => sut.Servers[0].Variables.Add("p2", new RestApiServerVariable("v2")));
        Assert.Throws<InvalidOperationException>(() => sut.Servers[0].Variables["p1"].ArgumentName = "a value");
        Assert.Throws<NotSupportedException>(() => sut.Servers[0].Variables["p1"].Enum!.Add("ev2"));

        Assert.Throws<InvalidOperationException>(() => sut.Payload!.Properties.Single(p => p.Name == "p3").ArgumentName = "a value");
        Assert.Throws<NotSupportedException>(() => sut.Payload!.Properties.Single(p => p.Name == "p3").Properties.Add(new RestApiPayloadProperty("p4", "string", false, [])));

        Assert.Throws<InvalidOperationException>(() => sut.Parameters.Single(p => p.Name == "p2").ArgumentName = "a value");

        Assert.Throws<NotSupportedException>(() => sut.SecurityRequirements.Add(new RestApiSecurityRequirement(new Dictionary<RestApiSecurityScheme, IList<string>>()
        {
            [new RestApiSecurityScheme() { Flows = new RestApiOAuthFlows() }] = ["scope2"]
        })));

        Assert.Throws<InvalidOperationException>(() => sut.SecurityRequirements[0].Add(new RestApiSecurityScheme() { Flows = new RestApiOAuthFlows() }, ["scope3"]));
        Assert.Throws<InvalidOperationException>(() => sut.SecurityRequirements[0][securityScheme] = ["scope4"]);
        Assert.Throws<NotSupportedException>(() => sut.SecurityRequirements[0][securityScheme][0] = "scope5");

        Assert.Throws<NotSupportedException>(() => sut.Responses.Add("200", new RestApiExpectedResponse("fake_description", "fake_media_type")));

        Assert.Throws<NotSupportedException>(() => sut.Extensions.Add("x-fake", "fake_value"));
    }
}


===== Functions.UnitTests\OpenApi\RestApiSecurityRequirementTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.SemanticKernel.Plugins.OpenApi;
using Xunit;

namespace SemanticKernel.Functions.UnitTests.OpenApi;

public class RestApiSecurityRequirementTests
{
    [Fact]
    public void ItShouldWorkAsInstance()
    {
        // Arrange
        RestApiSecurityRequirement sut = [];

        RestApiSecurityScheme scheme = new();

        IList<string> scopes = ["scope"];

        // Act & Assert

        // Add
        sut.Add(scheme, scopes);
        Assert.Single(sut);

        // Remove
        sut.Remove(scheme);
        Assert.Empty(sut);

        // Clear
        sut.Add(scheme, scopes);
        sut.Clear();
        Assert.Empty(sut);

        // ContainsKey
        sut.Add(scheme, scopes);
        Assert.True(sut.ContainsKey(scheme));

        // TryGetValue
        Assert.True(sut.TryGetValue(scheme, out IList<string>? value) && object.Equals(value, scopes));

        // this[RestApiSecurityScheme key]
        IList<string> newScopes = ["scope1"];
        sut[scheme] = newScopes;
        Assert.Equal(newScopes, sut[scheme]);

        // Keys
        Assert.Single(sut.Keys);
        Assert.Equal(scheme, sut.Keys.ElementAt(0));

        // Values
        Assert.Single(sut.Values);
        Assert.Equal(newScopes, sut.Values.ElementAt(0));

        // Freese
        sut.Freeze();
        Assert.Throws<InvalidOperationException>(() => sut.Add(scheme, scopes));
        Assert.Throws<InvalidOperationException>(() => sut.Remove(scheme));
        Assert.Throws<InvalidOperationException>(sut.Clear);
        Assert.Throws<InvalidOperationException>(() => sut[scheme] = scopes);
    }

    [Fact]
    public void ItShouldSupportAllMembersOfIDictionaryInterface()
    {
        // Arrange
        RestApiSecurityRequirement instance = [];

        IDictionary<RestApiSecurityScheme, IList<string>> sut = instance;

        RestApiSecurityScheme scheme = new();

        IList<string> scopes = ["scope"];

        // Act & Assert

        // Add
        sut.Add(scheme, scopes);
        Assert.Single(sut);

        // Remove
        sut.Remove(scheme);
        Assert.Empty(sut);

        // ContainsKey
        sut.Add(scheme, scopes);
        Assert.True(sut.ContainsKey(scheme));

        // TryGetValue
        Assert.True(sut.TryGetValue(scheme, out IList<string>? value) && object.Equals(value, scopes));

        // this[RestApiSecurityScheme key]
        IList<string> newScopes = ["scope1"];
        sut[scheme] = newScopes;
        Assert.Equal(newScopes, sut[scheme]);

        // Keys
        Assert.Single(sut.Keys);
        Assert.Equal(scheme, sut.Keys.ElementAt(0));

        // Values
        Assert.Single(sut.Values);
        Assert.Equal(newScopes, sut.Values.ElementAt(0));

        // Freese
        instance.Freeze();
        Assert.Throws<InvalidOperationException>(() => sut.Add(scheme, scopes));
        Assert.Throws<InvalidOperationException>(() => sut.Remove(scheme));
        Assert.Throws<InvalidOperationException>(() => sut[scheme] = scopes);
    }

    [Fact]
    public void ItShouldSupportAllMembersOfIReadOnlyDictionaryInterface()
    {
        // Arrange
        RestApiSecurityRequirement instance = [];

        IReadOnlyDictionary<RestApiSecurityScheme, IList<string>> sut = instance;

        RestApiSecurityScheme scheme = new();

        IList<string> scopes = ["scope"];

        // Act & Assert
        instance.Add(scheme, scopes);
        Assert.Single(sut);

        // ContainsKey
        Assert.True(sut.ContainsKey(scheme));

        // TryGetValue
        Assert.True(sut.TryGetValue(scheme, out IList<string>? value) && object.Equals(value, scopes));

        // this[RestApiSecurityScheme key]
        Assert.Equal(scopes, sut[scheme]);

        // Keys
        Assert.Single(sut.Keys);
        Assert.Equal(scheme, sut.Keys.ElementAt(0));

        // Values
        Assert.Single(sut.Values);
        Assert.Equal(scopes, sut.Values.ElementAt(0));
    }

    [Fact]
    public void ItShouldSupportAllMembersOfICollectionInterface()
    {
        // Arrange
        RestApiSecurityRequirement instance = [];

        ICollection<KeyValuePair<RestApiSecurityScheme, IList<string>>> sut = instance;

        RestApiSecurityScheme scheme = new();

        IList<string> scopes = ["scope"];

        KeyValuePair<RestApiSecurityScheme, IList<string>> keyValuePair = new(scheme, scopes);

        // Act & Assert

        // Add
        sut.Add(keyValuePair);

        // Count
#pragma warning disable xUnit2013 // Do not use equality check to check for collection size.
        Assert.Equal(1, sut.Count);
#pragma warning restore xUnit2013 // Do not use equality check to check for collection size.

        // Remove
        sut.Remove(keyValuePair);
        Assert.Empty(sut);

        // Contains
        sut.Add(keyValuePair);
        Assert.True(sut.Contains(keyValuePair));

        // Clear
        sut.Clear();

        // IsReadOnly
        Assert.False(sut.IsReadOnly);

        // CopyTo
        sut.Add(keyValuePair);
        KeyValuePair<RestApiSecurityScheme, IList<string>>[] array = new KeyValuePair<RestApiSecurityScheme, IList<string>>[1];
        sut.CopyTo(array, 0);
        Assert.Equal(keyValuePair, array[0]);

        // Freese
        instance.Freeze();
        Assert.True(sut.IsReadOnly);

        Assert.Throws<InvalidOperationException>(() => sut.Add(new KeyValuePair<RestApiSecurityScheme, IList<string>>()));
        Assert.Throws<InvalidOperationException>(() => sut.Remove(keyValuePair));
        Assert.Throws<InvalidOperationException>(sut.Clear);
    }

    [Fact]
    public void ItShouldSupportAllMembersOfIEnumerableInterface()
    {
        // Arrange
        RestApiSecurityScheme scheme = new();

        IList<string> scopes = ["scope"];

        RestApiSecurityRequirement instance = [];
        instance.Add(scheme, scopes);

        IEnumerable<KeyValuePair<RestApiSecurityScheme, IList<string>>> sut = instance;

        // Act & Assert

        var enumerator = sut.GetEnumerator();

        Assert.True(enumerator.MoveNext());
        Assert.Equal(instance.ElementAt(0), enumerator.Current);
        Assert.False(enumerator.MoveNext());
    }

    [Fact]
    public void ItShouldFreezeKeysAndValues()
    {
        // Arrange
        RestApiOAuthFlows flows = new()
        {
            Implicit = new RestApiOAuthFlow() { Scopes = new Dictionary<string, string>() { ["s1"] = "v1" } },
            Password = new RestApiOAuthFlow() { Scopes = new Dictionary<string, string>() { ["s1"] = "v1" } },
            ClientCredentials = new RestApiOAuthFlow() { Scopes = new Dictionary<string, string>() { ["s1"] = "v1" } },
            AuthorizationCode = new RestApiOAuthFlow() { Scopes = new Dictionary<string, string>() { ["s1"] = "v1" } },
        };

        RestApiSecurityScheme scheme = new() { Flows = flows };

        RestApiSecurityRequirement sut = [];
        sut.Add(scheme, ["scope"]);

        // Act
        sut.Freeze();

        // Assert
        Assert.Throws<NotSupportedException>(() => scheme.Flows.Implicit.Scopes.Add("scope-name", "scope-description"));
        Assert.Throws<NotSupportedException>(() => scheme.Flows.Implicit.Scopes["scope-name"] = "scope-description");

        Assert.Throws<NotSupportedException>(() => scheme.Flows.Password.Scopes.Add("scope-name", "scope-description"));
        Assert.Throws<NotSupportedException>(() => scheme.Flows.Password.Scopes["scope-name"] = "scope-description");

        Assert.Throws<NotSupportedException>(() => scheme.Flows.ClientCredentials.Scopes.Add("scope-name", "scope-description"));
        Assert.Throws<NotSupportedException>(() => scheme.Flows.ClientCredentials.Scopes["scope-name"] = "scope-description");

        Assert.Throws<NotSupportedException>(() => scheme.Flows.AuthorizationCode.Scopes.Add("scope-name", "scope-description"));
        Assert.Throws<NotSupportedException>(() => scheme.Flows.AuthorizationCode.Scopes["scope-name"] = "scope-description");

        Assert.Throws<NotSupportedException>(() => sut[scheme].Add("new-scheme"));
        Assert.Throws<InvalidOperationException>(() => sut[scheme] = []);
    }
}


===== Functions.UnitTests\OpenApi\Serialization\ArrayParameterSerializerTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Text.Json.Nodes;
using Microsoft.SemanticKernel.Plugins.OpenApi;
using Xunit;

namespace SemanticKernel.Functions.UnitTests.OpenApi.Serialization;

public class ArrayParameterSerializerTests
{
    [Fact]
    public void ItShouldCreateParameterPerArrayItem()
    {
        // Arrange
        var array = new JsonArray(1, 2, 3);

        // Act
        var result = ArrayParameterValueSerializer.SerializeArrayAsSeparateParameters("id", array, delimiter: "&");

        // Assert
        Assert.NotNull(result);

        Assert.Equal("id=1&id=2&id=3", result);
    }

    [Fact]
    public void ItShouldAllowDuplicatesWhenCreatingParameterPerArrayItem()
    {
        // Arrange
        var array = new JsonArray(1, 2, 2, 3);

        // Act
        var result = ArrayParameterValueSerializer.SerializeArrayAsSeparateParameters("id", array, delimiter: "&");

        // Assert
        Assert.NotNull(result);

        Assert.Equal("id=1&id=2&id=2&id=3", result);
    }

    [Fact]
    public void ItShouldAllowParameterDelimiterAsValueWhenCreatingParameterPerArrayItem()
    {
        // Arrange
        var array = new JsonArray("a", "b&", "c");

        // Act
        var result = ArrayParameterValueSerializer.SerializeArrayAsSeparateParameters("id", array, delimiter: "&");

        // Assert
        Assert.NotNull(result);

        Assert.Equal("id=a&id=b%26&id=c", result);
    }

    [Fact]
    public void ItShouldCreateParameterWithDelimitedValuePerArrayItem()
    {
        // Arrange
        var array = new JsonArray(1, 2, 3);

        // Act
        var result = ArrayParameterValueSerializer.SerializeArrayAsDelimitedValues(array, delimiter: "%20");

        // Assert
        Assert.NotNull(result);

        Assert.Equal("1%202%203", result);
    }

    [Fact]
    public void ItShouldAllowDuplicatesWhenCreatingParameterWithDelimitedValuePerArrayItem()
    {
        // Arrange
        var array = new JsonArray(1, 2, 2, 3);

        // Act
        var result = ArrayParameterValueSerializer.SerializeArrayAsDelimitedValues(array, delimiter: "%20");

        // Assert
        Assert.NotNull(result);

        Assert.Equal("1%202%202%203", result);
    }

    [Theory]
    [InlineData(":", "%3a")]
    [InlineData("/", "%2f")]
    [InlineData("?", "%3f")]
    [InlineData("#", "%23")]
    public void ItShouldEncodeSpecialSymbolsInSeparateParameterValues(string specialSymbol, string encodedEquivalent)
    {
        // Arrange
        var array = new JsonArray(specialSymbol);

        // Act
        var result = ArrayParameterValueSerializer.SerializeArrayAsSeparateParameters("id", array, delimiter: "&");

        // Assert
        Assert.NotNull(result);

        Assert.EndsWith(encodedEquivalent, result, StringComparison.Ordinal);
    }

    [Theory]
    [InlineData(":", "%3a")]
    [InlineData("/", "%2f")]
    [InlineData("?", "%3f")]
    [InlineData("#", "%23")]
    public void ItShouldEncodeSpecialSymbolsInDelimitedParameterValues(string specialSymbol, string encodedEquivalent)
    {
        // Arrange
        var array = new JsonArray(specialSymbol);

        // Act
        var result = ArrayParameterValueSerializer.SerializeArrayAsDelimitedValues(array, delimiter: "%20");

        // Assert
        Assert.NotNull(result);

        Assert.EndsWith(encodedEquivalent, result, StringComparison.Ordinal);
    }

    [Theory]
    [InlineData(":", ":")]
    [InlineData("/", "/")]
    [InlineData("?", "?")]
    [InlineData("#", "#")]
    public void ItShouldNotEncodeSpecialSymbolsInDelimitedParameterValuesIfEncodingDisabled(string specialSymbol, string expectedValue)
    {
        // Arrange
        var array = new JsonArray(specialSymbol);

        // Act
        var result = ArrayParameterValueSerializer.SerializeArrayAsDelimitedValues(array, delimiter: ",", encode: false);

        // Assert
        Assert.NotNull(result);

        Assert.EndsWith(expectedValue, result, StringComparison.Ordinal);
    }
}


===== Functions.UnitTests\OpenApi\Serialization\FormStyleParametersSerializerTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Text.Json.Nodes;
using Microsoft.SemanticKernel.Plugins.OpenApi;
using Xunit;

namespace SemanticKernel.Functions.UnitTests.OpenApi.Serialization;

public class FormStyleParametersSerializerTests
{
    [Fact]
    public void ItShouldCreateAmpersandSeparatedParameterPerArrayItem()
    {
        // Arrange
        var parameter = new RestApiParameter(
                name: "id",
                type: "array",
                isRequired: true,
                expand: true, //Specify generating a separate parameter for each array item.
                location: RestApiParameterLocation.Query,
                style: RestApiParameterStyle.Form,
                arrayItemType: "integer");

        // Act
        var result = FormStyleParameterSerializer.Serialize(parameter, new JsonArray(1, 2, 3));

        // Assert
        Assert.NotNull(result);

        Assert.Equal("id=1&id=2&id=3", result);
    }

    [Fact]
    public void ItShouldCreateParameterWithCommaSeparatedValuePerArrayItem()
    {
        // Arrange
        var parameter = new RestApiParameter(
                name: "id",
                type: "array",
                isRequired: true,
                expand: false, //Specify generating a parameter with comma-separated values for each array item.
                location: RestApiParameterLocation.Query,
                style: RestApiParameterStyle.Form,
                arrayItemType: "integer");

        // Act
        var result = FormStyleParameterSerializer.Serialize(parameter, new JsonArray(1, 2, 3));

        // Assert
        Assert.NotNull(result);

        Assert.Equal("id=1,2,3", result);
    }

    [Fact]
    public void ItShouldCreateParameterForPrimitiveValue()
    {
        // Arrange
        var parameter = new RestApiParameter(
                name: "id",
                type: "integer",
                isRequired: true,
                expand: false,
                location: RestApiParameterLocation.Query,
                style: RestApiParameterStyle.Form);

        // Act
        var result = FormStyleParameterSerializer.Serialize(parameter, "28");

        // Assert
        Assert.NotNull(result);

        Assert.Equal("id=28", result);
    }

    [Fact]
    public void ItShouldCreateParameterForDateTimeValue()
    {
        // Arrange
        var parameter = new RestApiParameter(
                name: "id",
                type: "string",
                isRequired: true,
                expand: false,
                location: RestApiParameterLocation.Query,
                style: RestApiParameterStyle.Form);

        // Act
        var result = FormStyleParameterSerializer.Serialize(parameter, JsonValue.Create(new DateTime(2023, 12, 06, 11, 53, 36, DateTimeKind.Utc)));

        // Assert
        Assert.NotNull(result);

        Assert.Equal("id=2023-12-06T11%3a53%3a36Z", result);
    }

    [Theory]
    [InlineData("2024-01-01T00:00:00+00:00", "2024-01-01T00%3a00%3a00%2b00%3a00")]
    public void ItShouldCreateParameterForStringValue(string value, string encodedValue)
    {
        // Arrange
        var parameter = new RestApiParameter(
                name: "id",
                type: "string",
                isRequired: true,
                expand: false,
                location: RestApiParameterLocation.Query,
                style: RestApiParameterStyle.Form);

        // Act
        var result = FormStyleParameterSerializer.Serialize(parameter, JsonValue.Create(value));

        // Assert
        Assert.NotNull(result);

        Assert.Equal($"id={encodedValue}", result);
    }

    [Theory]
    [InlineData(":", "%3a")]
    [InlineData("/", "%2f")]
    [InlineData("?", "%3f")]
    [InlineData("#", "%23")]
    public void ItShouldEncodeSpecialSymbolsInPrimitiveParameterValues(string specialSymbol, string encodedEquivalent)
    {
        // Arrange
        var parameter = new RestApiParameter("id", "string", false, false, RestApiParameterLocation.Query, RestApiParameterStyle.Form);

        // Act
        var result = FormStyleParameterSerializer.Serialize(parameter, $"fake_query_param_value{specialSymbol}");

        // Assert
        Assert.NotNull(result);

        Assert.EndsWith(encodedEquivalent, result, StringComparison.Ordinal);
    }

    [Theory]
    [InlineData(":", "%3a")]
    [InlineData("/", "%2f")]
    [InlineData("?", "%3f")]
    [InlineData("#", "%23")]
    public void ItShouldEncodeSpecialSymbolsInAmpersandSeparatedParameterValues(string specialSymbol, string encodedEquivalent)
    {
        // Arrange
        var parameter = new RestApiParameter("id", "array", false, true, RestApiParameterLocation.Query, RestApiParameterStyle.Form);

        // Act
        var result = FormStyleParameterSerializer.Serialize(parameter, new JsonArray($"{specialSymbol}"));

        // Assert
        Assert.NotNull(result);

        Assert.EndsWith(encodedEquivalent, result, StringComparison.Ordinal);
    }

    [Theory]
    [InlineData(":", "%3a")]
    [InlineData("/", "%2f")]
    [InlineData("?", "%3f")]
    [InlineData("#", "%23")]
    public void ItShouldEncodeSpecialSymbolsInCommaSeparatedParameterValues(string specialSymbol, string encodedEquivalent)
    {
        // Arrange
        var parameter = new RestApiParameter("id", "array", false, false, RestApiParameterLocation.Query, RestApiParameterStyle.Form);

        // Act
        var result = FormStyleParameterSerializer.Serialize(parameter, new JsonArray($"{specialSymbol}"));

        // Assert
        Assert.NotNull(result);

        Assert.EndsWith(encodedEquivalent, result, StringComparison.Ordinal);
    }
}


===== Functions.UnitTests\OpenApi\Serialization\OpenApiTypeConverterTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Text.Json;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Plugins.OpenApi;
using Microsoft.VisualBasic;
using Xunit;

namespace SemanticKernel.Functions.UnitTests.OpenApi.Serialization;

public class OpenApiTypeConverterTests
{
    [Fact]
    public void ItShouldConvertString()
    {
        // Act & Assert
        Assert.Equal("\"test\"", OpenApiTypeConverter.Convert("id", "string", "test").ToString());
        Assert.Equal("test", OpenApiTypeConverter.Convert("id", "string", CreateJsonElement("test")).ToString());
    }

    [Fact]
    public void ItShouldConvertNumber()
    {
        // Act & Assert - Basic numeric types
        Assert.Equal("10", OpenApiTypeConverter.Convert("id", "number", (byte)10).ToString());
        Assert.Equal("10", OpenApiTypeConverter.Convert("id", "number", (sbyte)10).ToString());
        Assert.Equal("10", OpenApiTypeConverter.Convert("id", "number", (short)10).ToString());
        Assert.Equal("10", OpenApiTypeConverter.Convert("id", "number", (ushort)10).ToString());
        Assert.Equal("10", OpenApiTypeConverter.Convert("id", "number", (int)10).ToString());
        Assert.Equal("10", OpenApiTypeConverter.Convert("id", "number", (uint)10).ToString());
        Assert.Equal("10", OpenApiTypeConverter.Convert("id", "number", (long)10).ToString());
        Assert.Equal("10", OpenApiTypeConverter.Convert("id", "number", (ulong)10).ToString());
        Assert.Equal("10.5", OpenApiTypeConverter.Convert("id", "number", (float)10.5).ToString());
        Assert.Equal("10.5", OpenApiTypeConverter.Convert("id", "number", (double)10.5).ToString());
        Assert.Equal("10.5", OpenApiTypeConverter.Convert("id", "number", (decimal)10.5).ToString());

        // String conversions
        Assert.Equal("10", OpenApiTypeConverter.Convert("id", "number", "10").ToString());
        Assert.Equal("10.5", OpenApiTypeConverter.Convert("id", "number", "10.5").ToString());

        // JsonElement conversions
        Assert.Equal("10", OpenApiTypeConverter.Convert("id", "number", CreateJsonElement(10)).ToString());
        Assert.Equal("10.5", OpenApiTypeConverter.Convert("id", "number", CreateJsonElement(10.5)).ToString());
    }

    [Fact]
    public void ItShouldConvertInteger()
    {
        // Act & Assert - Basic integer types
        Assert.Equal("10", OpenApiTypeConverter.Convert("id", "integer", (byte)10).ToString());
        Assert.Equal("10", OpenApiTypeConverter.Convert("id", "integer", (sbyte)10).ToString());
        Assert.Equal("10", OpenApiTypeConverter.Convert("id", "integer", (short)10).ToString());
        Assert.Equal("10", OpenApiTypeConverter.Convert("id", "integer", (ushort)10).ToString());
        Assert.Equal("10", OpenApiTypeConverter.Convert("id", "integer", (int)10).ToString());
        Assert.Equal("10", OpenApiTypeConverter.Convert("id", "integer", (uint)10).ToString());
        Assert.Equal("10", OpenApiTypeConverter.Convert("id", "integer", (long)10).ToString());
        Assert.Equal("10", OpenApiTypeConverter.Convert("id", "integer", (ulong)10).ToString());

        // String conversion
        Assert.Equal("10", OpenApiTypeConverter.Convert("id", "integer", "10").ToString());

        // JsonElement conversion
        Assert.Equal("10", OpenApiTypeConverter.Convert("id", "integer", CreateJsonElement(10)).ToString());
    }

    [Fact]
    public void ItShouldConvertBoolean()
    {
        // Act & Assert - Basic boolean values
        Assert.Equal("true", OpenApiTypeConverter.Convert("id", "boolean", true).ToString());
        Assert.Equal("false", OpenApiTypeConverter.Convert("id", "boolean", false).ToString());

        // String conversions
        Assert.Equal("true", OpenApiTypeConverter.Convert("id", "boolean", "true").ToString());
        Assert.Equal("false", OpenApiTypeConverter.Convert("id", "boolean", "false").ToString());

        // JsonElement conversions
        Assert.Equal("true", OpenApiTypeConverter.Convert("id", "boolean", CreateJsonElement(true)).ToString());
        Assert.Equal("false", OpenApiTypeConverter.Convert("id", "boolean", CreateJsonElement(false)).ToString());
    }

    [Fact]
    public void ItShouldConvertDateTime()
    {
        // Arrange
        var dateTime = DateTime.ParseExact("06.12.2023 11:53:36+02:00", "dd.MM.yyyy HH:mm:sszzz", CultureInfo.InvariantCulture, DateTimeStyles.AdjustToUniversal);

        // Act & Assert
        Assert.Equal("\"2023-12-06T09:53:36Z\"", OpenApiTypeConverter.Convert("id", "string", dateTime).ToString());
    }

    [Fact]
    public void ItShouldConvertDateTimeOffset()
    {
        // Arrange
        var offset = DateTimeOffset.ParseExact("06.12.2023 11:53:36 +02:00", "dd.MM.yyyy HH:mm:ss zzz", CultureInfo.InvariantCulture);

        // Act & Assert
        Assert.Equal("\"2023-12-06T11:53:36+02:00\"", OpenApiTypeConverter.Convert("id", "string", offset).ToString());
    }

    [Fact]
    public void ItShouldConvertCollections()
    {
        // Act & Assert - Basic collections
        Assert.Equal("[1,2,3]", OpenApiTypeConverter.Convert("id", "array", new[] { 1, 2, 3 }).ToJsonString());
        Assert.Equal("[1,2,3]", OpenApiTypeConverter.Convert("id", "array", new List<int> { 1, 2, 3 }).ToJsonString());
        Assert.Equal("[1,2,3]", OpenApiTypeConverter.Convert("id", "array", new Collection() { 1, 2, 3 }).ToJsonString());
        Assert.Equal("[1,2,3]", OpenApiTypeConverter.Convert("id", "array", "[1, 2, 3]").ToJsonString());

        // JsonElement array conversion
        Assert.Equal("[1,2,3]", OpenApiTypeConverter.Convert("id", "array", CreateJsonElement(new[] { 1, 2, 3 })).ToJsonString());
    }

    [Fact]
    public void ItShouldConvertWithNoTypeAndNoSchema()
    {
        // Act
        var result = OpenApiTypeConverter.Convert("lat", null!, 51.8985136);

        // Assert
        Assert.Equal(51.8985136, result.GetValue<double>());
    }

    [Fact]
    public void ItShouldConvertWithNoTypeAndValidSchema()
    {
        // Arrange
        var schema = KernelJsonSchema.Parse(
        """
        {
            "type": "number",
            "format": "double",
            "nullable": false
        }
        """);

        // Act
        var result = OpenApiTypeConverter.Convert("lat", null!, 51.8985136, schema);

        // Assert
        Assert.Equal(51.8985136, result.GetValue<double>());
    }

    [Fact]
    public void ItShouldThrowExceptionWhenNoTypeAndInvalidSchema()
    {
        // Arrange
        var schema = KernelJsonSchema.Parse(
        """
        {
            "type": "boolean",
            "nullable": false
        }
        """);

        // Act & Assert
        Assert.Throws<ArgumentOutOfRangeException>(() => OpenApiTypeConverter.Convert("lat", null!, 51.8985136, schema));
    }

    private static JsonElement CreateJsonElement(object value)
    {
        var json = JsonSerializer.Serialize(value);
        return JsonSerializer.Deserialize<JsonElement>(json)!;
    }
}


===== Functions.UnitTests\OpenApi\Serialization\PipeDelimitedStyleParametersSerializerTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Text.Json.Nodes;
using Microsoft.SemanticKernel.Plugins.OpenApi;
using Xunit;

namespace SemanticKernel.Functions.UnitTests.OpenApi.Serialization;

public class PipeDelimitedStyleParametersSerializerTests
{
    [Fact]
    public void ItShouldThrowExceptionForUnsupportedParameterStyle()
    {
        // Arrange
        var parameter = new RestApiParameter(name: "p1", type: "string", isRequired: false, expand: false, location: RestApiParameterLocation.Query, style: RestApiParameterStyle.Form);

        // Act & Assert
        Assert.Throws<NotSupportedException>(() => PipeDelimitedStyleParameterSerializer.Serialize(parameter, "fake-argument"));
    }

    [Theory]
    [InlineData("integer")]
    [InlineData("number")]
    [InlineData("string")]
    [InlineData("boolean")]
    [InlineData("object")]
    public void ItShouldThrowExceptionIfParameterTypeIsNotArray(string parameterType)
    {
        // Arrange
        var parameter = new RestApiParameter(name: "p1", type: parameterType, isRequired: false, expand: false, location: RestApiParameterLocation.Query, style: RestApiParameterStyle.PipeDelimited);

        // Act & Assert
        Assert.Throws<NotSupportedException>(() => PipeDelimitedStyleParameterSerializer.Serialize(parameter, "fake-argument"));
    }

    [Fact]
    public void ItShouldCreateAmpersandSeparatedParameterPerArrayItem()
    {
        // Arrange
        var parameter = new RestApiParameter(
                name: "id",
                type: "array",
                isRequired: true,
                expand: true, //Specifies to generate a separate parameter for each array item.
                location: RestApiParameterLocation.Query,
                style: RestApiParameterStyle.PipeDelimited,
                arrayItemType: "integer");

        // Act
        var result = PipeDelimitedStyleParameterSerializer.Serialize(parameter, new JsonArray(1, 2, 3));

        // Assert
        Assert.NotNull(result);

        Assert.Equal("id=1&id=2&id=3", result);
    }

    [Fact]
    public void ItShouldCreateParameterWithPipeSeparatedValuePerArrayItem()
    {
        // Arrange
        var parameter = new RestApiParameter(
                name: "id",
                type: "array",
                isRequired: true,
                expand: false, //Specify generating a parameter with pipe-separated values for each array item.
                location: RestApiParameterLocation.Query,
                style: RestApiParameterStyle.PipeDelimited,
                arrayItemType: "integer");

        // Act
        var result = PipeDelimitedStyleParameterSerializer.Serialize(parameter, new JsonArray("1", "2", "3"));

        // Assert
        Assert.NotNull(result);

        Assert.Equal("id=1|2|3", result);
    }

    [Theory]
    [InlineData(":", "%3a")]
    [InlineData("/", "%2f")]
    [InlineData("?", "%3f")]
    [InlineData("#", "%23")]
    public void ItShouldEncodeSpecialSymbolsInPipeDelimitedParameterValues(string specialSymbol, string encodedEquivalent)
    {
        // Arrange
        var parameter = new RestApiParameter(name: "id", type: "array", isRequired: false, expand: false, location: RestApiParameterLocation.Query, style: RestApiParameterStyle.PipeDelimited);

        // Act
        var result = PipeDelimitedStyleParameterSerializer.Serialize(parameter, new JsonArray(specialSymbol));

        // Assert
        Assert.NotNull(result);

        Assert.EndsWith(encodedEquivalent, result, StringComparison.Ordinal);
    }

    [Theory]
    [InlineData(":", "%3a")]
    [InlineData("/", "%2f")]
    [InlineData("?", "%3f")]
    [InlineData("#", "%23")]
    public void ItShouldEncodeSpecialSymbolsInAmpersandDelimitedParameterValues(string specialSymbol, string encodedEquivalent)
    {
        // Arrange
        var parameter = new RestApiParameter(name: "id", type: "array", isRequired: false, expand: true, location: RestApiParameterLocation.Query, style: RestApiParameterStyle.PipeDelimited);

        // Act
        var result = PipeDelimitedStyleParameterSerializer.Serialize(parameter, new JsonArray(specialSymbol));

        // Assert
        Assert.NotNull(result);

        Assert.EndsWith(encodedEquivalent, result, StringComparison.Ordinal);
    }
}


===== Functions.UnitTests\OpenApi\Serialization\SimpleStyleParametersSerializerTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Text.Json.Nodes;
using Microsoft.SemanticKernel.Plugins.OpenApi;
using Xunit;

namespace SemanticKernel.Functions.UnitTests.OpenApi.Serialization;

public class SimpleStyleParametersSerializerTests
{
    [Fact]
    public void ItShouldCreateParameterWithCommaSeparatedValuePerArrayItem()
    {
        // Arrange
        var parameter = new RestApiParameter(name: "id", type: "array", isRequired: true, expand: false, location: RestApiParameterLocation.Header, style: RestApiParameterStyle.Simple, arrayItemType: "integer");

        // Act
        var result = SimpleStyleParameterSerializer.Serialize(parameter, new JsonArray(1, 2, 3));

        // Assert
        Assert.NotNull(result);

        Assert.Equal("1,2,3", result);
    }

    [Fact]
    public void ItShouldCreateParameterWithCommaSeparatedValuePerArrayStringItem()
    {
        // Arrange
        var parameter = new RestApiParameter(name: "id", type: "array", isRequired: true, expand: false, location: RestApiParameterLocation.Header, style: RestApiParameterStyle.Simple, arrayItemType: "integer");

        // Act
        var result = SimpleStyleParameterSerializer.Serialize(parameter, new JsonArray("1", "2", "3"));

        // Assert
        Assert.NotNull(result);

        Assert.Equal("1,2,3", result);
    }

    [Fact]
    public void ItShouldCreateParameterForPrimitiveValue()
    {
        // Arrange
        var parameter = new RestApiParameter(name: "id", type: "integer", isRequired: true, expand: false, location: RestApiParameterLocation.Header, style: RestApiParameterStyle.Simple);

        // Act
        var result = SimpleStyleParameterSerializer.Serialize(parameter, "28");

        // Assert
        Assert.NotNull(result);

        Assert.Equal("28", result);
    }

    [Theory]
    [InlineData(":", ":")]
    [InlineData("/", "/")]
    [InlineData("?", "?")]
    [InlineData("#", "#")]
    public void ItShouldNotEncodeSpecialSymbolsInPrimitiveParameterValues(string specialSymbol, string expectedSymbol)
    {
        // Arrange
        var parameter = new RestApiParameter(name: "id", type: "string", isRequired: true, expand: false, location: RestApiParameterLocation.Header, style: RestApiParameterStyle.Simple);

        // Act
        var result = SimpleStyleParameterSerializer.Serialize(parameter, $"fake_query_param_value{specialSymbol}");

        // Assert
        Assert.NotNull(result);

        Assert.EndsWith(expectedSymbol, result, StringComparison.Ordinal);
    }

    [Theory]
    [InlineData(":", ":")]
    [InlineData("/", "/")]
    [InlineData("?", "?")]
    [InlineData("#", "#")]
    public void ItShouldEncodeSpecialSymbolsInCommaSeparatedParameterValues(string specialSymbol, string expectedSymbol)
    {
        // Arrange
        var parameter = new RestApiParameter(name: "id", type: "array", isRequired: true, expand: false, location: RestApiParameterLocation.Header, style: RestApiParameterStyle.Simple);

        // Act
        var result = SimpleStyleParameterSerializer.Serialize(parameter, new JsonArray(specialSymbol));

        // Assert
        Assert.NotNull(result);

        Assert.EndsWith(expectedSymbol, result, StringComparison.Ordinal);
    }
}


===== Functions.UnitTests\OpenApi\Serialization\SpaceDelimitedStyleParametersSerializerTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Text.Json.Nodes;
using Microsoft.SemanticKernel.Plugins.OpenApi;
using Xunit;

namespace SemanticKernel.Functions.UnitTests.OpenApi.Serialization;

public class SpaceDelimitedStyleParametersSerializerTests
{
    [Fact]
    public void ItShouldThrowExceptionForUnsupportedParameterStyle()
    {
        // Arrange
        var parameter = new RestApiParameter(name: "p1", type: "string", isRequired: false, expand: false, location: RestApiParameterLocation.Query, style: RestApiParameterStyle.Label);

        // Act & Assert
        Assert.Throws<NotSupportedException>(() => SpaceDelimitedStyleParameterSerializer.Serialize(parameter, "fake-argument"));
    }

    [Theory]
    [InlineData("integer")]
    [InlineData("number")]
    [InlineData("string")]
    [InlineData("boolean")]
    [InlineData("object")]
    public void ItShouldThrowExceptionIfParameterTypeIsNotArray(string parameterType)
    {
        // Arrange
        var parameter = new RestApiParameter(name: "p1", type: parameterType, isRequired: false, expand: false, location: RestApiParameterLocation.Query, style: RestApiParameterStyle.SpaceDelimited);

        // Act & Assert
        Assert.Throws<NotSupportedException>(() => SpaceDelimitedStyleParameterSerializer.Serialize(parameter, "fake-argument"));
    }

    [Fact]
    public void ItShouldCreateAmpersandSeparatedParameterPerArrayItem()
    {
        // Arrange
        var parameter = new RestApiParameter(
                name: "id",
                type: "array",
                isRequired: true,
                expand: true, //Specifies to generate a separate parameter for each array item.
                location: RestApiParameterLocation.Query,
                style: RestApiParameterStyle.SpaceDelimited,
                arrayItemType: "integer");

        // Act
        var result = SpaceDelimitedStyleParameterSerializer.Serialize(parameter, new JsonArray("1", "2", "3"));

        // Assert
        Assert.NotNull(result);

        Assert.Equal("id=1&id=2&id=3", result);
    }

    [Fact]
    public void ItShouldCreateParameterWithSpaceSeparatedValuePerArrayItem()
    {
        // Arrange
        var parameter = new RestApiParameter(
                name: "id",
                type: "array",
                isRequired: true,
                expand: false, //Specify generating a parameter with space-separated values for each array item.
                location: RestApiParameterLocation.Query,
                style: RestApiParameterStyle.SpaceDelimited,
                arrayItemType: "integer");

        // Act
        var result = SpaceDelimitedStyleParameterSerializer.Serialize(parameter, new JsonArray(1, 2, 3));

        // Assert
        Assert.NotNull(result);

        Assert.Equal("id=1%202%203", result);
    }

    [Theory]
    [InlineData(":", "%3a")]
    [InlineData("/", "%2f")]
    [InlineData("?", "%3f")]
    [InlineData("#", "%23")]
    public void ItShouldEncodeSpecialSymbolsInSpaceDelimitedParameterValues(string specialSymbol, string encodedEquivalent)
    {
        // Arrange
        var parameter = new RestApiParameter(name: "id", type: "array", isRequired: false, expand: false, location: RestApiParameterLocation.Query, style: RestApiParameterStyle.SpaceDelimited);

        // Act
        var result = SpaceDelimitedStyleParameterSerializer.Serialize(parameter, new JsonArray(specialSymbol));

        // Assert
        Assert.NotNull(result);

        Assert.EndsWith(encodedEquivalent, result, StringComparison.Ordinal);
    }

    [Theory]
    [InlineData(":", "%3a")]
    [InlineData("/", "%2f")]
    [InlineData("?", "%3f")]
    [InlineData("#", "%23")]
    public void ItShouldEncodeSpecialSymbolsInAmpersandDelimitedParameterValues(string specialSymbol, string encodedEquivalent)
    {
        // Arrange
        var parameter = new RestApiParameter(name: "id", type: "array", isRequired: false, expand: true, location: RestApiParameterLocation.Query, style: RestApiParameterStyle.SpaceDelimited);

        // Act
        var result = SpaceDelimitedStyleParameterSerializer.Serialize(parameter, new JsonArray(specialSymbol));

        // Assert
        Assert.NotNull(result);

        Assert.EndsWith(encodedEquivalent, result, StringComparison.Ordinal);
    }
}


===== Functions.UnitTests\OpenApi\TestPlugins\ResourcePluginsProvider.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.IO;
using System.Resources;

namespace SemanticKernel.Functions.UnitTests.OpenApi.TestPlugins;

internal static class ResourcePluginsProvider
{
    /// <summary>
    /// Loads OpenAPI document from assembly resource.
    /// </summary>
    /// <param name="resourceName">The resource name.</param>
    /// <returns>The OpenAPI document resource stream.</returns>
    public static Stream LoadFromResource(string resourceName)
    {
        var type = typeof(ResourcePluginsProvider);

        return type.Assembly.GetManifestResourceStream(type, resourceName) ??
            throw new MissingManifestResourceException($"Unable to load OpenAPI plugin from assembly resource '{resourceName}'.");
    }
}


===== Functions.UnitTests\OpenApi\TestResponses\ResourceResponseProvider.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.IO;
using System.Resources;

namespace SemanticKernel.Functions.UnitTests.OpenApi.TestResponses;

internal static class ResourceResponseProvider
{
    /// <summary>
    /// Loads OpenAPI response schema and content from assembly resource.
    /// </summary>
    /// <param name="resourceName">The resource name.</param>
    /// <returns>The OpenAPI response schema or content resource stream.</returns>
    public static string LoadFromResource(string resourceName)
    {
        var type = typeof(ResourceResponseProvider);

        var stream = type.Assembly.GetManifestResourceStream(type, resourceName) ??
            throw new MissingManifestResourceException($"Unable to load OpenAPI response from assembly resource '{resourceName}'.");

        using var reader = new StreamReader(stream);
        return reader.ReadToEnd();
    }
}


===== Functions.UnitTests\Yaml\Functions\KernelFunctionYamlTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Linq;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Connectors.OpenAI;
using Xunit;
using YamlDotNet.Serialization;
using YamlDotNet.Serialization.NamingConventions;

namespace SemanticKernel.Functions.UnitTests.Yaml;

public class KernelFunctionYamlTests
{
    private readonly ISerializer _serializer;
    private readonly Kernel _kernel;

    public KernelFunctionYamlTests()
    {
        this._kernel = new Kernel();
        this._kernel.Plugins.AddFromFunctions("p1", [KernelFunctionFactory.CreateFromMethod(() => { }, "f1")]);
        this._kernel.Plugins.AddFromFunctions("p2", [KernelFunctionFactory.CreateFromMethod(() => { }, "f2")]);
        this._kernel.Plugins.AddFromFunctions("p3", [KernelFunctionFactory.CreateFromMethod(() => { }, "f3")]);

        this._serializer = new SerializerBuilder()
            .WithNamingConvention(UnderscoredNamingConvention.Instance)
            .Build();
    }

    [Fact]
    public void ItShouldCreateFunctionFromPromptYamlWithNoExecutionSettings()
    {
        // Arrange
        // Act
        var function = KernelFunctionYaml.FromPromptYaml(YAMLNoExecutionSettings);

        // Assert
        Assert.NotNull(function);
        Assert.Equal("SayHello", function.Name);
        Assert.Equal("Say hello to the specified person using the specified language", function.Description);
        Assert.Equal(2, function.Metadata.Parameters.Count);
        //Assert.Equal(0, function.ExecutionSettings.Count);
    }

    [Fact]
    public void ItShouldCreateFunctionFromPromptYaml()
    {
        // Arrange
        // Act
        var function = KernelFunctionYaml.FromPromptYaml(YAML);

        // Assert
        Assert.NotNull(function);
        Assert.Equal("SayHello", function.Name);
        Assert.Equal("Say hello to the specified person using the specified language", function.Description);
    }

    [Fact]
    public void ItShouldCreateFunctionFromPromptYamlWithCustomExecutionSettings()
    {
        // Arrange
        // Act
        var function = KernelFunctionYaml.FromPromptYaml(YAMLWithCustomSettings);

        // Assert
        Assert.NotNull(function);
        Assert.Equal("SayHello", function.Name);
        Assert.Equal("Say hello to the specified person using the specified language", function.Description);
        Assert.Equal(2, function.Metadata.Parameters.Count);
    }

    [Fact]
    public void ItShouldSupportCreatingOpenAIExecutionSettings()
    {
        // Arrange
        var deserializer = new DeserializerBuilder()
            .WithNamingConvention(UnderscoredNamingConvention.Instance)
            .WithTypeConverter(new PromptExecutionSettingsTypeConverter())
            .Build();
        var promptFunctionModel = deserializer.Deserialize<PromptTemplateConfig>(YAML);

        // Act
        var executionSettings = OpenAIPromptExecutionSettings.FromExecutionSettings(promptFunctionModel.ExecutionSettings["service1"]);

        // Assert
        Assert.NotNull(executionSettings);
        Assert.Equal("gpt-4", executionSettings.ModelId);
        Assert.Equal(1.0, executionSettings.Temperature);
        Assert.Equal(0.0, executionSettings.TopP);
    }

    [Fact]
    public void ItShouldDeserializeAutoFunctionChoiceBehaviors()
    {
        // Act
        var promptTemplateConfig = KernelFunctionYaml.ToPromptTemplateConfig(YAML);

        // Assert
        Assert.NotNull(promptTemplateConfig?.ExecutionSettings);

        // Service with auto function choice behavior
        var executionSettings = promptTemplateConfig.ExecutionSettings["service1"];
        Assert.NotNull(executionSettings?.FunctionChoiceBehavior);

        var config = executionSettings.FunctionChoiceBehavior.GetConfiguration(new FunctionChoiceBehaviorConfigurationContext([]) { Kernel = this._kernel });
        Assert.NotNull(config);
        Assert.Equal(FunctionChoice.Auto, config.Choice);
        Assert.NotNull(config.Functions);
        Assert.Equal("p1", config.Functions.Single().PluginName);
        Assert.Equal("f1", config.Functions.Single().Name);
    }

    [Fact]
    public void ItShouldDeserializeRequiredFunctionChoiceBehaviors()
    {
        // Act
        var promptTemplateConfig = KernelFunctionYaml.ToPromptTemplateConfig(YAML);

        // Assert
        Assert.NotNull(promptTemplateConfig?.ExecutionSettings);

        // Service with required function choice behavior
        var executionSettings = promptTemplateConfig.ExecutionSettings["service2"];
        Assert.NotNull(executionSettings?.FunctionChoiceBehavior);

        var config = executionSettings.FunctionChoiceBehavior.GetConfiguration(new FunctionChoiceBehaviorConfigurationContext([]) { Kernel = this._kernel });
        Assert.NotNull(config);
        Assert.Equal(FunctionChoice.Required, config.Choice);
        Assert.NotNull(config.Functions);
        Assert.Equal("p2", config.Functions.Single().PluginName);
        Assert.Equal("f2", config.Functions.Single().Name);
    }

    [Fact]
    public void ItShouldDeserializeNoneFunctionChoiceBehaviors()
    {
        // Act
        var promptTemplateConfig = KernelFunctionYaml.ToPromptTemplateConfig(YAML);

        // Assert
        Assert.NotNull(promptTemplateConfig?.ExecutionSettings);

        // Service with none function choice behavior
        var executionSettings = promptTemplateConfig.ExecutionSettings["service3"];
        Assert.NotNull(executionSettings?.FunctionChoiceBehavior);

        var noneConfig = executionSettings.FunctionChoiceBehavior.GetConfiguration(new FunctionChoiceBehaviorConfigurationContext([]) { Kernel = this._kernel });
        Assert.NotNull(noneConfig);
        Assert.Equal(FunctionChoice.None, noneConfig.Choice);
        Assert.NotNull(noneConfig.Functions);
        Assert.Equal("p3", noneConfig.Functions.Single().PluginName);
        Assert.Equal("f3", noneConfig.Functions.Single().Name);
    }

    [Fact]
    public void ItShouldCreateFunctionWithDefaultValueOfStringType()
    {
        // Act
        var function = KernelFunctionYaml.FromPromptYaml(YAMLWithCustomSettings);

        // Assert
        Assert.NotNull(function?.Metadata?.Parameters);
        Assert.Equal("John", function?.Metadata?.Parameters[0].DefaultValue);
        Assert.Equal("English", function?.Metadata?.Parameters[1].DefaultValue);
    }

    [Fact]
    // This test checks that the logic of imposing a temporary limitation on the default value being a string is in place and works as expected.
    public void ItShouldThrowExceptionWhileCreatingFunctionWithDefaultValueOtherThanString()
    {
        string CreateYaml(object defaultValue)
        {
            var obj = new
            {
                description = "function description",
                input_variables = new[]
                {
                    new
                    {
                        name = "name",
                        description = "description",
                        @default = defaultValue,
                        isRequired = true
                    }
                }
            };

            return this._serializer.Serialize(obj);
        }

        // Act
        Assert.Throws<NotSupportedException>(() => KernelFunctionYaml.FromPromptYaml(CreateYaml(new { p1 = "v1" })));
    }

    private const string YAMLNoExecutionSettings = """
                                                    template_format: semantic-kernel
                                                    template:        Say hello world to {{$name}} in {{$language}}
                                                    description:     Say hello to the specified person using the specified language
                                                    name:            SayHello
                                                    input_variables:
                                                      - name:          name
                                                        description:   The name of the person to greet
                                                        default:       John
                                                      - name:          language
                                                        description:   The language to generate the greeting in
                                                        default: English
                                                    """;

    private const string YAML = """
                                template_format: semantic-kernel
                                template:        Say hello world to {{$name}} in {{$language}}
                                description:     Say hello to the specified person using the specified language
                                name:            SayHello
                                input_variables:
                                  - name:          name
                                    description:   The name of the person to greet
                                    default:       John
                                  - name:          language
                                    description:   The language to generate the greeting in
                                    default: English
                                execution_settings:
                                  service1:
                                    model_id:          gpt-4
                                    temperature:       1.0
                                    top_p:             0.0
                                    presence_penalty:  0.0
                                    frequency_penalty: 0.0
                                    max_tokens:        256
                                    stop_sequences:    []
                                    function_choice_behavior:
                                      type: auto
                                      functions:
                                      - p1.f1
                                  service2:
                                    model_id:          gpt-3.5
                                    temperature:       1.0
                                    top_p:             0.0
                                    presence_penalty:  0.0
                                    frequency_penalty: 0.0
                                    max_tokens:        256
                                    stop_sequences:    [ "foo", "bar", "baz" ]
                                    function_choice_behavior:
                                      type: required
                                      functions:
                                      - p2.f2
                                  service3:
                                    model_id:          gpt-3.5
                                    temperature:       1.0
                                    top_p:             0.0
                                    presence_penalty:  0.0
                                    frequency_penalty: 0.0
                                    max_tokens:        256
                                    stop_sequences:    [ "foo", "bar", "baz" ]
                                    function_choice_behavior:
                                      type: none
                                      functions:
                                      - p3.f3
                                """;

    private const string YAMLWithCustomSettings = """
                                                  template_format: semantic-kernel
                                                  template:        Say hello world to {{$name}} in {{$language}}
                                                  description:     Say hello to the specified person using the specified language
                                                  name:            SayHello
                                                  input_variables:
                                                    - name:          name
                                                      description:   The name of the person to greet
                                                      default:       John
                                                    - name:          language
                                                      description:   The language to generate the greeting in
                                                      default:       English
                                                  execution_settings:
                                                    service1:
                                                      model_id:          gpt-4
                                                      temperature:       1.0
                                                      top_p:             0.0
                                                      presence_penalty:  0.0
                                                      frequency_penalty: 0.0
                                                      max_tokens:        256
                                                      stop_sequences:    []
                                                    service2:
                                                      model_id:          random-model
                                                      temperaturex:      1.0
                                                      top_q:             0.0
                                                      rando_penalty:     0.0
                                                      max_token_count:   256
                                                      stop_sequences:    [ "foo", "bar", "baz" ]
                                                  """;
}


===== Functions.UnitTests\Yaml\Plugins\CreateKernelPluginYamlTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.IO;
using System.Linq;
using Xunit;

namespace Microsoft.SemanticKernel.Functions.UnitTests;

public sealed class PromptYamlKernelExtensionsTests : IDisposable
{
    private readonly IKernelBuilder _kernelBuilder;
    private readonly Kernel _kernel;

    private readonly string _pluginsDirectory;

    private readonly string _plugin1Name;
    private readonly string _plugin2Name;

    public PromptYamlKernelExtensionsTests()
    {
        this._kernelBuilder = Kernel.CreateBuilder();
        this._kernel = this._kernelBuilder.Build();

        this._pluginsDirectory = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString());

        this._plugin1Name = "Plugin1";
        this._plugin2Name = "Plugin2";
        string plugin1Directory = Path.Combine(this._pluginsDirectory, this._plugin1Name);
        string plugin2Directory = Path.Combine(this._pluginsDirectory, this._plugin2Name);

        try
        {
            Directory.CreateDirectory(this._pluginsDirectory);
            Directory.CreateDirectory(plugin1Directory);
            Directory.CreateDirectory(plugin2Directory);

            string yamlFile1Path = Path.Combine(plugin1Directory, $"{nameof(YAML)}.yaml");
            string yamlFile2Path = Path.Combine(plugin1Directory, $"{nameof(YAMLWithCustomSettings)}.yaml");
            string yamlFile3Path = Path.Combine(plugin2Directory, $"{nameof(YAMLNoExecutionSettings)}.yaml");

            File.WriteAllText(yamlFile1Path, YAML);
            File.WriteAllText(yamlFile2Path, YAMLWithCustomSettings);
            File.WriteAllText(yamlFile3Path, YAMLNoExecutionSettings);

            // Add .yml file to plugin2 to ensure both extensions are supported
            string ymlFile1Path = Path.Combine(plugin2Directory, $"{nameof(YAML)}.yml");

            File.WriteAllText(ymlFile1Path, YAML);
        }
        catch (Exception)
        {
            Directory.Delete(this._pluginsDirectory, true);
            throw;
        }
    }

    public void Dispose()
    {
        if (Directory.Exists(this._pluginsDirectory))
        {
            Directory.Delete(this._pluginsDirectory, true);
        }
    }

    [Fact]
    public void ItShouldCreatePluginFromPromptDirectoryYaml()
    {
        // Arrange
        // Act
        var plugins = Directory
            .EnumerateDirectories(this._pluginsDirectory)
            .Select(directory => this._kernel.CreatePluginFromPromptDirectoryYaml(directory));

        this._kernel.Plugins.AddRange(plugins);

        // Assert
        VerifyPluginCounts(this._kernel, this._plugin1Name, this._plugin2Name);
    }

    [Fact]
    public void ItShouldImportPluginFromPromptDirectoryYaml()
    {
        // Arrange
        // Act
        foreach (string directory in Directory.EnumerateDirectories(this._pluginsDirectory))
        {
            this._kernel.ImportPluginFromPromptDirectoryYaml(directory);
        }

        // Assert
        VerifyPluginCounts(this._kernel, this._plugin1Name, this._plugin2Name);
    }

    [Fact]
    public void ItShouldAddFromPromptDirectoryYaml()
    {
        // Arrange
        // Act
        foreach (string directory in Directory.EnumerateDirectories(this._pluginsDirectory))
        {
            this._kernelBuilder.Plugins.AddFromPromptDirectoryYaml(directory);
        }

        var kernel = this._kernelBuilder.Build();

        // Assert
        VerifyPluginCounts(kernel, this._plugin1Name, this._plugin2Name);
    }

    private static void VerifyPluginCounts(Kernel kernel, string expectedPlugin1, string expectedPlugin2)
    {
        Assert.NotNull(kernel.Plugins);
        Assert.Equal(2, kernel.Plugins.Count);

        Assert.NotNull(kernel.Plugins[expectedPlugin1]);
        Assert.NotNull(kernel.Plugins[expectedPlugin2]);

        Assert.Equal(2, kernel.Plugins[expectedPlugin1].Count());
        Assert.Equal(2, kernel.Plugins[expectedPlugin2].Count());
    }

    private const string YAML = """
                                template_format: semantic-kernel
                                template:        Say hello world to {{$name}} in {{$language}}
                                description:     Say hello to the specified person using the specified language
                                name:            SayHello
                                input_variables:
                                  - name:          name
                                    description:   The name of the person to greet
                                    default:       John
                                  - name:          language
                                    description:   The language to generate the greeting in
                                    default: English
                                execution_settings:
                                  service1:
                                    model_id:          gpt-4
                                    temperature:       1.0
                                    top_p:             0.0
                                    presence_penalty:  0.0
                                    frequency_penalty: 0.0
                                    max_tokens:        256
                                    stop_sequences:    []
                                    function_choice_behavior:
                                      type: auto
                                      functions:
                                      - p1.f1
                                  service2:
                                    model_id:          gpt-3.5
                                    temperature:       1.0
                                    top_p:             0.0
                                    presence_penalty:  0.0
                                    frequency_penalty: 0.0
                                    max_tokens:        256
                                    stop_sequences:    [ "foo", "bar", "baz" ]
                                    function_choice_behavior:
                                      type: required
                                      functions:
                                      - p2.f2
                                  service3:
                                    model_id:          gpt-3.5
                                    temperature:       1.0
                                    top_p:             0.0
                                    presence_penalty:  0.0
                                    frequency_penalty: 0.0
                                    max_tokens:        256
                                    stop_sequences:    [ "foo", "bar", "baz" ]
                                    function_choice_behavior:
                                      type: none
                                      functions:
                                      - p3.f3
                                """;
    private const string YAMLWithCustomSettings = """
                                                  template_format: semantic-kernel
                                                  template:        Say hello world to {{$name}} in {{$language}}
                                                  description:     Say hello to the specified person using the specified language
                                                  name:            SayHelloWithCustomSettings
                                                  input_variables:
                                                    - name:          name
                                                      description:   The name of the person to greet
                                                      default:       John
                                                    - name:          language
                                                      description:   The language to generate the greeting in
                                                      default:       English
                                                  execution_settings:
                                                    service1:
                                                      model_id:          gpt-4
                                                      temperature:       1.0
                                                      top_p:             0.0
                                                      presence_penalty:  0.0
                                                      frequency_penalty: 0.0
                                                      max_tokens:        256
                                                      stop_sequences:    []
                                                    service2:
                                                      model_id:          random-model
                                                      temperaturex:      1.0
                                                      top_q:             0.0
                                                      rando_penalty:     0.0
                                                      max_token_count:   256
                                                      stop_sequences:    [ "foo", "bar", "baz" ]
                                                  """;

    private const string YAMLNoExecutionSettings = """
                                                   template_format: semantic-kernel
                                                   template:        Say hello world to {{$name}} in {{$language}}
                                                   description:     Say hello to the specified person using the specified language
                                                   name:            SayHelloNoExecutionSettings
                                                   input_variables:
                                                     - name:          name
                                                       description:   The name of the person to greet
                                                       default:       John
                                                     - name:          language
                                                       description:   The language to generate the greeting in
                                                       default: English
                                                   """;
}


===== Functions.UnitTests\Yaml\PromptExecutionSettingsTypeConverterTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using Microsoft.SemanticKernel;
using Xunit;
using YamlDotNet.Serialization;
using YamlDotNet.Serialization.NamingConventions;

namespace SemanticKernel.Functions.UnitTests.Yaml;

/// <summary>
/// Tests for <see cref="PromptExecutionSettingsTypeConverter"/>.
/// </summary>
public sealed class PromptExecutionSettingsTypeConverterTests
{
    private readonly IDeserializer _deserializer;

    private readonly Kernel _kernel;

    public PromptExecutionSettingsTypeConverterTests()
    {
        this._deserializer = new DeserializerBuilder()
            .WithNamingConvention(UnderscoredNamingConvention.Instance)
            .WithTypeConverter(new PromptExecutionSettingsTypeConverter())
        .Build();

        this._kernel = new Kernel();
        this._kernel.Plugins.Add(GetTestPlugin());
    }

    [Fact]
    public void ItShouldCreatePromptFunctionFromYamlWithCustomModelSettings()
    {
        // Act
        var semanticFunctionConfig = this._deserializer.Deserialize<PromptTemplateConfig>(this._yaml);

        // Assert
        Assert.NotNull(semanticFunctionConfig);
        Assert.Equal("SayHello", semanticFunctionConfig.Name);
        Assert.Equal("Say hello to the specified person using the specified language", semanticFunctionConfig.Description);
        Assert.Equal(2, semanticFunctionConfig.InputVariables.Count);
        Assert.Equal("language", semanticFunctionConfig.InputVariables[1].Name);
        Assert.Equal(3, semanticFunctionConfig.ExecutionSettings.Count);
        Assert.Equal("gpt-4", semanticFunctionConfig.ExecutionSettings["service1"].ModelId);
        Assert.Equal("gpt-3.5", semanticFunctionConfig.ExecutionSettings["service2"].ModelId);
        Assert.Equal("gpt-3.5-turbo", semanticFunctionConfig.ExecutionSettings["service3"].ModelId);
    }

    [Fact]
    public void ItShouldDeserializeAutoFunctionChoiceBehaviorFromYamlWithNoFunctionsProperty()
    {
        // Arrange
        var yaml = """
            function_choice_behavior:
              type: auto
        """;

        var executionSettings = this._deserializer.Deserialize<PromptExecutionSettings>(yaml);

        // Act
        var config = executionSettings!.FunctionChoiceBehavior!.GetConfiguration(new(chatHistory: []) { Kernel = this._kernel });

        // Assert
        Assert.NotNull(config);

        Assert.Equal(FunctionChoice.Auto, config.Choice);

        Assert.True(config.AutoInvoke);

        Assert.NotNull(config?.Functions);
        Assert.Equal(3, config.Functions.Count);
        Assert.Contains(config.Functions, f => f.PluginName == "MyPlugin" && f.Name == "Function1");
        Assert.Contains(config.Functions, f => f.PluginName == "MyPlugin" && f.Name == "Function2");
        Assert.Contains(config.Functions, f => f.PluginName == "MyPlugin" && f.Name == "Function3");
    }

    [Fact]
    public void ItShouldDeserializeAutoFunctionChoiceBehaviorFromYamlWithEmptyFunctionsProperty()
    {
        // Arrange
        var yaml = """
            function_choice_behavior:
              type: auto
              functions: []
        """;

        var executionSettings = this._deserializer.Deserialize<PromptExecutionSettings>(yaml);

        // Act
        var config = executionSettings!.FunctionChoiceBehavior!.GetConfiguration(new(chatHistory: []) { Kernel = this._kernel });

        // Assert
        Assert.NotNull(config);

        Assert.Equal(FunctionChoice.Auto, config.Choice);

        Assert.True(config.AutoInvoke);

        Assert.Null(config?.Functions);
    }

    [Fact]
    public void ItShouldDeserializeAutoFunctionChoiceBehaviorFromYamlWithSpecifiedFunctionsProperty()
    {
        // Arrange
        var yaml = """
            function_choice_behavior:
              type: auto
              functions:
              - MyPlugin.Function1
              - MyPlugin.Function3
        """;

        var executionSettings = this._deserializer.Deserialize<PromptExecutionSettings>(yaml);

        // Act
        var config = executionSettings!.FunctionChoiceBehavior!.GetConfiguration(new(chatHistory: []) { Kernel = this._kernel });

        // Assert
        Assert.NotNull(config);

        Assert.Equal(FunctionChoice.Auto, config.Choice);

        Assert.True(config.AutoInvoke);

        Assert.NotNull(config?.Functions);
        Assert.Equal(2, config.Functions.Count);
        Assert.Contains(config.Functions, f => f.PluginName == "MyPlugin" && f.Name == "Function1");
        Assert.Contains(config.Functions, f => f.PluginName == "MyPlugin" && f.Name == "Function3");
    }

    [Fact]
    public void ItShouldDeserializeRequiredFunctionChoiceBehaviorFromYamlWithNoFunctionsProperty()
    {
        // Arrange
        var yaml = """
            function_choice_behavior:
              type: required
        """;

        var executionSettings = this._deserializer.Deserialize<PromptExecutionSettings>(yaml);

        // Act
        var config = executionSettings!.FunctionChoiceBehavior!.GetConfiguration(new(chatHistory: []) { Kernel = this._kernel });

        // Assert
        Assert.NotNull(config);

        Assert.Equal(FunctionChoice.Required, config.Choice);

        Assert.True(config.AutoInvoke);

        Assert.NotNull(config?.Functions);
        Assert.Equal(3, config.Functions.Count);
        Assert.Contains(config.Functions, f => f.PluginName == "MyPlugin" && f.Name == "Function1");
        Assert.Contains(config.Functions, f => f.PluginName == "MyPlugin" && f.Name == "Function2");
        Assert.Contains(config.Functions, f => f.PluginName == "MyPlugin" && f.Name == "Function3");
    }

    [Fact]
    public void ItShouldDeserializeRequiredFunctionChoiceBehaviorFromYamlWithEmptyFunctionsProperty()
    {
        // Arrange
        var yaml = """
            function_choice_behavior:
              type: required
              functions: []
        """;

        var executionSettings = this._deserializer.Deserialize<PromptExecutionSettings>(yaml);

        // Act
        var config = executionSettings!.FunctionChoiceBehavior!.GetConfiguration(new(chatHistory: []) { Kernel = this._kernel });

        // Assert
        Assert.NotNull(config);

        Assert.Equal(FunctionChoice.Required, config.Choice);

        Assert.True(config.AutoInvoke);

        Assert.Null(config?.Functions);
    }

    [Fact]
    public void ItShouldDeserializeRequiredFunctionChoiceBehaviorFromYamlWithSpecifiedFunctionsProperty()
    {
        // Arrange
        var yaml = """
            function_choice_behavior:
              type: required
              functions:
              - MyPlugin.Function1
              - MyPlugin.Function3
        """;

        var executionSettings = this._deserializer.Deserialize<PromptExecutionSettings>(yaml);

        // Act
        var config = executionSettings!.FunctionChoiceBehavior!.GetConfiguration(new(chatHistory: []) { Kernel = this._kernel });

        // Assert
        Assert.NotNull(config);

        Assert.Equal(FunctionChoice.Required, config.Choice);

        Assert.True(config.AutoInvoke);

        Assert.NotNull(config?.Functions);
        Assert.Equal(2, config.Functions.Count);
        Assert.Contains(config.Functions, f => f.PluginName == "MyPlugin" && f.Name == "Function1");
        Assert.Contains(config.Functions, f => f.PluginName == "MyPlugin" && f.Name == "Function3");
    }

    [Fact]
    public void ItShouldDeserializedNoneFunctionChoiceBehaviorFromYamlWithNoFunctionsProperty()
    {
        // Arrange
        var yaml = """
            function_choice_behavior:
              type: none
        """;

        var executionSettings = this._deserializer.Deserialize<PromptExecutionSettings>(yaml);

        // Act
        var config = executionSettings!.FunctionChoiceBehavior!.GetConfiguration(new(chatHistory: []) { Kernel = this._kernel });

        // Assert
        Assert.NotNull(config);

        Assert.Equal(FunctionChoice.None, config.Choice);

        Assert.False(config.AutoInvoke);

        Assert.NotNull(config?.Functions);
        Assert.Equal(3, config.Functions.Count);
        Assert.Contains(config.Functions, f => f.PluginName == "MyPlugin" && f.Name == "Function1");
        Assert.Contains(config.Functions, f => f.PluginName == "MyPlugin" && f.Name == "Function2");
        Assert.Contains(config.Functions, f => f.PluginName == "MyPlugin" && f.Name == "Function3");
    }

    [Fact]
    public void ItShouldDeserializedNoneFunctionChoiceBehaviorFromYamlWithEmptyFunctionsProperty()
    {
        // Arrange
        var yaml = """
            function_choice_behavior:
              type: none
              functions: []
        """;

        var executionSettings = this._deserializer.Deserialize<PromptExecutionSettings>(yaml);

        // Act
        var config = executionSettings!.FunctionChoiceBehavior!.GetConfiguration(new(chatHistory: []) { Kernel = this._kernel });

        // Assert
        Assert.NotNull(config);

        Assert.Equal(FunctionChoice.None, config.Choice);

        Assert.False(config.AutoInvoke);

        Assert.Null(config?.Functions);
    }

    [Fact]
    public void ItShouldDeserializedNoneFunctionChoiceBehaviorFromYamlWithSpecifiedFunctionsProperty()
    {
        // Arrange
        var yaml = """
            function_choice_behavior:
              type: none
              functions:
              - MyPlugin.Function1
              - MyPlugin.Function3
        """;

        var executionSettings = this._deserializer.Deserialize<PromptExecutionSettings>(yaml);

        // Act
        var config = executionSettings!.FunctionChoiceBehavior!.GetConfiguration(new(chatHistory: []) { Kernel = this._kernel });

        // Assert
        Assert.NotNull(config);

        Assert.Equal(FunctionChoice.None, config.Choice);

        Assert.False(config.AutoInvoke);

        Assert.NotNull(config?.Functions);
        Assert.Equal(2, config.Functions.Count);
        Assert.Contains(config.Functions, f => f.PluginName == "MyPlugin" && f.Name == "Function1");
        Assert.Contains(config.Functions, f => f.PluginName == "MyPlugin" && f.Name == "Function3");
    }

    [Fact]
    public void ItShouldDeserializeAutoFunctionChoiceBehaviorFromJsonWithOptions()
    {
        // Arrange
        var yaml = """
            function_choice_behavior:
              type: auto
              options:
                allow_parallel_calls: true
                allow_concurrent_invocation: true
                allow_strict_schema_adherence: true
        """;

        var executionSettings = this._deserializer.Deserialize<PromptExecutionSettings>(yaml);

        // Act
        var config = executionSettings!.FunctionChoiceBehavior!.GetConfiguration(new(chatHistory: []) { Kernel = this._kernel });

        // Assert
        Assert.True(config.Options.AllowParallelCalls);
        Assert.True(config.Options.AllowConcurrentInvocation);
        Assert.True(config.Options.AllowStrictSchemaAdherence);
    }

    [Fact]
    public void ItShouldDeserializeRequiredFunctionChoiceBehaviorFromJsonWithOptions()
    {
        // Arrange
        var yaml = """
            function_choice_behavior:
              type: required
              options:
                allow_parallel_calls: true
                allow_concurrent_invocation: true
                allow_strict_schema_adherence: true
        """;

        var executionSettings = this._deserializer.Deserialize<PromptExecutionSettings>(yaml);

        // Act
        var config = executionSettings!.FunctionChoiceBehavior!.GetConfiguration(new(chatHistory: []) { Kernel = this._kernel });

        // Assert
        Assert.True(config.Options.AllowParallelCalls);
        Assert.True(config.Options.AllowConcurrentInvocation);
        Assert.True(config.Options.AllowStrictSchemaAdherence);
    }

    private readonly string _yaml = """
        template_format: semantic-kernel
        template:        Say hello world to {{$name}} in {{$language}}
        description:     Say hello to the specified person using the specified language
        name:            SayHello
        input_variables:
          - name:          name
            description:   The name of the person to greet
            default:       John
          - name:          language
            description:   The language to generate the greeting in
            default:       English
        execution_settings:
          service1:
            model_id:          gpt-4
            temperature:       1.0
            top_p:             0.0
            presence_penalty:  0.0
            frequency_penalty: 0.0
            max_tokens:        256
            stop_sequences:    []
            function_choice_behavior:
              type: auto
              functions:
              - p1.f1
          service2:
            model_id:          gpt-3.5
            temperature:       1.0
            top_p:             0.0
            presence_penalty:  0.0
            frequency_penalty: 0.0
            max_tokens:        256
            stop_sequences:    [ "foo", "bar", "baz" ]
            function_choice_behavior:
              type: required
              functions:
              - p2.f2
          service3:
            model_id:          gpt-3.5-turbo
            temperature:       1.0
            top_p:             0.0
            presence_penalty:  0.0
            frequency_penalty: 0.0
            max_tokens:        256
            stop_sequences:    [ "foo", "bar", "baz" ]
            function_choice_behavior:
              type: none
              functions:
              - p3.f3
        """;

    private static KernelPlugin GetTestPlugin()
    {
        var function1 = KernelFunctionFactory.CreateFromMethod(() => { }, "Function1");
        var function2 = KernelFunctionFactory.CreateFromMethod(() => { }, "Function2");
        var function3 = KernelFunctionFactory.CreateFromMethod(() => { }, "Function3");

        return KernelPluginFactory.CreateFromFunctions("MyPlugin", [function1, function2, function3]);
    }
}


===== Functions.Yaml\KernelFunctionYaml.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using Microsoft.Extensions.Logging;
using YamlDotNet.Serialization;
using YamlDotNet.Serialization.NamingConventions;

namespace Microsoft.SemanticKernel;

/// <summary>
/// Factory methods for creating <seealso cref="KernelFunction"/> instances.
/// </summary>
public static class KernelFunctionYaml
{
    /// <summary>
    /// Creates a <see cref="KernelFunction"/> instance for a prompt function using the specified markdown text.
    /// </summary>
    /// <param name="text">YAML representation of the <see cref="PromptTemplateConfig"/> to use to create the prompt function.</param>
    /// <param name="promptTemplateFactory">
    /// The <see cref="IPromptTemplateFactory"/> to use when interpreting the prompt template configuration into a <see cref="IPromptTemplate"/>.
    /// If null, a default factory will be used.
    /// </param>
    /// <param name="loggerFactory">The <see cref="ILoggerFactory"/> to use for logging. If null, no logging will be performed.</param>
    /// <returns>The created <see cref="KernelFunction"/>.</returns>
    public static KernelFunction FromPromptYaml(
        string text,
        IPromptTemplateFactory? promptTemplateFactory = null,
        ILoggerFactory? loggerFactory = null)
    {
        PromptTemplateConfig promptTemplateConfig = ToPromptTemplateConfig(text);

        // Prevent the default value from being any type other than a string.
        // It's a temporary limitation that helps shape the public API surface
        // (changing the type of the Default property to object) now, before the release.
        // This helps avoid a breaking change while a proper solution for
        // dealing with the different deserialization outputs of JSON/YAML prompt configurations is being evaluated.
        foreach (var inputVariable in promptTemplateConfig.InputVariables)
        {
            if (inputVariable.Default is not null and not string)
            {
                throw new NotSupportedException($"Default value for input variable '{inputVariable.Name}' must be a string. " +
                        $"This is a temporary limitation; future updates are expected to remove this constraint. Prompt function - '{promptTemplateConfig.Name ?? promptTemplateConfig.Description}'.");
            }
        }

        return KernelFunctionFactory.CreateFromPrompt(
            promptTemplateConfig,
            promptTemplateFactory,
            loggerFactory);
    }

    /// <summary>
    /// Convert the given YAML text to a <see cref="PromptTemplateConfig"/> model.
    /// </summary>
    /// <param name="text">YAML representation of the <see cref="PromptTemplateConfig"/> to use to create the prompt function.</param>
    public static PromptTemplateConfig ToPromptTemplateConfig(string text)
    {
        var deserializer = new DeserializerBuilder()
            .WithNamingConvention(UnderscoredNamingConvention.Instance)
            .WithTypeConverter(new PromptExecutionSettingsTypeConverter())
            .Build();

        return deserializer.Deserialize<PromptTemplateConfig>(text);
    }
}


===== Functions.Yaml\PromptExecutionSettingsTypeConverter.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.Json.Serialization;
using YamlDotNet.Core;
using YamlDotNet.Core.Events;
using YamlDotNet.Serialization;
using YamlDotNet.Serialization.BufferedDeserialization;
using YamlDotNet.Serialization.NamingConventions;
using YamlDotNet.Serialization.ObjectFactories;

namespace Microsoft.SemanticKernel;

/// <summary>
/// Allows custom deserialization for <see cref="PromptExecutionSettings"/> from YAML prompts.
/// </summary>
internal sealed class PromptExecutionSettingsTypeConverter : IYamlTypeConverter
{
    /// <inheritdoc/>
    public bool Accepts(Type type)
    {
        return type == typeof(PromptExecutionSettings);
    }

    /// <inheritdoc/>
    public object? ReadYaml(IParser parser, Type type, ObjectDeserializer rootDeserializer)
    {
        s_deserializer ??= new DeserializerBuilder()
            .WithNamingConvention(UnderscoredNamingConvention.Instance)
            .IgnoreUnmatchedProperties() // Required to ignore the 'type' property used as type discrimination. Otherwise, the "Property 'type' not found on type '{type.FullName}'" exception is thrown.
            .WithObjectFactory(new FunctionChoiceBehaviorsObjectFactory())
            .WithTypeDiscriminatingNodeDeserializer(CreateAndRegisterTypeDiscriminatingNodeDeserializer)
            .Build();

        parser.MoveNext(); // Move to the first property  

        var executionSettings = new PromptExecutionSettings();
        while (parser.Current is not MappingEnd)
        {
            var propertyName = parser.Consume<Scalar>().Value;
            switch (propertyName)
            {
                case "model_id":
                    executionSettings.ModelId = s_deserializer.Deserialize<string>(parser);
                    break;
                case "function_choice_behavior":
                    executionSettings.FunctionChoiceBehavior = s_deserializer.Deserialize<FunctionChoiceBehavior>(parser);
                    break;
                default:
                    (executionSettings.ExtensionData ??= new Dictionary<string, object>()).Add(propertyName, s_deserializer.Deserialize<object>(parser));
                    break;
            }
        }
        parser.MoveNext(); // Move past the MappingEnd event  
        return executionSettings;
    }

    /// <inheritdoc/>
    public void WriteYaml(IEmitter emitter, object? value, Type type, ObjectSerializer serializer)
    {
        throw new NotImplementedException();
    }

    /// <summary>
    /// Creates and register a <see cref="TypeDiscriminatingNodeDeserializer" /> for polymorphic deserialization of <see cref="FunctionChoiceBehavior" />.
    /// </summary>
    /// <param name="options">The <see cref="ITypeDiscriminatingNodeDeserializerOptions" /> to configure the <see cref="TypeDiscriminatingNodeDeserializer" />.</param>
    private static void CreateAndRegisterTypeDiscriminatingNodeDeserializer(ITypeDiscriminatingNodeDeserializerOptions options)
    {
        var attributes = typeof(FunctionChoiceBehavior).GetCustomAttributes(false);

        // Getting the type discriminator property name - "type" from the JsonPolymorphicAttribute.
        var discriminatorKey = attributes.OfType<JsonPolymorphicAttribute>().Single().TypeDiscriminatorPropertyName;
        if (string.IsNullOrEmpty(discriminatorKey))
        {
            throw new InvalidOperationException("Type discriminator property name is not specified.");
        }

        var discriminatorTypeMapping = new Dictionary<string, Type>();

        // Getting FunctionChoiceBehavior subtypes and their type discriminators registered for polymorphic deserialization.
        var derivedTypeAttributes = attributes.OfType<JsonDerivedTypeAttribute>();
        foreach (var derivedTypeAttribute in derivedTypeAttributes)
        {
            var discriminator = derivedTypeAttribute.TypeDiscriminator?.ToString();
            if (string.IsNullOrEmpty(discriminator))
            {
                throw new InvalidOperationException($"Type discriminator is not specified for the {derivedTypeAttribute.DerivedType} type.");
            }

            discriminatorTypeMapping.Add(discriminator!, derivedTypeAttribute.DerivedType);
        }

        options.AddKeyValueTypeDiscriminator<FunctionChoiceBehavior>(discriminatorKey!, discriminatorTypeMapping);
    }

    /// <summary>
    /// The YamlDotNet deserializer instance.
    /// </summary>
    private static IDeserializer? s_deserializer;

    private sealed class FunctionChoiceBehaviorsObjectFactory : ObjectFactoryBase
    {
        private static DefaultObjectFactory? s_defaultFactory = null;

        public override object Create(Type type)
        {
            if (type == typeof(AutoFunctionChoiceBehavior) ||
                type == typeof(NoneFunctionChoiceBehavior) ||
                type == typeof(RequiredFunctionChoiceBehavior))
            {
                return Activator.CreateInstance(type, nonPublic: true)!;
            }

            // Use the default object factory for other types
            return (s_defaultFactory ??= new DefaultObjectFactory()).Create(type);
        }
    }
}


===== Functions.Yaml\PromptYamlKernelExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Linq;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;

namespace Microsoft.SemanticKernel;

/// <summary>
/// Class for extensions methods to define functions using prompt YAML format.
/// </summary>
public static class PromptYamlKernelExtensions
{
    #region CreateFunctionFromPromptYaml
    /// <summary>
    /// Creates a <see cref="KernelFunction"/> instance for a prompt function using the specified YAML.
    /// </summary>
    /// <param name="kernel">The <see cref="Kernel"/> containing services, plugins, and other state for use throughout the operation.</param>
    /// <param name="text">YAML representation of the <see cref="PromptTemplateConfig"/> to use to create the prompt function</param>
    /// <param name="promptTemplateFactory">
    /// The <see cref="IPromptTemplateFactory"/> to use when interpreting the prompt template configuration into a <see cref="IPromptTemplate"/>.
    /// If null, a default factory will be used.
    /// </param>
    /// <returns>The created <see cref="KernelFunction"/>.</returns>
    public static KernelFunction CreateFunctionFromPromptYaml(
        this Kernel kernel,
        string text,
        IPromptTemplateFactory? promptTemplateFactory = null)
    {
        return KernelFunctionYaml.FromPromptYaml(text, promptTemplateFactory, kernel.LoggerFactory);
    }
    #endregion

    #region CreatePluginFromDirectoryYaml
    /// <summary>Creates a plugin containing one function per YAML file in the <paramref name="pluginDirectory"/>.</summary>
    /// <remarks>
    /// <para>
    /// A plugin directory contains a set of YAML files, each representing a function in the form of a prompt.
    /// This method accepts the path of the plugin directory. Each YAML file's name is used as the function name
    /// and may contain only alphanumeric chars and underscores.
    /// </para>
    /// <code>
    /// The following directory structure, with pluginDirectory = "D:\plugins\OfficePlugin",
    /// will create a plugin with three functions:
    /// D:\plugins\
    ///     |__ OfficePlugin\                      # pluginDirectory
    ///         |__ ScheduleMeeting.yaml           #   YAML function
    ///         |__ SummarizeEmailThread.yaml      #   YAML function
    ///         |__ MergeWordAndExcelDocs.yaml     #   YAML function
    /// </code>
    /// <para>
    /// See https://github.com/microsoft/semantic-kernel/tree/main/prompt_template_samples for examples in the Semantic Kernel repository.
    /// </para>
    /// </remarks>
    /// <param name="kernel">The <see cref="Kernel"/> containing services, plugins, and other state for use throughout the operation.</param>
    /// <param name="pluginDirectory">Path to the directory containing the plugin.</param>
    /// <param name="pluginName">The name of the plugin. If null, the name is derived from the <paramref name="pluginDirectory"/> directory name.</param>
    /// <param name="promptTemplateFactory">
    /// The <see cref="IPromptTemplateFactory"/> to use when interpreting discovered prompts into <see cref="IPromptTemplate"/>s.
    /// If null, a default factory will be used.
    /// </param>
    /// <returns>A <see cref="KernelPlugin"/> containing prompt functions created from the specified directory.</returns>
    [RequiresUnreferencedCode("Uses reflection to handle various aspects of the function creation and invocation, making it incompatible with AOT scenarios.")]
    [RequiresDynamicCode("Uses reflection to handle various aspects of the function creation and invocation, making it incompatible with AOT scenarios.")]
    public static KernelPlugin CreatePluginFromPromptDirectoryYaml(
        this Kernel kernel,
        string pluginDirectory,
        string? pluginName = null,
        IPromptTemplateFactory? promptTemplateFactory = null)
    {
        Verify.NotNull(kernel);

        return CreatePluginFromPromptDirectoryYaml(pluginDirectory, pluginName, promptTemplateFactory, kernel.Services);
    }

    /// <summary>Creates a plugin containing one function per YAML file in the <paramref name="pluginDirectory"/>.</summary>
    [RequiresUnreferencedCode("Uses reflection to handle various aspects of the function creation and invocation, making it incompatible with AOT scenarios.")]
    [RequiresDynamicCode("Uses reflection to handle various aspects of the function creation and invocation, making it incompatible with AOT scenarios.")]
    private static KernelPlugin CreatePluginFromPromptDirectoryYaml(
        string pluginDirectory,
        string? pluginName = null,
        IPromptTemplateFactory? promptTemplateFactory = null,
        IServiceProvider? services = null)
    {
        Verify.DirectoryExists(pluginDirectory);
        pluginName ??= new DirectoryInfo(pluginDirectory).Name;

        ILoggerFactory loggerFactory = services?.GetService<ILoggerFactory>() ?? NullLoggerFactory.Instance;

        var functions = new List<KernelFunction>();
        ILogger logger = loggerFactory.CreateLogger(typeof(Kernel)) ?? NullLogger.Instance;

        var functionFiles = Directory.GetFiles(pluginDirectory, "*.yaml").Concat(Directory.GetFiles(pluginDirectory, "*.yml"));

        foreach (string functionFile in functionFiles)
        {
            var functionName = Path.GetFileName(functionFile);
            var functionYaml = File.ReadAllText(functionFile);

            if (logger.IsEnabled(LogLevel.Trace))
            {
                logger.LogTrace("Registering function {0}.{1} loaded from {2}", pluginName, functionName, functionFile);
            }

            functions.Add(KernelFunctionYaml.FromPromptYaml(functionYaml, promptTemplateFactory, loggerFactory));
        }

        return KernelPluginFactory.CreateFromFunctions(pluginName, null, functions);
    }
    #endregion

    #region ImportPlugin/AddFromPromptDirectoryYaml
    /// <summary>Creates a plugin containing one function per YAML file in the <paramref name="pluginDirectory"/>.</summary>
    /// and imports it into the <paramref name="kernel"/>'s plugin collection.
    /// <remarks>
    /// <para>
    /// A plugin directory contains a set of YAML files, each representing a function in the form of a prompt.
    /// This method accepts the path of the plugin directory. Each YAML file's name is used as the function name
    /// and may contain only alphanumeric chars and underscores.
    /// </para>
    /// <code>
    /// The following directory structure, with pluginDirectory = "D:\plugins\OfficePlugin",
    /// will create a plugin with three functions:
    /// D:\plugins\
    ///     |__ OfficePlugin\                      # pluginDirectory
    ///         |__ ScheduleMeeting.yaml           #   YAML function
    ///         |__ SummarizeEmailThread.yaml      #   YAML function
    ///         |__ MergeWordAndExcelDocs.yaml     #   YAML function
    /// </code>
    /// <para>
    /// See https://github.com/microsoft/semantic-kernel/tree/main/prompt_template_samples for examples in the Semantic Kernel repository.
    /// </para>
    /// </remarks>
    /// <param name="kernel">The <see cref="Kernel"/> containing services, plugins, and other state for use throughout the operation.</param>
    /// <param name="pluginDirectory">Path to the directory containing the plugin.</param>
    /// <param name="pluginName">The name of the plugin. If null, the name is derived from the <paramref name="pluginDirectory"/> directory name.</param>
    /// <param name="promptTemplateFactory">
    /// The <see cref="IPromptTemplateFactory"/> to use when interpreting discovered prompts into <see cref="IPromptTemplate"/>s.
    /// If null, a default factory will be used.
    /// </param>
    /// <returns>A <see cref="KernelPlugin"/> containing prompt functions created from the specified directory.</returns>
    [RequiresUnreferencedCode("Uses reflection to handle various aspects of the function creation and invocation, making it incompatible with AOT scenarios.")]
    [RequiresDynamicCode("Uses reflection to handle various aspects of the function creation and invocation, making it incompatible with AOT scenarios.")]
    public static KernelPlugin ImportPluginFromPromptDirectoryYaml(
        this Kernel kernel,
        string pluginDirectory,
        string? pluginName = null,
        IPromptTemplateFactory? promptTemplateFactory = null)
    {
        KernelPlugin plugin = CreatePluginFromPromptDirectoryYaml(kernel, pluginDirectory, pluginName, promptTemplateFactory);
        kernel.Plugins.Add(plugin);
        return plugin;
    }
    #endregion

    /// <summary>Creates a plugin containing one function per YAML file in the <paramref name="pluginDirectory"/>.</summary>
    /// and adds it into the plugin collection.
    /// <remarks>
    /// <para>
    /// A plugin directory contains a set of YAML files, each representing a function in the form of a prompt.
    /// This method accepts the path of the plugin directory. Each YAML file's name is used as the function name
    /// and may contain only alphanumeric chars and underscores.
    /// </para>
    /// <code>
    /// The following directory structure, with pluginDirectory = "D:\plugins\OfficePlugin",
    /// will create a plugin with three functions:
    /// D:\plugins\
    ///     |__ OfficePlugin\                      # pluginDirectory
    ///         |__ ScheduleMeeting.yaml           #   YAML function
    ///         |__ SummarizeEmailThread.yaml      #   YAML function
    ///         |__ MergeWordAndExcelDocs.yaml     #   YAML function
    /// </code>
    /// <para>
    /// See https://github.com/microsoft/semantic-kernel/tree/main/prompt_template_samples for examples in the Semantic Kernel repository.
    /// </para>
    /// </remarks>
    /// <param name="plugins">The plugin collection to which the new plugin should be added.</param>
    /// <param name="pluginDirectory">Path to the directory containing the plugin.</param>
    /// <param name="pluginName">The name of the plugin. If null, the name is derived from the <paramref name="pluginDirectory"/> directory name.</param>
    /// <param name="promptTemplateFactory">
    /// The <see cref="IPromptTemplateFactory"/> to use when interpreting discovered prompts into <see cref="IPromptTemplate"/>s.
    /// If null, a default factory will be used.
    /// </param>
    /// <returns>A <see cref="KernelPlugin"/> containing prompt functions created from the specified directory.</returns>
    [RequiresUnreferencedCode("Uses reflection to handle various aspects of the function creation and invocation, making it incompatible with AOT scenarios.")]
    [RequiresDynamicCode("Uses reflection to handle various aspects of the function creation and invocation, making it incompatible with AOT scenarios.")]
    public static IKernelBuilderPlugins AddFromPromptDirectoryYaml(
        this IKernelBuilderPlugins plugins,
        string pluginDirectory,
        string? pluginName = null,
        IPromptTemplateFactory? promptTemplateFactory = null)
    {
        Verify.NotNull(plugins);

        plugins.Services.AddSingleton<KernelPlugin>(services =>
            CreatePluginFromPromptDirectoryYaml(pluginDirectory, pluginName, promptTemplateFactory, services));

        return plugins;
    }
}


