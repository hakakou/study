
===== A2A\A2AAgent.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using A2A;
using Microsoft.SemanticKernel.ChatCompletion;

namespace Microsoft.SemanticKernel.Agents.A2A;

/// <summary>
/// Provides a specialized <see cref="Agent"/> based on the A2A Protocol.
/// </summary>
public sealed class A2AAgent : Agent
{
    /// <summary>
    /// Initializes a new instance of the <see cref="A2AAgent"/> class.
    /// </summary>
    /// <param name="client"><see cref="A2AClient"/> instance to associate with the agent.</param>
    /// <param name="agentCard"><see cref="AgentCard"/> instance associated ith the agent.</param>
    public A2AAgent(A2AClient client, AgentCard agentCard)
    {
        Verify.NotNull(client);
        Verify.NotNull(agentCard);

        this.Client = client;
        this.AgentCard = agentCard;
        this.Name = agentCard.Name;
        this.Description = agentCard.Description;
    }

    /// <summary>
    /// The associated client.
    /// </summary>
    public A2AClient Client { get; }

    /// <summary>
    /// The associated agent card.
    /// </summary>
    public AgentCard AgentCard { get; }

    /// <inheritdoc/>
    public override async IAsyncEnumerable<AgentResponseItem<ChatMessageContent>> InvokeAsync(ICollection<ChatMessageContent> messages, AgentThread? thread = null, AgentInvokeOptions? options = null, [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        Verify.NotNull(messages);

        var agentThread = await this.EnsureThreadExistsWithMessagesAsync(
            messages,
            thread,
            () => new A2AAgentThread(this.Client),
            cancellationToken).ConfigureAwait(false);

        // Invoke the agent.
        var invokeResults = this.InternalInvokeAsync(
            this.AgentCard.Name,
            messages,
            agentThread,
            options ?? new AgentInvokeOptions(),
            cancellationToken);

        // Notify the thread of new messages and return them to the caller.
        await foreach (var result in invokeResults.ConfigureAwait(false))
        {
            await this.NotifyThreadOfNewMessage(agentThread, result, cancellationToken).ConfigureAwait(false);
            yield return new(result, agentThread);
        }
    }

    /// <inheritdoc/>
    public override async IAsyncEnumerable<AgentResponseItem<StreamingChatMessageContent>> InvokeStreamingAsync(ICollection<ChatMessageContent> messages, AgentThread? thread = null, AgentInvokeOptions? options = null, [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        Verify.NotNull(messages);

        var agentThread = await this.EnsureThreadExistsWithMessagesAsync(
            messages,
            thread,
            () => new A2AAgentThread(this.Client),
            cancellationToken).ConfigureAwait(false);

        // Invoke the agent.
        var chatMessages = new ChatHistory();
        var invokeResults = this.InternalInvokeStreamingAsync(
            messages,
            agentThread,
            options ?? new AgentInvokeOptions(),
            chatMessages,
            cancellationToken);

        // Return the chunks to the caller.
        await foreach (var result in invokeResults.ConfigureAwait(false))
        {
            yield return new(result, agentThread);
        }

        // Notify the thread of any new messages that were assembled from the streaming response.
        foreach (var chatMessage in chatMessages)
        {
            await this.NotifyThreadOfNewMessage(agentThread, chatMessage, cancellationToken).ConfigureAwait(false);

            if (options?.OnIntermediateMessage is not null)
            {
                await options.OnIntermediateMessage(chatMessage).ConfigureAwait(false);
            }
        }
    }

    /// <inheritdoc/>
    protected override Task<AgentChannel> CreateChannelAsync(CancellationToken cancellationToken)
    {
        throw new NotSupportedException($"{nameof(A2AAgent)} is not for use with {nameof(AgentChat)}.");
    }

    /// <inheritdoc/>
    protected override IEnumerable<string> GetChannelKeys()
    {
        throw new NotSupportedException($"{nameof(A2AAgent)} is not for use with {nameof(AgentChat)}.");
    }

    /// <inheritdoc/>
    protected override Task<AgentChannel> RestoreChannelAsync(string channelState, CancellationToken cancellationToken)
    {
        throw new NotSupportedException($"{nameof(A2AAgent)} is not for use with {nameof(AgentChat)}.");
    }

    #region private
    private async IAsyncEnumerable<AgentResponseItem<ChatMessageContent>> InternalInvokeAsync(string name, ICollection<ChatMessageContent> messages, A2AAgentThread thread, AgentInvokeOptions options, [EnumeratorCancellation] CancellationToken cancellationToken)
    {
        Verify.NotNull(messages);

        // Ensure all messages have the correct role.
        if (!messages.All(m => m.Role == AuthorRole.User))
        {
            throw new ArgumentException($"All messages must have the role {AuthorRole.User}.", nameof(messages));
        }

        // Send all messages to the remote agent in a single request.
        await foreach (var result in this.InvokeAgentAsync(messages, thread, options, cancellationToken).ConfigureAwait(false))
        {
            await this.NotifyThreadOfNewMessage(thread, result, cancellationToken).ConfigureAwait(false);
            yield return new(result, thread);
        }
    }

    private async IAsyncEnumerable<AgentResponseItem<ChatMessageContent>> InvokeAgentAsync(ICollection<ChatMessageContent> messages, A2AAgentThread thread, AgentInvokeOptions options, [EnumeratorCancellation] CancellationToken cancellationToken)
    {
        List<Part> parts = [];
        foreach (var message in messages)
        {
            foreach (var item in message.Items)
            {
                if (item is TextContent textContent)
                {
                    parts.Add(new TextPart
                    {
                        Text = textContent.Text ?? string.Empty,
                    });
                }
                else
                {
                    throw new NotSupportedException($"Unsupported content type: {item.GetType().Name}. Only TextContent are supported.");
                }
            }
        }

        var messageSendParams = new MessageSendParams
        {
            Message = new AgentMessage
            {
                MessageId = Guid.NewGuid().ToString(),
                Role = MessageRole.User,
                Parts = parts,
            }
        };

        A2AResponse response = await this.Client.SendMessageAsync(messageSendParams, cancellationToken).ConfigureAwait(false);
        if (response is AgentTask agentTask)
        {
            if (agentTask.Artifacts != null && agentTask.Artifacts.Count > 0)
            {
                foreach (var artifact in agentTask.Artifacts)
                {
                    foreach (var part in artifact.Parts)
                    {
                        if (part is TextPart textPart)
                        {
                            yield return new AgentResponseItem<ChatMessageContent>(new ChatMessageContent(AuthorRole.Assistant, textPart.Text), thread);
                        }
                    }
                }
                Console.WriteLine();
            }
        }
        else if (response is AgentMessage messageResponse)
        {
            foreach (var part in messageResponse.Parts)
            {
                if (part is TextPart textPart)
                {
                    yield return new AgentResponseItem<ChatMessageContent>(
                        new ChatMessageContent(
                            AuthorRole.Assistant,
                            textPart.Text),
                        thread);
                }
            }
        }
        else
        {
            throw new InvalidOperationException("Unexpected response type from A2A client.");
        }
    }

    private async IAsyncEnumerable<AgentResponseItem<StreamingChatMessageContent>> InternalInvokeStreamingAsync(ICollection<ChatMessageContent> messages, A2AAgentThread thread, AgentInvokeOptions options, ChatHistory chatMessages, [EnumeratorCancellation] CancellationToken cancellationToken)
    {
        Verify.NotNull(messages);

        // Ensure all messages have the correct role.
        if (messages.Any(m => m.Role != AuthorRole.User))
        {
            throw new ArgumentException($"All messages must have the role {AuthorRole.User}.", nameof(messages));
        }

        // Send all messages to the remote agent in a single request.
        await foreach (var result in this.InvokeAgentAsync(messages, thread, options, cancellationToken).ConfigureAwait(false))
        {
            await this.NotifyThreadOfNewMessage(thread, result, cancellationToken).ConfigureAwait(false);
            yield return new(this.ToStreamingAgentResponseItem(result), thread);
        }
    }

    private AgentResponseItem<StreamingChatMessageContent> ToStreamingAgentResponseItem(AgentResponseItem<ChatMessageContent> responseItem)
    {
        var messageContent = new StreamingChatMessageContent(
            responseItem.Message.Role,
            responseItem.Message.Content,
            innerContent: responseItem.Message.InnerContent,
            modelId: responseItem.Message.ModelId,
            encoding: responseItem.Message.Encoding,
            metadata: responseItem.Message.Metadata);

        return new AgentResponseItem<StreamingChatMessageContent>(messageContent, responseItem.Thread);
    }
    #endregion
}


===== A2A\A2AAgentExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Diagnostics.CodeAnalysis;
using System.Text.Json;
using MAAI = Microsoft.Agents.AI;

namespace Microsoft.SemanticKernel.Agents.A2A;

/// <summary>
/// Exposes a Semantic Kernel Agent Framework <see cref="A2AAgent"/> as a Microsoft Agent Framework <see cref="MAAI.AIAgent"/>.
/// </summary>
public static class A2AAgentExtensions
{
    /// <summary>
    /// Exposes a Semantic Kernel Agent Framework <see cref="A2AAgent"/> as a Microsoft Agent Framework <see cref="MAAI.AIAgent"/>.
    /// </summary>
    /// <param name="a2aAgent">The Semantic Kernel <see cref="A2AAgent"/> to expose as a Microsoft Agent Framework <see cref="MAAI.AIAgent"/>.</param>
    /// <returns>The Semantic Kernel Agent Framework <see cref="Agent"/> exposed as a Microsoft Agent Framework <see cref="MAAI.AIAgent"/></returns>
    [Experimental("SKEXP0110")]
    public static MAAI.AIAgent AsAIAgent(this A2AAgent a2aAgent)
        => a2aAgent.AsAIAgent(
            () => new A2AAgentThread(a2aAgent.Client),
            (json, options) =>
            {
                var agentId = JsonSerializer.Deserialize<string>(json);
                return agentId is null ? new A2AAgentThread(a2aAgent.Client) : new A2AAgentThread(a2aAgent.Client, agentId);
            },
            (thread, options) => JsonSerializer.SerializeToElement((thread as A2AAgentThread)?.Id));
}


===== A2A\A2AAgentThread.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Threading;
using System.Threading.Tasks;
using A2A;

namespace Microsoft.SemanticKernel.Agents.A2A;

/// <summary>
/// Represents a conversation thread for an A2A agent.
/// </summary>
public sealed class A2AAgentThread : AgentThread
{
    /// <summary>
    /// Initializes a new instance of the <see cref="A2AAgentThread"/> class that resumes an existing thread.
    /// </summary>
    /// <param name="client">The agents client to use for interacting with threads.</param>
    /// <param name="id">The ID of an existing thread to resume.</param>
    public A2AAgentThread(A2AClient client, string? id = null)
    {
        Verify.NotNull(client);

        this._client = client;
        this.Id = id ?? Guid.NewGuid().ToString("N");
    }

    /// <inheritdoc />
    protected override Task<string?> CreateInternalAsync(CancellationToken cancellationToken)
    {
        return Task.FromResult<string?>(Guid.NewGuid().ToString("N"));
    }

    /// <inheritdoc />
    protected override Task DeleteInternalAsync(CancellationToken cancellationToken)
    {
        return Task.CompletedTask;
    }

    /// <inheritdoc />
    protected override Task OnNewMessageInternalAsync(ChatMessageContent newMessage, CancellationToken cancellationToken = default)
    {
        return Task.CompletedTask;
    }

    #region private
    private readonly A2AClient _client;
    #endregion
}


===== A2A\A2AHostAgent.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using A2A;

namespace Microsoft.SemanticKernel.Agents.A2A;

/// <summary>
/// Host which will attach a <see cref="A2AAgent"/> to a <see cref="ITaskManager"/>
/// </summary>
public sealed class A2AHostAgent
{
    /// <summary>
    /// Initializes a new instance of the SemanticKernelTravelAgent
    /// </summary>
    public A2AHostAgent(Agent agent, AgentCard agentCard, TaskManager? taskManager = null)
    {
        Verify.NotNull(agent);
        Verify.NotNull(agentCard);

        this.Agent = agent;
        this._agentCard = agentCard;

        this.Attach(taskManager ?? new TaskManager());
    }

    /// <summary>
    /// The associated <see cref="Agent"/>
    /// </summary>
    public Agent? Agent { get; private set; }

    /// <summary>
    /// The associated <see cref="ITaskManager"/>
    /// </summary>
    public TaskManager? TaskManager => this._taskManager;

    /// <summary>
    /// Attach the <see cref="A2AAgent"/> to the provided <see cref="ITaskManager"/>
    /// </summary>
    /// <param name="taskManager"></param>
    public void Attach(TaskManager taskManager)
    {
        Verify.NotNull(taskManager);

        this._taskManager = taskManager;
        taskManager.OnTaskCreated = this.ExecuteAgentTaskAsync;
        taskManager.OnTaskUpdated = this.ExecuteAgentTaskAsync;
        taskManager.OnAgentCardQuery = this.GetAgentCardAsync;
    }
    /// <summary>
    /// Execute the specific <see cref="AgentTask"/>
    /// </summary>
    /// <param name="task">The <see cref="AgentTask"/> to execute</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to cancel the operation</param>
    /// <exception cref="Exception"></exception>
    public async Task ExecuteAgentTaskAsync(AgentTask task, CancellationToken cancellationToken = default)
    {
        Verify.NotNull(task);
        Verify.NotNull(this.Agent);

        if (this._taskManager is null)
        {
            throw new InvalidOperationException("TaskManager must be attached before executing an agent task.");
        }

        await this._taskManager.UpdateStatusAsync(task.Id, TaskState.Working, cancellationToken: cancellationToken).ConfigureAwait(false);

        // Get message from the user
        var userMessage = task.History!.Last().Parts.First().AsTextPart().Text;

        // Get the response from the agent
        var artifact = new Artifact();
        await foreach (AgentResponseItem<ChatMessageContent> response in this.Agent.InvokeAsync(userMessage, cancellationToken: cancellationToken).ConfigureAwait(false))
        {
            var content = response.Message.Content;
            artifact.Parts.Add(new TextPart() { Text = content! });
        }

        // Return as artifacts
        await this._taskManager.ReturnArtifactAsync(task.Id, artifact, cancellationToken).ConfigureAwait(false);
        await this._taskManager.UpdateStatusAsync(task.Id, TaskState.Completed, cancellationToken: cancellationToken).ConfigureAwait(false);
    }

    /// <summary>
    /// Return the <see cref="AgentCard"/> associated with this hosted agent.
    /// </summary>
    /// <param name="agentUrl">Current URL for the agent</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to cancel the operation</param>
#pragma warning disable CA1054 // URI-like parameters should not be strings
    public async Task<AgentCard> GetAgentCardAsync(string agentUrl, CancellationToken cancellationToken)
    {
        // Ensure the URL is in the correct format
        Uri uri = new(agentUrl);
        agentUrl = $"{uri.Scheme}://{uri.Host}:{uri.Port}/";

        this._agentCard.Url = agentUrl;
        return this._agentCard;
    }
#pragma warning restore CA1054 // URI-like parameters should not be strings

    #region private
    private readonly AgentCard _agentCard;
    private TaskManager? _taskManager;
    #endregion
}


===== A2A\Extensions\AuthorRoleExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using A2A;
using Microsoft.SemanticKernel.ChatCompletion;

namespace Microsoft.SemanticKernel.Agents.A2A;

/// <summary>
/// Extensions for converting between <see cref="MessageRole"/> amd <see cref="AuthorRole"/>.
/// </summary>
internal static class AuthorRoleExtensions
{
    public static AuthorRole ToAuthorRole(this MessageRole role)
    {
        return role switch
        {
            MessageRole.User => AuthorRole.User,
            MessageRole.Agent => AuthorRole.Assistant,
            _ => throw new ArgumentOutOfRangeException(nameof(role), role, "Invalid message role")
        };
    }

    public static MessageRole ToMessageRole(this AuthorRole role)
    {
        return role.Label switch
        {
            "user" => MessageRole.User,
            "assistant" => MessageRole.Agent,
            _ => throw new ArgumentOutOfRangeException(nameof(role), role, "Invalid author role")
        };
    }
}


===== Abstractions\Agent.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.AI;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.SemanticKernel.Arguments.Extensions;
using Microsoft.SemanticKernel.ChatCompletion;

namespace Microsoft.SemanticKernel.Agents;

/// <summary>
/// Base abstraction for all Semantic Kernel agents.  An agent instance
/// may participate in one or more conversations, or <see cref="AgentChat"/>.
/// A conversation may include one or more agents.
/// </summary>
/// <remarks>
/// In addition to identity and descriptive meta-data, an <see cref="Agent"/>
/// must define its communication protocol, or <see cref="AgentChannel"/>.
/// </remarks>
public abstract class Agent
{
    /// <summary>
    /// Gets the description of the agent (optional).
    /// </summary>
    public string? Description { get; init; }

    /// <summary>
    /// Gets the identifier of the agent (optional).
    /// </summary>
    /// <value>
    /// The identifier of the agent. The default is a random GUID value, but that can be overridden.
    /// </value>
    public string Id { get; init; } = Guid.NewGuid().ToString();

    /// <summary>
    /// Gets the name of the agent (optional).
    /// </summary>
    public string? Name { get; init; }

    /// <summary>
    /// A <see cref="ILoggerFactory"/> for this <see cref="Agent"/>.
    /// </summary>
    public ILoggerFactory? LoggerFactory { get; init; }

    /// <summary>
    /// Gets the arguments for the agent instruction parameters (optional).
    /// </summary>
    /// <remarks>
    /// Also includes <see cref="PromptExecutionSettings"/>.
    /// </remarks>
    public KernelArguments? Arguments { get; init; }

    /// <summary>
    /// Gets the instructions for the agent (optional).
    /// </summary>
    public string? Instructions { get; init; }

    /// <summary>
    /// Gets the <see cref="Kernel"/> containing services, plugins, and filters for use throughout the agent lifetime.
    /// </summary>
    /// <value>
    /// The <see cref="Kernel"/> containing services, plugins, and filters for use throughout the agent lifetime. The default value is an empty Kernel, but that can be overridden.
    /// </value>
    public Kernel Kernel { get; init; } = new();

    /// <summary>
    /// This option forces the agent to clone the original kernel instance during invocation if <c>true</c>. Default is <c>false</c>.
    /// </summary>
    /// <remarks>
    /// <see cref="AIContextProvider"/> implementations that provide <see cref="AIFunction"/> instances require the
    /// kernel to be cloned during agent invocation, but cloning has the side affect of causing modifications to Kernel
    /// Data by plugins to be lost.  Cloning is therefore opt-in.
    /// </remarks>
    [Experimental("SKEXP0130")]
    public bool UseImmutableKernel { get; set; } = false;

    /// <summary>
    /// Gets or sets a prompt template based on the agent instructions.
    /// </summary>
    public IPromptTemplate? Template { get; set; }

    /// <summary>
    /// Invoke the agent with no message assuming that all required instructions are already provided to the agent or on the thread.
    /// </summary>
    /// <param name="thread">The conversation thread to continue with this invocation. If not provided, creates a new thread.</param>
    /// <param name="options">Optional parameters for agent invocation.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>An async list of response items that each contain a <see cref="ChatMessageContent"/> and an <see cref="AgentThread"/>.</returns>
    /// <remarks>
    /// To continue this thread in the future, use an <see cref="AgentThread"/> returned in one of the response items.
    /// </remarks>
    public virtual IAsyncEnumerable<AgentResponseItem<ChatMessageContent>> InvokeAsync(
        AgentThread? thread = null,
        AgentInvokeOptions? options = null,
        CancellationToken cancellationToken = default)
    {
        return this.InvokeAsync((ICollection<ChatMessageContent>)[], thread, options, cancellationToken);
    }

    /// <summary>
    /// Invoke the agent with the provided message and arguments.
    /// </summary>
    /// <param name="message">The message to pass to the agent.</param>
    /// <param name="thread">The conversation thread to continue with this invocation. If not provided, creates a new thread.</param>
    /// <param name="options">Optional parameters for agent invocation.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>An async list of response items that each contain a <see cref="ChatMessageContent"/> and an <see cref="AgentThread"/>.</returns>
    /// <remarks>
    /// <para>
    /// The provided message string will be treated as a user message.
    /// </para>
    /// <para>
    /// To continue this thread in the future, use an <see cref="AgentThread"/> returned in one of the response items.
    /// </para>
    /// </remarks>
    public virtual IAsyncEnumerable<AgentResponseItem<ChatMessageContent>> InvokeAsync(
        string message,
        AgentThread? thread = null,
        AgentInvokeOptions? options = null,
        CancellationToken cancellationToken = default)
    {
        Verify.NotNull(message);

        return this.InvokeAsync(new ChatMessageContent(AuthorRole.User, message), thread, options, cancellationToken);
    }

    /// <summary>
    /// Invoke the agent with the provided message and arguments.
    /// </summary>
    /// <param name="message">The message to pass to the agent.</param>
    /// <param name="thread">The conversation thread to continue with this invocation. If not provided, creates a new thread.</param>
    /// <param name="options">Optional parameters for agent invocation.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>An async list of response items that each contain a <see cref="ChatMessageContent"/> and an <see cref="AgentThread"/>.</returns>
    /// <remarks>
    /// To continue this thread in the future, use an <see cref="AgentThread"/> returned in one of the response items.
    /// </remarks>
    public virtual IAsyncEnumerable<AgentResponseItem<ChatMessageContent>> InvokeAsync(
        ChatMessageContent message,
        AgentThread? thread = null,
        AgentInvokeOptions? options = null,
        CancellationToken cancellationToken = default)
    {
        Verify.NotNull(message);

        return this.InvokeAsync([message], thread, options, cancellationToken);
    }

    /// <summary>
    /// Invoke the agent with the provided message and arguments.
    /// </summary>
    /// <param name="messages">The messages to pass to the agent.</param>
    /// <param name="thread">The conversation thread to continue with this invocation. If not provided, creates a new thread.</param>
    /// <param name="options">Optional parameters for agent invocation.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>An async list of response items that each contain a <see cref="ChatMessageContent"/> and an <see cref="AgentThread"/>.</returns>
    /// <remarks>
    /// To continue this thread in the future, use an <see cref="AgentThread"/> returned in one of the response items.
    /// </remarks>
    public abstract IAsyncEnumerable<AgentResponseItem<ChatMessageContent>> InvokeAsync(
        ICollection<ChatMessageContent> messages,
        AgentThread? thread = null,
        AgentInvokeOptions? options = null,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Invoke the agent with no message assuming that all required instructions are already provided to the agent or on the thread.
    /// </summary>
    /// <param name="thread">The conversation thread to continue with this invocation. If not provided, creates a new thread.</param>
    /// <param name="options">Optional parameters for agent invocation.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>An async list of response items that each contain a <see cref="ChatMessageContent"/> and an <see cref="AgentThread"/>.</returns>
    /// <remarks>
    /// To continue this thread in the future, use an <see cref="AgentThread"/> returned in one of the response items.
    /// </remarks>
    public virtual IAsyncEnumerable<AgentResponseItem<StreamingChatMessageContent>> InvokeStreamingAsync(
        AgentThread? thread = null,
        AgentInvokeOptions? options = null,
        CancellationToken cancellationToken = default)
    {
        return this.InvokeStreamingAsync((ICollection<ChatMessageContent>)[], thread, options, cancellationToken);
    }

    /// <summary>
    /// Invoke the agent with the provided message and arguments.
    /// </summary>
    /// <param name="message">The message to pass to the agent.</param>
    /// <param name="thread">The conversation thread to continue with this invocation. If not provided, creates a new thread.</param>
    /// <param name="options">Optional parameters for agent invocation.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>An async list of response items that each contain a <see cref="ChatMessageContent"/> and an <see cref="AgentThread"/>.</returns>
    /// <remarks>
    /// <para>
    /// The provided message string will be treated as a user message.
    /// </para>
    /// <para>
    /// To continue this thread in the future, use an <see cref="AgentThread"/> returned in one of the response items.
    /// </para>
    /// </remarks>
    public virtual IAsyncEnumerable<AgentResponseItem<StreamingChatMessageContent>> InvokeStreamingAsync(
        string message,
        AgentThread? thread = null,
        AgentInvokeOptions? options = null,
        CancellationToken cancellationToken = default)
    {
        Verify.NotNull(message);

        return this.InvokeStreamingAsync(new ChatMessageContent(AuthorRole.User, message), thread, options, cancellationToken);
    }

    /// <summary>
    /// Invoke the agent with the provided message and arguments.
    /// </summary>
    /// <param name="message">The message to pass to the agent.</param>
    /// <param name="thread">The conversation thread to continue with this invocation. If not provided, creates a new thread.</param>
    /// <param name="options">Optional parameters for agent invocation.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>An async list of response items that each contain a <see cref="StreamingChatMessageContent"/> and an <see cref="AgentThread"/>.</returns>
    /// <remarks>
    /// To continue this thread in the future, use an <see cref="AgentThread"/> returned in one of the response items.
    /// </remarks>
    public virtual IAsyncEnumerable<AgentResponseItem<StreamingChatMessageContent>> InvokeStreamingAsync(
        ChatMessageContent message,
        AgentThread? thread = null,
        AgentInvokeOptions? options = null,
        CancellationToken cancellationToken = default)
    {
        Verify.NotNull(message);

        return this.InvokeStreamingAsync([message], thread, options, cancellationToken);
    }

    /// <summary>
    /// Invoke the agent with the provided message and arguments.
    /// </summary>
    /// <param name="messages">The messages to pass to the agent.</param>
    /// <param name="thread">The conversation thread to continue with this invocation. If not provided, creates a new thread.</param>
    /// <param name="options">Optional parameters for agent invocation.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>An async list of response items that each contain a <see cref="StreamingChatMessageContent"/> and an <see cref="AgentThread"/>.</returns>
    /// <remarks>
    /// To continue this thread in the future, use an <see cref="AgentThread"/> returned in one of the response items.
    /// </remarks>
    public abstract IAsyncEnumerable<AgentResponseItem<StreamingChatMessageContent>> InvokeStreamingAsync(
        ICollection<ChatMessageContent> messages,
        AgentThread? thread = null,
        AgentInvokeOptions? options = null,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// The <see cref="ILogger"/> associated with this  <see cref="Agent"/>.
    /// </summary>
    protected ILogger Logger => this._logger ??= this.ActiveLoggerFactory.CreateLogger(this.GetType());

    /// <summary>
    /// Get the active logger factory, if defined; otherwise, provide the default.
    /// </summary>
    protected virtual ILoggerFactory ActiveLoggerFactory => this.LoggerFactory ?? NullLoggerFactory.Instance;

    /// <summary>
    /// Formats the system instructions for the agent.
    /// </summary>
    /// <param name="kernel">The <see cref="Kernel"/> containing services, plugins, and other state for use by the agent.</param>
    /// <param name="arguments">Optional arguments to pass to the agents's invocation, including any <see cref="PromptExecutionSettings"/>.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>The formatted system instructions for the agent.</returns>
    protected async Task<string?> RenderInstructionsAsync(Kernel kernel, KernelArguments? arguments, CancellationToken cancellationToken)
    {
        if (this.Template is null)
        {
            // Use the instructions as-is
            return this.Instructions;
        }

        var mergedArguments = this.Arguments.Merge(arguments);

        // Use the provided template as the instructions
        return await this.Template.RenderAsync(kernel, mergedArguments, cancellationToken).ConfigureAwait(false);
    }

    /// <summary>
    /// Set of keys to establish channel affinity.  Minimum expected key-set:
    /// <example>
    /// yield return typeof(YourAgentChannel).FullName;
    /// </example>
    /// </summary>
    /// <remarks>
    /// Two specific agents of the same type may each require their own channel.  This is
    /// why the channel type alone is insufficient.
    /// For example, two OpenAI Assistant agents each targeting a different Azure OpenAI endpoint
    /// would require their own channel. In this case, the endpoint could be expressed as an additional key.
    /// </remarks>
    [Experimental("SKEXP0110")]
#pragma warning disable CA1024 // Use properties where appropriate
    protected internal abstract IEnumerable<string> GetChannelKeys();
#pragma warning restore CA1024 // Use properties where appropriate

    /// <summary>
    /// Produce an <see cref="AgentChannel"/> appropriate for the agent type.
    /// </summary>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>An <see cref="AgentChannel"/> appropriate for the agent type.</returns>
    /// <remarks>
    /// Every agent conversation, or <see cref="AgentChat"/>, will establish one or more <see cref="AgentChannel"/>
    /// objects according to the specific <see cref="Agent"/> type.
    /// </remarks>
    [Experimental("SKEXP0110")]
    protected internal abstract Task<AgentChannel> CreateChannelAsync(CancellationToken cancellationToken);

    /// <summary>
    /// Produce an <see cref="AgentChannel"/> appropriate for the agent type based on the provided state.
    /// </summary>
    /// <param name="channelState">The channel state, as serialized</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>An <see cref="AgentChannel"/> appropriate for the agent type.</returns>
    /// <remarks>
    /// Every agent conversation, or <see cref="AgentChat"/>, will establish one or more <see cref="AgentChannel"/>
    /// objects according to the specific <see cref="Agent"/> type.
    /// </remarks>
    [Experimental("SKEXP0110")]
    protected internal abstract Task<AgentChannel> RestoreChannelAsync(string channelState, CancellationToken cancellationToken);

    private ILogger? _logger;

    /// <summary>
    /// Ensures that the thread exists, is of the expected type, and is active, plus adds the provided message to the thread.
    /// </summary>
    /// <typeparam name="TThreadType">The expected type of the thead.</typeparam>
    /// <param name="messages">The messages to add to the thread once it is setup.</param>
    /// <param name="thread">The thread to create if it's null, validate it's type if not null, and start if it is not active.</param>
    /// <param name="constructThread">A callback to use to construct the thread if it's null.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>An async task that completes once all update are complete.</returns>
    /// <exception cref="KernelException"></exception>
    protected virtual async Task<TThreadType> EnsureThreadExistsWithMessagesAsync<TThreadType>(
        ICollection<ChatMessageContent> messages,
        AgentThread? thread,
        Func<TThreadType> constructThread,
        CancellationToken cancellationToken)
        where TThreadType : AgentThread
    {
        if (thread is null)
        {
            thread = constructThread();
        }

        if (thread is not TThreadType concreteThreadType)
        {
            throw new KernelException($"{this.GetType().Name} currently only supports agent threads of type {typeof(TThreadType).Name}.");
        }

        // We have to explicitly call create here to ensure that the thread is created
        // before we invoke using the thread. While threads will be created when
        // notified of new messages, some agents support invoking without a message,
        // and in that case no messages will be sent in the next step.
        await thread.CreateAsync(cancellationToken).ConfigureAwait(false);

        // Notify the thread that new messages are available.
        foreach (var message in messages)
        {
            await this.NotifyThreadOfNewMessage(thread, message, cancellationToken).ConfigureAwait(false);
        }

        return concreteThreadType;
    }

    /// <summary>
    /// Notfiy the given thread that a new message is available.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Note that while all agents should notify their threads of new messages,
    /// not all threads will necessarily take action. For some treads, this may be
    /// the only way that they would know that a new message is available to be added
    /// to their history.
    /// </para>
    /// <para>
    /// For other thread types, where history is managed by the service, the thread may
    /// not need to take any action.
    /// </para>
    /// <para>
    /// Where threads manage other memory components that need access to new messages,
    /// notifying the thread will be important, even if the thread itself does not
    /// require the message.
    /// </para>
    /// </remarks>
    /// <param name="thread">The thread to notify of the new message.</param>
    /// <param name="message">The message to pass to the thread.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>An async task that completes once the notification is complete.</returns>
    protected Task NotifyThreadOfNewMessage(AgentThread thread, ChatMessageContent message, CancellationToken cancellationToken)
    {
        return thread.OnNewMessageAsync(message, cancellationToken);
    }

    /// <summary>
    /// Default formatting for additional instructions for the AI agent based on the provided context and invocation options.
    /// </summary>
    /// <param name="context">The context containing relevant information for the AI agent's operation.</param>
    /// <param name="options">Optional parameters that influence the invocation behavior. Can be <see langword="null"/>.</param>
    /// <returns>A formatted string representing the additional instructions for the AI agent.</returns>
#pragma warning disable SKEXP0130 // Type is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.
    protected static string FormatAdditionalInstructions(AIContext context, AgentInvokeOptions? options)
#pragma warning restore SKEXP0130 // Type is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.
    {
        return string.Concat(ProcessInstructions());

        IEnumerable<string> ProcessInstructions()
        {
            bool hasInstructions = false;
            if (options?.AdditionalInstructions is not null)
            {
                yield return options!.AdditionalInstructions;
                hasInstructions = true;
            }

            if (!string.IsNullOrWhiteSpace(context.Instructions))
            {
                if (hasInstructions)
                {
                    yield return Environment.NewLine;
                    yield return Environment.NewLine;
                }

                yield return context.Instructions!;
            }
        }
    }
}


===== Abstractions\AgentChannel.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;

namespace Microsoft.SemanticKernel.Agents;

/// <summary>
/// Defines the communication protocol for a particular <see cref="Agent"/> type.
/// </summary>
/// <remarks>
/// An agent provides it own <see cref="AgentChannel"/> via <see cref="Agent.CreateChannelAsync"/>.
/// </remarks>
[Experimental("SKEXP0110")]
public abstract class AgentChannel
{
    /// <summary>
    /// Gets or sets the <see cref="ILogger"/> associated with the <see cref="AgentChannel"/>.
    /// </summary>
    public ILogger Logger { get; set; } = NullLogger.Instance;

    /// <summary>
    /// Responsible for providing the serialized representation of the channel.
    /// </summary>
    protected internal abstract string Serialize();

    /// <summary>
    /// Receive the conversation messages.  Used when joining a conversation and also during each agent interaction.
    /// </summary>
    /// <param name="history">The chat history at the point the channel is created.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    protected internal abstract Task ReceiveAsync(IEnumerable<ChatMessageContent> history, CancellationToken cancellationToken = default);

    /// <summary>
    /// Reset any persistent state associated with the channel.
    /// </summary>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <remarks>
    /// The channel won't be reused; rather, it will be discarded and a new one created.
    /// </remarks>
    protected internal abstract Task ResetAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// Perform a discrete incremental interaction between a single <see cref="Agent"/> and <see cref="AgentChat"/>.
    /// </summary>
    /// <param name="agent">The agent actively interacting with the chat.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>Asynchronous enumeration of messages.</returns>
    /// <remarks>
    /// In the enumeration returned by this method, a message is considered visible if it is intended to be displayed to the user.
    /// Example of a non-visible message is function-content for functions that are automatically executed.
    /// </remarks>
    protected internal abstract IAsyncEnumerable<(bool IsVisible, ChatMessageContent Message)> InvokeAsync(
        Agent agent,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Perform a discrete incremental interaction between a single <see cref="Agent"/> and <see cref="AgentChat"/> with streaming results.
    /// </summary>
    /// <param name="agent">The agent actively interacting with the chat.</param>
    /// <param name="messages">The receiver for the completed messages generated</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>Asynchronous enumeration of streaming messages.</returns>
    protected internal abstract IAsyncEnumerable<StreamingChatMessageContent> InvokeStreamingAsync(
        Agent agent,
        IList<ChatMessageContent> messages,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Retrieve the message history specific to this channel.
    /// </summary>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>Asynchronous enumeration of messages.</returns>
    protected internal abstract IAsyncEnumerable<ChatMessageContent> GetHistoryAsync(CancellationToken cancellationToken = default);
}

/// <summary>
/// Defines the communication protocol for a particular <see cref="Agent"/> type.
/// </summary>
/// <typeparam name="TAgent">The agent type for this channel.</typeparam>
/// <remarks>
/// An agent provides it own <see cref="AgentChannel"/> via <see cref="Agent.CreateChannelAsync"/>.
/// This class is a convenience upcast to an agent for <see cref="AgentChannel{TAgent}.InvokeAsync(TAgent, CancellationToken)"/>.
/// </remarks>
[Experimental("SKEXP0110")]
public abstract class AgentChannel<TAgent> : AgentChannel where TAgent : Agent
{
    /// <summary>
    /// Process a discrete incremental interaction between a single <see cref="Agent"/> and a <see cref="AgentChat"/>.
    /// </summary>
    /// <param name="agent">The agent actively interacting with the chat.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>Asynchronous enumeration of messages.</returns>
    /// <remarks>
    /// In the enumeration returned by this method, a message is considered visible if it is intended to be displayed to the user.
    /// Example of a non-visible message is function-content for functions that are automatically executed.
    /// </remarks>
    protected internal abstract IAsyncEnumerable<(bool IsVisible, ChatMessageContent Message)> InvokeAsync(
        TAgent agent,
        CancellationToken cancellationToken = default);

    /// <inheritdoc/>
    protected internal override IAsyncEnumerable<(bool IsVisible, ChatMessageContent Message)> InvokeAsync(
        Agent agent,
        CancellationToken cancellationToken = default)
    {
        if (agent.GetType() != typeof(TAgent))
        {
            throw new KernelException($"Invalid agent channel: {typeof(TAgent).Name}/{agent.GetType().Name}");
        }

        return this.InvokeAsync((TAgent)agent, cancellationToken);
    }
    /// <summary>
    /// Process a discrete incremental interaction between a single <see cref="Agent"/> and a <see cref="AgentChat"/>.
    /// </summary>
    /// <param name="agent">The agent actively interacting with the chat.</param>
    /// <param name="messages">The receiver for the completed messages generated</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>Asynchronous enumeration of messages.</returns>
    /// <remarks>
    /// In the enumeration returned by this method, a message is considered visible if it is intended to be displayed to the user.
    /// Example of a non-visible message is function-content for functions that are automatically executed.
    /// </remarks>
    protected internal abstract IAsyncEnumerable<StreamingChatMessageContent> InvokeStreamingAsync(
        TAgent agent,
        IList<ChatMessageContent> messages,
        CancellationToken cancellationToken = default);

    /// <inheritdoc/>
    protected internal override IAsyncEnumerable<StreamingChatMessageContent> InvokeStreamingAsync(
        Agent agent,
        IList<ChatMessageContent> messages,
        CancellationToken cancellationToken = default)
    {
        if (agent.GetType() != typeof(TAgent))
        {
            throw new KernelException($"Invalid agent channel: {typeof(TAgent).Name}/{agent.GetType().Name}");
        }

        return this.InvokeStreamingAsync((TAgent)agent, messages, cancellationToken);
    }
}


===== Abstractions\AgentChat.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.SemanticKernel.Agents.Extensions;
using Microsoft.SemanticKernel.Agents.Internal;
using Microsoft.SemanticKernel.Agents.Serialization;
using Microsoft.SemanticKernel.ChatCompletion;

namespace Microsoft.SemanticKernel.Agents;

/// <summary>
/// Provides a point of interaction for one or more agents.
/// </summary>
/// <remarks>
/// <see cref="AgentChat" /> instances don't support concurrent invocation and
/// will throw an exception if concurrent activity is attempted for any public method.
/// </remarks>
[Experimental("SKEXP0110")]
public abstract class AgentChat
{
    private readonly BroadcastQueue _broadcastQueue;
    private readonly Dictionary<string, AgentChannel> _agentChannels; // Map channel hash to channel: one entry per channel.
    private readonly Dictionary<Agent, string> _channelMap; // Map agent to its channel-hash: one entry per agent.

    private int _isActive;
    private ILogger? _logger;

    /// <summary>
    /// Gets the agents participating in the chat.
    /// </summary>
    public abstract IReadOnlyList<Agent> Agents { get; }

    /// <summary>
    /// Gets a value that indicates whether a chat operation is active. Activity is defined as
    /// any execution of a public method.
    /// </summary>
    public bool IsActive => Interlocked.CompareExchange(ref this._isActive, 1, 1) > 0;

    /// <summary>
    /// Gets the <see cref="ILoggerFactory"/> associated with the <see cref="AgentChat"/>.
    /// </summary>
    public ILoggerFactory LoggerFactory { get; init; } = NullLoggerFactory.Instance;

    /// <summary>
    /// Gets the <see cref="ILogger"/> associated with this chat.
    /// </summary>
    protected ILogger Logger => this._logger ??= this.LoggerFactory.CreateLogger(this.GetType());

    /// <summary>
    /// Gets the internal history to expose it to subclasses.
    /// </summary>
    protected ChatHistory History { get; }

    /// <summary>
    /// Processes a series of interactions between the agents participating in this chat.
    /// </summary>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>An asynchronous enumeration of messages.</returns>
    public abstract IAsyncEnumerable<ChatMessageContent> InvokeAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// Processes a series of interactions between the agents participating in this chat.
    /// </summary>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>An asynchronous enumeration of messages.</returns>
    public abstract IAsyncEnumerable<StreamingChatMessageContent> InvokeStreamingAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// Retrieves the chat history.
    /// </summary>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>The message history.</returns>
    public IAsyncEnumerable<ChatMessageContent> GetChatMessagesAsync(CancellationToken cancellationToken = default) =>
        this.GetChatMessagesAsync(agent: null, cancellationToken);

    /// <summary>
    /// Retrieves the message history, either the primary history or
    /// an agent-specific version.
    /// </summary>
    /// <param name="agent">An optional agent, if requesting an agent history.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>The message history.</returns>
    /// <remarks>
    /// <see cref="AgentChat" /> instances don't support concurrent invocation and
    /// will throw exception if concurrent activity is attempted.
    /// </remarks>
    public async IAsyncEnumerable<ChatMessageContent> GetChatMessagesAsync(
        Agent? agent,
        [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        this.SetActivityOrThrow(); // Disallow concurrent access to chat history

        this.Logger.LogAgentChatGetChatMessages(nameof(GetChatMessagesAsync), agent);

        try
        {
            IAsyncEnumerable<ChatMessageContent>? messages = null;

            if (agent is null)
            {
                // Provide primary history
                messages = this.History.ToDescendingAsync();
            }
            else // else provide channel specific history
            {
                // Retrieve the requested channel, if exists, and block until channel is synchronized.
                string channelKey = this.GetAgentHash(agent);
                AgentChannel? channel = await this.SynchronizeChannelAsync(channelKey, cancellationToken).ConfigureAwait(false);
                if (channel is not null)
                {
                    messages = channel.GetHistoryAsync(cancellationToken);
                }
            }

            if (messages is not null)
            {
                await foreach (ChatMessageContent message in messages.ConfigureAwait(false))
                {
                    yield return message;
                }
            }
        }
        finally
        {
            this.ClearActivitySignal(); // Signal activity hash completed
        }
    }

    /// <summary>
    /// Appends a message to the conversation. Adding a message while an agent
    /// is active is not allowed.
    /// </summary>
    /// <param name="message">A non-system message to append to the conversation.</param>
    /// <remarks>
    /// Adding a message to the conversation requires that any active <see cref="AgentChannel"/> remains
    /// synchronized, so the message is broadcast to all channels.
    ///
    /// <see cref="AgentChat" /> instances don't support concurrent invocation and
    /// will throw exception if concurrent activity is attempted.
    /// </remarks>
    /// <exception cref="KernelException">A system message is present, and no other action is taken.</exception>
    public void AddChatMessage(ChatMessageContent message)
    {
        this.AddChatMessages([message]);
    }

    /// <summary>
    /// Appends messages to the conversation. Adding messages while an agent
    /// is active is not allowed.
    /// </summary>
    /// <param name="messages">A set of non-system messages to append to the conversation.</param>
    /// <remarks>
    /// Adding messages to the conversation requires that any active <see cref="AgentChannel"/> remains
    /// synchronized, so the messages are broadcast to all channels.
    ///
    /// <see cref="AgentChat" /> instances don't support concurrent invocation and
    /// will throw exception if concurrent activity is attempted.
    /// </remarks>
    /// <exception cref="KernelException">A system message is present, and no other action is taken.
    /// -or-
    /// The chat has current activity.</exception>
    public void AddChatMessages(IReadOnlyList<ChatMessageContent> messages)
    {
        this.SetActivityOrThrow(); // Disallow concurrent access to chat history

        for (int index = 0; index < messages.Count; ++index)
        {
            if (messages[index].Role == AuthorRole.System)
            {
                throw new KernelException($"History does not support messages with Role of {AuthorRole.System}.");
            }
        }

        this.Logger.LogAgentChatAddingMessages(nameof(AddChatMessages), messages.Count);

        try
        {
            // Append to chat history
            this.History.AddRange(messages);

            // Broadcast message to other channels (in parallel)
            // Note: Able to queue messages without synchronizing channels.
            var channelRefs = this._agentChannels.Select(kvp => new ChannelReference(kvp.Value, kvp.Key));
            this._broadcastQueue.Enqueue(channelRefs, messages);

            this.Logger.LogAgentChatAddedMessages(nameof(AddChatMessages), messages.Count);
        }
        finally
        {
            this.ClearActivitySignal(); // Signal activity hash completed
        }
    }

    /// <summary>
    /// Processes a discrete incremental interaction between a single <see cref="Agent"/> and a <see cref="AgentChat"/>.
    /// </summary>
    /// <param name="agent">The agent actively interacting with the chat.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>An asynchronous enumeration of messages.</returns>
    /// <remarks>
    /// <see cref="AgentChat" /> instances don't support concurrent invocation and
    /// will throw exception if concurrent activity is attempted.
    /// </remarks>
    protected async IAsyncEnumerable<ChatMessageContent> InvokeAgentAsync(
        Agent agent,
        [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        this.SetActivityOrThrow(); // Disallow concurrent access to chat history

        this.Logger.LogAgentChatInvokingAgent(nameof(InvokeAgentAsync), agent.GetType(), agent.Id, agent.GetDisplayName());

        try
        {
            // Get or create the required channel and block until channel is synchronized.
            // Will throw exception when propagating a processing failure.
            AgentChannel channel = await this.GetOrCreateChannelAsync(agent, cancellationToken).ConfigureAwait(false);

            // Invoke agent & process response
            List<ChatMessageContent> messages = [];

            await foreach ((bool isVisible, ChatMessageContent message) in channel.InvokeAsync(agent, cancellationToken).ConfigureAwait(false))
            {
                this.Logger.LogAgentChatInvokedAgentMessage(nameof(InvokeAgentAsync), agent.GetType(), agent.Id, agent.GetDisplayName(), message);

                messages.Add(message);

                // Add to primary history
                this.History.Add(message);

                if (isVisible)
                {
                    // Yield message to caller
                    yield return message;
                }
            }

            // Broadcast message to other channels (in parallel)
            // Note: Able to queue messages without synchronizing channels.
            var channelRefs =
                this._agentChannels
                    .Where(kvp => kvp.Value != channel)
                    .Select(kvp => new ChannelReference(kvp.Value, kvp.Key));
            this._broadcastQueue.Enqueue(channelRefs, messages);

            this.Logger.LogAgentChatInvokedAgent(nameof(InvokeAgentAsync), agent.GetType(), agent.Id, agent.GetDisplayName());
        }
        finally
        {
            this.ClearActivitySignal(); // Signal activity hash completed
        }
    }

    /// <summary>
    /// Processes a discrete incremental interaction between a single <see cref="Agent"/> and a <see cref="AgentChat"/>.
    /// </summary>
    /// <param name="agent">The agent actively interacting with the chat.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>Asynchronous enumeration of messages.</returns>
    /// <remarks>
    /// <see cref="AgentChat" /> instances don't support concurrent invocation and
    /// will throw exception if concurrent activity is attempted.
    /// </remarks>
    protected async IAsyncEnumerable<StreamingChatMessageContent> InvokeStreamingAgentAsync(
        Agent agent,
        [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        this.SetActivityOrThrow(); // Disallow concurrent access to chat history

        this.Logger.LogAgentChatInvokingAgent(nameof(InvokeAgentAsync), agent.GetType(), agent.Id, agent.GetDisplayName());

        try
        {
            // Get or create the required channel and block until channel is synchronized.
            // Will throw exception when propagating a processing failure.
            AgentChannel channel = await this.GetOrCreateChannelAsync(agent, cancellationToken).ConfigureAwait(false);

            // Invoke agent & process response
            ChatHistory messages = [];

            await foreach (StreamingChatMessageContent streamingContent in channel.InvokeStreamingAsync(agent, messages, cancellationToken).ConfigureAwait(false))
            {
                yield return streamingContent;
            }

            this.History.AddRange(messages);

            this.Logger.LogAgentChatInvokedStreamingAgentMessages(nameof(InvokeAgentAsync), agent.GetType(), agent.Id, agent.GetDisplayName(), messages);

            // Broadcast message to other channels (in parallel)
            // Note: Able to queue messages without synchronizing channels.
            var channelRefs =
                this._agentChannels
                    .Where(kvp => kvp.Value != channel)
                    .Select(kvp => new ChannelReference(kvp.Value, kvp.Key));
            this._broadcastQueue.Enqueue(channelRefs, messages);

            this.Logger.LogAgentChatInvokedAgent(nameof(InvokeAgentAsync), agent.GetType(), agent.Id, agent.GetDisplayName());
        }
        finally
        {
            this.ClearActivitySignal(); // Signal activity hash completed
        }
    }

    /// <summary>
    /// Resets the chat, clearing all history and persisted state.
    /// All agents will remain present.
    /// </summary>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    public async Task ResetAsync(CancellationToken cancellationToken = default)
    {
        this.SetActivityOrThrow(); // Disallow concurrent access to chat

        try
        {
            Task[] resetTasks = this._agentChannels.Values.Select(c => c.ResetAsync(cancellationToken)).ToArray();
            await Task.WhenAll(resetTasks).ConfigureAwait(false);
            this._agentChannels.Clear();
            this._channelMap.Clear();
            this.History.Clear();
        }
        finally
        {
            this.ClearActivitySignal();
        }
    }

    internal async Task DeserializeAsync(AgentChatState state)
    {
        if (this._agentChannels.Count > 0 || this.History.Count > 0)
        {
            throw new KernelException($"Unable to restore chat to instance of {this.GetType().Name}: Already in use.");
        }

        try
        {
            Dictionary<string, AgentChannelState> channelStateMap = state.Channels.ToDictionary(c => c.ChannelKey);
            foreach (Agent agent in this.Agents)
            {
                string channelKey = this.GetAgentHash(agent);

                if (this._agentChannels.ContainsKey(channelKey))
                {
                    continue;
                }

                AgentChannel channel = await agent.RestoreChannelAsync(channelStateMap[channelKey].ChannelState, CancellationToken.None).ConfigureAwait(false);
                this._agentChannels.Add(channelKey, channel);
                channel.Logger = this.LoggerFactory.CreateLogger(channel.GetType());
            }

            IEnumerable<ChatMessageContent>? history = JsonSerializer.Deserialize<IEnumerable<ChatMessageContent>>(state.History);
            if (history != null)
            {
                this.History.AddRange(history);
            }
        }
        catch
        {
            this._agentChannels.Clear();
            this.History.Clear();
            throw;
        }
    }

    internal AgentChatState Serialize() =>
        new()
        {
            Participants = this.Agents.Select(a => new AgentParticipant(a)),
            History = JsonSerializer.Serialize(ChatMessageReference.Prepare(this.History)),
            Channels =
                this._agentChannels.Select(
                    kvp =>
                        new AgentChannelState
                        {
                            ChannelKey = kvp.Key,
                            ChannelType = kvp.Value.GetType().FullName!,
                            ChannelState = kvp.Value.Serialize()
                        })
        };

    /// <summary>
    /// Clear activity signal to indicate that activity has ceased.
    /// </summary>
    private void ClearActivitySignal()
    {
        // Note: Interlocked is the absolute lightest synchronization mechanism available in dotnet.
        Interlocked.Exchange(ref this._isActive, 0);
    }

    /// <summary>
    /// Checks to ensure the chat is not concurrently active and throws an exception if it is.
    /// If not, activity is signaled.
    /// </summary>
    /// <remarks>
    /// Rather than allowing concurrent invocation to result in undefined behavior or failure,
    /// it's preferred to fail fast to avoid side effects or state mutation.
    /// The activity signal is used to manage ability and visibility for taking actions based
    /// on conversation history.
    /// </remarks>
    protected void SetActivityOrThrow()
    {
        // Note: Interlocked is the absolute lightest synchronization mechanism available in dotnet.
        int wasActive = Interlocked.CompareExchange(ref this._isActive, 1, 0);
        if (wasActive > 0)
        {
            throw new KernelException("Unable to proceed while another agent is active.");
        }
    }

    private string GetAgentHash(Agent agent)
    {
        if (!this._channelMap.TryGetValue(agent, out string? hash))
        {
            hash = KeyEncoder.GenerateHash(agent.GetChannelKeys());

            // Ok if already present: same agent always produces the same hash
            this._channelMap.Add(agent, hash);
        }

        return hash;
    }

    private async Task<AgentChannel> GetOrCreateChannelAsync(Agent agent, CancellationToken cancellationToken)
    {
        string channelKey = this.GetAgentHash(agent);
        AgentChannel? channel = await this.SynchronizeChannelAsync(channelKey, cancellationToken).ConfigureAwait(false);
        if (channel is null)
        {
            this.Logger.LogAgentChatCreatingChannel(nameof(InvokeAgentAsync), agent.GetType(), agent.Id, agent.GetDisplayName());

            channel = await agent.CreateChannelAsync(cancellationToken).ConfigureAwait(false);

            this._agentChannels.Add(channelKey, channel);

            if (this.History.Count > 0)
            {
                // Sync channel with existing history
                await channel.ReceiveAsync(this.History, cancellationToken).ConfigureAwait(false);
            }

            this.Logger.LogAgentChatCreatedChannel(nameof(InvokeAgentAsync), agent.GetType(), agent.Id, agent.GetDisplayName());
        }

        return channel;
    }

    private async Task<AgentChannel?> SynchronizeChannelAsync(string channelKey, CancellationToken cancellationToken)
    {
        if (this._agentChannels.TryGetValue(channelKey, out AgentChannel? channel))
        {
            await this._broadcastQueue.EnsureSynchronizedAsync(
                new ChannelReference(channel, channelKey), cancellationToken).ConfigureAwait(false);
        }

        return channel;
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AgentChat"/> class.
    /// </summary>
    protected AgentChat()
    {
        this._agentChannels = [];
        this._broadcastQueue = new();
        this._channelMap = [];
        this.History = [];
    }
}


===== Abstractions\AgentChatSerializer.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading.Tasks;
using Microsoft.SemanticKernel.Agents.Serialization;

namespace Microsoft.SemanticKernel.Agents;

/// <summary>
/// Serializes and deserializes an <see cref="AgentChat"/>.
/// </summary>
[Experimental("SKEXP0110")]
public sealed class AgentChatSerializer
{
    private readonly AgentChatState _state;

    private static readonly JsonSerializerOptions s_defaultOptions =
        new()
        {
            WriteIndented = true,
            DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingDefault,
        };

    /// <summary>
    /// Serializes the provided <see cref="AgentChat"/> to the target stream.
    /// </summary>
    public static async Task SerializeAsync<TChat>(TChat chat, Stream stream, JsonSerializerOptions? serializerOptions = null) where TChat : AgentChat
    {
        AgentChatState state = chat.Serialize();
        await JsonSerializer.SerializeAsync(stream, state, serializerOptions ?? s_defaultOptions).ConfigureAwait(false);
    }

    /// <summary>
    /// Provides a <see cref="AgentChatSerializer"/> that's able to restore an <see cref="AgentChat"/>.
    /// </summary>
    public static async Task<AgentChatSerializer> DeserializeAsync(Stream stream, JsonSerializerOptions? serializerOptions = null)
    {
        AgentChatState state =
            await JsonSerializer.DeserializeAsync<AgentChatState>(stream, serializerOptions ?? s_defaultOptions).ConfigureAwait(false) ??
            throw new KernelException("Unable to restore chat: invalid format.");

        return new AgentChatSerializer(state);
    }

    /// <summary>
    /// Gets the participants of the original <see cref="AgentChat"/> so that
    /// the caller can include them in the restored <see cref="AgentChat"/>.
    /// </summary>
    public IEnumerable<AgentParticipant> Participants => this._state.Participants;

    /// <summary>
    /// Restores the <see cref="AgentChat"/> to the previously captured state.
    /// </summary>
    public Task DeserializeAsync<TChat>(TChat chat) where TChat : AgentChat => chat.DeserializeAsync(this._state);

    private AgentChatSerializer(AgentChatState state)
    {
        this._state = state;
    }
}


===== Abstractions\AgentExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Diagnostics.CodeAnalysis;
using System.Text.Json;
using MAAI = Microsoft.Agents.AI;

namespace Microsoft.SemanticKernel.Agents;

/// <summary>
/// Exposes a Semantic Kernel Agent Framework <see cref="Agent"/> as a Microsoft Agent Framework <see cref="MAAI.AIAgent"/>.
/// </summary>
public static class AgentExtensions
{
    /// <summary>
    /// Exposes a Semantic Kernel Agent Framework <see cref="Agent"/> as a Microsoft Agent Framework <see cref="MAAI.AIAgent"/>.
    /// </summary>
    /// <param name="semanticKernelAgent">The Semantic Kernel <see cref="Agent"/> to expose as a Microsoft Agent Framework <see cref="MAAI.AIAgent"/>.</param>
    /// <param name="threadFactory">A factory method to create the required <see cref="AgentThread"/> type to use with the agent.</param>
    /// <param name="threadDeserializationFactory">A factory method to deserialize the required <see cref="AgentThread"/> type.</param>
    /// <param name="threadSerializer">A method to serialize the <see cref="AgentThread"/> type.</param>
    /// <returns>The Semantic Kernel Agent Framework <see cref="Agent"/> exposed as a Microsoft Agent Framework <see cref="MAAI.AIAgent"/></returns>
    [Experimental("SKEXP0110")]
    public static MAAI.AIAgent AsAIAgent(
        this Agent semanticKernelAgent,
        Func<AgentThread> threadFactory,
        Func<JsonElement, JsonSerializerOptions?, AgentThread> threadDeserializationFactory,
        Func<AgentThread, JsonSerializerOptions?, JsonElement> threadSerializer)
        => new SemanticKernelAIAgent(
            semanticKernelAgent,
            threadFactory,
            threadDeserializationFactory,
            threadSerializer);
}


===== Abstractions\AgentInvokeOptions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Threading.Tasks;

namespace Microsoft.SemanticKernel.Agents;

/// <summary>
/// Optional parameters for agent invocation.
/// </summary>
public class AgentInvokeOptions
{
    /// <summary>
    /// Initializes a new instance of the <see cref="AgentInvokeOptions"/> class.
    /// </summary>
    public AgentInvokeOptions()
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AgentInvokeOptions"/> class by cloning the provided options.
    /// </summary>
    /// <param name="options">The options to clone.</param>
    public AgentInvokeOptions(AgentInvokeOptions options)
    {
        Verify.NotNull(options);

        this.KernelArguments = options.KernelArguments;
        this.Kernel = options.Kernel;
        this.AdditionalInstructions = options.AdditionalInstructions;
        this.OnIntermediateMessage = options.OnIntermediateMessage;
    }

    /// <summary>
    /// Gets or sets optional arguments to pass to the agent's invocation, including any <see cref="PromptExecutionSettings"/>
    /// </summary>
    public KernelArguments? KernelArguments { get; init; } = null;

    /// <summary>
    /// Gets or sets the <see cref="Kernel"/> containing services, plugins, and other state for use by the agent
    /// </summary>
    public Kernel? Kernel { get; init; } = null;

    /// <summary>
    /// Gets or sets any instructions, in addition to those that were provided to the agent
    /// initially, that need to be added to the prompt for this invocation only.
    /// </summary>
    public string AdditionalInstructions { get; init; } = string.Empty;

    /// <summary>
    /// Gets or sets a function to be called when a complete new message is generated by the agent.
    /// </summary>
    /// <remarks>
    /// <para>
    /// This callback is particularly useful in cases where the caller wants to receive complete messages
    /// when invoking the agent with streaming.
    /// </para>
    /// </remarks>
    public Func<ChatMessageContent, Task>? OnIntermediateMessage { get; init; } = null;
}


===== Abstractions\AgentResponseItem.cs =====

// Copyright (c) Microsoft. All rights reserved.

namespace Microsoft.SemanticKernel.Agents;

/// <summary>
/// Container class that holds a <see cref="ChatMessageContent"/> or <see cref="StreamingChatMessageContent"/> and an <see cref="AgentThread"/>.
/// </summary>
public class AgentResponseItem<TMessage>
{
    private readonly TMessage _message;
    private readonly AgentThread _thread;

    /// <summary>
    /// Initializes a new instance of the <see cref="AgentResponseItem{T}"/> class.
    /// </summary>
    /// <param name="message">The chat message content.</param>
    /// <param name="thread">The conversation thread associated with the response.</param>
    public AgentResponseItem(TMessage message, AgentThread thread)
    {
        Verify.NotNull(message);
        Verify.NotNull(thread);

        this._message = message;
        this._thread = thread;
    }

    /// <summary>
    /// Gets the chat message content.
    /// </summary>
    public TMessage Message => this._message;

    /// <summary>
    /// Gets the conversation thread associated with the response.
    /// </summary>
    public AgentThread Thread => this._thread;

    /// <summary>
    /// Implicitly converts an <see cref="AgentResponseItem{T}"/> to a <see cref="ChatMessageContent"/> or <see cref="StreamingChatMessageContent"/>.
    /// </summary>
    /// <param name="responseItem"></param>
    public static implicit operator TMessage(AgentResponseItem<TMessage> responseItem) => responseItem.Message;
}


===== Abstractions\AgentThread.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Diagnostics.CodeAnalysis;
using System.Threading;
using System.Threading.Tasks;

namespace Microsoft.SemanticKernel.Agents;

/// <summary>
/// Base abstraction for all Semantic Kernel agent threads.
/// A thread represents a specific conversation with an agent.
/// </summary>
/// <remarks>
/// This class is used to manage the lifecycle of an agent thread.
/// The thread can be not-start, started or ended.
/// </remarks>
public abstract class AgentThread
{
    /// <summary>
    /// Gets the id of the current thread.
    /// </summary>
    public virtual string? Id { get; protected set; }

    /// <summary>
    /// Gets a value indicating whether the thread has been deleted.
    /// </summary>
    public virtual bool IsDeleted { get; protected set; } = false;

    /// <summary>
    /// Gets or sets the container for <see cref="AIContextProvider"/> objects that manages their lifecycle and interactions.
    /// </summary>
    [Experimental("SKEXP0110")]
    public virtual AggregateAIContextProvider AIContextProviders { get; init; } = new AggregateAIContextProvider();

    /// <summary>
    /// Called when the current conversion is temporarily suspended and any state should be saved.
    /// </summary>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>An async task.</returns>
    /// <remarks>
    /// In a service that hosts an agent, that is invoked via calls to the service, this might be at the end of each service call.
    /// In a client application, this might be when the user closes the chat window or the application.
    /// </remarks>
    [Experimental("SKEXP0110")]
    public virtual Task OnSuspendAsync(CancellationToken cancellationToken = default)
    {
        return this.AIContextProviders.SuspendingAsync(this.Id, cancellationToken);
    }

    /// <summary>
    /// Called when the current conversion is resumed and any state should be restored.
    /// </summary>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>An async task.</returns>
    /// <remarks>
    /// In a service that hosts an agent, that is invoked via calls to the service, this might be at the start of each service call where a previous conversation is being continued.
    /// In a client application, this might be when the user re-opens the chat window to resume a conversation after having previously closed it.
    /// </remarks>
    [Experimental("SKEXP0110")]
    public virtual Task OnResumeAsync(CancellationToken cancellationToken = default)
    {
        if (this.IsDeleted)
        {
            throw new InvalidOperationException("This thread has been deleted and cannot be used anymore.");
        }

        if (this.Id is null)
        {
            throw new InvalidOperationException("This thread cannot be resumed, since it has not been created.");
        }

        return this.AIContextProviders.ResumingAsync(this.Id, cancellationToken);
    }

    /// <summary>
    /// Creates the thread and returns the thread id.
    /// </summary>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>A task that completes when the thread has been created.</returns>
    /// <exception cref="InvalidOperationException">The thread has been deleted.</exception>
    protected internal virtual async Task CreateAsync(CancellationToken cancellationToken = default)
    {
        if (this.IsDeleted)
        {
            throw new InvalidOperationException("This thread has been deleted and cannot be recreated.");
        }

        if (this.Id is not null)
        {
            return;
        }

        this.Id = await this.CreateInternalAsync(cancellationToken).ConfigureAwait(false);

#pragma warning disable SKEXP0110 // Type is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.
        await this.AIContextProviders.ConversationCreatedAsync(this.Id, cancellationToken).ConfigureAwait(false);
#pragma warning restore SKEXP0110 // Type is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.
    }

    /// <summary>
    /// Deletes the current thread.
    /// </summary>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>A task that completes when the thread has been deleted.</returns>
    /// <exception cref="InvalidOperationException">The thread was never created.</exception>
    public virtual async Task DeleteAsync(CancellationToken cancellationToken = default)
    {
        if (this.IsDeleted)
        {
            return;
        }

        if (this.Id is null)
        {
            throw new InvalidOperationException("This thread cannot be deleted, since it has not been created.");
        }

#pragma warning disable SKEXP0110 // Type is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.
        await this.AIContextProviders.ConversationDeletingAsync(this.Id, cancellationToken).ConfigureAwait(false);
#pragma warning restore SKEXP0110 // Type is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.

        await this.DeleteInternalAsync(cancellationToken).ConfigureAwait(false);

        this.IsDeleted = true;
    }

    /// <summary>
    /// This method is called when a new message has been contributed to the chat by any participant.
    /// </summary>
    /// <remarks>
    /// Inheritors can use this method to update their context based on the new message.
    /// </remarks>
    /// <param name="newMessage">The new message.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>A task that completes when the context has been updated.</returns>
    /// <exception cref="InvalidOperationException">The thread has been deleted.</exception>
    internal virtual async Task OnNewMessageAsync(ChatMessageContent newMessage, CancellationToken cancellationToken = default)
    {
        if (this.IsDeleted)
        {
            throw new InvalidOperationException("This thread has been deleted and cannot be used anymore.");
        }

        if (this.Id is null)
        {
            await this.CreateAsync(cancellationToken).ConfigureAwait(false);
        }

#pragma warning disable SKEXP0110 // Type is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.
        await this.AIContextProviders.MessageAddingAsync(this.Id, newMessage, cancellationToken).ConfigureAwait(false);
#pragma warning restore SKEXP0110 // Type is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.

        await this.OnNewMessageInternalAsync(newMessage, cancellationToken).ConfigureAwait(false);
    }

    /// <summary>
    /// Creates the thread and returns the thread id.
    /// Checks have already been completed in the <see cref="CreateAsync"/> method to ensure that the thread can be created.
    /// </summary>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>The id of the thread that was created if one is available.</returns>
    protected abstract Task<string?> CreateInternalAsync(CancellationToken cancellationToken);

    /// <summary>
    /// Deletes the current thread.
    /// Checks have already been completed in the <see cref="DeleteAsync"/> method to ensure that the thread can be deleted.
    /// </summary>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>A task that completes when the thread has been deleted.</returns>
    protected abstract Task DeleteInternalAsync(CancellationToken cancellationToken);

    /// <summary>
    /// This method is called when a new message has been contributed to the chat by any participant.
    /// Checks have already been completed in the <see cref="OnNewMessageAsync"/> method to ensure that the thread can be updated.
    /// </summary>
    /// <param name="newMessage">The new message.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>A task that completes when the context has been updated.</returns>
    protected abstract Task OnNewMessageInternalAsync(ChatMessageContent newMessage, CancellationToken cancellationToken = default);
}


===== Abstractions\AgentThreadOperationException.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;

namespace Microsoft.SemanticKernel.Agents;

/// <summary>
/// Defines an exception that's thrown when an operation on an <see cref="AgentThread"/> fails, such as creating or deleting the thread.
/// </summary>
public class AgentThreadOperationException : KernelException
{
    /// <summary>
    /// Initializes a new instance of the <see cref="AgentThreadOperationException"/> class.
    /// </summary>
    public AgentThreadOperationException()
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AgentThreadOperationException"/> class with a specified error message.
    /// </summary>
    /// <param name="message">The error message that explains the reason for the exception.</param>
    public AgentThreadOperationException(string? message) : base(message)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AgentThreadOperationException"/> class with a specified error message and a reference to the inner exception that is the cause of this exception.
    /// </summary>
    /// <param name="message">The error message that explains the reason for the exception.</param>
    /// <param name="innerException">The exception that is the cause of the current exception, or a null reference if no inner exception is specified.</param>
    public AgentThreadOperationException(string? message, Exception? innerException) : base(message, innerException)
    {
    }
}


===== Abstractions\AggregatorAgent.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.SemanticKernel.Agents.Serialization;

namespace Microsoft.SemanticKernel.Agents;

/// <summary>
/// Defines the relationship between the internal aggregated chat and the chat
/// with which <see cref="AggregatorAgent"/> is participating.
/// </summary>
[Experimental("SKEXP0110")]
public enum AggregatorMode
{
    /// <summary>
    /// A flat embedding of the aggregated chat within another chat.
    /// </summary>
    Flat,

    /// <summary>
    /// A nested embedding the aggregated chat within another chat.
    /// </summary>
    Nested,
}

/// <summary>
/// Allows an <see cref="AgentChat"/> to participate in another <see cref="AgentChat"/> as an <see cref="Agent"/>.
/// </summary>
/// <param name="chatProvider">A factory method that produces a new <see cref="AgentChat"/> instance.</param>
[Experimental("SKEXP0110")]
public sealed class AggregatorAgent(Func<AgentChat> chatProvider) : Agent
{
    /// <summary>
    /// Gets the relationship between the internal aggregated chat and the chat
    /// with which <see cref="AggregatorAgent"/> is participating.
    /// </summary>
    /// <value>
    /// The relationship between the internal aggregated chat and the chat
    /// with which <see cref="AggregatorAgent"/> is participating. The default value is <see cref="AggregatorMode.Flat"/>.
    /// </value>
    public AggregatorMode Mode { get; init; } = AggregatorMode.Flat;

    /// <inheritdoc/>
    public override IAsyncEnumerable<AgentResponseItem<ChatMessageContent>> InvokeAsync(
        ICollection<ChatMessageContent> messages,
        AgentThread? thread = null,
        AgentInvokeOptions? options = null,
        CancellationToken cancellationToken = default)
    {
        // TODO: Need to determine the correct approach here.
        throw new NotImplementedException();
    }

    /// <inheritdoc/>
    public override IAsyncEnumerable<AgentResponseItem<StreamingChatMessageContent>> InvokeStreamingAsync(
        ICollection<ChatMessageContent> messages,
        AgentThread? thread = null,
        AgentInvokeOptions? options = null,
        CancellationToken cancellationToken = default)
    {
        // TODO: Need to determine the correct approach here.
        throw new NotImplementedException();
    }

    /// <inheritdoc/>
    /// <remarks>
    /// Different <see cref="AggregatorAgent"/> instances will never share the same channel.
    /// </remarks>
    protected internal override IEnumerable<string> GetChannelKeys()
    {
        yield return typeof(AggregatorChannel).FullName!;
        yield return this.Name ?? this.Id;
    }

    /// <inheritdoc/>
    protected internal override Task<AgentChannel> CreateChannelAsync(CancellationToken cancellationToken)
    {
        this.Logger.LogAggregatorAgentCreatingChannel(nameof(CreateChannelAsync), nameof(AggregatorChannel));

        AgentChat chat = chatProvider.Invoke();
        AggregatorChannel channel = new(chat);

        this.Logger.LogAggregatorAgentCreatedChannel(nameof(CreateChannelAsync), nameof(AggregatorChannel), this.Mode, chat.GetType());

        return Task.FromResult<AgentChannel>(channel);
    }

    /// <inheritdoc/>
    protected internal async override Task<AgentChannel> RestoreChannelAsync(string channelState, CancellationToken cancellationToken)
    {
        this.Logger.LogOpenAIAssistantAgentRestoringChannel(nameof(CreateChannelAsync), nameof(AggregatorChannel));

        AgentChat chat = chatProvider.Invoke();
        AgentChatState agentChatState =
            JsonSerializer.Deserialize<AgentChatState>(channelState) ??
            throw new KernelException("Unable to restore channel: invalid state.");

        await chat.DeserializeAsync(agentChatState).ConfigureAwait(false); ;
        AggregatorChannel channel = new(chat);

        this.Logger.LogOpenAIAssistantAgentRestoredChannel(nameof(CreateChannelAsync), nameof(AggregatorChannel));

        return channel;
    }
}


===== Abstractions\AggregatorChannel.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;

namespace Microsoft.SemanticKernel.Agents;

/// <summary>
/// Adapt channel contract to underlying <see cref="AgentChat"/>.
/// </summary>
[Experimental("SKEXP0110")]
internal sealed class AggregatorChannel(AgentChat chat) : AgentChannel<AggregatorAgent>
{
    private readonly AgentChat _chat = chat;

    /// <inheritdoc/>
    protected internal override IAsyncEnumerable<ChatMessageContent> GetHistoryAsync(CancellationToken cancellationToken = default)
    {
        return this._chat.GetChatMessagesAsync(cancellationToken);
    }

    /// <inheritdoc/>
    protected internal override async IAsyncEnumerable<(bool IsVisible, ChatMessageContent Message)> InvokeAsync(AggregatorAgent agent, [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        ChatMessageContent? lastMessage = null;

        await foreach (ChatMessageContent message in this._chat.InvokeAsync(cancellationToken).ConfigureAwait(false))
        {
            // For AggregatorMode.Flat, the entire aggregated chat is merged into the owning chat.
            if (agent.Mode == AggregatorMode.Flat)
            {
                yield return (IsVisible: true, message);
            }

            lastMessage = message;
        }

        // For AggregatorMode.Nested, only the final message is merged into the owning chat.
        // The entire history is always preserved within nested chat, however.
        if (agent.Mode == AggregatorMode.Nested && lastMessage is not null)
        {
            ChatMessageContent message =
                new(lastMessage.Role, lastMessage.Items, lastMessage.ModelId, lastMessage.InnerContent, lastMessage.Encoding, lastMessage.Metadata)
                {
                    AuthorName = agent.Name
                };

            yield return (IsVisible: true, message);
        }
    }

    /// <inheritdoc/>
    protected internal override async IAsyncEnumerable<StreamingChatMessageContent> InvokeStreamingAsync(AggregatorAgent agent, IList<ChatMessageContent> messages, [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        int initialCount = 0;
        await foreach (var _ in this._chat.GetChatMessagesAsync(cancellationToken).ConfigureAwait(false))
        {
            initialCount++;
        }

        await foreach (StreamingChatMessageContent message in this._chat.InvokeStreamingAsync(cancellationToken).ConfigureAwait(false))
        {
            if (agent.Mode == AggregatorMode.Flat)
            {
                yield return message;
            }
        }

        List<ChatMessageContent> history = [];
        await foreach (var item in this._chat.GetChatMessagesAsync(cancellationToken).ConfigureAwait(false))
        {
            history.Add(item);
        }

        if (history.Count > initialCount)
        {
            if (agent.Mode == AggregatorMode.Flat)
            {
                for (int index = history.Count - 1; index >= initialCount; --index)
                {
                    messages.Add(history[index]);
                }
            }
            else if (agent.Mode == AggregatorMode.Nested)
            {
                ChatMessageContent finalMessage = history[0]; // Order descending
                yield return new StreamingChatMessageContent(finalMessage.Role, finalMessage.Content) { AuthorName = finalMessage.AuthorName };
                messages.Add(finalMessage);
            }
        }
    }

    /// <inheritdoc/>
    protected internal override Task ReceiveAsync(IEnumerable<ChatMessageContent> history, CancellationToken cancellationToken = default)
    {
        // Always receive the initial history from the owning chat.
        this._chat.AddChatMessages([.. history]);

        return Task.CompletedTask;
    }

    /// <inheritdoc/>
    protected internal override Task ResetAsync(CancellationToken cancellationToken = default) =>
        this._chat.ResetAsync(cancellationToken);

    protected internal override string Serialize() =>
        JsonSerializer.Serialize(this._chat.Serialize());
}


===== Abstractions\AIAgent\SemanticKernelAIAgent.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.AI;
using MAAI = Microsoft.Agents.AI;
using MEAI = Microsoft.Extensions.AI;

namespace Microsoft.SemanticKernel.Agents;

/// <summary>
/// Exposes a Semantic Kernel Agent Framework <see cref="Agent"/> as a Microsoft Agent Framework <see cref="MAAI.AIAgent"/>.
/// </summary>
[Experimental("SKEXP0110")]
internal sealed class SemanticKernelAIAgent : MAAI.AIAgent
{
    private readonly Agent _innerAgent;
    private readonly Func<AgentThread> _threadFactory;
    private readonly Func<JsonElement, JsonSerializerOptions?, AgentThread> _threadDeserializationFactory;
    private readonly Func<AgentThread, JsonSerializerOptions?, JsonElement> _threadSerializer;

    /// <summary>
    /// Initializes a new instance of the <see cref="SemanticKernelAIAgent"/> class.
    /// </summary>
    /// <param name="semanticKernelAgent">The Semantic Kernel <see cref="Agent"/> to expose as a Microsoft Agent Framework <see cref="MAAI.AIAgent"/>.</param>
    /// <param name="threadFactory">A factory method to create the required <see cref="AgentThread"/> type to use with the agent.</param>
    /// <param name="threadDeserializationFactory">A factory method to deserialize the required <see cref="AgentThread"/> type.</param>
    /// <param name="threadSerializer">A method to serialize the <see cref="AgentThread"/> type.</param>
    public SemanticKernelAIAgent(
        Agent semanticKernelAgent,
        Func<AgentThread> threadFactory,
        Func<JsonElement, JsonSerializerOptions?, AgentThread> threadDeserializationFactory,
        Func<AgentThread, JsonSerializerOptions?, JsonElement> threadSerializer)
    {
        Throw.IfNull(semanticKernelAgent);
        Throw.IfNull(threadFactory);
        Throw.IfNull(threadDeserializationFactory);
        Throw.IfNull(threadSerializer);

        this._innerAgent = semanticKernelAgent;
        this._threadFactory = threadFactory;
        this._threadDeserializationFactory = threadDeserializationFactory;
        this._threadSerializer = threadSerializer;
    }

    /// <inheritdoc />
    public override string Id => this._innerAgent.Id;

    /// <inheritdoc />
    public override string? Name => this._innerAgent.Name;

    /// <inheritdoc />
    public override string? Description => this._innerAgent.Description;

    /// <inheritdoc />
    public override MAAI.AgentThread DeserializeThread(JsonElement serializedThread, JsonSerializerOptions? jsonSerializerOptions = null)
        => new SemanticKernelAIAgentThread(this._threadDeserializationFactory(serializedThread, jsonSerializerOptions), this._threadSerializer);

    /// <inheritdoc />
    public override MAAI.AgentThread GetNewThread() => new SemanticKernelAIAgentThread(this._threadFactory(), this._threadSerializer);

    /// <inheritdoc />
    public override async Task<MAAI.AgentRunResponse> RunAsync(IEnumerable<ChatMessage> messages, MAAI.AgentThread? thread = null, MAAI.AgentRunOptions? options = null, CancellationToken cancellationToken = default)
    {
        thread ??= this.GetNewThread();
        if (thread is not SemanticKernelAIAgentThread typedThread)
        {
            throw new InvalidOperationException("The provided thread is not compatible with the agent. Only threads created by the agent can be used.");
        }

        List<ChatMessage> responseMessages = [];
        var invokeOptions = new AgentInvokeOptions()
        {
            OnIntermediateMessage = (msg) =>
            {
                // As a backwards compatibility measure, ChatCompletionService inserts the function result
                // as a text message followed by a function result message. If we detect that pattern,
                // we must remove the text message to avoid the function result showing up in the user output.
                var chatMessage = msg.ToChatMessage();
                if (chatMessage.Role == ChatRole.Tool
                    && chatMessage.Contents.Count == 2
                    && chatMessage.Contents[0] is MEAI.TextContent textContent
                    && chatMessage.Contents[1] is MEAI.FunctionResultContent functionResultContent
                    && textContent.Text == functionResultContent.Result?.ToString())
                {
                    chatMessage.Contents.RemoveAt(0);
                }

                responseMessages.Add(chatMessage);
                return Task.CompletedTask;
            }
        };

        AgentResponseItem<ChatMessageContent>? lastResponseItem = null;
        ChatMessage? lastResponseMessage = null;
        await foreach (var responseItem in this._innerAgent.InvokeAsync(messages.Select(x => x.ToChatMessageContent()).ToList(), typedThread.InnerThread, invokeOptions, cancellationToken).ConfigureAwait(false))
        {
            lastResponseItem = responseItem;
        }

        return new MAAI.AgentRunResponse(responseMessages)
        {
            AgentId = this._innerAgent.Id,
            RawRepresentation = lastResponseItem,
            AdditionalProperties = lastResponseMessage?.AdditionalProperties,
            CreatedAt = lastResponseMessage?.CreatedAt,
        };
    }

    /// <inheritdoc />
    public override async IAsyncEnumerable<MAAI.AgentRunResponseUpdate> RunStreamingAsync(
        IEnumerable<ChatMessage> messages,
        MAAI.AgentThread? thread = null,
        MAAI.AgentRunOptions? options = null,
        [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        thread ??= this.GetNewThread();
        if (thread is not SemanticKernelAIAgentThread typedThread)
        {
            throw new InvalidOperationException("The provided thread is not compatible with the agent. Only threads created by the agent can be used.");
        }

        await foreach (var responseItem in this._innerAgent.InvokeStreamingAsync(messages.Select(x => x.ToChatMessageContent()).ToList(), typedThread.InnerThread, cancellationToken: cancellationToken).ConfigureAwait(false))
        {
            var update = responseItem.Message.ToChatResponseUpdate();

            yield return new MAAI.AgentRunResponseUpdate
            {
                AuthorName = update.AuthorName,
                AgentId = this._innerAgent.Id,
                RawRepresentation = responseItem,
                AdditionalProperties = update.AdditionalProperties,
                MessageId = update.MessageId,
                Role = update.Role,
                ResponseId = update.ResponseId,
                CreatedAt = update.CreatedAt,
                Contents = update.Contents
            };
        }
    }

    /// <inheritdoc />
    public override object? GetService(Type serviceType, object? serviceKey = null)
    {
        Throw.IfNull(serviceType);

        return serviceKey is null && serviceType == typeof(Kernel)
        ? this._innerAgent.Kernel
        : serviceKey is null && serviceType.IsInstanceOfType(this._innerAgent)
        ? this._innerAgent
        : base.GetService(serviceType, serviceKey);
    }
}


===== Abstractions\AIAgent\SemanticKernelAIAgentThread.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Diagnostics.CodeAnalysis;
using System.Text.Json;
using MAAI = Microsoft.Agents.AI;

namespace Microsoft.SemanticKernel.Agents;

[Experimental("SKEXP0110")]
internal sealed class SemanticKernelAIAgentThread : MAAI.AgentThread
{
    private readonly Func<AgentThread, JsonSerializerOptions?, JsonElement> _threadSerializer;

    internal SemanticKernelAIAgentThread(AgentThread thread, Func<AgentThread, JsonSerializerOptions?, JsonElement> threadSerializer)
    {
        Throw.IfNull(thread);
        Throw.IfNull(threadSerializer);

        this.InnerThread = thread;
        this._threadSerializer = threadSerializer;
    }

    /// <summary>
    /// Gets the underlying Semantic Kernel Agent Framework <see cref="AgentThread"/>.
    /// </summary>
    public AgentThread InnerThread { get; }

    /// <inheritdoc />
    public override JsonElement Serialize(JsonSerializerOptions? jsonSerializerOptions = null)
        => this._threadSerializer(this.InnerThread, jsonSerializerOptions);

    /// <inheritdoc />
    public override object? GetService(Type serviceType, object? serviceKey = null)
    {
        Throw.IfNull(serviceType);

        return serviceKey is null && serviceType.IsInstanceOfType(this.InnerThread)
        ? this.InnerThread
        : base.GetService(serviceType, serviceKey);
    }
}


===== Abstractions\Definition\AgentCreationOptions.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Diagnostics.CodeAnalysis;

namespace Microsoft.SemanticKernel.Agents;

/// <summary>
/// Optional parameters for agent creation used when create an <see cref="Agent"/>
/// using an instance of <see cref="AgentFactory"/>.
/// <remarks>
/// Implementors of <see cref="AgentFactory"/> can extend this class to provide
/// agent specific creation options.
/// </remarks>
/// </summary>
[Experimental("SKEXP0110")]
public class AgentCreationOptions
{
    /// <summary>
    /// Gets or sets the <see cref="Kernel"/>, a kernel instance to resolve services.
    /// </summary>
    public Kernel? Kernel { get; init; } = null;

    /// <summary>
    /// Gets or sets the <see cref="IPromptTemplateFactory"/>, a factory for prompt templates for one or more prompt template formats.
    /// </summary>
    public IPromptTemplateFactory? PromptTemplateFactory { get; init; } = null;
}


===== Abstractions\Definition\AgentDefinition.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;

namespace Microsoft.SemanticKernel.Agents;

/// <summary>
/// Defines an agent.
/// </summary>
[Experimental("SKEXP0110")]
public sealed class AgentDefinition
{
    /// <summary>
    /// Gets or sets the version of the agent.
    /// </summary>
    public string? Version { get; set; }

    /// <summary>
    /// Gets or sets the unique identifier of the agent.
    /// </summary>
    public string? Id { get; set; }

    /// <summary>
    /// Gets or sets the type of the  agent.
    /// </summary>
    public string? Type { get; set; }

    /// <summary>
    /// Gets or sets the name of the  agent.
    /// </summary>
    public string? Name { get; set; }

    /// <summary>
    /// Gets or sets the short description of the agent.
    /// </summary>
    public string? Description { get; set; }

    /// <summary>
    /// Gets or sets the instructions for the agent to use.
    /// </summary>
    public string? Instructions { get; set; }

    /// <summary>
    /// Gets or sets the metadata associated with the agent, including its authors and tags
    /// as specific metadata but can accept any optional metadata that can be handled by the provider.
    /// </summary>
    public AgentMetadata? Metadata { get; set; }

    /// <summary>
    /// Gets or sets the model used by the agent, including the API, connection, and options.
    /// </summary>
    public ModelDefinition? Model { get; set; }

    /// <summary>
    /// Gets or sets the collection of inputs used by the agent, including their type, default value, and description.
    /// </summary>
    /// <remarks>
    /// This is typically a set of inputs that will be used as parameters that participate in the template rendering.
    /// </remarks>
    public IDictionary<string, AgentInput>? Inputs { get; set; }

    /// <summary>
    /// Gets or sets the collection of outputs supported by the agent, including their type and description.
    /// </summary>
    public IDictionary<string, AgentOutput>? Outputs { get; set; }

    /// <summary>
    /// Gets or sets the template options used by the agent, including its type and parser.
    /// </summary>
    public TemplateOptions? Template { get; set; }

    /// <summary>
    /// Gets or sets the collection of tools used by the agent, including their name, type, and options.
    /// </summary>
    public IList<AgentToolDefinition>? Tools { get; set; }
}


===== Abstractions\Definition\AgentFactory.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

namespace Microsoft.SemanticKernel.Agents;

/// <summary>
/// Represents a factory for creating <see cref="Agent"/> instances.
/// </summary>
[Experimental("SKEXP0110")]
public abstract class AgentFactory
{
    /// <summary>
    /// Gets the types of agents this factory can create.
    /// </summary>
    public IReadOnlyList<string> Types { get; }

    /// <summary>
    /// Initializes a new instance of the <see cref="AgentFactory"/> class.
    /// </summary>
    /// <param name="types">Types of agent this factory can create</param>
    protected AgentFactory(IEnumerable<string> types)
    {
        this.Types = [.. types];
    }

    /// <summary>
    /// Return true if this instance of <see cref="AgentFactory"/> supports creating agents from the provided <see cref="AgentDefinition"/>
    /// </summary>
    /// <param name="agentDefinition">Definition of the agent to check is supported.</param>
    public bool IsSupported(AgentDefinition agentDefinition)
    {
        return this.Types.Any(s => string.Equals(s, agentDefinition.Type, StringComparison.OrdinalIgnoreCase));
    }

    /// <summary>
    /// Create a <see cref="Agent"/> from the specified <see cref="AgentDefinition"/>.
    /// </summary>
    /// <param name="kernel">Kernel instance to associate with the agent.</param>
    /// <param name="agentDefinition">Definition of the agent to create.</param>
    /// <param name="agentCreationOptions">Options used when creating the agent.</param>
    /// <param name="cancellationToken">Optional cancellation token.</param>
    /// <return>The created <see cref="Agent"/>, if null the agent type is not supported.</return>
    public async Task<Agent> CreateAsync(Kernel kernel, AgentDefinition agentDefinition, AgentCreationOptions? agentCreationOptions = null, CancellationToken cancellationToken = default)
    {
        Verify.NotNull(kernel);
        Verify.NotNull(agentDefinition);

        var kernelAgent = await this.TryCreateAsync(kernel, agentDefinition, agentCreationOptions, cancellationToken).ConfigureAwait(false);
        return (Agent?)kernelAgent ?? throw new NotSupportedException($"Agent type {agentDefinition.Type} is not supported.");
    }

    /// <summary>
    /// Tries to create a <see cref="Agent"/> from the specified <see cref="AgentDefinition"/>.
    /// </summary>
    /// <param name="kernel">Kernel instance to associate with the agent.</param>
    /// <param name="agentDefinition">Definition of the agent to create.</param>
    /// <param name="agentCreationOptions">Options used when creating the agent.</param>
    /// <param name="cancellationToken">Optional cancellation token.</param>
    /// <return>The created <see cref="Agent"/>, if null the agent type is not supported.</return>
    public abstract Task<Agent?> TryCreateAsync(Kernel kernel, AgentDefinition agentDefinition, AgentCreationOptions? agentCreationOptions = null, CancellationToken cancellationToken = default);
}


===== Abstractions\Definition\AgentInput.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Diagnostics.CodeAnalysis;

namespace Microsoft.SemanticKernel.Agents;

/// <summary>
/// Represents an input for an agent.
/// </summary>
[Experimental("SKEXP0110")]
public sealed class AgentInput
{
    /// <summary>
    /// Gets or sets the type of the input.
    /// </summary>
    /// <remarks>
    /// This can be either a string, number, array, object, or boolean.
    /// </remarks>
    public string? Type { get; set; }

    /// <summary>
    /// Gets or sets the name of the input.
    /// </summary>
    public string? Name { get; set; }

    /// <summary>
    /// Gets or sets a description of the input.
    /// </summary>
    public string? Description { get; set; }

    /// <summary>
    /// Gets or sets a default value for the input.
    /// </summary>
    public object? Default { get; set; }

    /// <summary>
    /// Gets or sets whether the input is considered required (rather than optional).
    /// </summary>
    /// <remarks>
    /// The default is true.
    /// </remarks>
    public bool Required { get; set; } = true;

    /// <summary>
    /// Gets or sets JSON Schema describing this input.
    /// </summary>
    public string? JsonSchema { get; set; }

    /// <summary>
    /// Gets or sets a value indicating whether the input can contain structural text.
    /// </summary>
    /// <remarks>
    /// The default is true.
    /// When set to false the value of the input is treated as safe content i.e. the input can emit structural text.
    /// </remarks>
    public bool Strict { get; set; } = true;

    /// <summary>
    /// Gets or sets a sample value for the input.
    /// </summary>
    /// <remarks>
    /// This is used to provide examples to the user of the agent.
    /// This can also be used by developer tooling as the value to use without needing to prompt the developer to enter a value.
    /// </remarks>
    public object? Sample { get; set; }
}


===== Abstractions\Definition\AgentMetadata.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Text.Json.Serialization;

namespace Microsoft.SemanticKernel.Agents;

/// <summary>
/// Defines agent metadata.
/// </summary>
[Experimental("SKEXP0110")]
public sealed class AgentMetadata
{
    /// <summary>
    /// Gets or sets the collection of authors associated with the agent.
    /// </summary>
    public IList<string>? Authors { get; set; }

    /// <summary>
    /// Gets or sets the collection of tags associated with the agent.
    /// </summary>
    public IList<string>? Tags { get; set; }

    /// <summary>
    /// Extra properties that may be included in the serialized agent metadata.
    /// </summary>
    /// <remarks>
    /// Used to store agent specific metadata.
    /// </remarks>
    [JsonExtensionData]
    public IDictionary<string, object?> ExtensionData
    {
        get => this._extensionData ??= new Dictionary<string, object?>();
        set
        {
            Verify.NotNull(value);
            this._extensionData = value;
        }
    }

    #region private
    private IDictionary<string, object?>? _extensionData;
    #endregion
}


===== Abstractions\Definition\AgentOutput.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Diagnostics.CodeAnalysis;

namespace Microsoft.SemanticKernel.Agents;

/// <summary>
/// Represents an output for an agent.
/// </summary>
[Experimental("SKEXP0110")]
public sealed class AgentOutput
{
    /// <summary>
    /// Gets or sets the type of the output.
    /// </summary>
    /// <remarks>
    /// This can be either a string, number, array, object, or boolean.
    /// </remarks>
    public string? Type { get; set; }

    /// <summary>
    /// Gets or sets the name of the output.
    /// </summary>
    public string? Name { get; set; }

    /// <summary>
    /// Gets or sets a description of the output.
    /// </summary>
    public string? Description { get; set; }

    /// <summary>
    /// Gets or sets JSON Schema describing this output.
    /// </summary>
    public string? JsonSchema { get; set; }
}


===== Abstractions\Definition\AgentToolDefinition.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Text.Json.Serialization;

namespace Microsoft.SemanticKernel.Agents;

/// <summary>
/// The options for defining a tool.
/// </summary>
[Experimental("SKEXP0110")]
public sealed class AgentToolDefinition
{
    /// <summary>
    /// The id of the tool.
    /// </summary>
    /// <remarks>
    /// This is typically a short string, but can be any string that is compatible with the agent.
    /// The id is used to identify the tool in the agent and must be unique in the collection of tools.
    /// </remarks>
    public string? Id { get; set; }

    /// <summary>
    /// The type of the tool.
    /// </summary>
    /// <remarks>
    /// Used to identify which type of tool is being used e.g., code interpreter, openapi, ...
    /// </remarks>
    public string? Type { get; set; }

    /// <summary>
    /// The description of the tool.
    /// </summary>
    public string? Description { get; set; }

    /// <summary>
    /// Gets or sets the options for the tool.
    /// </summary>
    /// <remarks>
    /// Used to store tool specific options e.g., files associated with the tool, etc.
    /// </remarks>
    [JsonExtensionData]
    public IDictionary<string, object?>? Options { get; set; }
}


===== Abstractions\Definition\AggregatorAgentFactory.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

namespace Microsoft.SemanticKernel.Agents;

/// <summary>
/// Provides a <see cref="AgentFactory"/> which aggregates multiple agent factories.
/// </summary>
[Experimental("SKEXP0110")]
public sealed class AggregatorAgentFactory : AgentFactory
{
    private readonly AgentFactory[] _agentFactories;

    /// <summary>Initializes the instance.</summary>
    /// <param name="agentFactories">Ordered <see cref="AgentFactory"/> instances to aggregate.</param>
    /// <remarks>
    /// Where multiple <see cref="AgentFactory"/> instances are provided, the first factory that supports the <see cref="AgentDefinition"/> will be used.
    /// </remarks>
    public AggregatorAgentFactory(params AgentFactory[] agentFactories) : base(agentFactories.SelectMany(f => f.Types).ToArray())
    {
        Verify.NotNullOrEmpty(agentFactories);

        foreach (AgentFactory agentFactory in agentFactories)
        {
            Verify.NotNull(agentFactory, nameof(agentFactories));
        }

        this._agentFactories = agentFactories;
    }

    /// <inheritdoc/>
    public override async Task<Agent?> TryCreateAsync(Kernel kernel, AgentDefinition agentDefinition, AgentCreationOptions? agentCreationOptions = null, CancellationToken cancellationToken = default)
    {
        Verify.NotNull(agentDefinition);

        foreach (var agentFactory in this._agentFactories)
        {
            if (agentFactory.IsSupported(agentDefinition))
            {
                var kernelAgent = await agentFactory.TryCreateAsync(kernel, agentDefinition, agentCreationOptions, cancellationToken).ConfigureAwait(false);
                if (kernelAgent is not null)
                {
                    return kernelAgent;
                }
            }
        }

        return null;
    }
}


===== Abstractions\Definition\ModelConnection.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Text.Json.Serialization;

namespace Microsoft.SemanticKernel.Agents;

/// <summary>
/// Defines the connection for a model.
/// </summary>
[Experimental("SKEXP0110")]
public sealed class ModelConnection
{
    /// <summary>
    /// The type of the model connection.
    /// </summary>
    /// <remarks>
    /// Used to identify the type of deployment e.g., azure_openai, openai, ...
    /// This type will also be used for connection hosting.
    /// </remarks>
    public string? Type { get; set; }

    /// <summary>
    /// Gets or sets the Service ID of the model connection.
    /// </summary>
    public string? ServiceId { get; set; }

    /// <summary>
    /// Extra properties that may be included in the serialized model connection.
    /// </summary>
    /// <remarks>
    /// Used to store model specific connection e.g., the deployment name, endpoint, etc.
    /// </remarks>
    [JsonExtensionData]
    public IDictionary<string, object?> ExtensionData
    {
        get => this._extensionData ??= new Dictionary<string, object?>();
        set
        {
            Verify.NotNull(value);
            this._extensionData = value;
        }
    }

    #region private
    private IDictionary<string, object?>? _extensionData;
    #endregion
}


===== Abstractions\Definition\ModelDefinition.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;

namespace Microsoft.SemanticKernel.Agents;

/// <summary>
/// Defines the model to be used by an agent.
/// </summary>
[Experimental("SKEXP0110")]
public sealed class ModelDefinition
{
    /// <summary>
    /// The default API type.
    /// </summary>
    private const string DefaultApi = "chat";

    /// <summary>
    /// Gets or sets the unique identifier of the model.
    /// </summary>
    /// <remarks>
    /// This is typically a short string, but can be any string that is compatible with the agent.
    /// Typically, depending on the provider, this can replace the entire connection settings if
    /// the provider has a way to resolve the model connection from the id.
    /// </remarks>
    public string? Id { get; set; }

    /// <summary>
    /// Gets or sets the type of API used by the agent.
    /// </summary>
    /// <remarks>
    /// This is typically a chat or completion API, but can be any API that is compatible with the agent.
    /// </remarks>
    public string Api
    {
        get => this._api ?? DefaultApi;
        set
        {
            Verify.NotNullOrWhiteSpace(value);
            this._api = value;
        }
    }

    /// <summary>
    /// Gets or sets the options used by the agent.
    /// </summary>
    /// <remarks>
    /// This is typically a set of options that are compatible with the API and connection used by the agent.
    /// This optional section is used to specify the options to be used when executing the agent.
    /// If this section is not included, the runtime will use the default options for the API and connection used by the agent.
    /// </remarks>
    public IDictionary<string, object>? Options { get; set; }

    /// <summary>
    /// Gets or sets the connection used by the agent.
    /// </summary>
    /// <remarks>
    /// This is typically a type and deployment, but can be any connection that is compatible with the agent.
    /// The type parameter is used to tell the runtime how to load and execute the agent.
    /// The deployment parameter, in this example, is used to tell the runtime which deployment to use when executing against Azure OpenAI.
    /// </remarks>
    public ModelConnection? Connection { get; set; }

    #region
    private string? _api;
    #endregion
}


===== Abstractions\Extensions\AgentDefinitionExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;

namespace Microsoft.SemanticKernel.Agents;

/// <summary>
/// Provides extension methods for <see cref="AgentDefinition"/>.
/// </summary>
[Experimental("SKEXP0110")]
public static class AgentDefinitionExtensions
{
    private const string FunctionType = "function";
    private const string FunctionNameSeparator = ".";

    /// <summary>
    /// Creates default <see cref="KernelArguments"/> from the <see cref="AgentDefinition"/>.
    /// </summary>
    /// <param name="agentDefinition">Agent definition to retrieve default arguments from.</param>
    /// <param name="kernel">Kernel instance.</param>
    public static KernelArguments GetDefaultKernelArguments(this AgentDefinition agentDefinition, Kernel kernel)
    {
        Verify.NotNull(agentDefinition);
        Verify.NotNull(kernel);

        PromptExecutionSettings executionSettings = new()
        {
            ExtensionData = agentDefinition.Model?.Options ?? new Dictionary<string, object>()
        };

        // Enable automatic function calling if functions are defined.
        var functions = agentDefinition.GetToolDefinitions(FunctionType);
        if (functions is not null)
        {
            List<KernelFunction> kernelFunctions = [];
            foreach (var function in functions)
            {
                var nameParts = FunctionName.Parse(function.Id!, FunctionNameSeparator);

                // Look up the function in the kernel.
                if (kernel.Plugins.TryGetFunction(nameParts.PluginName, nameParts.Name, out var kernelFunction))
                {
                    kernelFunctions.Add(kernelFunction);
                    continue;
                }
                throw new KernelException($"The specified function {function.Id} is not available in the kernel.");
            }

            executionSettings.FunctionChoiceBehavior = FunctionChoiceBehavior.Auto(kernelFunctions);
        }

        var arguments = new KernelArguments(executionSettings);
        if (agentDefinition?.Inputs is not null)
        {
            // Add default arguments for the agent
            foreach (var keyValuePair in agentDefinition.Inputs)
            {
                if (keyValuePair.Value.Default is not null)
                {
                    arguments.Add(keyValuePair.Key, keyValuePair.Value.Default);
                }
            }
        }

        return arguments;
    }

    /// <summary>
    /// Creates a <see cref="IPromptTemplate"/> from the <see cref="AgentDefinition"/> if required.
    /// </summary>
    /// <param name="agentDefinition">Agent definition to retrieve default arguments from.</param>
    /// <param name="kernel">Kernel instance.</param>
    /// <param name="templateFactory">Optional prompt template factory</param>
    public static IPromptTemplate? GetPromptTemplate(this AgentDefinition agentDefinition, Kernel kernel, IPromptTemplateFactory? templateFactory)
    {
        Verify.NotNull(agentDefinition);

        if (templateFactory is null || agentDefinition.Template is null || agentDefinition.Instructions is null)
        {
            return null;
        }

        PromptTemplateConfig templateConfig = new(agentDefinition.Instructions)
        {
            TemplateFormat = agentDefinition.Template.Format,
        };

        return templateFactory.Create(templateConfig);
    }

    /// <summary>
    /// Get the first tool definition of the specified type.
    /// </summary>
    /// <param name="agentDefinition">Agent definition to retrieve the first tool from.</param>
    /// <param name="toolType">Tool type</param>
    public static AgentToolDefinition? GetFirstToolDefinition(this AgentDefinition agentDefinition, string toolType)
    {
        Verify.NotNull(agentDefinition);
        Verify.NotNull(toolType);
        return agentDefinition.Tools?.FirstOrDefault(tool => tool.Type == toolType);
    }

    /// <summary>
    /// Get all of the tool definitions of the specified type.
    /// </summary>
    /// <param name="agentDefinition">Agent definition to retrieve the tools from.</param>
    /// <param name="toolType">Tool type</param>
    public static IEnumerable<AgentToolDefinition>? GetToolDefinitions(this AgentDefinition agentDefinition, string toolType)
    {
        Verify.NotNull(agentDefinition);
        Verify.NotNull(toolType);
        return agentDefinition.Tools?.Where(tool => tool.Type == toolType);
    }

    /// <summary>
    /// Determines if the agent definition has a tool of the specified type.
    /// </summary>
    /// <param name="agentDefinition">Agent definition</param>
    /// <param name="toolType">Tool type</param>
    public static bool HasToolType(this AgentDefinition agentDefinition, string toolType)
    {
        Verify.NotNull(agentDefinition);

        return agentDefinition.Tools?.Any(tool => tool?.Type?.Equals(toolType, System.StringComparison.Ordinal) ?? false) ?? false;
    }
}


===== Abstractions\Extensions\AgentToolDefinitionExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Diagnostics.CodeAnalysis;

namespace Microsoft.SemanticKernel.Agents;

/// <summary>
/// Provides extension methods for <see cref="AgentDefinition"/>.
/// </summary>
[Experimental("SKEXP0110")]
public static class AgentToolDefinitionExtensions
{
    /// <summary>
    /// Get the option value for the specified key.
    /// </summary>
    /// <typeparam name="T">Expected type for the option value.</typeparam>
    /// <param name="agentToolDefinition">Agent definition instance.</param>
    /// <param name="key">Key of the option value.</param>
    /// <exception cref="InvalidCastException"></exception>
    public static T? GetOption<T>(this AgentToolDefinition agentToolDefinition, string key)
    {
        Verify.NotNull(agentToolDefinition);
        Verify.NotNull(key);

        if (agentToolDefinition.Options?.TryGetValue(key, out var value) ?? false)
        {
            if (value == null)
            {
                return default;
            }

            try
            {
                return (T?)Convert.ChangeType(value, typeof(T));
            }
            catch (InvalidCastException ex)
            {
                throw new InvalidCastException($"The option key '{key}' value must be of type '{typeof(T?)}' but is '{value.GetType()}'.", ex);
            }
        }

        return default;
    }
}


===== Abstractions\Extensions\ChatHistoryExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Collections.Generic;
using Microsoft.SemanticKernel.ChatCompletion;

namespace Microsoft.SemanticKernel.Agents.Extensions;

/// <summary>
/// Provides extension methods for <see cref="ChatMessageContent"/>.
/// </summary>
public static class ChatHistoryExtensions
{
    /// <summary>
    /// Enumerates a chat history in descending order.
    /// </summary>
    /// <param name="history">The chat history to sort.</param>
    public static IEnumerable<ChatMessageContent> ToDescending(this ChatHistory history)
    {
        for (int index = history.Count; index > 0; --index)
        {
            yield return history[index - 1];
        }
    }

    /// <summary>
    /// Enumerates a history in descending order asynchronously.
    /// </summary>
    /// <param name="history">The chat history to sort.</param>
    public static async IAsyncEnumerable<ChatMessageContent> ToDescendingAsync(this ChatHistory history)
    {
        for (int index = history.Count; index > 0; --index)
        {
            yield return history[index - 1];
        }
    }
}


===== Abstractions\Internal\BroadcastQueue.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Threading;
using System.Threading.Tasks;
using ChannelQueue = System.Collections.Generic.Queue<System.Collections.Generic.IReadOnlyList<Microsoft.SemanticKernel.ChatMessageContent>>;

namespace Microsoft.SemanticKernel.Agents.Internal;

/// <summary>
/// Utility class used by <see cref="AgentChat"/> to manage the broadcast of
/// conversation messages via the <see cref="AgentChannel.ReceiveAsync"/>.
/// Interaction occurs via two methods:
/// - <see cref="BroadcastQueue.Enqueue"/>: Adds messages to a channel specific queue for processing.
/// - <see cref="BroadcastQueue.EnsureSynchronizedAsync"/>: Blocks until the specified channel's processing queue is empty.
/// </summary>
/// <remarks>
/// Maintains a set of channel specific queues, each with individual locks.
/// Queue specific locks exist to synchronize access to an individual queue only.
/// Due to the closed "friend" relationship between with <see cref="AgentChat"/>,
/// <see cref="BroadcastQueue"/> is never invoked concurrently, which eliminates
/// race conditions over the queue dictionary.
/// </remarks>
[Experimental("SKEXP0110")]
internal sealed class BroadcastQueue
{
    private readonly Dictionary<string, QueueReference> _queues = [];

    /// <summary>
    /// Defines the yield duration when waiting on a channel-queue to synchronize
    /// and drain.
    /// </summary>
    public TimeSpan BlockDuration { get; set; } = TimeSpan.FromSeconds(0.1);

    /// <summary>
    /// Enqueue a set of messages for a given channel.
    /// </summary>
    /// <param name="channelRefs">The target channels for which to broadcast.</param>
    /// <param name="messages">The messages being broadcast.</param>
    public void Enqueue(IEnumerable<ChannelReference> channelRefs, IReadOnlyList<ChatMessageContent> messages)
    {
        // Ensure mutating _queues
        foreach (var channelRef in channelRefs)
        {
            if (!this._queues.TryGetValue(channelRef.Hash, out var queueRef))
            {
                queueRef = new();
                this._queues.Add(channelRef.Hash, queueRef);
            }

            lock (queueRef.QueueLock)
            {
                queueRef.Queue.Enqueue(messages);

                if (queueRef.ReceiveTask?.IsCompleted ?? true)
                {
                    queueRef.ReceiveTask = ReceiveAsync(channelRef, queueRef);
                }
            }
        }
    }

    /// <summary>
    /// Blocks until a channel-queue is not in a receive state to ensure that
    /// channel history is complete.
    /// </summary>
    /// <param name="channelRef">A <see cref="ChannelReference"/> structure.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>false when channel is no longer receiving.</returns>
    /// <throws>
    /// When channel is out of sync.
    /// </throws>
    public async Task EnsureSynchronizedAsync(ChannelReference channelRef, CancellationToken cancellationToken = default)
    {
        // Either won race with Enqueue or lost race with ReceiveAsync.
        // Missing queue is synchronized by definition.
        if (!this._queues.TryGetValue(channelRef.Hash, out QueueReference? queueRef))
        {
            return;
        }

        // Evaluate queue state
        bool isEmpty = true;
        do
        {
            // Queue state is only changed within acquired QueueLock.
            // If its empty here, it is synchronized.
            lock (queueRef.QueueLock)
            {
                isEmpty = queueRef.IsEmpty;

                // Propagate prior failure (inform caller of synchronization issue)
                if (queueRef.ReceiveFailure is not null)
                {
                    Exception failure = queueRef.ReceiveFailure;
                    queueRef.ReceiveFailure = null;
                    throw new KernelException($"Unexpected failure broadcasting to channel: {channelRef.Channel.GetType()}", failure);
                }

                // Activate non-empty queue
                if (!isEmpty)
                {
                    if (queueRef.ReceiveTask?.IsCompleted ?? true)
                    {
                        queueRef.ReceiveTask = ReceiveAsync(channelRef, queueRef, cancellationToken);
                    }
                }
            }

            if (!isEmpty)
            {
                await Task.Delay(this.BlockDuration, cancellationToken).ConfigureAwait(false);
            }
        }
        while (!isEmpty);
    }

    /// <summary>
    /// Processes the specified queue with the provided channel, until queue is empty.
    /// </summary>
    private static async Task ReceiveAsync(ChannelReference channelRef, QueueReference queueRef, CancellationToken cancellationToken = default)
    {
        Exception? failure = null;

        bool isEmpty = true; // Default to fall-through state
        do
        {
            Task receiveTask;

            // Queue state is only changed within acquired QueueLock.
            // If its empty here, it is synchronized.
            lock (queueRef.QueueLock)
            {
                isEmpty = queueRef.IsEmpty;

                // Process non empty queue
                if (isEmpty)
                {
                    break;
                }

                var messages = queueRef.Queue.Peek();
                receiveTask = channelRef.Channel.ReceiveAsync(messages, cancellationToken);
            }

            // Queue not empty.
            try
            {
                await receiveTask.ConfigureAwait(false);
            }
            catch (Exception exception) when (!exception.IsCriticalException())
            {
                failure = exception;
            }

            lock (queueRef.QueueLock)
            {
                // Propagate failure or update queue
                if (failure is not null)
                {
                    queueRef.ReceiveFailure = failure;
                    break; // Failure on non-empty queue means, still not empty.
                }

                // Queue has already been peeked.  Remove head on success.
                queueRef.Queue.Dequeue();

                isEmpty = queueRef.IsEmpty; // Re-evaluate state
            }
        }
        while (!isEmpty);
    }

    /// <summary>
    /// Utility class to associate a queue with its specific lock.
    /// </summary>
    private sealed class QueueReference
    {
        /// <summary>
        /// Convenience logic
        /// </summary>
        public bool IsEmpty => this.Queue.Count == 0;

        /// <summary>
        /// Queue specific lock to control queue access with finer granularity
        /// than the state-lock.
        /// </summary>
        public object QueueLock { get; } = new object();

        /// <summary>
        /// The target queue.
        /// </summary>
        public ChannelQueue Queue { get; } = new ChannelQueue();

        /// <summary>
        /// The task receiving and processing messages from <see cref="Queue" />.
        /// </summary>
        public Task? ReceiveTask { get; set; }

        /// <summary>
        /// Capture any failure that may occur during execution of <see cref="ReceiveTask"/>.
        /// </summary>
        public Exception? ReceiveFailure { get; set; }
    }
}


===== Abstractions\Internal\ChannelReference.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Diagnostics.CodeAnalysis;

namespace Microsoft.SemanticKernel.Agents.Internal;

/// <summary>
/// Tracks channel along with its hashed key.
/// </summary>
[Experimental("SKEXP0110")]
internal readonly struct ChannelReference(AgentChannel channel, string hash)
{
    /// <summary>
    /// The referenced channel.
    /// </summary>
    public AgentChannel Channel { get; } = channel;

    /// <summary>
    /// The channel hash.
    /// </summary>
    public string Hash { get; } = hash;
}


===== Abstractions\Internal\KeyEncoder.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.Collections.Generic;
using System.Security.Cryptography;
using System.Text;

namespace Microsoft.SemanticKernel.Agents.Internal;

/// <summary>
/// Utility to encode a list of string keys to an base-64 encoded hash.
/// </summary>
internal static class KeyEncoder
{
    /// <summary>
    /// Produces a base-64 encoded hash for a set of input strings.
    /// </summary>
    /// <param name="keys">A set of input strings</param>
    /// <returns>A base-64 encoded hash</returns>
    public static string GenerateHash(IEnumerable<string> keys)
    {
        byte[] buffer = Encoding.UTF8.GetBytes(string.Join(":", keys));

#if NET
        Span<byte> hash = stackalloc byte[32];
        SHA256.HashData(buffer, hash);
#else
        using SHA256 shaProvider = SHA256.Create();
        byte[] hash = shaProvider.ComputeHash(buffer);
#endif

        return Convert.ToBase64String(hash);
    }
}


===== Abstractions\Logging\AgentChatLogMessages.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using Microsoft.Extensions.Logging;
using Microsoft.SemanticKernel.Agents.Extensions;

namespace Microsoft.SemanticKernel.Agents;

#pragma warning disable SYSLIB1006 // Multiple logging methods cannot use the same event id within a class

/// <summary>
/// Extensions for logging <see cref="AggregatorAgent"/> invocations.
/// </summary>
/// <remarks>
/// This extension uses the <see cref="LoggerMessageAttribute"/> to
/// generate logging code at compile time to achieve optimized code.
/// </remarks>
[ExcludeFromCodeCoverage]
internal static partial class AgentChatLogMessages
{
    /// <summary>
    /// Logs retrieval of <see cref="AgentChat"/> messages.
    /// </summary>
    private static readonly Action<ILogger, string, string, string, string?, Exception?> s_logAgentChatGetChatMessages =
        LoggerMessage.Define<string, string, string, string?>(
            logLevel: LogLevel.Debug,
            eventId: 0,
            "[{MethodName}] Source: {MessageSourceType}/{MessageSourceId}/{MessageSourceName}.");

    public static void LogAgentChatGetChatMessages(
        this ILogger logger,
        string methodName,
        Agent? agent)
    {
        if (logger.IsEnabled(LogLevel.Debug))
        {
            if (agent is null)
            {
                s_logAgentChatGetChatMessages(logger, methodName, "primary", "primary", null, null);
            }
            else
            {
                s_logAgentChatGetChatMessages(logger, methodName, agent.GetType().Name, agent.Id, agent.GetDisplayName(), null);
            }
        }
    }

    /// <summary>
    /// Logs <see cref="AgentChat"/> adding messages (started).
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Debug,
        Message = "[{MethodName}] Adding Messages: {MessageCount}.")]
    public static partial void LogAgentChatAddingMessages(
        this ILogger logger,
        string methodName,
        int messageCount);

    /// <summary>
    /// Logs <see cref="AgentChat"/> added messages (complete).
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Information,
        Message = "[{MethodName}] Added Messages: {MessageCount}.")]
    public static partial void LogAgentChatAddedMessages(
        this ILogger logger,
        string methodName,
        int messageCount);

    /// <summary>
    /// Logs <see cref="AgentChat"/> invoking agent (started).
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Debug,
        Message = "[{MethodName}] Invoking agent {AgentType}/{AgentId}/{AgentName}.")]
    public static partial void LogAgentChatInvokingAgent(
        this ILogger logger,
        string methodName,
        Type agentType,
        string agentId,
        string agentName);

    /// <summary>
    /// Logs <see cref="AgentChat"/> invoked agent message
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Trace,
        Message = "[{MethodName}] Agent message {AgentType}/{AgentId}/{AgentName}: {Message}.")]
    public static partial void LogAgentChatInvokedAgentMessage(
        this ILogger logger,
        string methodName,
        Type agentType,
        string agentId,
        string agentName,
        ChatMessageContent message);

    /// <summary>
    /// Logs retrieval of streamed <see cref="AgentChat"/> messages.
    /// </summary>
    private static readonly Action<ILogger, string, Type, string, string, ChatMessageContent, Exception?> s_logAgentChatInvokedStreamingAgentMessages =
        LoggerMessage.Define<string, Type, string, string, ChatMessageContent>(
            logLevel: LogLevel.Debug,
            eventId: 0,
            "[{MethodName}] Agent message {AgentType}/{AgentId}/{AgentName}: {Message}.");

    public static void LogAgentChatInvokedStreamingAgentMessages(
        this ILogger logger,
        string methodName,
        Type agentType,
        string agentId,
        string agentName,
        IList<ChatMessageContent> messages)
    {
        if (logger.IsEnabled(LogLevel.Debug))
        {
            foreach (ChatMessageContent message in messages)
            {
                s_logAgentChatInvokedStreamingAgentMessages(logger, methodName, agentType, agentId, agentName, message, null);
            }
        }
    }

    /// <summary>
    /// Logs <see cref="AgentChat"/> invoked agent (complete).
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Information,
        Message = "[{MethodName}] Invoked agent {AgentType}/{AgentId}/{AgentName}.")]
    public static partial void LogAgentChatInvokedAgent(
        this ILogger logger,
        string methodName,
        Type agentType,
        string agentId,
        string agentName);

    /// <summary>
    /// Logs <see cref="AgentChat"/> creating agent channel (started).
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Debug,
        Message = "[{MethodName}] Creating channel for {AgentType}: {AgentId}/{AgentName}")]
    public static partial void LogAgentChatCreatingChannel(
        this ILogger logger,
        string methodName,
        Type agentType,
        string agentId,
        string agentName);

    /// <summary>
    /// Logs <see cref="AgentChat"/> created agent channel (complete).
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Information,
        Message = "[{MethodName}] Created channel for {AgentType}: {AgentId}/{AgentName}")]
    public static partial void LogAgentChatCreatedChannel(
        this ILogger logger,
        string methodName,
        Type agentType,
        string agentId,
        string agentName);
}


===== Abstractions\Logging\AggregatorAgentLogMessages.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.Diagnostics.CodeAnalysis;
using Microsoft.Extensions.Logging;

namespace Microsoft.SemanticKernel.Agents;

#pragma warning disable SYSLIB1006 // Multiple logging methods cannot use the same event id within a class

/// <summary>
/// Extensions for logging <see cref="AggregatorAgent"/> invocations.
/// </summary>
/// <remarks>
/// This extension uses the <see cref="LoggerMessageAttribute"/> to
/// generate logging code at compile time to achieve optimized code.
/// </remarks>
[ExcludeFromCodeCoverage]
[Experimental("SKEXP0110")]
internal static partial class AggregatorAgentLogMessages
{
    /// <summary>
    /// Logs <see cref="AggregatorAgent"/> creating channel (started).
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Debug,
        Message = "[{MethodName}] Creating channel {ChannelType}.")]
    public static partial void LogAggregatorAgentCreatingChannel(
        this ILogger logger,
        string methodName,
        string channelType);

    /// <summary>
    /// Logs <see cref="AggregatorAgent"/> created channel (complete).
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Information,
        Message = "[{MethodName}] Created channel {ChannelType} ({ChannelMode}) with: {AgentChatType}.")]
    public static partial void LogAggregatorAgentCreatedChannel(
        this ILogger logger,
        string methodName,
        string channelType,
        AggregatorMode channelMode,
        Type agentChatType);

    /// <summary>
    /// Logs <see cref="AggregatorAgent"/> restoring serialized channel (started).
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Debug,
        Message = "[{MethodName}] Restoring assistant channel for {ChannelType}.")]
    public static partial void LogOpenAIAssistantAgentRestoringChannel(
        this ILogger logger,
        string methodName,
        string channelType);

    /// <summary>
    /// Logs <see cref="AggregatorAgent"/> restored serialized channel (complete).
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Information,
        Message = "[{MethodName}] Restored assistant channel for {ChannelType}.")]
    public static partial void LogOpenAIAssistantAgentRestoredChannel(
        this ILogger logger,
        string methodName,
        string channelType);
}


===== Abstractions\Serialization\AgentChannelState.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Text.Json.Serialization;

namespace Microsoft.SemanticKernel.Agents.Serialization;

/// <summary>
/// Captures the serialized state of an <see cref="AgentChannel"/> along with relevant meta-data.
/// </summary>
internal sealed class AgentChannelState
{
    /// <summary>
    /// The unique key for the channel.
    /// </summary>
    /// <remarks>
    /// This is a hash <see cref="AgentChat"/> generates and manages based <see cref="Agent.GetChannelKeys()"/>.
    /// </remarks>
    public string ChannelKey { get; set; } = string.Empty;

    /// <summary>
    /// The fully qualified type name of the channel.
    /// </summary>
    /// <remarks>
    /// Not utilized in deserialization, but useful for auditing the serialization payload.
    /// </remarks>
    public string ChannelType { get; set; } = string.Empty;

    /// <summary>
    /// The serialized channel state, as provided by <see cref="AgentChannel.Serialize"/>.
    /// </summary>
    /// <remarks>
    /// Converter will serialize JSON string as JSON.
    /// </remarks>
    [JsonConverter(typeof(JsonChannelStateConverter))]
    public string ChannelState { get; set; } = string.Empty;
}


===== Abstractions\Serialization\AgentChatState.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.Collections.Generic;
using System.Text.Json.Serialization;

namespace Microsoft.SemanticKernel.Agents.Serialization;

/// <summary>
/// Captures the serialized state of an <see cref="AgentChat"/> along with relevant meta-data.
/// </summary>
internal sealed class AgentChatState
{
    /// <summary>
    /// Metadata to identify the <see cref="Agent"/> instances participating in an <see cref="AgentChat"/>.
    /// </summary>
    public IEnumerable<AgentParticipant> Participants { get; init; } = Array.Empty<AgentParticipant>();

    /// <summary>
    /// The serialized chat history.
    /// </summary>
    /// <remarks>
    /// Converter will serialize JSON string as JSON.
    /// </remarks>
    [JsonConverter(typeof(JsonChannelStateConverter))]
    public string History { get; init; } = string.Empty;

    /// <summary>
    /// The state of each <see cref="AgentChannel"/> active in an <see cref="AgentChat"/>.
    /// </summary>
    public IEnumerable<AgentChannelState> Channels { get; init; } = [];
}


===== Abstractions\Serialization\AgentParticipant.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Text.Json.Serialization;

namespace Microsoft.SemanticKernel.Agents.Serialization;

/// <summary>
/// References an <see cref="Agent"/> instance participating in an <see cref="AgentChat"/>.
/// </summary>
public sealed class AgentParticipant
{
    /// <summary>
    /// Gets the captured <see cref="Agent.Id"/>.
    /// </summary>
    public string Id { get; init; } = string.Empty;

    /// <summary>
    /// Gets the captured <see cref="Agent.Name"/>.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public string? Name { get; init; }

    /// <summary>
    /// Gets the fully qualified <see cref="Agent"/> type name.
    /// </summary>
    public string Type { get; init; } = string.Empty;

    /// <summary>
    /// Creates a new instance of <see cref="AgentParticipant"/>.
    /// </summary>
    /// <remarks>
    /// This parameterless constructor is for deserialization.
    /// </remarks>
    [JsonConstructor]
    public AgentParticipant() { }

    /// <summary>
    /// Creates a new instance of <see cref="AgentParticipant"/> with the specified agent.
    /// </summary>
    /// <remarks>
    /// This is a convenience constructor for serialization.
    /// </remarks>
    /// <param name="agent">The referenced <see cref="Agent"/>.</param>
    internal AgentParticipant(Agent agent)
    {
        this.Id = agent.Id;
        this.Name = agent.Name;
        this.Type = agent.GetType().FullName!;
    }
}


===== Abstractions\Serialization\ChatMessageReference.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Text.Json.Serialization;
using Microsoft.SemanticKernel.ChatCompletion;

namespace Microsoft.SemanticKernel.Agents.Serialization;

/// <summary>
/// Represents a <see cref="ChatMessageContent"/> for serialization without metadata.
/// </summary>
/// <param name="message">The referenced message</param>
[Experimental("SKEXP0110")]
public sealed class ChatMessageReference(ChatMessageContent message)
{
    /// <summary>
    /// Gets the referenced <see cref="ChatMessageContent.AuthorName"/> property.
    /// </summary>
    public string? AuthorName => message.AuthorName;

    /// <summary>
    /// Gets the referenced <see cref="ChatMessageContent.Role"/> property.
    /// </summary>
    public AuthorRole Role => message.Role;

    /// <summary>
    /// Gets the referenced <see cref="ChatMessageContent.Items"/> collection.
    /// </summary>
    public IEnumerable<KernelContent> Items => message.Items;

    /// <summary>
    /// Gets the referenced <see cref="KernelContent.ModelId"/> property.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public string? ModelId => message.ModelId;

    /// <summary>
    /// Gets the referenced <see cref="KernelContent.MimeType"/> property.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public string? MimeType => message.MimeType;

    /// <summary>
    /// Converts a set of messages to <see cref="ChatMessageReference"/> instances.
    /// </summary>
    public static IEnumerable<ChatMessageReference> Prepare(IEnumerable<ChatMessageContent> messages) =>
        messages.Select(m => new ChatMessageReference(m));
}


===== Abstractions\Serialization\JsonChannelStateConverter.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace Microsoft.SemanticKernel.Agents.Serialization;

/// <summary>
/// Translates the serialized state to avoid escaping nested JSON as string.
/// </summary>
/// <example>
/// Without converter:
/// <code>
/// {
///   "state": "{\"key\":\"value\"}"
/// }
/// </code>
///
/// With converter:
/// <code>
/// {
///   "state": {"key": "value"}
/// }
/// </code>
///
/// Always:
/// <code>
/// {
///   "state": "text",
/// }
/// </code>
/// </example>
internal class JsonChannelStateConverter : JsonConverter<string>
{
    /// <inheritdoc/>
    public override string? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        if (reader.TokenType == JsonTokenType.String)
        {
            string? token = reader.GetString();
            return token;
        }

        using var doc = JsonDocument.ParseValue(ref reader);
        return doc.RootElement.GetRawText();
    }

    /// <inheritdoc/>
    public override void Write(Utf8JsonWriter writer, string value, JsonSerializerOptions options)
    {
        if ((value.StartsWith("[", StringComparison.Ordinal) && value.EndsWith("]", StringComparison.Ordinal)) ||
            (value.StartsWith("{", StringComparison.Ordinal) && value.EndsWith("}", StringComparison.Ordinal)))
        {
            writer.WriteRawValue(value);
        }
        else
        {
            writer.WriteStringValue(value);
        }
    }
}


===== AzureAI\AzureAIAgent.ClientFactory.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Net.Http;
using Azure.AI.Agents.Persistent;
using Azure.Core;
using Azure.Core.Pipeline;
using Microsoft.SemanticKernel.Http;

namespace Microsoft.SemanticKernel.Agents.AzureAI;

/// <summary>
/// Provides an <see cref="PersistentAgentsClient"/> for use by <see cref="AzureAIAgent"/>.
/// </summary>
public sealed partial class AzureAIAgent : Agent
{
    /// <summary>
    /// Produces a <see cref="PersistentAgentsClient"/>.
    /// </summary>
    /// <param name="endpoint">The Azure AI Foundry project endpoint.</param>
    /// <param name="credential"> A credential used to authenticate to an Azure Service.</param>
    /// <param name="httpClient">A custom <see cref="HttpClient"/> for HTTP requests.</param>
    public static PersistentAgentsClient CreateAgentsClient(
        string endpoint,
        TokenCredential credential,
        HttpClient? httpClient = null)
    {
        Verify.NotNull(endpoint, nameof(endpoint));
        Verify.NotNull(credential, nameof(credential));

        PersistentAgentsAdministrationClientOptions clientOptions = CreateAzureClientOptions(httpClient);

        return new PersistentAgentsClient(endpoint, credential, clientOptions);
    }

    private static PersistentAgentsAdministrationClientOptions CreateAzureClientOptions(HttpClient? httpClient)
    {
        PersistentAgentsAdministrationClientOptions options = new();

        options.AddPolicy(new SemanticKernelHeadersPolicy(), HttpPipelinePosition.PerCall);

        if (httpClient is not null)
        {
            options.Transport = new HttpClientTransport(httpClient);
            // Disable retry policy if and only if a custom HttpClient is provided.
            options.RetryPolicy = new RetryPolicy(maxRetries: 0);
        }

        return options;
    }

    private class SemanticKernelHeadersPolicy : HttpPipelineSynchronousPolicy
    {
        public override void OnSendingRequest(HttpMessage message)
        {
            message.Request.Headers.Add(
                HttpHeaderConstant.Names.UserAgent,
                $"{HttpHeaderConstant.Values.UserAgent} {nameof(AzureAIAgent)}");

            message.Request.Headers.Add(
                HttpHeaderConstant.Names.SemanticKernelVersion,
                HttpHeaderConstant.Values.GetAssemblyVersion(typeof(AzureAIAgent)));
        }
    }
}


===== AzureAI\AzureAIAgent.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using Azure.AI.Agents.Persistent;
using Microsoft.Extensions.Logging;
using Microsoft.SemanticKernel.Agents.AzureAI.Internal;
using Microsoft.SemanticKernel.Agents.Extensions;
using Microsoft.SemanticKernel.ChatCompletion;
using Microsoft.SemanticKernel.Diagnostics;

namespace Microsoft.SemanticKernel.Agents.AzureAI;

/// <summary>
/// Provides a specialized <see cref="Agent"/> based on an Azure AI agent.
/// </summary>
public sealed partial class AzureAIAgent : Agent
{
    /// <summary>
    /// Provides tool definitions used when associating a file attachment to an input message:
    /// <see cref="FileReferenceContent.Tools"/>.
    /// </summary>
    public static class Tools
    {
        /// <summary>
        /// The code-interpreter tool.
        /// </summary>
        public static readonly string CodeInterpreter = "code_interpreter";

        /// <summary>
        /// The file-search tool.
        /// </summary>
        public const string FileSearch = "file_search";
    }

    /// <summary>
    /// The metadata key that identifies code-interpreter content.
    /// </summary>
    public const string CodeInterpreterMetadataKey = "code";

    /// <summary>
    /// Gets the assistant definition.
    /// </summary>
    public PersistentAgent Definition { get; private init; }

    /// <summary>
    /// Gets the polling behavior for run processing.
    /// </summary>
    public RunPollingOptions PollingOptions { get; } = new();

    /// <summary>
    /// Initializes a new instance of the <see cref="AzureAIAgent"/> class.
    /// </summary>
    /// <param name="model">The agent model definition.</param>
    /// <param name="client">An <see cref="PersistentAgentsClient"/> instance.</param>
    /// <param name="plugins">Optional collection of plugins to add to the kernel.</param>
    /// <param name="templateFactory">An optional factory to produce the <see cref="IPromptTemplate"/> for the agent.</param>
    /// <param name="templateFormat">The format of the prompt template used when "templateFactory" parameter is supplied.</param>
    public AzureAIAgent(
        PersistentAgent model,
        PersistentAgentsClient client,
        IEnumerable<KernelPlugin>? plugins = null,
        IPromptTemplateFactory? templateFactory = null,
        string? templateFormat = null)
    {
        this.Client = client;
        this.Definition = model;
        this.Description = this.Definition.Description;
        this.Id = this.Definition.Id;
        this.Name = this.Definition.Name;
        this.Instructions = this.Definition.Instructions;

        if (templateFactory != null)
        {
            Verify.NotNullOrWhiteSpace(templateFormat);

            PromptTemplateConfig templateConfig = new(this.Instructions)
            {
                TemplateFormat = templateFormat
            };

            this.Template = templateFactory.Create(templateConfig);
        }

        if (plugins != null)
        {
            this.Kernel.Plugins.AddRange(plugins);
        }
    }

    /// <summary>
    /// The associated client.
    /// </summary>
    public PersistentAgentsClient Client { get; }

    /// <inheritdoc/>
    public override IAsyncEnumerable<AgentResponseItem<ChatMessageContent>> InvokeAsync(
        ICollection<ChatMessageContent> messages,
        AgentThread? thread = null,
        AgentInvokeOptions? options = null,
        CancellationToken cancellationToken = default)
    {
        return this.InvokeAsync(
            messages,
            thread,
            options is null ?
                null :
                options is AzureAIAgentInvokeOptions azureAIAgentInvokeOptions ? azureAIAgentInvokeOptions : new AzureAIAgentInvokeOptions(options),
            cancellationToken);
    }

    /// <summary>
    /// Invoke the agent with the provided message and arguments.
    /// </summary>
    /// <param name="messages">The messages to pass to the agent.</param>
    /// <param name="thread">The conversation thread to continue with this invocation. If not provided, creates a new thread.</param>
    /// <param name="options">Optional parameters for agent invocation.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>An async list of response items that each contain a <see cref="ChatMessageContent"/> and an <see cref="AgentThread"/>.</returns>
    /// <remarks>
    /// To continue this thread in the future, use an <see cref="AgentThread"/> returned in one of the response items.
    /// </remarks>
    public async IAsyncEnumerable<AgentResponseItem<ChatMessageContent>> InvokeAsync(
        ICollection<ChatMessageContent> messages,
        AgentThread? thread = null,
        AzureAIAgentInvokeOptions? options = null,
        [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        Verify.NotNull(messages);

        AzureAIAgentThread azureAIAgentThread = await this.EnsureThreadExistsWithMessagesAsync(
            messages,
            thread,
            () => new AzureAIAgentThread(this.Client),
            cancellationToken).ConfigureAwait(false);

        Kernel kernel = this.GetKernel(options);
#pragma warning disable SKEXP0110, SKEXP0130 // Type is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.
        if (this.UseImmutableKernel)
        {
            kernel = kernel.Clone();
        }

        // Get the context contributions from the AIContextProviders.
        AIContext providersContext = await azureAIAgentThread.AIContextProviders.ModelInvokingAsync(messages, cancellationToken).ConfigureAwait(false);

        // Check for compatibility AIContextProviders and the UseImmutableKernel setting.
        if (providersContext.AIFunctions is { Count: > 0 } && !this.UseImmutableKernel)
        {
            throw new InvalidOperationException("AIContextProviders with AIFunctions are not supported when Agent UseImmutableKernel setting is false.");
        }

        kernel.Plugins.AddFromAIContext(providersContext, "Tools");
#pragma warning restore SKEXP0110, SKEXP0130 // Type is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.

        string mergedAdditionalInstructions = FormatAdditionalInstructions(providersContext, options);
        var extensionsContextOptions = options is null ?
            new AzureAIAgentInvokeOptions() { AdditionalInstructions = mergedAdditionalInstructions } :
            new AzureAIAgentInvokeOptions(options) { AdditionalInstructions = mergedAdditionalInstructions };

        using var activity = ModelDiagnostics.StartAgentInvocationActivity(this.Id, this.GetDisplayName(), this.Description, kernel, messages);
        List<ChatMessageContent>? chatMessageContents = activity is not null ? [] : null;

        await foreach (var result in InternalInvokeAsync().ConfigureAwait(false))
        {
            yield return new(result, azureAIAgentThread);
            chatMessageContents?.Add(result);
        }

        activity?.SetAgentResponse(chatMessageContents);

        async IAsyncEnumerable<ChatMessageContent> InternalInvokeAsync()
        {
            await foreach ((bool isVisible, ChatMessageContent message) in AgentThreadActions.InvokeAsync(
                this,
                this.Client,
                azureAIAgentThread.Id!,
                extensionsContextOptions?.ToAzureAIInvocationOptions(),
                this.Logger,
                kernel,
                options?.KernelArguments,
                cancellationToken).ConfigureAwait(false))
            {
                // The thread and the caller should be notified of all messages regardless of visibility.
                await this.NotifyThreadOfNewMessage(azureAIAgentThread, message, cancellationToken).ConfigureAwait(false);
                if (options?.OnIntermediateMessage is not null)
                {
                    await options.OnIntermediateMessage(message).ConfigureAwait(false);
                }

                if (isVisible)
                {
                    yield return message;
                }
            }
        }
    }

    /// <inheritdoc/>
    public override IAsyncEnumerable<AgentResponseItem<StreamingChatMessageContent>> InvokeStreamingAsync(
        ICollection<ChatMessageContent> messages,
        AgentThread? thread = null,
        AgentInvokeOptions? options = null,
        CancellationToken cancellationToken = default)
    {
        return this.InvokeStreamingAsync(
            messages,
            thread,
            options is null ?
                null :
                options is AzureAIAgentInvokeOptions azureAIAgentInvokeOptions ? azureAIAgentInvokeOptions : new AzureAIAgentInvokeOptions(options),
            cancellationToken);
    }

    /// <summary>
    /// Invoke the agent with the provided message and arguments.
    /// </summary>
    /// <param name="messages">The messages to pass to the agent.</param>
    /// <param name="thread">The conversation thread to continue with this invocation. If not provided, creates a new thread.</param>
    /// <param name="options">Optional parameters for agent invocation.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>An async list of response items that each contain a <see cref="StreamingChatMessageContent"/> and an <see cref="AgentThread"/>.</returns>
    /// <remarks>
    /// To continue this thread in the future, use an <see cref="AgentThread"/> returned in one of the response items.
    /// </remarks>
    public async IAsyncEnumerable<AgentResponseItem<StreamingChatMessageContent>> InvokeStreamingAsync(
        ICollection<ChatMessageContent> messages,
        AgentThread? thread = null,
        AzureAIAgentInvokeOptions? options = null,
        [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        Verify.NotNull(messages);

        AzureAIAgentThread azureAIAgentThread = await this.EnsureThreadExistsWithMessagesAsync(
            messages,
            thread,
            () => new AzureAIAgentThread(this.Client),
            cancellationToken).ConfigureAwait(false);

        Kernel kernel = this.GetKernel(options);
#pragma warning disable SKEXP0110, SKEXP0130 // Type is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.
        if (this.UseImmutableKernel)
        {
            kernel = kernel.Clone();
        }

        // Get the context contributions from the AIContextProviders.
        AIContext providersContext = await azureAIAgentThread.AIContextProviders.ModelInvokingAsync(messages, cancellationToken).ConfigureAwait(false);

        // Check for compatibility AIContextProviders and the UseImmutableKernel setting.
        if (providersContext.AIFunctions is { Count: > 0 } && !this.UseImmutableKernel)
        {
            throw new InvalidOperationException("AIContextProviders with AIFunctions are not supported when Agent UseImmutableKernel setting is false.");
        }

        kernel.Plugins.AddFromAIContext(providersContext, "Tools");
#pragma warning restore SKEXP0110, SKEXP0130 // Type is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.

        string mergedAdditionalInstructions = FormatAdditionalInstructions(providersContext, options);
        var extensionsContextOptions = options is null ?
            new AzureAIAgentInvokeOptions() { AdditionalInstructions = mergedAdditionalInstructions } :
            new AzureAIAgentInvokeOptions(options) { AdditionalInstructions = mergedAdditionalInstructions };

        using var activity = ModelDiagnostics.StartAgentInvocationActivity(this.Id, this.GetDisplayName(), this.Description, kernel, messages);
        List<StreamingChatMessageContent>? streamedContents = activity is not null ? [] : null;

        // Invoke the Agent with the thread that we already added our message to, and with
        // a chat history to receive complete messages.
        ChatHistory newMessagesReceiver = [];
        var invokeResults = AgentThreadActions.InvokeStreamingAsync(
            this,
            this.Client,
            azureAIAgentThread.Id!,
            newMessagesReceiver,
            extensionsContextOptions.ToAzureAIInvocationOptions(),
            this.Logger,
            kernel,
            options?.KernelArguments,
            cancellationToken);

        // Return the chunks to the caller.
        int messageIndex = 0;
        await foreach (var result in invokeResults.ConfigureAwait(false))
        {
            // Notify the thread of any messages that were assembled from the streaming response during this iteration.
            await NotifyMessagesAsync().ConfigureAwait(false);

            yield return new(result, azureAIAgentThread);
            streamedContents?.Add(result);
        }

        // Notify the thread of any remaining messages that were assembled from the streaming response after all iterations are complete.
        await NotifyMessagesAsync().ConfigureAwait(false);

        activity?.EndAgentStreamingResponse(streamedContents);

        async Task NotifyMessagesAsync()
        {
            for (; messageIndex < newMessagesReceiver.Count; messageIndex++)
            {
                ChatMessageContent newMessage = newMessagesReceiver[messageIndex];
                await this.NotifyThreadOfNewMessage(azureAIAgentThread, newMessage, cancellationToken).ConfigureAwait(false);

                if (options?.OnIntermediateMessage is not null)
                {
                    await options.OnIntermediateMessage(newMessage).ConfigureAwait(false);
                }
            }
        }
    }

    /// <inheritdoc/>
    protected override IEnumerable<string> GetChannelKeys()
    {
        // Distinguish from other channel types.
        yield return typeof(AzureAIChannel).FullName!;
        // Distinguish based on client instance.
        yield return this.Client.GetHashCode().ToString();
    }

    /// <inheritdoc/>
    protected override async Task<AgentChannel> CreateChannelAsync(CancellationToken cancellationToken)
    {
        this.Logger.LogAzureAIAgentCreatingChannel(nameof(CreateChannelAsync), nameof(AzureAIChannel));

        string threadId = await AgentThreadActions.CreateThreadAsync(this.Client, cancellationToken).ConfigureAwait(false);

        this.Logger.LogInformation("[{MethodName}] Created assistant thread: {ThreadId}", nameof(CreateChannelAsync), threadId);

        AzureAIChannel channel =
            new(this.Client, threadId)
            {
                Logger = this.ActiveLoggerFactory.CreateLogger<AzureAIChannel>()
            };

        this.Logger.LogAzureAIAgentCreatedChannel(nameof(CreateChannelAsync), nameof(AzureAIChannel), threadId);

        return channel;
    }

    internal Task<string?> GetInstructionsAsync(Kernel kernel, KernelArguments? arguments, CancellationToken cancellationToken)
    {
        return this.RenderInstructionsAsync(kernel, arguments, cancellationToken);
    }

    /// <inheritdoc/>
    protected override async Task<AgentChannel> RestoreChannelAsync(string channelState, CancellationToken cancellationToken)
    {
        string threadId = channelState;

        this.Logger.LogAzureAIAgentRestoringChannel(nameof(RestoreChannelAsync), nameof(AzureAIChannel), threadId);

        PersistentAgentThread thread = await this.Client.Threads.GetThreadAsync(threadId, cancellationToken).ConfigureAwait(false);

        this.Logger.LogAzureAIAgentRestoredChannel(nameof(RestoreChannelAsync), nameof(AzureAIChannel), threadId);

        return new AzureAIChannel(this.Client, thread.Id);
    }
}


===== AzureAI\AzureAIAgentExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Diagnostics.CodeAnalysis;
using System.Text.Json;
using MAAI = Microsoft.Agents.AI;

namespace Microsoft.SemanticKernel.Agents.AzureAI;

/// <summary>
/// Exposes a Semantic Kernel Agent Framework <see cref="AzureAIAgent"/> as a Microsoft Agent Framework <see cref="MAAI.AIAgent"/>.
/// </summary>
public static class AzureAIAgentExtensions
{
    /// <summary>
    /// Exposes a Semantic Kernel Agent Framework <see cref="AzureAIAgent"/> as a Microsoft Agent Framework <see cref="MAAI.AIAgent"/>.
    /// </summary>
    /// <param name="azureAIAgent">The Semantic Kernel <see cref="AzureAIAgent"/> to expose as a Microsoft Agent Framework <see cref="MAAI.AIAgent"/>.</param>
    /// <returns>The Semantic Kernel Agent Framework <see cref="Agent"/> exposed as a Microsoft Agent Framework <see cref="MAAI.AIAgent"/></returns>
    [Experimental("SKEXP0110")]
    public static MAAI.AIAgent AsAIAgent(this AzureAIAgent azureAIAgent)
        => azureAIAgent.AsAIAgent(
            () => new AzureAIAgentThread(azureAIAgent.Client),
            (json, options) =>
            {
                var agentId = JsonSerializer.Deserialize<string>(json);
                return agentId is null ? new AzureAIAgentThread(azureAIAgent.Client) : new AzureAIAgentThread(azureAIAgent.Client, agentId);
            },
            (thread, options) => JsonSerializer.SerializeToElement((thread as AzureAIAgentThread)?.Id));
}


===== AzureAI\AzureAIAgentInvokeOptions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Text.Json.Serialization;

namespace Microsoft.SemanticKernel.Agents.AzureAI;

/// <summary>
/// Optional parameters for <see cref="AzureAIAgent"/> invocation.
/// </summary>
public sealed class AzureAIAgentInvokeOptions : AgentInvokeOptions
{
    /// <summary>
    /// Initializes a new instance of the <see cref="AzureAIAgentInvokeOptions"/> class.
    /// </summary>
    public AzureAIAgentInvokeOptions()
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AzureAIAgentInvokeOptions"/> class by cloning the provided options.
    /// </summary>
    /// <param name="options">The options to clone.</param>
    public AzureAIAgentInvokeOptions(AgentInvokeOptions options)
        : base(options)
    {
        Verify.NotNull(options);
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AzureAIAgentInvokeOptions"/> class by cloning the provided options.
    /// </summary>
    /// <param name="options">The options to clone.</param>
    public AzureAIAgentInvokeOptions(AzureAIAgentInvokeOptions options)
        : base(options)
    {
        Verify.NotNull(options);

        this.ModelName = options.ModelName;
        this.OverrideInstructions = options.OverrideInstructions;
        this.AdditionalMessages = options.AdditionalMessages;
        this.EnableCodeInterpreter = options.EnableCodeInterpreter;
        this.EnableFileSearch = options.EnableFileSearch;
        this.EnableJsonResponse = options.EnableJsonResponse;
        this.MaxCompletionTokens = options.MaxCompletionTokens;
        this.MaxPromptTokens = options.MaxPromptTokens;
        this.ParallelToolCallsEnabled = options.ParallelToolCallsEnabled;
        this.TruncationMessageCount = options.TruncationMessageCount;
        this.Temperature = options.Temperature;
        this.TopP = options.TopP;
        this.Metadata = options.Metadata;
    }

    /// <summary>
    /// Gets or sets the AI model targeted by the agent.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public string? ModelName { get; init; }

    /// <summary>
    /// Gets or sets the override instructions.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public string? OverrideInstructions { get; init; }

    /// <summary>
    /// Gets or sets the additional messages to add to the thread.
    /// </summary>
    /// <remarks>
    /// Only supports messages with <see href="https://platform.openai.com/docs/api-reference/runs/createRun#runs-createrun-additional_messages">role = User or Assistant</see>.
    /// </remarks>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public IReadOnlyList<ChatMessageContent>? AdditionalMessages { get; init; }

    /// <summary>
    /// Gets or sets a value that indicates whether the code_interpreter tool is enabled.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public bool EnableCodeInterpreter { get; init; }

    /// <summary>
    /// Gets or sets the additional uploaded files for use with the code-interpe.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public IReadOnlyList<string>? CodeInterpreterFiles { get; init; }

    /// <summary>
    /// Gets or sets a value that indicates whether the file_search tool is enabled.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public bool EnableFileSearch { get; init; }

    /// <summary>
    /// Gets or sets a value that indicates whether the JSON response format is enabled.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public bool? EnableJsonResponse { get; init; }

    /// <summary>
    /// Gets or sets the maximum number of completion tokens that can be used over the course of the run.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public int? MaxCompletionTokens { get; init; }

    /// <summary>
    /// Gets or sets the maximum number of prompt tokens that can be used over the course of the run.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public int? MaxPromptTokens { get; init; }

    /// <summary>
    /// Gets or sets a value that indicates whether the parallel function calling is enabled during tool use.
    /// </summary>
    /// <value>
    /// <see langword="true"/> if parallel function calling is enabled during tool use; otherwise, <see langword="false"/>. The default is <see langword="true"/>.
    /// </value>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public bool? ParallelToolCallsEnabled { get; init; }

    /// <summary>
    /// Gets or sets the number of recent messages that the thread will be truncated to.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public int? TruncationMessageCount { get; init; }

    /// <summary>
    /// Gets or sets the sampling temperature to use, between 0 and 2.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public float? Temperature { get; init; }

    /// <summary>
    /// Gets or sets the probability mass of tokens whose results are considered in nucleus sampling.
    /// </summary>
    /// <remarks>
    /// It's recommended to set this property or <see cref="Temperature"/>, but not both.
    ///
    /// Nucleus sampling is an alternative to sampling with temperature where the model
    /// considers the results of the tokens with <see cref="TopP"/> probability mass.
    /// For example, 0.1 means only the tokens comprising the top 10% probability mass are considered.
    /// </remarks>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public float? TopP { get; init; }

    /// <summary>
    /// Gets or sets a set of up to 16 key/value pairs that can be attached to an agent, used for
    /// storing additional information about that object in a structured format.
    /// </summary>
    /// <remarks>
    /// Keys can be up to 64 characters in length, and values can be up to 512 characters in length.
    /// </remarks>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public IReadOnlyDictionary<string, string>? Metadata { get; init; }

    /// <summary>
    /// Converts the current options to an <see cref="AzureAIInvocationOptions"/> instance.
    /// </summary>
    /// <returns>The converted <see cref="AzureAIInvocationOptions"/> instance.</returns>
    internal AzureAIInvocationOptions ToAzureAIInvocationOptions()
    {
        return new AzureAIInvocationOptions
        {
            ModelName = this.ModelName,
            OverrideInstructions = this.OverrideInstructions,
            AdditionalInstructions = this.AdditionalInstructions,
            AdditionalMessages = this.AdditionalMessages,
            EnableCodeInterpreter = this.EnableCodeInterpreter,
            EnableFileSearch = this.EnableFileSearch,
            EnableJsonResponse = this.EnableJsonResponse,
            MaxCompletionTokens = this.MaxCompletionTokens,
            MaxPromptTokens = this.MaxPromptTokens,
            ParallelToolCallsEnabled = this.ParallelToolCallsEnabled,
            TruncationMessageCount = this.TruncationMessageCount,
            Temperature = this.Temperature,
            TopP = this.TopP,
            Metadata = this.Metadata
        };
    }
}


===== AzureAI\AzureAIAgentThread.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.AI.Agents.Persistent;
using Microsoft.SemanticKernel.Agents.AzureAI.Internal;

namespace Microsoft.SemanticKernel.Agents.AzureAI;

/// <summary>
/// Represents a conversation thread for an Azure AI agent.
/// </summary>
public sealed class AzureAIAgentThread : AgentThread
{
    private readonly PersistentAgentsClient _client;
    private readonly IEnumerable<ThreadMessageOptions>? _messages;
    private readonly ToolResources? _toolResources;
    private readonly IReadOnlyDictionary<string, string>? _metadata;

    /// <summary>
    /// Initializes a new instance of the <see cref="AzureAIAgentThread"/> class.
    /// </summary>
    /// <param name="client">The agents client to use for interacting with threads.</param>
    /// <param name="messages">The initial messages to associate with the new thread after it is created.</param>
    /// <param name="toolResources">
    /// A set of resources that are made available to the agent's tools in this thread. The resources are specific to the
    /// type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires
    /// a list of vector store IDs.
    /// </param>
    /// <param name="metadata">Metadata to attach to the underlying thread when it is created..</param>
    public AzureAIAgentThread(
        PersistentAgentsClient client,
        IEnumerable<ThreadMessageOptions>? messages = null,
        ToolResources? toolResources = null,
        IReadOnlyDictionary<string, string>? metadata = null)
    {
        Verify.NotNull(client);

        this._client = client;
        this._messages = messages;
        this._toolResources = toolResources;
        this._metadata = metadata;
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AzureAIAgentThread"/> class that resumes an existing thread.
    /// </summary>
    /// <param name="client">The agents client to use for interacting with threads.</param>
    /// <param name="id">The ID of an existing thread to resume.</param>
    public AzureAIAgentThread(PersistentAgentsClient client, string id)
    {
        Verify.NotNull(client);
        Verify.NotNull(id);

        this._client = client;
        this.Id = id;
    }

    /// <summary>
    /// Creates the thread and returns the thread id.
    /// </summary>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>A task that completes when the thread has been created.</returns>
    public new Task CreateAsync(CancellationToken cancellationToken = default)
    {
        return base.CreateAsync(cancellationToken);
    }

    /// <inheritdoc />
    protected async override Task<string?> CreateInternalAsync(CancellationToken cancellationToken)
    {
        const string ErrorMessage = "The thread could not be created due to an error response from the service.";

        try
        {
            var agentThreadResponse = await this._client.Threads.CreateThreadAsync(
                this._messages,
                this._toolResources,
                this._metadata,
                cancellationToken: cancellationToken).ConfigureAwait(false);
            return agentThreadResponse.Value.Id;
        }
        catch (RequestFailedException ex)
        {
            throw new AgentThreadOperationException(ErrorMessage, ex);
        }
        catch (AggregateException ex)
        {
            throw new AgentThreadOperationException(ErrorMessage, ex);
        }
    }

    /// <inheritdoc />
    protected override async Task DeleteInternalAsync(CancellationToken cancellationToken)
    {
        const string ErrorMessage = "The thread could not be deleted due to an error response from the service.";

        try
        {
            await this._client.Threads.DeleteThreadAsync(this.Id, cancellationToken).ConfigureAwait(false);
        }
        catch (RequestFailedException ex) when (ex.Status == 404)
        {
            // Do nothing, since the thread was already deleted.
        }
        catch (RequestFailedException ex)
        {
            throw new AgentThreadOperationException(ErrorMessage, ex);
        }
        catch (AggregateException ex)
        {
            throw new AgentThreadOperationException(ErrorMessage, ex);
        }
    }

    /// <inheritdoc />
    protected override async Task OnNewMessageInternalAsync(ChatMessageContent newMessage, CancellationToken cancellationToken = default)
    {
        const string ErrorMessage = "The message could not be added to the thread due to an error response from the service.";

        // If the message was generated by this agent, it is already in the thread and we shouldn't add it again.
        if (newMessage.Metadata == null || !newMessage.Metadata.TryGetValue("ThreadId", out var messageThreadId) || !string.Equals(messageThreadId, this.Id))
        {
            try
            {
                await AgentThreadActions.CreateMessageAsync(this._client, this.Id!, newMessage, cancellationToken).ConfigureAwait(false);
            }
            catch (RequestFailedException ex)
            {
                throw new AgentThreadOperationException(ErrorMessage, ex);
            }
            catch (AggregateException ex)
            {
                throw new AgentThreadOperationException(ErrorMessage, ex);
            }
        }
    }

    /// <summary>
    /// Asynchronously retrieves all messages in the thread.
    /// </summary>
    /// <param name="sortOrder">The order to return messages in.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>The messages in the thread.</returns>
    /// <exception cref="InvalidOperationException">The thread has been deleted.</exception>
    [Experimental("SKEXP0110")]
    public async IAsyncEnumerable<ChatMessageContent> GetMessagesAsync(ListSortOrder? sortOrder = default, [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        if (this.IsDeleted)
        {
            throw new InvalidOperationException("This thread has been deleted and cannot be used anymore.");
        }

        if (this.Id is null)
        {
            await this.CreateAsync(cancellationToken).ConfigureAwait(false);
        }

        await foreach (var message in AgentThreadActions.GetMessagesAsync(this._client, this.Id!, sortOrder, cancellationToken).ConfigureAwait(false))
        {
            yield return message;
        }
    }
}


===== AzureAI\AzureAIChannel.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.AI.Agents.Persistent;
using Microsoft.SemanticKernel.Agents.AzureAI.Internal;
using Microsoft.SemanticKernel.Agents.Extensions;
using Microsoft.SemanticKernel.Diagnostics;

namespace Microsoft.SemanticKernel.Agents.AzureAI;

/// <summary>
/// A <see cref="AgentChannel"/> specialization for use with <see cref="AzureAIAgent"/>.
/// </summary>
internal sealed class AzureAIChannel(PersistentAgentsClient client, string threadId)
    : AgentChannel<AzureAIAgent>
{
    /// <inheritdoc/>
    protected override async Task ReceiveAsync(IEnumerable<ChatMessageContent> history, CancellationToken cancellationToken)
    {
        const string ErrorMessage = "The message could not be added to the thread due to an error response from the service.";

        foreach (ChatMessageContent message in history)
        {
            try
            {
                await AgentThreadActions.CreateMessageAsync(client, threadId, message, cancellationToken).ConfigureAwait(false);
            }
            catch (RequestFailedException ex)
            {
                throw new AgentThreadOperationException(ErrorMessage, ex);
            }
            catch (AggregateException ex)
            {
                throw new AgentThreadOperationException(ErrorMessage, ex);
            }
        }
    }

    /// <inheritdoc/>
    protected override IAsyncEnumerable<(bool IsVisible, ChatMessageContent Message)> InvokeAsync(
        AzureAIAgent agent,
        CancellationToken cancellationToken)
    {
        return ActivityExtensions.RunWithActivityAsync(
            () => ModelDiagnostics.StartAgentInvocationActivity(agent.Id, agent.GetDisplayName(), agent.Description, agent.Kernel, []),
            () => AgentThreadActions.InvokeAsync(agent, client, threadId, invocationOptions: null, this.Logger, agent.Kernel, agent.Arguments, cancellationToken),
            cancellationToken);
    }

    /// <inheritdoc/>
    protected override IAsyncEnumerable<StreamingChatMessageContent> InvokeStreamingAsync(AzureAIAgent agent, IList<ChatMessageContent> messages, CancellationToken cancellationToken = default)
    {
        return ActivityExtensions.RunWithActivityAsync(
            () => ModelDiagnostics.StartAgentInvocationActivity(agent.Id, agent.GetDisplayName(), agent.Description, agent.Kernel, messages),
            () => AgentThreadActions.InvokeStreamingAsync(agent, client, threadId, messages, invocationOptions: null, this.Logger, agent.Kernel, agent.Arguments, cancellationToken),
            cancellationToken);
    }

    /// <inheritdoc/>
    protected override IAsyncEnumerable<ChatMessageContent> GetHistoryAsync(CancellationToken cancellationToken)
    {
        return AgentThreadActions.GetMessagesAsync(client, threadId, null, cancellationToken);
    }

    /// <inheritdoc/>
    protected override Task ResetAsync(CancellationToken cancellationToken = default)
    {
        return client.Threads.DeleteThreadAsync(threadId, cancellationToken);
    }

    /// <inheritdoc/>
    protected override string Serialize() { return threadId; }
}


===== AzureAI\AzureAIInvocationOptions.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Collections.Generic;
using System.Text.Json.Serialization;

namespace Microsoft.SemanticKernel.Agents.AzureAI;

/// <summary>
/// Defines per-invocation execution options that override the assistant definition.
/// </summary>
/// <remarks>
/// This class is not applicable to <see cref="AgentChat"/> usage.
/// </remarks>
public sealed class AzureAIInvocationOptions
{
    /// <summary>
    /// Gets the AI model targeted by the agent.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public string? ModelName { get; init; }

    /// <summary>
    /// Gets the override instructions.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public string? OverrideInstructions { get; init; }

    /// <summary>
    /// Gets the additional instructions.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public string? AdditionalInstructions { get; init; }

    /// <summary>
    /// Gets the additional messages to add to the thread.
    /// </summary>
    /// <remarks>
    /// Only supports messages with <see href="https://platform.openai.com/docs/api-reference/runs/createRun#runs-createrun-additional_messages">role = User or Assistant</see>.
    /// </remarks>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public IReadOnlyList<ChatMessageContent>? AdditionalMessages { get; init; }

    /// <summary>
    /// Gets a value that indicates whether the code_interpreter tool is enabled.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public bool EnableCodeInterpreter { get; init; }

    /// <summary>
    /// Gets a value that indicates whether the file_search tool is enabled.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public bool EnableFileSearch { get; init; }

    /// <summary>
    /// Gets a value that indicates whether the JSON response format is enabled.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public bool? EnableJsonResponse { get; init; }

    /// <summary>
    /// Gets the maximum number of completion tokens that can be used over the course of the run.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public int? MaxCompletionTokens { get; init; }

    /// <summary>
    /// Gets the maximum number of prompt tokens that can be used over the course of the run.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public int? MaxPromptTokens { get; init; }

    /// <summary>
    /// Gets a value that indicates whether the parallel function calling is enabled during tool use.
    /// </summary>
    /// <value>
    /// <see langword="true"/> if parallel function calling is enabled during tool use; otherwise, <see langword="false"/>. The default is <see langword="true"/>.
    /// </value>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public bool? ParallelToolCallsEnabled { get; init; }

    /// <summary>
    /// Gets the number of recent messages that the thread will be truncated to.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public int? TruncationMessageCount { get; init; }

    /// <summary>
    /// Gets the sampling temperature to use, between 0 and 2.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public float? Temperature { get; init; }

    /// <summary>
    /// Gets the probability mass of tokens whose results are considered in nucleus sampling.
    /// </summary>
    /// <remarks>
    /// It's recommended to set this property or <see cref="Temperature"/>, but not both.
    ///
    /// Nucleus sampling is an alternative to sampling with temperature where the model
    /// considers the results of the tokens with <see cref="TopP"/> probability mass.
    /// For example, 0.1 means only the tokens comprising the top 10% probability mass are considered.
    /// </remarks>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public float? TopP { get; init; }

    /// <summary>
    /// Gets a set of up to 16 key/value pairs that can be attached to an agent, used for
    /// storing additional information about that object in a structured format.
    /// </summary>
    /// <remarks>
    /// Keys can be up to 64 characters in length, and values can be up to 512 characters in length.
    /// </remarks>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public IReadOnlyDictionary<string, string>? Metadata { get; init; }
}


===== AzureAI\AzureAIThreadMessageFactory.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Collections.Generic;
using Azure.AI.Agents.Persistent;
using Microsoft.SemanticKernel.Agents.AzureAI.Internal;

namespace Microsoft.SemanticKernel.Agents.AzureAI;

/// <summary>
/// Exposes patterns for creating and managing agent threads.
/// </summary>
/// <remarks>
/// This class supports translation of <see cref="ChatMessageContent"/> from native models.
/// </remarks>
public static class AzureAIThreadMessageFactory
{
    /// <summary>
    /// Translates <see cref="ChatMessageContent"/> to <see cref="ThreadMessageOptions"/> for thread creation.
    /// </summary>
    public static IEnumerable<ThreadMessageOptions> Translate(IEnumerable<ChatMessageContent> messages)
    {
        return AgentMessageFactory.GetThreadMessages(messages);
    }
}


===== AzureAI\Definition\AzureAIAgentFactory.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Diagnostics.CodeAnalysis;
using System.Threading;
using System.Threading.Tasks;
using Azure.AI.Agents.Persistent;

namespace Microsoft.SemanticKernel.Agents.AzureAI;

/// <summary>
/// Provides a <see cref="AgentFactory"/> which creates instances of <see cref="AzureAIAgent"/>.
/// </summary>
[Experimental("SKEXP0110")]
public sealed class AzureAIAgentFactory : AgentFactory
{
    /// <summary>
    /// The type of the Azure AI agent.
    /// </summary>
    public const string AzureAIAgentType = "foundry_agent";

    /// <summary>
    /// Initializes a new instance of the <see cref="AzureAIAgentFactory"/> class.
    /// </summary>
    public AzureAIAgentFactory()
        : base([AzureAIAgentType])
    {
    }

    /// <inheritdoc/>
    public override async Task<Agent?> TryCreateAsync(Kernel kernel, AgentDefinition agentDefinition, AgentCreationOptions? agentCreationOptions = null, CancellationToken cancellationToken = default)
    {
        Verify.NotNull(agentDefinition);

        if (agentDefinition.Type?.Equals(AzureAIAgentType, System.StringComparison.Ordinal) ?? false)
        {
            var client = agentDefinition.GetAgentsClient(kernel);

            PersistentAgent agent;
            if (!string.IsNullOrEmpty(agentDefinition.Id))
            {
                // Get an existing agent
                agent = await client.Administration.GetAgentAsync(
                    agentDefinition.Id,
                    cancellationToken: cancellationToken).ConfigureAwait(false);

                return new AzureAIAgent(agent, client)
                {
                    Kernel = kernel,
                    Arguments = agentDefinition.GetDefaultKernelArguments(kernel) ?? [],
                    Template = agentDefinition.GetPromptTemplate(kernel, agentCreationOptions?.PromptTemplateFactory),
                    Instructions = agentDefinition.Instructions ?? agent.Instructions,
                };
            }

            // Create a new agent
            Verify.NotNull(agentDefinition.Model);
            Verify.NotNull(agentDefinition.Model.Id);

            agent = await client.Administration.CreateAgentAsync(
                model: agentDefinition.Model.Id,
                name: agentDefinition.Name,
                description: agentDefinition.Description,
                instructions: agentDefinition.Instructions,
                tools: agentDefinition.GetAzureToolDefinitions(kernel),
                toolResources: agentDefinition.GetAzureToolResources(),
                metadata: agentDefinition.GetMetadata(),
                cancellationToken: cancellationToken).ConfigureAwait(false);

            return new AzureAIAgent(agent, client)
            {
                Kernel = kernel,
                Arguments = agentDefinition.GetDefaultKernelArguments(kernel) ?? [],
                Template = agentDefinition.GetPromptTemplate(kernel, agentCreationOptions?.PromptTemplateFactory),
            };
        }

        return null;
    }
}


===== AzureAI\Extensions\AgentDefinitionExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.Collections.Generic;
using System.Linq;
using Azure.AI.Agents.Persistent;
using Azure.AI.Projects;
using Azure.Core;
using Azure.Core.Pipeline;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.SemanticKernel.Http;

namespace Microsoft.SemanticKernel.Agents.AzureAI;

/// <summary>
/// Provides extension methods for <see cref="AgentDefinition"/>.
/// </summary>
internal static class AgentDefinitionExtensions
{
    private const string AzureAISearchType = "azure_ai_search";
    private const string AzureFunctionType = "azure_function";
    private const string BingGroundingType = "bing_grounding";
    private const string CodeInterpreterType = "code_interpreter";
    private const string FileSearchType = "file_search";
    private const string FunctionType = "function";
    private const string OpenApiType = "openapi";

    private static readonly string[] s_validToolTypes =
    [
        AzureAISearchType,
        AzureFunctionType,
        BingGroundingType,
        CodeInterpreterType,
        FileSearchType,
        FunctionType,
        OpenApiType,
    ];

    private const string Endpoint = "endpoint";

    /// <summary>
    /// Return the Azure AI tool definitions which corresponds with the provided <see cref="AgentDefinition"/>.
    /// </summary>
    /// <param name="agentDefinition">Agent definition</param>
    /// <param name="kernel">Kernel instance to associate with the agent.</param>
    /// <exception cref="InvalidOperationException"></exception>
    public static IEnumerable<ToolDefinition> GetAzureToolDefinitions(this AgentDefinition agentDefinition, Kernel kernel)
    {
        Verify.NotNull(agentDefinition);

        return agentDefinition.Tools?.Select<AgentToolDefinition, ToolDefinition>(tool =>
        {
            return tool.Type switch
            {
                AzureAISearchType => CreateAzureAISearchToolDefinition(tool),
                AzureFunctionType => CreateAzureFunctionToolDefinition(tool),
                BingGroundingType => CreateBingGroundingToolDefinition(tool, agentDefinition.GetProjectsClient(kernel)),
                CodeInterpreterType => CreateCodeInterpreterToolDefinition(tool),
                FileSearchType => CreateFileSearchToolDefinition(tool),
                FunctionType => CreateFunctionToolDefinition(tool),
                OpenApiType => CreateOpenApiToolDefinition(tool),
                _ => throw new NotSupportedException($"Unable to create Azure AI tool definition because of unsupported tool type: {tool.Type}, supported tool types are: {string.Join(",", s_validToolTypes)}"),
            };
        }) ?? [];
    }

    /// <summary>
    /// Return the Azure AI tool resources which corresponds with the provided <see cref="AgentDefinition"/>.
    /// </summary>
    /// <param name="agentDefinition">Agent definition</param>
    public static ToolResources GetAzureToolResources(this AgentDefinition agentDefinition)
    {
        Verify.NotNull(agentDefinition);

        var toolResources = new ToolResources();

        var codeInterpreter = agentDefinition.GetCodeInterpreterToolResource();
        if (codeInterpreter is not null)
        {
            toolResources.CodeInterpreter = codeInterpreter;
        }
        var fileSearch = agentDefinition.GetFileSearchToolResource();
        if (fileSearch is not null)
        {
            toolResources.FileSearch = fileSearch;
        }
        var azureAISearch = agentDefinition.GetAzureAISearchResource();
        if (azureAISearch is not null)
        {
            toolResources.AzureAISearch = azureAISearch;
        }

        return toolResources;
    }

    /// <summary>
    /// Retrieve the metadata from the agent definition.
    /// </summary>
    /// <param name="agentDefinition">Agent definition</param>
    public static IReadOnlyDictionary<string, string>? GetMetadata(this AgentDefinition agentDefinition)
    {
        Verify.NotNull(agentDefinition);

        // TODO: Implement
        return null;
    }

    /// <summary>
    /// Return the <see cref="PersistentAgentsClient"/> to be used with the specified <see cref="AgentDefinition"/>.
    /// </summary>
    /// <param name="agentDefinition">Agent definition which will be used to provide connection for the <see cref="PersistentAgentsClient"/>.</param>
    /// <param name="kernel">Kernel instance which will be used to resolve a default <see cref="PersistentAgentsClient"/>.</param>
    public static PersistentAgentsClient GetAgentsClient(this AgentDefinition agentDefinition, Kernel kernel)
    {
        Verify.NotNull(agentDefinition);

        // Use the agent connection as the first option
        var connection = agentDefinition?.Model?.Connection;
        if (connection is not null)
        {
            if (connection.ExtensionData.TryGetValue(Endpoint, out var value) && value is string endpoint)
            {
#pragma warning disable CA2000 // Dispose objects before losing scope, not relevant because the HttpClient is created and may be used elsewhere
                var httpClient = HttpClientProvider.GetHttpClient(kernel.Services);
#pragma warning restore CA2000 // Dispose objects before losing scope

                var tokenCredential = kernel.Services.GetRequiredService<TokenCredential>();
                return AzureAIAgent.CreateAgentsClient(endpoint, tokenCredential, httpClient);
            }
        }

        // Return the client registered on the kernel
        var client = kernel.GetAllServices<PersistentAgentsClient>().FirstOrDefault();
        return client ?? throw new InvalidOperationException("AzureAI agents client not found.");
    }

    /// <summary>
    /// Return the <see cref="PersistentAgentsClient"/> to be used with the specified <see cref="AgentDefinition"/>.
    /// </summary>
    /// <param name="agentDefinition">Agent definition which will be used to provide connection for the <see cref="PersistentAgentsClient"/>.</param>
    /// <param name="kernel">Kernel instance which will be used to resolve a default <see cref="PersistentAgentsClient"/>.</param>
    public static AIProjectClient GetProjectsClient(this AgentDefinition agentDefinition, Kernel kernel)
    {
        Verify.NotNull(agentDefinition);

        // Use the agent connection as the first option
        var connection = agentDefinition?.Model?.Connection;
        if (connection is not null)
        {
            if (connection.ExtensionData.TryGetValue(Endpoint, out var value) && value is string endpoint)
            {
#pragma warning disable CA2000 // Dispose objects before losing scope, not relevant because the HttpClient is created and may be used elsewhere
                var httpClient = HttpClientProvider.GetHttpClient(kernel.Services);
#pragma warning restore CA2000 // Dispose objects before losing scope

                var tokenCredential = kernel.Services.GetRequiredService<TokenCredential>();
                AIProjectClientOptions options =
                    new()
                    {
                        Transport = new HttpClientTransport(httpClient),
                        RetryPolicy = new RetryPolicy(maxRetries: 0) // Disable retry policy if a custom HttpClient is provided.
                    };
                return new AIProjectClient(new Uri(endpoint), tokenCredential, options);
            }
        }

        // Return the client registered on the kernel
        var client = kernel.GetAllServices<AIProjectClient>().FirstOrDefault();
        return client ?? throw new InvalidOperationException("AzureAI project client not found.");
    }

    #region private
    private static CodeInterpreterToolResource? GetCodeInterpreterToolResource(this AgentDefinition agentDefinition)
    {
        Verify.NotNull(agentDefinition);

        CodeInterpreterToolResource? resource = null;

        var codeInterpreter = agentDefinition.GetFirstToolDefinition(CodeInterpreterType);
        if (codeInterpreter is not null)
        {
            var fileIds = codeInterpreter.GetFileIds();
            var dataSources = codeInterpreter.GetDataSources();
            if (fileIds is not null || dataSources is not null)
            {
                resource = new CodeInterpreterToolResource();
                if (fileIds is not null)
                {
                    resource.FileIds.AddRange(fileIds);
                }
                if (dataSources is not null)
                {
                    resource.DataSources.AddRange(dataSources);
                }
            }
        }

        return resource;
    }

    private static FileSearchToolResource? GetFileSearchToolResource(this AgentDefinition agentDefinition)
    {
        Verify.NotNull(agentDefinition);

        var fileSearch = agentDefinition.GetFirstToolDefinition(FileSearchType);
        if (fileSearch is not null)
        {
            var vectorStoreIds = fileSearch.GetVectorStoreIds();
            var vectorStores = fileSearch.GetVectorStoreConfigurations();
            if (vectorStoreIds is not null || vectorStores is not null)
            {
                return new FileSearchToolResource(vectorStoreIds, vectorStores);
            }
        }

        return null;
    }

    private static AzureAISearchToolResource? GetAzureAISearchResource(this AgentDefinition agentDefinition)
    {
        Verify.NotNull(agentDefinition);

        var azureAISearch = agentDefinition.GetFirstToolDefinition(AzureAISearchType);
        if (azureAISearch is not null)
        {
            string? indexConnectionId = azureAISearch.GetOption<string>("index_connection_id");
            string? indexName = azureAISearch.GetOption<string>("index_name");
            if (string.IsNullOrEmpty(indexConnectionId) && string.IsNullOrEmpty(indexName))
            {
                return null;
            }
            if (string.IsNullOrEmpty(indexConnectionId) || string.IsNullOrEmpty(indexName))
            {
                throw new InvalidOperationException("Azure AI Search tool definition must have both 'index_connection_id' and 'index_name' options set.");
            }
            int topK = azureAISearch.GetTopK() ?? 5;
            string filter = azureAISearch.GetFilter() ?? string.Empty;
            AzureAISearchQueryType? queryType = azureAISearch.GetAzureAISearchQueryType();

            return new AzureAISearchToolResource(indexConnectionId, indexName, topK, filter, queryType);
        }

        return null;
    }

    private static AzureAISearchToolDefinition CreateAzureAISearchToolDefinition(AgentToolDefinition tool)
    {
        Verify.NotNull(tool);

        return new AzureAISearchToolDefinition();
    }

    private static AzureFunctionToolDefinition CreateAzureFunctionToolDefinition(AgentToolDefinition tool)
    {
        Verify.NotNull(tool);
        Verify.NotNull(tool.Id);
        Verify.NotNull(tool.Description);

        string name = tool.Id;
        string description = tool.Description;
        AzureFunctionBinding inputBinding = tool.GetInputBinding();
        AzureFunctionBinding outputBinding = tool.GetOutputBinding();
        BinaryData parameters = tool.GetParameters();

        return new AzureFunctionToolDefinition(name, description, inputBinding, outputBinding, parameters);
    }

    private static BingGroundingToolDefinition CreateBingGroundingToolDefinition(AgentToolDefinition tool, AIProjectClient projectClient)
    {
        Verify.NotNull(tool);

        IEnumerable<string> connectionIds = projectClient.GetConnectionIds(tool);
        BingGroundingSearchToolParameters bingToolParameters = new([new BingGroundingSearchConfiguration(connectionIds.Single())]);

        return new BingGroundingToolDefinition(bingToolParameters);
    }

    private static CodeInterpreterToolDefinition CreateCodeInterpreterToolDefinition(AgentToolDefinition tool)
    {
        return new CodeInterpreterToolDefinition();
    }

    private static FileSearchToolDefinition CreateFileSearchToolDefinition(AgentToolDefinition tool)
    {
        Verify.NotNull(tool);

        return new FileSearchToolDefinition()
        {
            FileSearch = tool.GetFileSearchToolDefinitionDetails()
        };
    }

    private static FunctionToolDefinition CreateFunctionToolDefinition(AgentToolDefinition tool)
    {
        Verify.NotNull(tool);
        Verify.NotNull(tool.Id);
        Verify.NotNull(tool.Description);

        string name = tool.Id;
        string description = tool.Description;
        BinaryData parameters = tool.GetParameters();

        return new FunctionToolDefinition(name, description, parameters);
    }

    private static OpenApiToolDefinition CreateOpenApiToolDefinition(AgentToolDefinition tool)
    {
        Verify.NotNull(tool);
        Verify.NotNull(tool.Id);
        Verify.NotNull(tool.Description);

        string name = tool.Id;
        string description = tool.Description;
        BinaryData spec = tool.GetSpecification();
        OpenApiAuthDetails auth = tool.GetOpenApiAuthDetails();

        return new OpenApiToolDefinition(name, description, spec, auth);
    }

    private static IEnumerable<string> GetConnectionIds(this AIProjectClient projectClient, AgentToolDefinition tool)
    {
        HashSet<string> connections = [.. tool.GetToolConnections()];
        Connections connectionClient = projectClient.GetConnectionsClient();
        return
            connectionClient.GetConnections()
                .Where(connection => connections.Contains(connection.Name))
                .Select(connection => connection.Id);
    }
    #endregion
}


===== AzureAI\Extensions\AgentRunExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.AI.Agents.Persistent;
using Microsoft.SemanticKernel.Agents.AzureAI.Internal;

namespace Microsoft.SemanticKernel.Agents.AzureAI.Extensions;

/// <summary>
/// Extensions associated with an Agent run processing.
/// </summary>
/// <remarks>
/// Improves testability.
/// </remarks>
internal static class AgentRunExtensions
{
    public static async IAsyncEnumerable<RunStep> GetStepsAsync(
           this PersistentAgentsClient client,
           ThreadRun run,
           [EnumeratorCancellation] CancellationToken cancellationToken)
    {
        AsyncPageable<RunStep>? steps = client.Runs.GetRunStepsAsync(run, cancellationToken: cancellationToken);
        await foreach (RunStep step in steps.ConfigureAwait(false))
        {
            yield return step;
        }
    }

    public static async Task<ThreadRun> CreateAsync(
        this PersistentAgentsClient client,
        string threadId,
        AzureAIAgent agent,
        string? instructions,
        ToolDefinition[] tools,
        AzureAIInvocationOptions? invocationOptions,
        CancellationToken cancellationToken)
    {
        Truncation? truncationStrategy = GetTruncationStrategy(invocationOptions);
        BinaryData? responseFormat = GetResponseFormat(invocationOptions);
        return
            await client.Runs.CreateRunAsync(
                threadId,
                agent.Id,
                overrideModelName: invocationOptions?.ModelName,
                overrideInstructions: invocationOptions?.OverrideInstructions ?? instructions,
                additionalInstructions: invocationOptions?.AdditionalInstructions,
                additionalMessages: [.. AgentMessageFactory.GetThreadMessages(invocationOptions?.AdditionalMessages)],
                overrideTools: tools,
                stream: false,
                temperature: invocationOptions?.Temperature,
                topP: invocationOptions?.TopP,
                maxPromptTokens: invocationOptions?.MaxPromptTokens,
                maxCompletionTokens: invocationOptions?.MaxCompletionTokens,
                truncationStrategy,
                toolChoice: null,
                responseFormat,
                parallelToolCalls: invocationOptions?.ParallelToolCallsEnabled,
                metadata: invocationOptions?.Metadata,
                include: null,
                cancellationToken).ConfigureAwait(false);
    }

    private static BinaryData? GetResponseFormat(AzureAIInvocationOptions? invocationOptions)
    {
        return invocationOptions?.EnableJsonResponse == true ?
            BinaryData.FromString(
                """
                {
                    "type": "json_object"
                }                        
                """) :
            null;
    }

    private static Truncation? GetTruncationStrategy(AzureAIInvocationOptions? invocationOptions)
    {
        return invocationOptions?.TruncationMessageCount == null ?
            null :
            new(TruncationStrategy.LastMessages)
            {
                LastMessages = invocationOptions.TruncationMessageCount
            };
    }

    public static IAsyncEnumerable<StreamingUpdate> CreateStreamingAsync(
        this PersistentAgentsClient client,
        string threadId,
        AzureAIAgent agent,
        string? instructions,
        ToolDefinition[] tools,
        AzureAIInvocationOptions? invocationOptions,
        CancellationToken cancellationToken)
    {
        Truncation? truncationStrategy = GetTruncationStrategy(invocationOptions);
        BinaryData? responseFormat = GetResponseFormat(invocationOptions);
        return
            client.Runs.CreateRunStreamingAsync(
                threadId,
                agent.Id,
                overrideModelName: invocationOptions?.ModelName,
                overrideInstructions: invocationOptions?.OverrideInstructions ?? instructions,
                additionalInstructions: invocationOptions?.AdditionalInstructions,
                additionalMessages: [.. AgentMessageFactory.GetThreadMessages(invocationOptions?.AdditionalMessages)],
                overrideTools: tools,
                temperature: invocationOptions?.Temperature,
                topP: invocationOptions?.TopP,
                maxPromptTokens: invocationOptions?.MaxPromptTokens,
                maxCompletionTokens: invocationOptions?.MaxCompletionTokens,
                truncationStrategy,
                toolChoice: null,
                responseFormat,
                parallelToolCalls: invocationOptions?.ParallelToolCallsEnabled,
                metadata: invocationOptions?.Metadata,
                cancellationToken);
    }
}


===== AzureAI\Extensions\AgentToolDefinitionExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Linq;
using Azure.AI.Agents.Persistent;

namespace Microsoft.SemanticKernel.Agents.AzureAI;

/// <summary>
/// Provides extension methods for <see cref="AgentToolDefinition"/>.
/// </summary>
internal static class AgentToolDefinitionExtensions
{
    internal static AzureFunctionBinding GetInputBinding(this AgentToolDefinition agentToolDefinition)
    {
        return agentToolDefinition.GetAzureFunctionBinding("input_binding");
    }

    internal static AzureFunctionBinding GetOutputBinding(this AgentToolDefinition agentToolDefinition)
    {
        return agentToolDefinition.GetAzureFunctionBinding("output_binding");
    }

    internal static BinaryData GetParameters(this AgentToolDefinition agentToolDefinition)
    {
        var parameters = agentToolDefinition.GetOption<List<object>?>("parameters");
        return parameters is not null ? CreateParameterSpec(parameters) : s_noParams;
    }

    internal static BinaryData CreateParameterSpec(List<object> parameters)
    {
        JsonSchemaFunctionParameters parameterSpec = new();
        foreach (var parameter in parameters)
        {
            var parameterProps = parameter as Dictionary<object, object>;
            if (parameterProps is not null)
            {
                bool isRequired = parameterProps.TryGetValue("required", out var requiredValue) && requiredValue is string requiredString && requiredString.Equals("true", StringComparison.OrdinalIgnoreCase);
                string? name = parameterProps.TryGetValue("name", out var nameValue) && nameValue is string nameString ? nameString : null;
                string? type = parameterProps.TryGetValue("type", out var typeValue) && typeValue is string typeString ? typeString : null;
                string? description = parameterProps.TryGetValue("description", out var descriptionValue) && descriptionValue is string descriptionString ? descriptionString : string.Empty;

                if (string.IsNullOrEmpty(name) || string.IsNullOrEmpty(type))
                {
                    throw new ArgumentException("The option keys 'name' and 'type' are required for a parameter.");
                }

                if (isRequired)
                {
                    parameterSpec.Required.Add(name!);
                }
                parameterSpec.Properties.Add(name!, KernelJsonSchema.Parse($"{{ \"type\": \"{type}\", \"description\": \"{description}\" }}"));
            }
        }

        return BinaryData.FromObjectAsJson(parameterSpec);
    }

    internal static FileSearchToolDefinitionDetails GetFileSearchToolDefinitionDetails(this AgentToolDefinition agentToolDefinition)
    {
        var details = new FileSearchToolDefinitionDetails();
        var maxNumResults = agentToolDefinition.GetOption<int?>("max_num_results");
        if (maxNumResults is not null && maxNumResults > 0)
        {
            details.MaxNumResults = maxNumResults;
        }

        FileSearchRankingOptions? rankingOptions = agentToolDefinition.GetFileSearchRankingOptions();
        if (rankingOptions is not null)
        {
            details.RankingOptions = rankingOptions;
        }

        return details;
    }

    internal static BinaryData GetSpecification(this AgentToolDefinition agentToolDefinition)
    {
        Verify.NotNull(agentToolDefinition.Options);

        var specification = agentToolDefinition.GetRequiredOption<object>("specification");
        if (specification is string specificationStr)
        {
            return new BinaryData(specificationStr);
        }

        return new BinaryData(specification);
    }

    internal static OpenApiAuthDetails GetOpenApiAuthDetails(this AgentToolDefinition agentToolDefinition)
    {
        var connectionId = agentToolDefinition.GetOption<string>("connection_id");
        if (!string.IsNullOrEmpty(connectionId))
        {
            return new OpenApiConnectionAuthDetails(new OpenApiConnectionSecurityScheme(connectionId));
        }

        var audience = agentToolDefinition.GetOption<string>("audience");
        if (!string.IsNullOrEmpty(audience))
        {
            return new OpenApiManagedAuthDetails(new OpenApiManagedSecurityScheme(audience));
        }

        return new OpenApiAnonymousAuthDetails();
    }

    internal static List<string>? GetVectorStoreIds(this AgentToolDefinition agentToolDefinition)
    {
        return agentToolDefinition.GetOption<List<object>>("vector_store_ids")?.Select(id => $"{id}").ToList();
    }

    internal static List<string>? GetFileIds(this AgentToolDefinition agentToolDefinition)
    {
        return agentToolDefinition.GetOption<List<object>>("file_ids")?.Select(id => id.ToString()!).ToList();
    }

    internal static List<VectorStoreDataSource>? GetDataSources(this AgentToolDefinition agentToolDefinition)
    {
        var dataSources = agentToolDefinition.GetOption<List<object>?>("data_sources");
        return dataSources is not null ? CreateDataSources(dataSources) : null;
    }

    internal static List<VectorStoreDataSource> CreateDataSources(List<object> values)
    {
        List<VectorStoreDataSource> dataSources = [];
        foreach (var value in values)
        {
            if (value is Dictionary<object, object> dataSourceDict)
            {
                string? assetIdentifier = dataSourceDict.TryGetValue("asset_identifier", out var identifierValue) && identifierValue is string identifierString ? identifierString : null;
                string? assetType = dataSourceDict.TryGetValue("asset_type", out var typeValue) && typeValue is string typeString ? typeString : null;

                if (string.IsNullOrEmpty(assetIdentifier) || string.IsNullOrEmpty(assetType))
                {
                    throw new ArgumentException("The option keys 'asset_identifier' and 'asset_type' are required for a vector store data source.");
                }

                dataSources.Add(new VectorStoreDataSource(assetIdentifier, new VectorStoreDataSourceAssetType(assetType)));
            }
        }

        return dataSources;
    }

    internal static IList<VectorStoreConfigurations>? GetVectorStoreConfigurations(this AgentToolDefinition agentToolDefinition)
    {
        var dataSources = agentToolDefinition.GetOption<List<object>?>("configurations");
        return dataSources is not null ? CreateVectorStoreConfigurations(dataSources) : null;
    }

    internal static List<VectorStoreConfigurations> CreateVectorStoreConfigurations(List<object> values)
    {
        List<VectorStoreConfigurations> configurations = [];
        foreach (var value in values)
        {
            if (value is Dictionary<object, object> configurationDict)
            {
                var storeName = configurationDict.TryGetValue("store_name", out var storeNameValue) && storeNameValue is string storeNameString ? storeNameString : null;
                var dataSources = configurationDict.TryGetValue("data_sources", out var dataSourceValue) && dataSourceValue is List<object> dataSourceList ? CreateDataSources(dataSourceList) : null;

                if (string.IsNullOrEmpty(storeName) || dataSources is null)
                {
                    throw new ArgumentException("The option keys 'store_name' and 'data_sources' are required for a vector store configuration.");
                }

                configurations.Add(new VectorStoreConfigurations(storeName, new VectorStoreConfiguration(dataSources)));
            }
        }

        return configurations;
    }

    private static AzureFunctionBinding GetAzureFunctionBinding(this AgentToolDefinition agentToolDefinition, string bindingType)
    {
        Verify.NotNull(agentToolDefinition.Options);

        var binding = agentToolDefinition.GetRequiredOption<Dictionary<object, object>>(bindingType);
        if (!binding.TryGetValue("storage_service_endpoint", out var endpointValue) || endpointValue is not string storageServiceEndpoint)
        {
            throw new ArgumentException($"The option key '{bindingType}.storage_service_endpoint' is required.");
        }
        if (!binding.TryGetValue("queue_name", out var nameValue) || nameValue is not string queueName)
        {
            throw new ArgumentException($"The option key '{bindingType}.queue_name' is required.");
        }

        return new AzureFunctionBinding(new AzureFunctionStorageQueue(storageServiceEndpoint, queueName));
    }

    internal static int? GetTopK(this AgentToolDefinition agentToolDefinition)
    {
        return agentToolDefinition.Options?.TryGetValue("top_k", out var topKValue) ?? false
            ? int.Parse((string)topKValue!)
            : null;
    }

    internal static string? GetFilter(this AgentToolDefinition agentToolDefinition)
    {
        return agentToolDefinition.Options?.TryGetValue("filter", out var filterValue) ?? false
            ? filterValue as string
            : null;
    }

    internal static AzureAISearchQueryType? GetAzureAISearchQueryType(this AgentToolDefinition agentToolDefinition)
    {
        return agentToolDefinition.Options?.TryGetValue("query_type", out var queryTypeValue) ?? false
            ? new AzureAISearchQueryType(queryTypeValue as string)
            : null;
    }

    private static FileSearchRankingOptions? GetFileSearchRankingOptions(this AgentToolDefinition agentToolDefinition)
    {
        string? ranker = agentToolDefinition.GetOption<string>("ranker");
        float? scoreThreshold = agentToolDefinition.GetOption<float>("score_threshold");

        if (ranker is not null && scoreThreshold is not null)
        {
            return new FileSearchRankingOptions(ranker, (float)scoreThreshold!);
        }

        return null;
    }

    internal static List<string> GetToolConnections(this AgentToolDefinition agentToolDefinition)
    {
        Verify.NotNull(agentToolDefinition.Options);

        List<object> toolConnections = agentToolDefinition.GetRequiredOption<List<object>>("tool_connections");

        return [.. toolConnections.Select(connectionId => $"{connectionId}")];
    }

    private static T GetRequiredOption<T>(this AgentToolDefinition agentToolDefinition, string key)
    {
        Verify.NotNull(agentToolDefinition);
        Verify.NotNull(agentToolDefinition.Options);
        Verify.NotNull(key);

        if (agentToolDefinition.Options?.TryGetValue(key, out var value) ?? false)
        {
            if (value == null)
            {
                throw new ArgumentNullException($"The option key '{key}' must be a non null value.");
            }

            if (value is T expectedValue)
            {
                return expectedValue;
            }
            throw new InvalidCastException($"The option key '{key}' value must be of type '{typeof(T)}' but is '{value.GetType()}'.");
        }

        throw new ArgumentException($"The option key '{key}' was not found.");
    }

    private static readonly BinaryData s_noParams = BinaryData.FromObjectAsJson(new { type = "object", properties = new { } });
}


===== AzureAI\Extensions\KernelFunctionExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using Azure.AI.Agents.Persistent;

namespace Microsoft.SemanticKernel.Agents.AzureAI;

/// <summary>
/// Extensions for <see cref="KernelFunction"/> to support Azure AI specific operations.
/// </summary>
public static class KernelFunctionExtensions
{
    /// <summary>
    /// Convert <see cref="KernelFunction"/> to an OpenAI tool model.
    /// </summary>
    /// <param name="function">The source function</param>
    /// <param name="pluginName">The plugin name</param>
    /// <returns>An OpenAI tool definition</returns>
    public static FunctionToolDefinition ToToolDefinition(this KernelFunction function, string pluginName)
    {
        if (function.Metadata.Parameters.Count > 0)
        {
            BinaryData parameterData = function.Metadata.CreateParameterSpec();

            return new FunctionToolDefinition(FunctionName.ToFullyQualifiedName(function.Name, pluginName), function.Description, parameterData);
        }

        return new FunctionToolDefinition(FunctionName.ToFullyQualifiedName(function.Name, pluginName), function.Description);
    }
}


===== AzureAI\Internal\AgentMessageFactory.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Collections.Generic;
using System.Linq;
using Azure.AI.Agents.Persistent;
using Microsoft.SemanticKernel.ChatCompletion;

namespace Microsoft.SemanticKernel.Agents.AzureAI.Internal;

/// <summary>
/// Factory for creating <see cref="MessageContent"/> based on <see cref="ChatMessageContent"/>.
/// </summary>
/// <remarks>
/// Improves testability.
/// </remarks>
internal static class AgentMessageFactory
{
    /// <summary>
    /// Translate metadata from a <see cref="ChatMessageContent"/> to be used for a <see cref="PersistentThreadMessage"/> or
    /// <see cref="ThreadMessageOptions"/>.
    /// </summary>
    /// <param name="message">The message content.</param>
    public static Dictionary<string, string> GetMetadata(ChatMessageContent message)
    {
        return message.Metadata?.ToDictionary(kvp => kvp.Key, kvp => kvp.Value?.ToString() ?? string.Empty) ?? [];
    }

    /// <summary>
    /// Translate attachments from a <see cref="ChatMessageContent"/> to be used for a <see cref="PersistentThreadMessage"/> or
    /// </summary>
    /// <param name="message">The message content.</param>
    public static IEnumerable<MessageAttachment> GetAttachments(ChatMessageContent message)
    {
        return
            message.Items
                .OfType<FileReferenceContent>()
                .Where(fileContent => fileContent.Tools?.Any() ?? false)
                .Select(
                    fileContent =>
                        new MessageAttachment(fileContent.FileId, [.. GetToolDefinition(fileContent.Tools!)]));

        static IEnumerable<ToolDefinition> GetToolDefinition(IEnumerable<string> tools)
        {
            foreach (string tool in tools)
            {
                if (s_toolMetadata.TryGetValue(tool, out ToolDefinition? toolDefinition))
                {
                    yield return toolDefinition;
                }
            }
        }
    }

    /// <summary>
    /// Translates a set of <see cref="ChatMessageContent"/> to a set of <see cref="MessageInputContentBlock"/>.
    /// </summary>
    /// <param name="message">A <see cref="ChatMessageContent"/> object/</param>
    public static IEnumerable<MessageInputContentBlock> GetMessageContent(ChatMessageContent? message)
    {
        if (message is not null)
        {
            foreach (KernelContent content in message.Items)
            {
                if (content is TextContent textContent)
                {
                    var text = content.ToString();
                    if (string.IsNullOrWhiteSpace(text))
                    {
                        // Message content must be non-empty.
                        continue;
                    }
                    yield return new MessageInputTextBlock(text);
                }
                else if (content is ImageContent imageContent)
                {
                    if (imageContent.Uri != null)
                    {
                        MessageImageUriParam imageUrlParam = new(uri: imageContent.Uri.ToString());
                        yield return new MessageInputImageUriBlock(imageUrlParam);
                    }
                    else if (!string.IsNullOrWhiteSpace(imageContent.DataUri))
                    {
                        MessageImageUriParam imageUrlParam = new(uri: imageContent.DataUri!);
                        yield return new MessageInputImageUriBlock(imageUrlParam);
                    }
                }
                else if (content is FileReferenceContent fileContent)
                {
                    MessageImageFileParam fileParam = new(fileContent.FileId);
                    yield return new MessageInputImageFileBlock(fileParam);
                }
            }
        }
    }

    /// <summary>
    /// Translates a set of <see cref="ChatMessageContent"/> to a set of <see cref="ThreadMessageOptions"/>."/>
    /// </summary>
    /// <param name="messages">A list of <see cref="ChatMessageContent"/> objects/</param>
    public static IEnumerable<ThreadMessageOptions> GetThreadMessages(IEnumerable<ChatMessageContent>? messages)
    {
        if (messages is not null)
        {
            foreach (ChatMessageContent message in messages)
            {
                string? content = message.Content;
                if (string.IsNullOrWhiteSpace(content))
                {
                    continue;
                }

                ThreadMessageOptions threadMessage = new(
                    role: message.Role == AuthorRole.User ? MessageRole.User : MessageRole.Agent,
                    content: message.Content)
                {
                    Attachments = [.. GetAttachments(message)],
                };

                if (message.Metadata != null)
                {
                    foreach (string key in message.Metadata.Keys)
                    {
                        threadMessage.Metadata = GetMetadata(message);
                    }
                }

                yield return threadMessage;
            }
        }
    }

    private static readonly Dictionary<string, ToolDefinition> s_toolMetadata =
        new()
        {
            { AzureAIAgent.Tools.CodeInterpreter, new CodeInterpreterToolDefinition() },
            { AzureAIAgent.Tools.FileSearch, new FileSearchToolDefinition() },
        };
}


===== AzureAI\Internal\AgentThreadActions.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.ClientModel;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Runtime.CompilerServices;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.AI.Agents.Persistent;
using Microsoft.Extensions.Logging;
using Microsoft.SemanticKernel.Agents.AzureAI.Extensions;
using Microsoft.SemanticKernel.Agents.Extensions;
using Microsoft.SemanticKernel.ChatCompletion;
using Microsoft.SemanticKernel.Connectors.FunctionCalling;

namespace Microsoft.SemanticKernel.Agents.AzureAI.Internal;

/// <summary>
/// Actions associated with an Open Assistant thread.
/// </summary>
internal static class AgentThreadActions
{
    private static readonly HashSet<RunStatus> s_pollingStatuses =
    [
        RunStatus.Queued,
        RunStatus.InProgress,
        RunStatus.Cancelling,
    ];

    private static readonly HashSet<RunStatus> s_failureStatuses =
    [
        RunStatus.Expired,
        RunStatus.Failed,
        RunStatus.Cancelled,
    ];

    /// <summary>
    /// Create a new assistant thread.
    /// </summary>
    /// <param name="client">The assistant client</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>The thread identifier</returns>
    public static async Task<string> CreateThreadAsync(PersistentAgentsClient client, CancellationToken cancellationToken = default)
    {
        PersistentAgentThread thread = await client.Threads.CreateThreadAsync(cancellationToken: cancellationToken).ConfigureAwait(false);

        return thread.Id;
    }

    /// <summary>
    /// Create a message in the specified thread.
    /// </summary>
    /// <param name="client">The assistant client</param>
    /// <param name="threadId">The thread identifier</param>
    /// <param name="message">The message to add</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <throws><see cref="KernelException"/> if a system message is present, without taking any other action</throws>
    public static async Task CreateMessageAsync(PersistentAgentsClient client, string threadId, ChatMessageContent message, CancellationToken cancellationToken)
    {
        if (message.Items.Any(i => i is FunctionCallContent))
        {
            return;
        }

        var contentBlocks = AgentMessageFactory.GetMessageContent(message);
        if (!contentBlocks.Any())
        {
            return;
        }

        await client.Messages.CreateMessageAsync(
            threadId,
            role: message.Role == AuthorRole.User ? MessageRole.User : MessageRole.Agent,
            contentBlocks: contentBlocks,
            attachments: AgentMessageFactory.GetAttachments(message),
            metadata: AgentMessageFactory.GetMetadata(message),
            cancellationToken).ConfigureAwait(false);
    }

    /// <summary>
    /// Retrieves the thread messages.
    /// </summary>
    /// <param name="client">The assistant client</param>
    /// <param name="threadId">The thread identifier</param>
    /// <param name="messageOrder">The order to return messages in.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>Asynchronous enumeration of messages.</returns>
    public static async IAsyncEnumerable<ChatMessageContent> GetMessagesAsync(PersistentAgentsClient client, string threadId, ListSortOrder? messageOrder, [EnumeratorCancellation] CancellationToken cancellationToken)
    {
        Dictionary<string, string?> agentNames = []; // Cache agent names by their identifier

        string? lastId = null;
        AsyncPageable<PersistentThreadMessage>? messages = client.Messages.GetMessagesAsync(threadId, runId: null, limit: null, messageOrder ?? ListSortOrder.Descending, after: lastId, before: null, cancellationToken);
        await foreach (PersistentThreadMessage message in messages.ConfigureAwait(false))
        {
            lastId = message.Id;
            string? assistantName = null;
            if (!string.IsNullOrWhiteSpace(message.AssistantId) &&
                !agentNames.TryGetValue(message.AssistantId, out assistantName))
            {
                PersistentAgent assistant = await client.Administration.GetAgentAsync(message.AssistantId, cancellationToken).ConfigureAwait(false);
                if (!string.IsNullOrWhiteSpace(assistant.Name))
                {
                    agentNames.Add(assistant.Id, assistant.Name);
                }
            }

            assistantName ??= message.AssistantId;

            ChatMessageContent content = GenerateMessageContent(assistantName, message);

            if (content.Items.Count > 0)
            {
                yield return content;
            }
        }
    }

    /// <summary>
    /// Invoke the assistant on the specified thread.
    /// In the enumeration returned by this method, a message is considered visible if it is intended to be displayed to the user.
    /// Example of a non-visible message is function-content for functions that are automatically executed.
    /// </summary>
    /// <param name="agent">The assistant agent to interact with the thread.</param>
    /// <param name="client">The assistant client</param>
    /// <param name="threadId">The thread identifier</param>
    /// <param name="invocationOptions">Options to utilize for the invocation</param>
    /// <param name="logger">The logger to utilize (might be agent or channel scoped)</param>
    /// <param name="kernel">The <see cref="Kernel"/> plugins and other state.</param>
    /// <param name="arguments">Optional arguments to pass to the agents's invocation, including any <see cref="PromptExecutionSettings"/>.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>Asynchronous enumeration of messages.</returns>
    public static async IAsyncEnumerable<(bool IsVisible, ChatMessageContent Message)> InvokeAsync(
        AzureAIAgent agent,
        PersistentAgentsClient client,
        string threadId,
        AzureAIInvocationOptions? invocationOptions,
        ILogger logger,
        Kernel kernel,
        KernelArguments? arguments,
        [EnumeratorCancellation] CancellationToken cancellationToken)
    {
        logger.LogAzureAIAgentCreatingRun(nameof(InvokeAsync), threadId);

        List<ToolDefinition> tools = new(agent.Definition.Tools);

        // Add unique functions from the Kernel which are not already present in the agent's tools
        HashSet<string> functionToolNames = new(tools.OfType<FunctionToolDefinition>().Select(t => t.Name));
        IEnumerable<FunctionToolDefinition> functionTools = kernel.Plugins
            .SelectMany(kp => kp.Select(kf => kf.ToToolDefinition(kp.Name)))
            .Where(tool => !functionToolNames.Contains(tool.Name));
        tools.AddRange(functionTools);

        string? instructions = await agent.GetInstructionsAsync(kernel, arguments, cancellationToken).ConfigureAwait(false);

        ThreadRun run = await client.CreateAsync(threadId, agent, instructions, [.. tools], invocationOptions, cancellationToken).ConfigureAwait(false);

        logger.LogAzureAIAgentCreatedRun(nameof(InvokeAsync), run.Id, threadId);

        FunctionCallsProcessor functionProcessor = new(logger);
        // This matches current behavior.  Will be configurable upon integrating with `FunctionChoice` (#6795/#5200)
        FunctionChoiceBehaviorOptions functionOptions = new() { AllowConcurrentInvocation = true, AllowParallelCalls = true };

        // Evaluate status and process steps and messages, as encountered.
        HashSet<string> processedStepIds = [];
        Dictionary<string, FunctionResultContent> functionSteps = [];
        do
        {
            // Check for cancellation
            cancellationToken.ThrowIfCancellationRequested();

            // Poll run and steps until actionable
            await PollRunStatusAsync().ConfigureAwait(false);

            // Is in terminal state?
            if (s_failureStatuses.Contains(run.Status))
            {
                throw new KernelException($"Agent Failure - Run terminated: {run.Status} [{run.Id}]: {run.LastError?.Message ?? "Unknown"}");
            }

            List<RunStep> steps = [];
            await foreach (var step in client.GetStepsAsync(run, cancellationToken: cancellationToken).ConfigureAwait(false))
            {
                steps.Add(step);
            }

            // Is tool action required?
            if (run.Status == RunStatus.RequiresAction)
            {
                logger.LogAzureAIAgentProcessingRunSteps(nameof(InvokeAsync), run.Id, threadId);

                // Execute functions in parallel and post results at once.
                FunctionCallContent[] functionCalls = [.. steps.SelectMany(step => ParseFunctionStep(agent, step))];
                if (functionCalls.Length > 0)
                {
                    // Emit function-call content
                    ChatMessageContent functionCallMessage = GenerateFunctionCallContent(agent.GetName(), functionCalls);
                    yield return (IsVisible: false, Message: functionCallMessage);

                    // Invoke functions for each tool-step
                    FunctionResultContent[] functionResults =
                        await functionProcessor.InvokeFunctionCallsAsync(
                            functionCallMessage,
                            (_) => true,
                            functionOptions,
                            kernel,
                            isStreaming: false,
                            cancellationToken).ConfigureAwait(false);

                    // Capture function-call for message processing
                    foreach (FunctionResultContent functionCall in functionResults)
                    {
                        functionSteps.Add(functionCall.CallId!, functionCall);
                    }

                    // Process tool output
                    ToolOutput[] toolOutputs = GenerateToolOutputs(functionResults);

                    await client.Runs.SubmitToolOutputsToRunAsync(run, toolOutputs, cancellationToken).ConfigureAwait(false);
                }

                logger.LogAzureAIAgentProcessedRunSteps(nameof(InvokeAsync), functionCalls.Length, run.Id, threadId);
            }

            // Enumerate completed messages
            logger.LogAzureAIAgentProcessingRunMessages(nameof(InvokeAsync), run.Id, threadId);

            IEnumerable<RunStep> completedStepsToProcess =
                steps
                    .Where(s => s.CompletedAt.HasValue && !processedStepIds.Contains(s.Id))
                    .OrderBy(s => s.CreatedAt);

            int messageCount = 0;
            foreach (RunStep completedStep in completedStepsToProcess)
            {
                if (completedStep.Type == RunStepType.ToolCalls)
                {
                    RunStepToolCallDetails toolDetails = (RunStepToolCallDetails)completedStep.StepDetails;
                    foreach (RunStepToolCall toolCall in toolDetails.ToolCalls)
                    {
                        bool isVisible = false;
                        ChatMessageContent? content = null;

                        // Process code-interpreter content
                        if (toolCall is RunStepCodeInterpreterToolCall codeTool)
                        {
                            content = GenerateCodeInterpreterContent(agent.GetName(), codeTool.Input, completedStep);
                            isVisible = true;
                        }
                        // Process function result content
                        else if (toolCall is RunStepFunctionToolCall functionTool)
                        {
                            FunctionResultContent functionStep = functionSteps[functionTool.Id]; // Function step always captured on invocation
                            content = GenerateFunctionResultContent(agent.GetName(), [functionStep], completedStep);
                        }

                        if (content is not null)
                        {
                            ++messageCount;

                            yield return (isVisible, Message: content);
                        }
                    }
                }
                else if (completedStep.Type == RunStepType.MessageCreation)
                {
                    // Retrieve the message
                    RunStepMessageCreationDetails messageDetails = (RunStepMessageCreationDetails)completedStep.StepDetails;
                    PersistentThreadMessage? message = await RetrieveMessageAsync(client, threadId, messageDetails.MessageCreation.MessageId, agent.PollingOptions.MessageSynchronizationDelay, cancellationToken).ConfigureAwait(false);

                    if (message is not null)
                    {
                        ChatMessageContent content = GenerateMessageContent(agent.GetName(), message, completedStep, logger);

                        if (content.Items.Count > 0)
                        {
                            ++messageCount;

                            yield return (IsVisible: true, Message: content);
                        }
                    }
                }

                processedStepIds.Add(completedStep.Id);
            }

            logger.LogAzureAIAgentProcessedRunMessages(nameof(InvokeAsync), messageCount, run.Id, threadId);
        }
        while (RunStatus.Completed != run.Status);

        logger.LogAzureAIAgentCompletedRun(nameof(InvokeAsync), run.Id, threadId);

        // Local function to assist in run polling (participates in method closure).
        async Task PollRunStatusAsync()
        {
            logger.LogAzureAIAgentPollingRunStatus(nameof(PollRunStatusAsync), run.Id, threadId);

            int count = 0;

            do
            {
                cancellationToken.ThrowIfCancellationRequested();

                if (count > 0)
                {
                    // Reduce polling frequency after a couple attempts
                    await Task.Delay(agent.PollingOptions.GetPollingInterval(count), cancellationToken).ConfigureAwait(false);
                }

                ++count;

                try
                {
                    run = await client.Runs.GetRunAsync(threadId, run.Id, cancellationToken).ConfigureAwait(false);
                }
                // The presence of a `Status` code means the server responded with error...always fail in that case
                catch (ClientResultException clientException) when (clientException.Status <= 0)
                {
                    // Check maximum retry count
                    if (count >= agent.PollingOptions.MaximumRetryCount)
                    {
                        throw;
                    }

                    // Retry for potential transient failure
                    continue;
                }
                catch (AggregateException aggregateException) when (aggregateException.InnerException is ClientResultException innerClientException)
                {
                    // The presence of a `Status` code means the server responded with error
                    if (innerClientException.Status > 0)
                    {
                        throw;
                    }

                    // Check maximum retry count
                    if (count >= agent.PollingOptions.MaximumRetryCount)
                    {
                        throw;
                    }

                    // Retry for potential transient failure
                    continue;
                }
            }
            while (s_pollingStatuses.Contains(run.Status));

            logger.LogAzureAIAgentPolledRunStatus(nameof(PollRunStatusAsync), run.Status, run.Id, threadId);
        }
    }

    /// <summary>
    /// Invoke the assistant on the specified thread using streaming.
    /// </summary>
    /// <param name="agent">The assistant agent to interact with the thread.</param>
    /// <param name="client">The assistant client</param>
    /// <param name="threadId">The thread identifier</param>
    /// <param name="messages">The receiver for the completed messages generated</param>
    /// <param name="invocationOptions">Options to utilize for the invocation</param>
    /// <param name="logger">The logger to utilize (might be agent or channel scoped)</param>
    /// <param name="kernel">The <see cref="Kernel"/> plugins and other state.</param>
    /// <param name="arguments">Optional arguments to pass to the agents's invocation, including any <see cref="PromptExecutionSettings"/>.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>Asynchronous enumeration of messages.</returns>
    /// <remarks>
    /// The `arguments` parameter is not currently used by the agent, but is provided for future extensibility.
    /// </remarks>
    public static async IAsyncEnumerable<StreamingChatMessageContent> InvokeStreamingAsync(
        AzureAIAgent agent,
        PersistentAgentsClient client,
        string threadId,
        IList<ChatMessageContent>? messages,
        AzureAIInvocationOptions? invocationOptions,
        ILogger logger,
        Kernel kernel,
        KernelArguments? arguments,
        [EnumeratorCancellation] CancellationToken cancellationToken)
    {
        logger.LogAzureAIAgentCreatingRun(nameof(InvokeAsync), threadId);

        ToolDefinition[]? tools = [.. agent.Definition.Tools, .. kernel.Plugins.SelectMany(p => p.Select(f => f.ToToolDefinition(p.Name)))];

        string? instructions = await agent.GetInstructionsAsync(kernel, arguments, cancellationToken).ConfigureAwait(false);

        // Evaluate status and process steps and messages, as encountered.
        HashSet<string> processedStepIds = [];
        Dictionary<string, FunctionResultContent[]> stepFunctionResults = [];
        List<RunStep> messageCreationStepsToProcess = [];

        FunctionCallsProcessor functionProcessor = new(logger);
        // This matches current behavior.  Will be configurable upon integrating with `FunctionChoice` (#6795/#5200)
        FunctionChoiceBehaviorOptions functionOptions = new() { AllowConcurrentInvocation = true, AllowParallelCalls = true };

        ThreadRun? run = null;
        IAsyncEnumerable<StreamingUpdate> asyncUpdates = client.CreateStreamingAsync(threadId, agent, instructions, tools, invocationOptions, cancellationToken);
        do
        {
            // Check for cancellation
            cancellationToken.ThrowIfCancellationRequested();

            messageCreationStepsToProcess.Clear();

            await foreach (StreamingUpdate update in asyncUpdates.ConfigureAwait(false))
            {
                if (update is RunUpdate runUpdate)
                {
                    run = runUpdate.Value;
                }
                else if (update is MessageContentUpdate contentUpdate)
                {
                    switch (contentUpdate.UpdateKind)
                    {
                        case StreamingUpdateReason.MessageUpdated:
                            yield return GenerateStreamingMessageContent(agent.GetName(), run!, contentUpdate, logger);
                            break;
                    }
                }
                else if (update is RunStepDetailsUpdate detailsUpdate)
                {
                    StreamingChatMessageContent? toolContent = GenerateStreamingCodeInterpreterContent(agent.GetName(), detailsUpdate);
                    if (toolContent != null)
                    {
                        yield return toolContent;
                    }
                    else if (detailsUpdate.FunctionArguments != null)
                    {
                        yield return
                            new StreamingChatMessageContent(AuthorRole.Assistant, null)
                            {
                                AuthorName = agent.Name,
                                Items = [new StreamingFunctionCallUpdateContent(detailsUpdate.ToolCallId, detailsUpdate.FunctionName, detailsUpdate.FunctionArguments, detailsUpdate.ToolCallIndex ?? 0)],
                                InnerContent = detailsUpdate,
                            };
                    }
                }
                else if (update is RunStepUpdate stepUpdate)
                {
                    switch (stepUpdate.UpdateKind)
                    {
                        case StreamingUpdateReason.RunStepCompleted when stepUpdate.Value.StepDetails is RunStepToolCallDetails toolDetails:
                            ProcessToolCallStep(stepUpdate.Value, toolDetails, agent, messages, threadId, stepFunctionResults);
                            break;

                        case StreamingUpdateReason.RunStepCompleted when stepUpdate.Value.StepDetails is RunStepMessageCreationDetails:
                            messageCreationStepsToProcess.Add(stepUpdate.Value);
                            break;

                        default:
                            break;
                    }
                }
            }

            if (run == null)
            {
                throw new KernelException($"Agent Failure - Run not created for thread: ${threadId}");
            }

            // Is in terminal state?
            if (s_failureStatuses.Contains(run.Status))
            {
                throw new KernelException($"Agent Failure - Run terminated: {run.Status} [{run.Id}]: {run.LastError?.Message ?? "Unknown"}");
            }

            if (run.Status == RunStatus.RequiresAction)
            {
                List<RunStep> activeSteps = [];
                await foreach (var step in client.GetStepsAsync(run, cancellationToken).ConfigureAwait(false))
                {
                    if (step.Status == RunStepStatus.InProgress)
                    {
                        activeSteps.Add(step);
                    }
                }

                // Capture map between the tool call and its associated step
                Dictionary<string, string> toolMap = [];
                foreach (RunStep step in activeSteps)
                {
                    RunStepToolCallDetails toolCallDetails = (RunStepToolCallDetails)step.StepDetails;
                    foreach (RunStepToolCall stepDetails in toolCallDetails.ToolCalls)
                    {
                        toolMap[stepDetails.Id] = step.Id;
                    }
                }

                // Execute functions in parallel and post results at once.
                FunctionCallContent[] functionCalls = [.. activeSteps.SelectMany(step => ParseFunctionStep(agent, step))];
                if (functionCalls.Length > 0)
                {
                    // Emit function-call content
                    ChatMessageContent functionCallMessage = GenerateFunctionCallContent(agent.GetName(), functionCalls);
                    messages?.Add(functionCallMessage);

                    FunctionResultContent[] functionResults =
                        await functionProcessor.InvokeFunctionCallsAsync(
                            functionCallMessage,
                            (_) => true,
                            functionOptions,
                            kernel,
                            isStreaming: true,
                            cancellationToken).ConfigureAwait(false);

                    // Process tool output
                    ToolOutput[] toolOutputs = GenerateToolOutputs(functionResults);
                    asyncUpdates = client.Runs.SubmitToolOutputsToStreamAsync(run, toolOutputs, cancellationToken);

                    foreach (RunStep step in activeSteps)
                    {
                        stepFunctionResults.Add(step.Id, [.. functionResults.Where(result => step.Id == toolMap[result.CallId!])]);
                    }
                }
            }

            if (messageCreationStepsToProcess.Count > 0)
            {
                logger.LogAzureAIAgentProcessingRunMessages(nameof(InvokeAsync), run!.Id, threadId);

                foreach (RunStep step in messageCreationStepsToProcess)
                {
                    if (step.StepDetails is RunStepMessageCreationDetails messageDetails)
                    {
                        await ProcessMessageCreationStepAsync(step, messageDetails, agent, client, messages, threadId, logger, cancellationToken).ConfigureAwait(false);
                    }
                }

                logger.LogAzureAIAgentProcessedRunMessages(nameof(InvokeAsync), messageCreationStepsToProcess.Count, run!.Id, threadId);
            }
        }
        while (run?.Status != RunStatus.Completed);

        logger.LogAzureAIAgentCompletedRun(nameof(InvokeAsync), run?.Id ?? "Failed", threadId);
    }

    private static async Task ProcessMessageCreationStepAsync(
        RunStep step,
        RunStepMessageCreationDetails messageDetails,
        AzureAIAgent agent,
        PersistentAgentsClient client,
        IList<ChatMessageContent>? messages,
        string threadId,
        ILogger logger,
        CancellationToken cancellationToken)
    {
        PersistentThreadMessage? message =
            await RetrieveMessageAsync(
                client,
                threadId,
                messageDetails.MessageCreation.MessageId,
                agent.PollingOptions.MessageSynchronizationDelay,
                cancellationToken).ConfigureAwait(false);

        if (message != null)
        {
            ChatMessageContent content = GenerateMessageContent(agent.GetName(), message, step, logger);
            messages?.Add(content);
        }
    }

    private static void ProcessToolCallStep(
        RunStep step,
        RunStepToolCallDetails toolDetails,
        AzureAIAgent agent,
        IList<ChatMessageContent>? messages,
        string threadId,
        Dictionary<string, FunctionResultContent[]> stepFunctionResults)
    {
        foreach (RunStepToolCall toolCall in toolDetails.ToolCalls)
        {
            if (toolCall is RunStepFunctionToolCall functionCall)
            {
                messages?.Add(GenerateFunctionResultContent(agent.GetName(), stepFunctionResults[step.Id], step));
                stepFunctionResults.Remove(step.Id);
                break;
            }

            if (toolCall is RunStepCodeInterpreterToolCall codeCall)
            {
                messages?.Add(GenerateCodeInterpreterContent(agent.GetName(), codeCall.Input, step));
            }
        }
    }

    private static ChatMessageContent GenerateMessageContent(string? assistantName, PersistentThreadMessage message, RunStep? completedStep = null, ILogger? logger = null)
    {
        AuthorRole role = new(message.Role.ToString());

        Dictionary<string, object?>? metadata =
            new()
            {
                { nameof(PersistentThreadMessage.CreatedAt), message.CreatedAt },
                { nameof(PersistentThreadMessage.AssistantId), message.AssistantId },
                { nameof(PersistentThreadMessage.ThreadId), message.ThreadId },
                { nameof(PersistentThreadMessage.RunId), message.RunId },
                { nameof(MessageContentUpdate.MessageId), message.Id },
            };

        if (completedStep != null)
        {
            metadata[nameof(RunStepDetailsUpdate.StepId)] = completedStep.Id;
            metadata[nameof(RunStep.Usage)] = completedStep.Usage;
        }

        ChatMessageContent content =
            new(role, content: null)
            {
                AuthorName = assistantName,
                Metadata = metadata,
            };

        foreach (MessageContent itemContent in message.ContentItems)
        {
            // Process text content
            if (itemContent is MessageTextContent textContent)
            {
                content.Items.Add(new TextContent(textContent.Text));

                foreach (MessageTextAnnotation annotation in textContent.Annotations)
                {
                    AnnotationContent? annotationItem = GenerateAnnotationContent(annotation);
                    if (annotationItem != null)
                    {
                        content.Items.Add(annotationItem);
                    }
                    else
                    {
                        logger?.LogAzureAIAgentUnknownAnnotation(nameof(GenerateMessageContent), message.RunId, message.ThreadId, annotation.GetType());
                    }
                }
            }
            // Process image content
            else if (itemContent is MessageImageFileContent imageContent)
            {
                content.Items.Add(new FileReferenceContent(imageContent.FileId));
            }
        }

        return content;
    }

    private static StreamingChatMessageContent GenerateStreamingMessageContent(string? assistantName, ThreadRun run, MessageContentUpdate update, ILogger? logger)
    {
        StreamingChatMessageContent content =
            new(AuthorRole.Assistant, content: null)
            {
                AuthorName = assistantName,
            };

        // Process text content
        if (!string.IsNullOrEmpty(update.Text))
        {
            content.Items.Add(new StreamingTextContent(update.Text));
        }
        // Process image content
        else if (update.ImageFileId != null)
        {
            content.Items.Add(new StreamingFileReferenceContent(update.ImageFileId));
        }
        // Process annotations
        else if (update.TextAnnotation != null)
        {
            StreamingAnnotationContent? annotationItem = GenerateStreamingAnnotationContent(update.TextAnnotation);
            if (annotationItem != null)
            {
                content.Items.Add(annotationItem);
            }
            else
            {
                logger?.LogAzureAIAgentUnknownAnnotation(nameof(GenerateStreamingMessageContent), run.Id, run.ThreadId, update.TextAnnotation.GetType());
            }
        }

        if (update.Role.HasValue && update.Role.Value != MessageRole.User)
        {
            content.Role = new(update.Role.Value.ToString() ?? MessageRole.Agent.ToString());
        }

        return content;
    }

    private static StreamingChatMessageContent? GenerateStreamingCodeInterpreterContent(string? assistantName, RunStepDetailsUpdate update)
    {
        StreamingChatMessageContent content =
            new(AuthorRole.Assistant, content: null)
            {
                AuthorName = assistantName,
            };

        // Process text content
        if (update.CodeInterpreterInput != null)
        {
            content.Items.Add(new StreamingTextContent(update.CodeInterpreterInput));
            content.Metadata = new Dictionary<string, object?> { { AzureAIAgent.CodeInterpreterMetadataKey, true } };
        }

        if ((update.CodeInterpreterOutputs?.Count ?? 0) > 0)
        {
            foreach (RunStepDeltaCodeInterpreterOutput output in update.CodeInterpreterOutputs!)
            {
                if (output is RunStepDeltaCodeInterpreterImageOutput imageOutput)
                {
                    content.Items.Add(new StreamingFileReferenceContent(imageOutput.Image.FileId));
                }
            }
        }

        return content.Items.Count > 0 ? content : null;
    }

    private static AnnotationContent? GenerateAnnotationContent(MessageTextAnnotation annotation)
    {
        if (annotation is MessageTextFileCitationAnnotation fileCitationAnnotation)
        {
            return
                new AnnotationContent(
                    kind: AnnotationKind.FileCitation,
                    label: annotation.Text,
                    referenceId: fileCitationAnnotation.FileId)
                {
                    InnerContent = annotation,
                    StartIndex = fileCitationAnnotation.StartIndex,
                    EndIndex = fileCitationAnnotation.EndIndex,
                };
        }
        if (annotation is MessageTextUriCitationAnnotation urlCitationAnnotation)
        {
            return
                new AnnotationContent(
                    kind: AnnotationKind.UrlCitation,
                    label: annotation.Text,
                    referenceId: urlCitationAnnotation.UriCitation.Uri)
                {
                    InnerContent = annotation,
                    Title = urlCitationAnnotation.UriCitation.Title,
                    StartIndex = urlCitationAnnotation.StartIndex,
                    EndIndex = urlCitationAnnotation.EndIndex,
                };
        }
        else if (annotation is MessageTextFilePathAnnotation filePathAnnotation)
        {
            return
                new AnnotationContent(
                    label: annotation.Text,
                    kind: AnnotationKind.TextCitation,
                    referenceId: filePathAnnotation.FileId)
                {
                    InnerContent = annotation,
                    StartIndex = filePathAnnotation.StartIndex,
                    EndIndex = filePathAnnotation.EndIndex,
                };
        }

        return null;
    }

    private static StreamingAnnotationContent? GenerateStreamingAnnotationContent(TextAnnotationUpdate annotation)
    {
        string? referenceId = null;
        AnnotationKind kind;

        if (!string.IsNullOrEmpty(annotation.OutputFileId))
        {
            referenceId = annotation.OutputFileId;
            kind = AnnotationKind.TextCitation;
        }
        else if (!string.IsNullOrEmpty(annotation.InputFileId))
        {
            referenceId = annotation.InputFileId;
            kind = AnnotationKind.FileCitation;
        }
        else if (!string.IsNullOrEmpty(annotation.Url))
        {
            referenceId = annotation.Url;
            kind = AnnotationKind.UrlCitation;
        }
        else
        {
            return null;
        }

        return
            new StreamingAnnotationContent(kind, referenceId)
            {
                Label = annotation.TextToReplace,
                InnerContent = annotation,
                Title = annotation.Title,
                StartIndex = annotation.StartIndex,
                EndIndex = annotation.EndIndex,
            };
    }

    private static ChatMessageContent GenerateCodeInterpreterContent(string agentName, string pythonCode, RunStep completedStep)
    {
        Dictionary<string, object?> metadata = GenerateToolCallMetadata(completedStep);
        metadata[AzureAIAgent.CodeInterpreterMetadataKey] = true;

        return
            new ChatMessageContent(
                AuthorRole.Assistant,
                [
                    new TextContent(pythonCode)
                ])
            {
                AuthorName = agentName,
                Metadata = metadata,
            };
    }

    private static IEnumerable<FunctionCallContent> ParseFunctionStep(AzureAIAgent agent, RunStep step)
    {
        if (step.Status == RunStepStatus.InProgress && step.Type == RunStepType.ToolCalls)
        {
            RunStepToolCallDetails toolCallDetails = (RunStepToolCallDetails)step.StepDetails;
            foreach (RunStepToolCall toolCall in toolCallDetails.ToolCalls)
            {
                if (toolCall is RunStepFunctionToolCall functionCall)
                {
                    (FunctionName nameParts, KernelArguments functionArguments) = ParseFunctionCall(functionCall.Name, functionCall.Arguments);

                    FunctionCallContent content = new(nameParts.Name, nameParts.PluginName, toolCall.Id, functionArguments);

                    yield return content;
                }
            }
        }
    }

    private static (FunctionName functionName, KernelArguments arguments) ParseFunctionCall(string functionName, string? functionArguments)
    {
        FunctionName nameParts = FunctionName.Parse(functionName);

        KernelArguments arguments = [];

        if (!string.IsNullOrWhiteSpace(functionArguments))
        {
            foreach (KeyValuePair<string, object> argumentKvp in JsonSerializer.Deserialize<Dictionary<string, object>>(functionArguments!) ?? [])
            {
                arguments[argumentKvp.Key] = argumentKvp.Value?.ToString();
            }
        }

        return (nameParts, arguments);
    }

    private static ChatMessageContent GenerateFunctionCallContent(string agentName, IList<FunctionCallContent> functionCalls)
    {
        ChatMessageContent functionCallContent = new(AuthorRole.Assistant, content: null)
        {
            AuthorName = agentName
        };

        functionCallContent.Items.AddRange(functionCalls);

        return functionCallContent;
    }

    private static ChatMessageContent GenerateFunctionResultContent(string agentName, IEnumerable<FunctionResultContent> functionResults, RunStep completedStep)
    {
        ChatMessageContent functionResultContent = new(AuthorRole.Tool, content: null)
        {
            AuthorName = agentName,
            Metadata = GenerateToolCallMetadata(completedStep),
        };

        foreach (FunctionResultContent functionResult in functionResults)
        {
            functionResultContent.Items.Add(
                new FunctionResultContent(
                    functionResult.FunctionName,
                    functionResult.PluginName,
                    functionResult.CallId,
                    functionResult.Result));
        }

        return functionResultContent;
    }

    private static Dictionary<string, object?> GenerateToolCallMetadata(RunStep completedStep)
    {
        return new()
            {
                { nameof(RunStep.CreatedAt), completedStep.CreatedAt },
                { nameof(RunStep.AssistantId), completedStep.AssistantId },
                { nameof(RunStep.ThreadId), completedStep.ThreadId },
                { nameof(RunStep.RunId), completedStep.RunId },
                { nameof(RunStepDetailsUpdate.StepId), completedStep.Id },
                { nameof(RunStep.Usage), completedStep.Usage },
            };
    }

    private static ToolOutput[] GenerateToolOutputs(FunctionResultContent[] functionResults)
    {
        ToolOutput[] toolOutputs = new ToolOutput[functionResults.Length];

        for (int index = 0; index < functionResults.Length; ++index)
        {
            FunctionResultContent functionResult = functionResults[index];

            object resultValue = functionResult.Result ?? string.Empty;

            if (resultValue is not string textResult)
            {
                textResult = JsonSerializer.Serialize(resultValue);
            }

            toolOutputs[index] = new ToolOutput(functionResult.CallId, textResult!);
        }

        return toolOutputs;
    }

    private static async Task<PersistentThreadMessage?> RetrieveMessageAsync(PersistentAgentsClient client, string threadId, string messageId, TimeSpan syncDelay, CancellationToken cancellationToken)
    {
        PersistentThreadMessage? message = null;

        bool retry = false;
        int count = 0;
        do
        {
            try
            {
                message = await client.Messages.GetMessageAsync(threadId, messageId, cancellationToken).ConfigureAwait(false);
            }
            catch (RequestFailedException exception)
            {
                // Step has provided the message-id.  Retry on of NotFound/404 exists.
                // Extremely rarely there might be a synchronization issue between the
                // assistant response and message-service.
                retry = exception.Status == (int)HttpStatusCode.NotFound && count < 3;
            }

            if (retry)
            {
                await Task.Delay(syncDelay, cancellationToken).ConfigureAwait(false);
            }

            ++count;
        }
        while (retry);

        return message;
    }
}


===== AzureAI\Logging\AgentThreadActionsLogMessages.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.Diagnostics.CodeAnalysis;
using Azure.AI.Agents.Persistent;
using Microsoft.Extensions.Logging;
using Microsoft.SemanticKernel.Agents.AzureAI.Internal;

namespace Microsoft.SemanticKernel.Agents.AzureAI;

#pragma warning disable SYSLIB1006 // Multiple logging methods cannot use the same event id within a class

/// <summary>
/// Extensions for logging <see cref="AgentThreadActions"/>.
/// </summary>
/// <remarks>
/// This extension uses the <see cref="LoggerMessageAttribute"/> to
/// generate logging code at compile time to achieve optimized code.
/// </remarks>
[ExcludeFromCodeCoverage]
internal static partial class AgentThreadActionsLogMessages
{
    /// <summary>
    /// Logs <see cref="AgentThreadActions"/> creating run (started).
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Debug,
        Message = "[{MethodName}] Creating run for thread: {ThreadId}.")]
    public static partial void LogAzureAIAgentCreatingRun(
        this ILogger logger,
        string methodName,
        string threadId);

    /// <summary>
    /// Logs <see cref="AgentThreadActions"/> created run (complete).
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Information,
        Message = "[{MethodName}] Created run for thread: {RunId}/{ThreadId}.")]
    public static partial void LogAzureAIAgentCreatedRun(
        this ILogger logger,
        string methodName,
        string runId,
        string threadId);

    /// <summary>
    /// Logs <see cref="AgentThreadActions"/> completed run (complete).
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Information,
        Message = "[{MethodName}] Completed run for thread: {RunId}/{ThreadId}.")]
    public static partial void LogAzureAIAgentCompletedRun(
        this ILogger logger,
        string methodName,
        string runId,
        string threadId);

    /// <summary>
    /// Logs <see cref="AgentThreadActions"/> processing run steps (started).
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Debug,
        Message = "[{MethodName}] Processing run steps for thread: {RunId}/{ThreadId}.")]
    public static partial void LogAzureAIAgentProcessingRunSteps(
        this ILogger logger,
        string methodName,
        string runId,
        string threadId);

    /// <summary>
    /// Logs <see cref="AgentThreadActions"/> processed run steps (complete).
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Information,
        Message = "[{MethodName}] Processed #{stepCount} run steps: {RunId}/{ThreadId}.")]
    public static partial void LogAzureAIAgentProcessedRunSteps(
        this ILogger logger,
        string methodName,
        int stepCount,
        string runId,
        string threadId);

    /// <summary>
    /// Logs <see cref="AgentThreadActions"/> processing run messages (started).
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Debug,
        Message = "[{MethodName}] Processing run messages for thread: {RunId}/{ThreadId}.")]
    public static partial void LogAzureAIAgentProcessingRunMessages(
        this ILogger logger,
        string methodName,
        string runId,
        string threadId);

    /// <summary>
    /// Logs <see cref="AgentThreadActions"/> processed run messages (complete).
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Information,
        Message = "[{MethodName}] Processed #{MessageCount} run steps: {RunId}/{ThreadId}.")]
    public static partial void LogAzureAIAgentProcessedRunMessages(
        this ILogger logger,
        string methodName,
        int messageCount,
        string runId,
        string threadId);

    /// <summary>
    /// Logs <see cref="AgentThreadActions"/> polling run status (started).
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Debug,
        Message = "[{MethodName}] Polling run status for thread: {RunId}/{ThreadId}.")]
    public static partial void LogAzureAIAgentPollingRunStatus(
        this ILogger logger,
        string methodName,
        string runId,
        string threadId);

    /// <summary>
    /// Logs <see cref="AgentThreadActions"/> polled run status (complete).
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Information,
        Message = "[{MethodName}] Run status is {RunStatus}: {RunId}/{ThreadId}.")]
    public static partial void LogAzureAIAgentPolledRunStatus(
        this ILogger logger,
        string methodName,
        RunStatus runStatus,
        string runId,
        string threadId);

    /// <summary>
    /// Logs <see cref="AgentThreadActions"/> polled run status (complete).
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Warning,
        Message = "[{MethodName}] Unknown annotation '{Type}': {RunId}/{ThreadId}.")]
    public static partial void LogAzureAIAgentUnknownAnnotation(
        this ILogger logger,
        string methodName,
        string runId,
        string threadId,
        Type type);
}


===== AzureAI\Logging\AzureAIAgentLogMessages.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Diagnostics.CodeAnalysis;
using Microsoft.Extensions.Logging;

namespace Microsoft.SemanticKernel.Agents.AzureAI;

#pragma warning disable SYSLIB1006 // Multiple logging methods cannot use the same event id within a class

/// <summary>
/// Extensions for logging <see cref="AzureAIAgent"/> invocations.
/// </summary>
/// <remarks>
/// This extension uses the <see cref="LoggerMessageAttribute"/> to
/// generate logging code at compile time to achieve optimized code.
/// </remarks>
[ExcludeFromCodeCoverage]
internal static partial class AzureAIAgentLogMessages
{
    /// <summary>
    /// Logs <see cref="AzureAIAgent"/> creating channel (started).
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Debug,
        Message = "[{MethodName}] Creating assistant thread for {ChannelType}.")]
    public static partial void LogAzureAIAgentCreatingChannel(
        this ILogger logger,
        string methodName,
        string channelType);

    /// <summary>
    /// Logs <see cref="AzureAIAgent"/> created channel (complete).
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Information,
        Message = "[{MethodName}] Created assistant thread for {ChannelType}: #{ThreadId}.")]
    public static partial void LogAzureAIAgentCreatedChannel(
        this ILogger logger,
        string methodName,
        string channelType,
        string threadId);

    /// <summary>
    /// Logs <see cref="AzureAIAgent"/> restoring serialized channel (started).
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Debug,
        Message = "[{MethodName}] Restoring assistant channel for {ChannelType}: #{ThreadId}.")]
    public static partial void LogAzureAIAgentRestoringChannel(
        this ILogger logger,
        string methodName,
        string channelType,
        string threadId);

    /// <summary>
    /// Logs <see cref="AzureAIAgent"/> restored serialized channel (complete).
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Information,
        Message = "[{MethodName}] Restored assistant channel for {ChannelType}: #{ThreadId}.")]
    public static partial void LogAzureAIAgentRestoredChannel(
        this ILogger logger,
        string methodName,
        string channelType,
        string threadId);
}


===== AzureAI\Properties\AssemblyInfo.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Diagnostics.CodeAnalysis;

// This assembly is currently experimental.
[assembly: Experimental("SKEXP0110")]


===== AzureAI\RunPollingOptions.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;

namespace Microsoft.SemanticKernel.Agents.AzureAI;

/// <summary>
/// Configuration and defaults associated with polling behavior for Assistant API run processing.
/// </summary>
public sealed class RunPollingOptions
{
    /// <summary>
    /// Gets the default maximum number of retries when monitoring thread-run status.
    /// </summary>
    public static int DefaultMaximumRetryCount { get; } = 3;

    /// <summary>
    /// Gets the default polling interval when monitoring thread-run status.
    /// </summary>
    public static TimeSpan DefaultPollingInterval { get; } = TimeSpan.FromMilliseconds(500);

    /// <summary>
    /// Gets the default back-off interval when monitoring thread-run status.
    /// </summary>
    public static TimeSpan DefaultPollingBackoff { get; } = TimeSpan.FromSeconds(1);

    /// <summary>
    /// Gets the default number of polling iterations before using <see cref="RunPollingBackoff"/>.
    /// </summary>
    public static int DefaultPollingBackoffThreshold { get; } = 2;

    /// <summary>
    /// Gets the default polling delay when retrying message retrieval due to a 404/NotFound from synchronization lag.
    /// </summary>
    public static TimeSpan DefaultMessageSynchronizationDelay { get; } = TimeSpan.FromMilliseconds(500);

    /// <summary>
    /// Gets or sets the maximum retry count when polling thread-run status.
    /// </summary>
    /// <remarks>
    /// This value only affects failures that have the potential to be transient.
    /// Explicit server error responses will result in immediate failure.
    /// </remarks>
    public int MaximumRetryCount { get; set; } = DefaultMaximumRetryCount;

    /// <summary>
    /// Gets or sets the polling interval when monitoring thread-run status.
    /// </summary>
    public TimeSpan RunPollingInterval { get; set; } = DefaultPollingInterval;

    /// <summary>
    /// Gets or sets the back-off interval when monitoring thread-run status.
    /// </summary>
    public TimeSpan RunPollingBackoff { get; set; } = DefaultPollingBackoff;

    /// <summary>
    /// Gets or sets the number of polling iterations before using <see cref="RunPollingBackoff"/>.
    /// </summary>
    public int RunPollingBackoffThreshold { get; set; } = DefaultPollingBackoffThreshold;

    /// <summary>
    /// Gets or sets the polling delay when retrying message retrieval due to a 404/NotFound from synchronization lag.
    /// </summary>
    public TimeSpan MessageSynchronizationDelay { get; set; } = DefaultMessageSynchronizationDelay;

    /// <summary>
    /// Gets the polling interval for the specified iteration count.
    /// </summary>
    /// <param name="iterationCount">The number of polling iterations already attempted.</param>
    public TimeSpan GetPollingInterval(int iterationCount)
    {
        return iterationCount > this.RunPollingBackoffThreshold ? this.RunPollingBackoff : this.RunPollingInterval;
    }
}


===== Bedrock\BedrockAgent.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Amazon.BedrockAgent;
using Amazon.BedrockAgentRuntime;
using Amazon.BedrockAgentRuntime.Model;
using Microsoft.SemanticKernel.Agents.Extensions;
using Microsoft.SemanticKernel.ChatCompletion;
using Microsoft.SemanticKernel.Diagnostics;

namespace Microsoft.SemanticKernel.Agents.Bedrock;

/// <summary>
/// Provides a specialized <see cref="Agent"/> for the Bedrock Agent service.
/// </summary>
public sealed class BedrockAgent : Agent
{
    private const string AdditionalInstructionsSessionAttributeName = "AdditionalInstructions";

    /// <summary>
    /// The client used to interact with the Bedrock Agent service.
    /// </summary>
    public IAmazonBedrockAgent Client { get; }

    /// <summary>
    /// The client used to interact with the Bedrock Agent runtime service.
    /// </summary>
    public IAmazonBedrockAgentRuntime RuntimeClient { get; }

    internal readonly Amazon.BedrockAgent.Model.Agent AgentModel;

    /// <summary>
    /// There is a default alias created by Bedrock for the working draft version of the agent.
    /// https://docs.aws.amazon.com/bedrock/latest/userguide/agents-deploy.html
    /// </summary>
    public static readonly string WorkingDraftAgentAlias = "TSTALIASID";

    /// <summary>
    /// Initializes a new instance of the <see cref="BedrockAgent"/> class.
    /// Unlike other types of agents in Semantic Kernel, prompt templates are not supported for Bedrock agents,
    /// since Bedrock agents don't support using an alternative instruction in runtime.
    /// </summary>
    /// <param name="agentModel">The agent model of an agent that exists on the Bedrock Agent service.</param>
    /// <param name="client">A client used to interact with the Bedrock Agent service.</param>
    /// <param name="runtimeClient">A client used to interact with the Bedrock Agent runtime service.</param>
    public BedrockAgent(
        Amazon.BedrockAgent.Model.Agent agentModel,
        IAmazonBedrockAgent client,
        IAmazonBedrockAgentRuntime runtimeClient)
    {
        this.AgentModel = agentModel;
        this.Client = client;
        this.RuntimeClient = runtimeClient;

        this.Id = agentModel.AgentId;
        this.Name = agentModel.AgentName;
        this.Description = agentModel.Description;
        this.Instructions = agentModel.Instruction;
    }

    #region static methods

    /// <summary>
    /// Convenient method to create an unique session id.
    /// </summary>
    public static string CreateSessionId()
    {
        return Guid.NewGuid().ToString();
    }

    #endregion

    #region public methods

    #region InvokeAsync

    /// <summary>
    /// Invoke the agent with the provided message and arguments.
    /// </summary>
    /// <param name="messages">The messages to pass to the agent.</param>
    /// <param name="thread">The conversation thread to continue with this invocation. If not provided, creates a new thread.</param>
    /// <param name="options">Optional instance of <see cref="BedrockAgentInvokeOptions"/> for agent invocation.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>An async list of response items that each contain a <see cref="ChatMessageContent"/> and an <see cref="AgentThread"/>.</returns>
    /// <remarks>
    /// To continue this thread in the future, use an <see cref="AgentThread"/> returned in one of the response items.
    /// </remarks>
    public IAsyncEnumerable<AgentResponseItem<ChatMessageContent>> InvokeAsync(
        ICollection<ChatMessageContent> messages,
        AgentThread? thread = null,
        BedrockAgentInvokeOptions? options = null,
        CancellationToken cancellationToken = default)
    {
        return this.InvokeAsync(messages, thread, (AgentInvokeOptions?)options, cancellationToken);
    }

    /// <inheritdoc/>
    public override async IAsyncEnumerable<AgentResponseItem<ChatMessageContent>> InvokeAsync(
        ICollection<ChatMessageContent> messages,
        AgentThread? thread = null,
        AgentInvokeOptions? options = null,
        [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        if (messages.Count == 0)
        {
            throw new InvalidOperationException("The Bedrock agent requires a message to be invoked.");
        }

        // Create a thread if needed
        BedrockAgentThread bedrockThread = await this.EnsureThreadExistsWithMessagesAsync(
            messages,
            thread,
            () => new BedrockAgentThread(this.RuntimeClient),
            cancellationToken).ConfigureAwait(false);

        // Get the context contributions from the AIContextProviders.
#pragma warning disable SKEXP0110, SKEXP0130  // Type is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.
        AIContext providersContext = await bedrockThread.AIContextProviders.ModelInvokingAsync(messages, cancellationToken).ConfigureAwait(false);
#pragma warning restore SKEXP0110, SKEXP0130 // Type is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.

        // Ensure that the last message provided is a user message
        string message = this.ExtractUserMessage(messages.Last());

        // Build session state with conversation history and override instructions if needed
        SessionState sessionState = this.ExtractSessionState(messages);
        string mergedAdditionalInstructions = FormatAdditionalInstructions(providersContext, options);
        sessionState.PromptSessionAttributes = new() { [AdditionalInstructionsSessionAttributeName] = mergedAdditionalInstructions };

        // Configure the agent request with the provided options
        var invokeAgentRequest = this.ConfigureAgentRequest(options, () =>
        {
            return new InvokeAgentRequest
            {
                SessionState = sessionState,
                AgentId = this.Id,
                SessionId = bedrockThread.Id,
                InputText = message,
            };
        });

        using var activity = ModelDiagnostics.StartAgentInvocationActivity(this.Id, this.GetDisplayName(), this.Description, this.Kernel, messages);

        // Invoke the agent
        var invokeResults = this.InvokeInternalAsync(invokeAgentRequest, options?.KernelArguments, cancellationToken);
        List<ChatMessageContent>? chatMessageContents = activity is not null ? [] : null;

        // Return the results to the caller in AgentResponseItems.
        await foreach (var result in invokeResults.ConfigureAwait(false))
        {
            await this.NotifyThreadOfNewMessage(bedrockThread, result, cancellationToken).ConfigureAwait(false);
            yield return new(result, bedrockThread);
            chatMessageContents?.Add(result);
        }

        activity?.SetAgentResponse(chatMessageContents);
    }

    /// <summary>
    /// Invoke the Bedrock agent with the given request. Use this method when you want to customize the request.
    /// The provided thread is used to continue the conversation. If the thread is not provided and the session id is provided,
    /// a new thread is created with the provided session id. If neither is provided, a new thread is created.
    /// </summary>
    /// <param name="invokeAgentRequest">The request to send to the agent.</param>
    /// <param name="thread">The conversation thread to continue with this invocation. If not provided, creates a new thread.</param>
    /// <param name="options">Optional parameter of type <see cref="BedrockAgentInvokeOptions"/> for agent invocation.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    public IAsyncEnumerable<AgentResponseItem<ChatMessageContent>> InvokeAsync(
        InvokeAgentRequest invokeAgentRequest,
        AgentThread? thread = null,
        BedrockAgentInvokeOptions? options = null,
        CancellationToken cancellationToken = default)
    {
        return this.InvokeAsync(invokeAgentRequest, thread, (AgentInvokeOptions?)options, cancellationToken);
    }

    /// <summary>
    /// Invoke the Bedrock agent with the given request. Use this method when you want to customize the request.
    /// The provided thread is used to continue the conversation. If the thread is not provided and the session id is provided,
    /// a new thread is created with the provided session id. If neither is provided, a new thread is created.
    /// </summary>
    /// <param name="invokeAgentRequest">The request to send to the agent.</param>
    /// <param name="thread">The conversation thread to continue with this invocation. If not provided, creates a new thread.</param>
    /// <param name="options">Optional parameters for agent invocation.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    public async IAsyncEnumerable<AgentResponseItem<ChatMessageContent>> InvokeAsync(
        InvokeAgentRequest invokeAgentRequest,
        AgentThread? thread = null,
        AgentInvokeOptions? options = null,
        [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        // The provided thread is used to continue the conversation. If the thread is not provided and the session id is provided,
        // a new thread is created with the provided session id. If neither is provided, a new thread is created.
        if (thread is null && invokeAgentRequest.SessionId is not null)
        {
            thread = new BedrockAgentThread(this.RuntimeClient, invokeAgentRequest.SessionId);
        }

        BedrockAgentThread bedrockThread = await this.EnsureThreadExistsWithMessagesAsync(
            [],
            thread,
            () => new BedrockAgentThread(this.RuntimeClient),
            cancellationToken).ConfigureAwait(false);

        // Configure the agent request with the provided options
        invokeAgentRequest.SessionId = bedrockThread.Id;
        invokeAgentRequest = this.ConfigureAgentRequest(options, () => invokeAgentRequest);

        using var activity = ModelDiagnostics.StartAgentInvocationActivity(this.Id, this.GetDisplayName(), this.Description, this.Kernel, []);
        List<ChatMessageContent>? chatMessageContents = activity is not null ? [] : null;

        // Invoke the agent
        var invokeResults = this.InvokeInternalAsync(invokeAgentRequest, options?.KernelArguments, cancellationToken);

        // Return the results to the caller in AgentResponseItems.
        await foreach (var result in invokeResults.ConfigureAwait(false))
        {
            await this.NotifyThreadOfNewMessage(bedrockThread, result, cancellationToken).ConfigureAwait(false);
            yield return new(result, bedrockThread);
            chatMessageContents?.Add(result);
        }

        activity?.SetAgentResponse(chatMessageContents);
    }

    #endregion

    #region InvokeStreamingAsync

    /// <summary>
    /// Invoke the agent with the provided message and arguments.
    /// </summary>
    /// <param name="messages">The messages to pass to the agent.</param>
    /// <param name="thread">The conversation thread to continue with this invocation. If not provided, creates a new thread.</param>
    /// <param name="options">Optional parameters of type <see cref="BedrockAgentInvokeOptions"/> for agent invocation.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>An async list of response items that each contain a <see cref="ChatMessageContent"/> and an <see cref="AgentThread"/>.</returns>
    /// <remarks>
    /// To continue this thread in the future, use an <see cref="AgentThread"/> returned in one of the response items.
    /// </remarks>
    public IAsyncEnumerable<AgentResponseItem<StreamingChatMessageContent>> InvokeStreamingAsync(
        ICollection<ChatMessageContent> messages,
        AgentThread? thread = null,
        BedrockAgentInvokeOptions? options = null,
        CancellationToken cancellationToken = default)
    {
        return this.InvokeStreamingAsync(messages, thread, options as AgentInvokeOptions, cancellationToken);
    }

    /// <inheritdoc/>
    public override async IAsyncEnumerable<AgentResponseItem<StreamingChatMessageContent>> InvokeStreamingAsync(
        ICollection<ChatMessageContent> messages,
        AgentThread? thread = null,
        AgentInvokeOptions? options = null,
        [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        Verify.NotNull(messages, nameof(messages));
        if (messages.Count == 0)
        {
            throw new InvalidOperationException("The Bedrock agent requires a message to be invoked.");
        }

        // Create a thread if needed
        BedrockAgentThread bedrockThread = await this.EnsureThreadExistsWithMessagesAsync(
            messages,
            thread,
            () => new BedrockAgentThread(this.RuntimeClient),
            cancellationToken).ConfigureAwait(false);

        // Get the context contributions from the AIContextProviders.
#pragma warning disable SKEXP0110, SKEXP0130 // Type is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.
        AIContext providersContext = await bedrockThread.AIContextProviders.ModelInvokingAsync(messages, cancellationToken).ConfigureAwait(false);
#pragma warning restore SKEXP0110, SKEXP0130 // Type is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.

        // Ensure that the last message provided is a user message
        string? message = this.ExtractUserMessage(messages.Last());

        // Build session state with conversation history and override instructions if needed
        SessionState sessionState = this.ExtractSessionState(messages);
        string mergedAdditionalInstructions = FormatAdditionalInstructions(providersContext, options);
        sessionState.PromptSessionAttributes = new() { [AdditionalInstructionsSessionAttributeName] = mergedAdditionalInstructions };

        // Configure the agent request with the provided options
        var invokeAgentRequest = this.ConfigureAgentRequest(options, () =>
        {
            return new InvokeAgentRequest
            {
                SessionState = sessionState,
                AgentId = this.Id,
                SessionId = bedrockThread.Id,
                InputText = message,
            };
        });

        using var activity = ModelDiagnostics.StartAgentInvocationActivity(this.Id, this.GetDisplayName(), this.Description, this.Kernel, []);
        List<StreamingChatMessageContent>? streamedContents = activity is not null ? [] : null;

        // Invoke the agent
        var invokeResults = this.InvokeStreamingInternalAsync(invokeAgentRequest, bedrockThread, options?.KernelArguments, cancellationToken);

        // Return the results to the caller in AgentResponseItems.
        await foreach (var result in invokeResults.ConfigureAwait(false))
        {
            yield return new(result, bedrockThread);
            streamedContents?.Add(result);
        }

        activity?.EndAgentStreamingResponse(streamedContents);
    }

    /// <summary>
    /// Invoke the Bedrock agent with the given request. Use this method when you want to customize the request.
    /// The provided thread is used to continue the conversation. If the thread is not provided and the session id is provided,
    /// a new thread is created with the provided session id. If neither is provided, a new thread is created.
    /// </summary>
    /// <param name="invokeAgentRequest">The request to send to the agent.</param>
    /// <param name="thread">The conversation thread to continue with this invocation. If not provided, creates a new thread.</param>
    /// <param name="options">Optional parameters of type <see cref="BedrockAgentInvokeOptions"/> for agent invocation.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>An <see cref="IAsyncEnumerable{T}"/> of <see cref="StreamingChatMessageContent"/>.</returns>
    public IAsyncEnumerable<AgentResponseItem<StreamingChatMessageContent>> InvokeStreamingAsync(
        InvokeAgentRequest invokeAgentRequest,
        AgentThread? thread = null,
        BedrockAgentInvokeOptions? options = null,
        CancellationToken cancellationToken = default)
    {
        return this.InvokeStreamingAsync(invokeAgentRequest, thread, options as AgentInvokeOptions, cancellationToken);
    }

    /// <summary>
    /// Invoke the Bedrock agent with the given request. Use this method when you want to customize the request.
    /// The provided thread is used to continue the conversation. If the thread is not provided and the session id is provided,
    /// a new thread is created with the provided session id. If neither is provided, a new thread is created.
    /// </summary>
    /// <param name="invokeAgentRequest">The request to send to the agent.</param>
    /// <param name="thread">The conversation thread to continue with this invocation. If not provided, creates a new thread.</param>
    /// <param name="options">Optional parameters for agent invocation.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>An <see cref="IAsyncEnumerable{T}"/> of <see cref="StreamingChatMessageContent"/>.</returns>
    public async IAsyncEnumerable<AgentResponseItem<StreamingChatMessageContent>> InvokeStreamingAsync(
        InvokeAgentRequest invokeAgentRequest,
        AgentThread? thread = null,
        AgentInvokeOptions? options = null,
        [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        // The provided thread is used to continue the conversation. If the thread is not provided and the session id is provided,
        // a new thread is created with the provided session id. If neither is provided, a new thread is created.
        if (thread is null && invokeAgentRequest.SessionId is not null)
        {
            thread = new BedrockAgentThread(this.RuntimeClient, invokeAgentRequest.SessionId);
        }

        var bedrockThread = await this.EnsureThreadExistsWithMessagesAsync(
            [],
            thread,
            () => new BedrockAgentThread(this.RuntimeClient),
            cancellationToken).ConfigureAwait(false);

        // Configure the agent request with the provided options
        invokeAgentRequest.SessionId = bedrockThread.Id;
        invokeAgentRequest = this.ConfigureAgentRequest(options, () => invokeAgentRequest);

        using var activity = ModelDiagnostics.StartAgentInvocationActivity(this.Id, this.GetDisplayName(), this.Description, this.Kernel, []);
        List<StreamingChatMessageContent>? streamedContents = activity is not null ? [] : null;

        var invokeResults = this.InvokeStreamingInternalAsync(invokeAgentRequest, bedrockThread, options?.KernelArguments, cancellationToken);

        // The Bedrock agent service has the same API for both streaming and non-streaming responses.
        // We are invoking the same method as the non-streaming response with the streaming configuration set,
        // and converting the chat message content to streaming chat message content.
        await foreach (StreamingChatMessageContent chatMessageContent in invokeResults.ConfigureAwait(false))
        {
            yield return new(
                message: new StreamingChatMessageContent(chatMessageContent.Role, chatMessageContent.Content)
                {
                    AuthorName = chatMessageContent.AuthorName,
                    ModelId = chatMessageContent.ModelId,
                    InnerContent = chatMessageContent.InnerContent,
                    Metadata = chatMessageContent.Metadata,
                },
                thread: bedrockThread);
            streamedContents?.Add(chatMessageContent);
        }

        activity?.EndAgentStreamingResponse(streamedContents);
    }

    #endregion

    #endregion

    /// <inheritdoc/>
    protected override IEnumerable<string> GetChannelKeys()
    {
        // Return the channel keys for the BedrockAgent
        yield return typeof(BedrockAgentChannel).FullName!;
    }

    /// <inheritdoc/>
    protected override Task<AgentChannel> CreateChannelAsync(CancellationToken cancellationToken)
    {
        // Create and return a new BedrockAgentChannel
        return Task.FromResult<AgentChannel>(new BedrockAgentChannel());
    }

    /// <inheritdoc/>
    protected override Task<AgentChannel> RestoreChannelAsync(string channelState, CancellationToken cancellationToken)
    {
        // Restore and return a BedrockAgentChannel from the given state
        return Task.FromResult<AgentChannel>(new BedrockAgentChannel());
    }

    #region internal methods

    internal string CodeInterpreterActionGroupSignature { get => $"{this.GetDisplayName()}_CodeInterpreter"; }
    internal string KernelFunctionActionGroupSignature { get => $"{this.GetDisplayName()}_KernelFunctions"; }
    internal string UseInputActionGroupSignature { get => $"{this.GetDisplayName()}_UserInput"; }

    #endregion

    #region private methods

    private IAsyncEnumerable<ChatMessageContent> InvokeInternalAsync(
        InvokeAgentRequest invokeAgentRequest,
        KernelArguments? arguments,
        CancellationToken cancellationToken = default)
    {
        return invokeAgentRequest.StreamingConfigurations != null && (invokeAgentRequest.StreamingConfigurations.StreamFinalResponse ?? false)
            ? throw new ArgumentException("The streaming configuration must be null for non-streaming responses.")
            : InvokeInternal();

        // Collect all responses from the agent and return them as a single chat message content since this
        // is a non-streaming API.
        // The Bedrock Agent API streams beck different types of responses, i.e. text, files, metadata, etc.
        // The Bedrock Agent API also won't stream back any content when it needs to call a function. It will
        // only start streaming back content after the function has been called and the response is ready.
        async IAsyncEnumerable<ChatMessageContent> InvokeInternal()
        {
            ChatMessageContentItemCollection items = [];
            string content = "";
            Dictionary<string, object?> metadata = [];
            List<object?> innerContents = [];

            await foreach (var message in this.InternalInvokeAsync(invokeAgentRequest, arguments, cancellationToken).ConfigureAwait(false))
            {
                items.AddRange(message.Items);
                content += message.Content ?? "";
                if (message.Metadata != null)
                {
                    foreach (var key in message.Metadata.Keys)
                    {
                        metadata[key] = message.Metadata[key];
                    }
                }
                innerContents.Add(message.InnerContent);
            }

            var chatMessageContent = new ChatMessageContent(AuthorRole.Assistant, content)
            {
                AuthorName = this.GetDisplayName(),
                Items = items,
                ModelId = this.AgentModel.FoundationModel,
                Metadata = metadata,
                InnerContent = innerContents,
            };

            yield return chatMessageContent;
        }
    }

    private IAsyncEnumerable<StreamingChatMessageContent> InvokeStreamingInternalAsync(
        InvokeAgentRequest invokeAgentRequest,
        AgentThread thread,
        KernelArguments? arguments,
        CancellationToken cancellationToken = default)
    {
        if (invokeAgentRequest.StreamingConfigurations == null)
        {
            invokeAgentRequest.StreamingConfigurations = new()
            {
                StreamFinalResponse = true,
            };
        }
        else if (!(invokeAgentRequest.StreamingConfigurations.StreamFinalResponse ?? false))
        {
            throw new ArgumentException("The streaming configuration must have StreamFinalResponse set to true.");
        }

        return InvokeInternal();

        async IAsyncEnumerable<StreamingChatMessageContent> InvokeInternal()
        {
            var combinedResponseMessageBuilder = new StringBuilder();
            StreamingChatMessageContent? lastMessage = null;

            // The Bedrock agent service has the same API for both streaming and non-streaming responses.
            // We are invoking the same method as the non-streaming response with the streaming configuration set,
            // and converting the chat message content to streaming chat message content.
            await foreach (var chatMessageContent in this.InternalInvokeAsync(invokeAgentRequest, arguments, cancellationToken).ConfigureAwait(false))
            {
                lastMessage = new StreamingChatMessageContent(chatMessageContent.Role, chatMessageContent.Content)
                {
                    AuthorName = chatMessageContent.AuthorName,
                    ModelId = chatMessageContent.ModelId,
                    InnerContent = chatMessageContent.InnerContent,
                    Metadata = chatMessageContent.Metadata,
                };
                yield return lastMessage;

                combinedResponseMessageBuilder.Append(chatMessageContent.Content);
            }

            // Build a combined message containing the text from all response parts
            // to send to the thread.
            var combinedMessage = new ChatMessageContent(AuthorRole.Assistant, combinedResponseMessageBuilder.ToString())
            {
                AuthorName = lastMessage?.AuthorName,
                ModelId = lastMessage?.ModelId,
                Metadata = lastMessage?.Metadata,
            };
            await this.NotifyThreadOfNewMessage(thread, combinedMessage, cancellationToken).ConfigureAwait(false);
        }
    }

    private InvokeAgentRequest ConfigureAgentRequest(AgentInvokeOptions? options, Func<InvokeAgentRequest> createRequest)
    {
        string agentAlias = WorkingDraftAgentAlias;
        bool enableTrace = false;
        if (options is BedrockAgentInvokeOptions bedrockOption)
        {
            agentAlias = bedrockOption.AgentAliasId ?? WorkingDraftAgentAlias;
            enableTrace = bedrockOption.EnableTrace;
        }

        var invokeRequest = createRequest();
        invokeRequest.AgentAliasId = agentAlias;
        invokeRequest.EnableTrace = enableTrace;
        return invokeRequest;
    }

    private string ExtractUserMessage(ChatMessageContent chatMessageContent)
    {
        if (!chatMessageContent.Role.Equals(AuthorRole.User))
        {
            throw new InvalidOperationException("Bedrock agents must be invoked with a user message");
        }

        return chatMessageContent.Content ?? "";
    }

    private SessionState ExtractSessionState(ICollection<ChatMessageContent> messages)
    {
        // If there is more than one message provided, add all but the last message to the session state
        SessionState sessionState = new();
        if (messages.Count > 1)
        {
            List<Amazon.BedrockAgentRuntime.Model.Message> messageHistory = [];
            for (int i = 0; i < messages.Count - 1; i++)
            {
                var currentMessage = messages.ElementAt(i);
                messageHistory.Add(this.ToBedrockMessage(currentMessage));
            }

            sessionState.ConversationHistory = new ConversationHistory() { Messages = messageHistory };
        }

        return sessionState;
    }

    private Amazon.BedrockAgentRuntime.Model.Message ToBedrockMessage(ChatMessageContent chatMessageContent)
    {
        return new Amazon.BedrockAgentRuntime.Model.Message()
        {
            Role = this.MapBedrockAgentUser(chatMessageContent.Role),
            Content = [new() { Text = chatMessageContent.Content }]
        };
    }

    private Amazon.BedrockAgentRuntime.ConversationRole MapBedrockAgentUser(AuthorRole authorRole)
    {
        if (authorRole == AuthorRole.User)
        {
            return Amazon.BedrockAgentRuntime.ConversationRole.User;
        }

        if (authorRole == AuthorRole.Assistant)
        {
            return Amazon.BedrockAgentRuntime.ConversationRole.Assistant;
        }

        throw new ArgumentOutOfRangeException($"Invalid role: {authorRole}");
    }

    #endregion
}


===== Bedrock\BedrockAgentChannel.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Amazon.BedrockAgentRuntime.Model;
using Microsoft.Extensions.Logging;
using Microsoft.SemanticKernel.Agents.Extensions;
using Microsoft.SemanticKernel.Agents.Serialization;
using Microsoft.SemanticKernel.ChatCompletion;

namespace Microsoft.SemanticKernel.Agents.Bedrock;

/// <summary>
/// A <see cref="AgentChannel"/> specialization for use with <see cref="BedrockAgent"/>.
/// </summary>
public class BedrockAgentChannel : AgentChannel<BedrockAgent>
{
    private readonly ChatHistory _history = [];

    private const string MessagePlaceholder = "[SILENCE]";

    /// <summary>
    /// Receive messages from a group chat.
    /// Bedrock requires the chat history to alternate between user and agent messages.
    /// Thus, when receiving messages, the message sequence will be mutated by inserting
    /// placeholder agent or user messages as needed.
    /// </summary>
    /// <param name="history">The history of messages to receive.</param>
    /// <param name="cancellationToken">A token to monitor for cancellation requests.</param>
    protected override Task ReceiveAsync(IEnumerable<ChatMessageContent> history, CancellationToken cancellationToken)
    {
        foreach (var incomingMessage in history)
        {
            if (string.IsNullOrEmpty(incomingMessage.Content))
            {
                this.Logger.LogWarning("Received a message with no content. Skipping.");
                continue;
            }

            if (this._history.Count == 0 || this._history.Last().Role != incomingMessage.Role)
            {
                this._history.Add(incomingMessage);
            }
            else
            {
                this._history.Add
                (
                    new ChatMessageContent
                    (
                        incomingMessage.Role == AuthorRole.Assistant ? AuthorRole.User : AuthorRole.Assistant,
                        MessagePlaceholder
                    )
                );
                this._history.Add(incomingMessage);
            }
        }

        return Task.CompletedTask;
    }

    /// <inheritdoc/>
    protected override async IAsyncEnumerable<(bool IsVisible, ChatMessageContent Message)> InvokeAsync(
        BedrockAgent agent,
        [EnumeratorCancellation] CancellationToken cancellationToken)
    {
        if (!this.PrepareAndValidateHistory())
        {
            yield break;
        }

        InvokeAgentRequest invokeAgentRequest = new()
        {
            AgentAliasId = BedrockAgent.WorkingDraftAgentAlias,
            AgentId = agent.Id,
            SessionId = BedrockAgent.CreateSessionId(),
            InputText = this._history.Last().Content,
            SessionState = this.ParseHistoryToSessionState(),
        };
        await foreach (ChatMessageContent message in agent.InvokeAsync(invokeAgentRequest, null, null, cancellationToken).ConfigureAwait(false))
        {
            if (message.Content is not null)
            {
                this._history.Add(message);
                // All messages from Bedrock agents are user facing, i.e., function calls are not returned as messages
                yield return (true, message);
            }
        }
    }

    /// <inheritdoc/>
    protected override async IAsyncEnumerable<StreamingChatMessageContent> InvokeStreamingAsync(
        BedrockAgent agent,
        IList<ChatMessageContent> messages,
        [EnumeratorCancellation] CancellationToken cancellationToken)
    {
        if (!this.PrepareAndValidateHistory())
        {
            yield break;
        }

        InvokeAgentRequest invokeAgentRequest = new()
        {
            AgentAliasId = BedrockAgent.WorkingDraftAgentAlias,
            AgentId = agent.Id,
            SessionId = BedrockAgent.CreateSessionId(),
            InputText = this._history.Last().Content,
            SessionState = this.ParseHistoryToSessionState(),
        };
        await foreach (StreamingChatMessageContent message in agent.InvokeStreamingAsync(invokeAgentRequest, null, null, cancellationToken).ConfigureAwait(false))
        {
            if (message.Content is not null)
            {
                this._history.Add(new()
                {
                    Role = AuthorRole.Assistant,
                    Content = message.Content,
                    AuthorName = message.AuthorName,
                    InnerContent = message.InnerContent,
                    ModelId = message.ModelId,
                });
                // All messages from Bedrock agents are user facing, i.e., function calls are not returned as messages
                yield return message;
            }
        }
    }

    /// <inheritdoc/>
    protected override IAsyncEnumerable<ChatMessageContent> GetHistoryAsync(CancellationToken cancellationToken)
    {
        return this._history.ToDescendingAsync();
    }

    /// <inheritdoc/>
    protected override Task ResetAsync(CancellationToken cancellationToken)
    {
        this._history.Clear();

        return Task.CompletedTask;
    }

    /// <inheritdoc/>
    protected override string Serialize()
        => JsonSerializer.Serialize(ChatMessageReference.Prepare(this._history));

    #region private methods

    private bool PrepareAndValidateHistory()
    {
        if (this._history.Count == 0)
        {
            this.Logger.LogWarning("No messages to send. Bedrock requires at least one message to start a conversation.");
            return false;
        }

        this.EnsureHistoryAlternates();
        this.EnsureLastMessageIsUser();
        if (string.IsNullOrEmpty(this._history.Last().Content))
        {
            this.Logger.LogWarning("Last message has no content. Bedrock doesn't support empty messages.");
            return false;
        }

        return true;
    }

    private void EnsureHistoryAlternates()
    {
        if (this._history.Count <= 1)
        {
            return;
        }

        int currentIndex = 1;
        while (currentIndex < this._history.Count)
        {
            if (this._history[currentIndex].Role == this._history[currentIndex - 1].Role)
            {
                this._history.Insert(
                    currentIndex,
                    new ChatMessageContent(
                        this._history[currentIndex].Role == AuthorRole.Assistant ? AuthorRole.User : AuthorRole.Assistant,
                        MessagePlaceholder
                    )
                );
                currentIndex += 2;
            }
            else
            {
                currentIndex++;
            }
        }
    }

    private void EnsureLastMessageIsUser()
    {
        if (this._history.Count > 0 && this._history.Last().Role != AuthorRole.User)
        {
            this._history.Add(new ChatMessageContent(AuthorRole.User, MessagePlaceholder));
        }
    }

    private SessionState ParseHistoryToSessionState()
    {
        SessionState sessionState = new();

        // We don't take the last message as it needs to be sent separately in another parameter.
        if (this._history.Count > 1)
        {
            sessionState.ConversationHistory = new()
            {
                Messages = []
            };

            foreach (var message in this._history.Take(this._history.Count - 1))
            {
                if (message.Content is null)
                {
                    throw new InvalidOperationException("Message content cannot be null.");
                }
                if (message.Role != AuthorRole.Assistant && message.Role != AuthorRole.User)
                {
                    throw new InvalidOperationException("Message role must be either Assistant or User.");
                }

                sessionState.ConversationHistory.Messages.Add(new()
                {
                    Role = message.Role == AuthorRole.Assistant
                        ? Amazon.BedrockAgentRuntime.ConversationRole.Assistant
                        : Amazon.BedrockAgentRuntime.ConversationRole.User,
                    Content = [
                        new Amazon.BedrockAgentRuntime.Model.ContentBlock()
                        {
                            Text = message.Content,
                        },
                    ],
                });
            }
        }

        return sessionState;
    }
    #endregion
}


===== Bedrock\BedrockAgentInvokeOptions.cs =====

// Copyright (c) Microsoft. All rights reserved.

namespace Microsoft.SemanticKernel.Agents.Bedrock;

/// <summary>
/// Optional parameters for BedrockAgent invocation.
/// </summary>
public sealed class BedrockAgentInvokeOptions : AgentInvokeOptions
{
    /// <summary>
    /// Gets or sets the alias ID of the agent to invoke.
    /// </summary>
    public string? AgentAliasId { get; set; }

    /// <summary>
    /// Enable trace to inspect the agent's thought process
    /// </summary>
    public bool EnableTrace { get; set; }
}


===== Bedrock\BedrockAgentThread.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Threading;
using System.Threading.Tasks;
using Amazon.BedrockAgentRuntime;

namespace Microsoft.SemanticKernel.Agents.Bedrock;
/// <summary>
/// Represents a conversation thread for a Bedrock agent.
/// </summary>
public sealed class BedrockAgentThread : AgentThread
{
    private readonly IAmazonBedrockAgentRuntime _runtimeClient;

    /// <summary>
    /// Initializes a new instance of the <see cref="BedrockAgentThread"/> class.
    /// </summary>
    /// <param name="runtimeClient">A client used to interact with the Bedrock Agent runtime service.</param>
    /// <param name="sessionId">An optional session Id to continue an existing session.</param>
    /// <exception cref="ArgumentNullException"></exception>
    public BedrockAgentThread(IAmazonBedrockAgentRuntime runtimeClient, string? sessionId = null)
    {
        this._runtimeClient = runtimeClient ?? throw new ArgumentNullException(nameof(runtimeClient));
        this.Id = sessionId;
    }

    /// <summary>
    /// Creates the thread and returns the thread id.
    /// </summary>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>A task that completes when the thread has been created.</returns>
    public new Task CreateAsync(CancellationToken cancellationToken = default)
    {
        return base.CreateAsync(cancellationToken);
    }

    /// <inheritdoc />
    protected override async Task<string?> CreateInternalAsync(CancellationToken cancellationToken)
    {
        const string ErrorMessage = "The thread could not be created due to an error response from the service.";

        try
        {
            var response = await this._runtimeClient.CreateSessionAsync(
                request: new(),
                cancellationToken: cancellationToken).ConfigureAwait(false);

            return response.SessionId;
        }
        catch (AmazonBedrockAgentRuntimeException ex)
        {
            throw new AgentThreadOperationException(ErrorMessage, ex);
        }
        catch (AggregateException ex)
        {
            throw new AgentThreadOperationException(ErrorMessage, ex);
        }
    }

    /// <inheritdoc />
    protected override async Task DeleteInternalAsync(CancellationToken cancellationToken)
    {
        const string ErrorMessage = "The thread could not be deleted due to an error response from the service.";

        try
        {
            var endSessionResponse = await this._runtimeClient.EndSessionAsync(
                request: new()
                {
                    SessionIdentifier = this.Id
                },
                cancellationToken: cancellationToken).ConfigureAwait(false);

            var deleteSessionResponse = await this._runtimeClient.DeleteSessionAsync(
                request: new()
                {
                    SessionIdentifier = this.Id
                },
                cancellationToken: cancellationToken).ConfigureAwait(false);

            this.Id = null;
        }
        catch (AmazonBedrockAgentRuntimeException ex)
        {
            throw new AgentThreadOperationException(ErrorMessage, ex);
        }
        catch (AggregateException ex)
        {
            throw new AgentThreadOperationException(ErrorMessage, ex);
        }
    }

    /// <inheritdoc />
    protected override async Task OnNewMessageInternalAsync(ChatMessageContent newMessage, CancellationToken cancellationToken = default)
    {
        // Create the thread if it does not exist. Bedrock agents cannot add messages to the thread without invoking so we don't do that here
        await this.CreateAsync(cancellationToken).ConfigureAwait(false);
    }
}


===== Bedrock\Definition\BedrockAgentFactory.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Diagnostics.CodeAnalysis;
using System.Threading;
using System.Threading.Tasks;
using Amazon.BedrockAgent;
using Amazon.BedrockAgentRuntime;

namespace Microsoft.SemanticKernel.Agents.Bedrock;

/// <summary>
/// Provides a <see cref="AgentFactory"/> which creates instances of <see cref="BedrockAgent"/>.
/// </summary>
[Experimental("SKEXP0110")]
public sealed class BedrockAgentFactory : AgentFactory
{
    /// <summary>
    /// The type of the Bedrock agent.
    /// </summary>
    public const string BedrockAgentType = "bedrock_agent";

    private const string AgentResourceRoleArn = "agent_resource_role_arn";

    /// <summary>
    /// Initializes a new instance of the <see cref="BedrockAgentFactory"/> class.
    /// </summary>
    public BedrockAgentFactory()
        : base([BedrockAgentType])
    {
    }

    /// <inheritdoc/>
    public override async Task<Agent?> TryCreateAsync(Kernel kernel, AgentDefinition agentDefinition, AgentCreationOptions? agentCreationOptions = null, CancellationToken cancellationToken = default)
    {
        Verify.NotNull(agentDefinition);

        if (agentDefinition.Type?.Equals(BedrockAgentType, System.StringComparison.Ordinal) ?? false)
        {
            var agentClient = new AmazonBedrockAgentClient();
            var runtimeClient = new AmazonBedrockAgentRuntimeClient();

            if (!string.IsNullOrEmpty(agentDefinition.Id))
            {
                // Get an existing agent
                var agentResponse = await agentClient.GetAgentAsync(
                    new()
                    {
                        AgentId = agentDefinition.Id,
                    },
                    cancellationToken
                ).ConfigureAwait(false);

                return new BedrockAgent(agentResponse.Agent, agentClient, runtimeClient)
                {
                    Kernel = kernel,
                    Arguments = agentDefinition.GetDefaultKernelArguments(kernel) ?? [],
                    Template = agentDefinition.GetPromptTemplate(kernel, agentCreationOptions?.PromptTemplateFactory),
                    Instructions = agentDefinition.Instructions,
                };
            }

            // create the agent
            Verify.NotNull(agentDefinition.Name);
            Verify.NotNull(agentDefinition.Description);
            Verify.NotNull(agentDefinition.Instructions);
            Verify.NotNull(agentDefinition.Model);
            Verify.NotNull(agentDefinition.Model.Id);
            var agentResourceRoleArn = GetAgentResourceRoleArn(agentDefinition);
            var agentModel = await agentClient.CreateAgentAndWaitAsync(
                new()
                {
                    FoundationModel = agentDefinition.Model!.Id,
                    AgentName = agentDefinition.Name,
                    Description = agentDefinition.Description,
                    Instruction = agentDefinition.Instructions,
                    AgentResourceRoleArn = agentResourceRoleArn,
                },
                cancellationToken
            ).ConfigureAwait(false);

            var agent = new BedrockAgent(agentModel, agentClient, runtimeClient)
            {
                Kernel = kernel,
                Arguments = agentDefinition.GetDefaultKernelArguments(kernel) ?? [],
                Template = agentDefinition.GetPromptTemplate(kernel, agentCreationOptions?.PromptTemplateFactory),
            };

            // create tools from the definition
            await agentDefinition.CreateToolsAsync(agent, cancellationToken).ConfigureAwait(false);

            // wait for the agent to be prepared
            await agentClient.PrepareAgentAndWaitAsync(agentModel, cancellationToken).ConfigureAwait(false);

            return agent;
        }

        return null;
    }

    #region private
    private static string? GetAgentResourceRoleArn(AgentDefinition agentDefinition)
    {
        return agentDefinition.Model?.Connection?.ExtensionData.TryGetValue(AgentResourceRoleArn, out var value) ?? false ? value as string : null;
    }

    #endregion
}


===== Bedrock\Extensions\BedrockAgentDefinitionExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Amazon.BedrockAgent.Model;

namespace Microsoft.SemanticKernel.Agents.Bedrock;

/// <summary>
/// Provides extension methods for <see cref="AgentDefinition"/>.
/// </summary>
internal static class BedrockAgentDefinitionExtensions
{
    private const string CodeInterpreterType = "code_interpreter";
    private const string KnowledgeBaseType = "knowledge_base";
    private const string FunctionType = "function";
    private const string KnowledgeBaseId = "knowledge_base_id";

    internal static async Task CreateToolsAsync(this AgentDefinition agentDefinition, BedrockAgent agent, CancellationToken cancellationToken)
    {
        if (agentDefinition.Tools is null || agentDefinition.Tools.Count == 0)
        {
            return;
        }

        var codeInterpreter = agentDefinition.GetFirstToolDefinition(CodeInterpreterType);
        if (codeInterpreter is not null)
        {
            await agent.CreateCodeInterpreterActionGroupAsync(cancellationToken).ConfigureAwait(false);
        }

        var functionSchema = agentDefinition.GetFunctionSchema();
        if (functionSchema is not null)
        {
            await agent.CreateKernelFunctionActionGroupAsync(functionSchema, cancellationToken).ConfigureAwait(false);
        }

        var knowledgeBases = agentDefinition.GetToolDefinitions(KnowledgeBaseType);
        if (knowledgeBases is not null)
        {
            foreach (var knowledgeBase in knowledgeBases)
            {
                if (knowledgeBase.Options?.TryGetValue(KnowledgeBaseId, out var value) ?? false && value is not null && value is string)
                {
                    var knowledgeBaseId = value as string;
                    var description = knowledgeBase.Description ?? string.Empty;
                    await agent.AssociateAgentKnowledgeBaseAsync(knowledgeBaseId!, description, cancellationToken).ConfigureAwait(false);
                }
            }
        }
    }

    internal static FunctionSchema? GetFunctionSchema(this AgentDefinition agentDefinition)
    {
        var functionTools = agentDefinition.GetToolDefinitions(FunctionType);
        if (functionTools is null)
        {
            return null;
        }

        List<Function> functions = [];
        foreach (var functionTool in functionTools)
        {
            functions.Add(new Function
            {
                Name = functionTool.Id,
                Description = functionTool.Description,
                Parameters = functionTool.CreateParameterDetails(),
                // This field controls whether user confirmation is required to invoke the function.
                // If this is set to "ENABLED", the user will be prompted to confirm the function invocation.
                // Only after the user confirms, the function call request will be issued by the agent.
                // If the user denies the confirmation, the agent will act as if the function does not exist.
                // Currently, we do not support this feature, so we set it to "DISABLED".
                RequireConfirmation = Amazon.BedrockAgent.RequireConfirmation.DISABLED,
            });
        }

        return functions.Count == 0 ? null : new FunctionSchema { Functions = functions };
    }
}


===== Bedrock\Extensions\BedrockAgentExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Diagnostics.CodeAnalysis;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Amazon.BedrockAgent;
using Amazon.BedrockAgent.Model;
using Microsoft.Agents.AI;

namespace Microsoft.SemanticKernel.Agents.Bedrock;

/// <summary>
/// Extensions associated with <see cref="AmazonBedrockAgentClient"/>
/// </summary>
public static class BedrockAgentExtensions
{
    /// <summary>
    /// Exposes a Semantic Kernel Agent Framework <see cref="BedrockAgent"/> as a Microsoft Agent Framework <see cref="AIAgent"/>.
    /// </summary>
    /// <param name="bedrockAgent">The Semantic Kernel <see cref="BedrockAgent"/> to expose as a Microsoft Agent Framework <see cref="AIAgent"/>.</param>
    /// <returns>The Semantic Kernel Agent Framework <see cref="Agent"/> exposed as a Microsoft Agent Framework <see cref="AIAgent"/></returns>
    [Experimental("SKEXP0110")]
    public static AIAgent AsAIAgent(this BedrockAgent bedrockAgent)
        => bedrockAgent.AsAIAgent(
            () => new BedrockAgentThread(bedrockAgent.RuntimeClient),
            (json, options) =>
            {
                var agentId = JsonSerializer.Deserialize<string>(json);
                return agentId is null ? new BedrockAgentThread(bedrockAgent.RuntimeClient) : new BedrockAgentThread(bedrockAgent.RuntimeClient, agentId);
            },
            (thread, options) => JsonSerializer.SerializeToElement((thread as BedrockAgentThread)?.Id));

    /// <summary>
    /// Creates an agent.
    /// </summary>
    /// <param name="client">The <see cref="AmazonBedrockAgentClient"/> instance.</param>
    /// <param name="request">The <see cref="CreateAgentRequest"/> instance.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> instance.</param>
    public static async Task<Amazon.BedrockAgent.Model.Agent> CreateAndPrepareAgentAsync(
        this IAmazonBedrockAgent client,
        CreateAgentRequest request,
        CancellationToken cancellationToken = default)
    {
        var createAgentResponse = await client.CreateAgentAsync(request, cancellationToken).ConfigureAwait(false);
        // The agent will first enter the CREATING status.
        // When the operation finishes, it will enter the NOT_PREPARED status.
        // We need to wait for the agent to reach the NOT_PREPARED status before we can prepare it.
        await client.WaitForAgentStatusAsync(createAgentResponse.Agent, AgentStatus.NOT_PREPARED, cancellationToken: cancellationToken).ConfigureAwait(false);
        return await client.PrepareAgentAndWaitUntilPreparedAsync(createAgentResponse.Agent, cancellationToken).ConfigureAwait(false);
    }

    /// <summary>
    /// Creates an agent.
    /// </summary>
    /// <param name="client">The <see cref="AmazonBedrockAgentClient"/> instance.</param>
    /// <param name="request">The <see cref="CreateAgentRequest"/> instance.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> instance.</param>
    public static async Task<Amazon.BedrockAgent.Model.Agent> CreateAgentAndWaitAsync(
        this IAmazonBedrockAgent client,
        CreateAgentRequest request,
        CancellationToken cancellationToken = default)
    {
        var createAgentResponse = await client.CreateAgentAsync(request, cancellationToken).ConfigureAwait(false);
        // The agent will first enter the CREATING status.
        // When the operation finishes, it will enter the NOT_PREPARED status.
        // We need to wait for the agent to reach the NOT_PREPARED status before we can prepare it.
        await client.WaitForAgentStatusAsync(createAgentResponse.Agent, AgentStatus.NOT_PREPARED, cancellationToken: cancellationToken).ConfigureAwait(false);
        return createAgentResponse.Agent;
    }

    /// <summary>
    /// Creates an agent.
    /// </summary>
    /// <param name="client">The <see cref="AmazonBedrockAgentClient"/> instance.</param>
    /// <param name="agent">The <see cref="Amazon.BedrockAgent.Model.Agent"/> instance.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> instance.</param>
    public static async Task<Amazon.BedrockAgent.Model.Agent> PrepareAgentAndWaitAsync(
        this IAmazonBedrockAgent client,
        Amazon.BedrockAgent.Model.Agent agent,
        CancellationToken cancellationToken = default)
    {
        return await client.PrepareAgentAndWaitUntilPreparedAsync(agent, cancellationToken).ConfigureAwait(false);
    }

    /// <summary>
    /// Associates an agent with a knowledge base.
    /// </summary>
    /// <param name="agent">The <see cref="BedrockAgent"/> instance.</param>
    /// <param name="knowledgeBaseId">The knowledge base ID.</param>
    /// <param name="description">The description of the association.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> instance.</param>
    public static async Task AssociateAgentKnowledgeBaseAsync(
        this BedrockAgent agent,
        string knowledgeBaseId,
        string description,
        CancellationToken cancellationToken = default)
    {
        await agent.Client.AssociateAgentKnowledgeBaseAsync(new()
        {
            AgentId = agent.Id,
            AgentVersion = agent.AgentModel.AgentVersion ?? "DRAFT",
            KnowledgeBaseId = knowledgeBaseId,
            Description = description,
        }, cancellationToken).ConfigureAwait(false);

        await agent.Client.PrepareAgentAndWaitUntilPreparedAsync(agent.AgentModel, cancellationToken).ConfigureAwait(false);
    }

    /// <summary>
    /// Disassociate the agent with a knowledge base.
    /// </summary>
    /// <param name="agent">The <see cref="BedrockAgent"/> instance.</param>
    /// <param name="knowledgeBaseId">The id of the knowledge base to disassociate with the agent.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    public static async Task DisassociateAgentKnowledgeBaseAsync(
        this BedrockAgent agent,
        string knowledgeBaseId,
        CancellationToken cancellationToken = default)
    {
        await agent.Client.DisassociateAgentKnowledgeBaseAsync(new()
        {
            AgentId = agent.Id,
            AgentVersion = agent.AgentModel.AgentVersion ?? "DRAFT",
            KnowledgeBaseId = knowledgeBaseId,
        }, cancellationToken).ConfigureAwait(false);

        await agent.Client.PrepareAgentAndWaitUntilPreparedAsync(agent.AgentModel, cancellationToken).ConfigureAwait(false);
    }

    /// <summary>
    /// List the knowledge bases associated with the agent.
    /// </summary>
    /// <param name="agent">The <see cref="BedrockAgent"/> instance.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>A <see cref="ListAgentKnowledgeBasesResponse"/> containing the knowledge bases associated with the agent.</returns>
    public static async Task<ListAgentKnowledgeBasesResponse> ListAssociatedKnowledgeBasesAsync(
        this BedrockAgent agent,
        CancellationToken cancellationToken = default)
    {
        return await agent.Client.ListAgentKnowledgeBasesAsync(new()
        {
            AgentId = agent.Id,
            AgentVersion = agent.AgentModel.AgentVersion ?? "DRAFT",
        }, cancellationToken).ConfigureAwait(false);
    }

    /// <summary>
    /// Create a code interpreter action group for the agent and prepare the agent.
    /// </summary>
    /// <param name="agent">The <see cref="BedrockAgent"/> instance.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    public static async Task CreateCodeInterpreterActionGroupAsync(
        this BedrockAgent agent,
        CancellationToken cancellationToken = default)
    {
        var createAgentActionGroupRequest = new CreateAgentActionGroupRequest
        {
            AgentId = agent.Id,
            AgentVersion = agent.AgentModel.AgentVersion ?? "DRAFT",
            ActionGroupName = agent.CodeInterpreterActionGroupSignature,
            ActionGroupState = ActionGroupState.ENABLED,
            ParentActionGroupSignature = new(Amazon.BedrockAgent.ActionGroupSignature.AMAZONCodeInterpreter),
        };

        await agent.Client.CreateAgentActionGroupAsync(createAgentActionGroupRequest, cancellationToken).ConfigureAwait(false);
        await agent.Client.PrepareAgentAndWaitUntilPreparedAsync(agent.AgentModel, cancellationToken).ConfigureAwait(false);
    }

    /// <summary>
    /// Create a kernel function action group for the agent and prepare the agent.
    /// </summary>
    /// <param name="agent">The <see cref="BedrockAgent"/> instance.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    public static async Task CreateKernelFunctionActionGroupAsync(
        this BedrockAgent agent,
        CancellationToken cancellationToken = default)
    {
        await agent.CreateKernelFunctionActionGroupAsync(agent.Kernel.ToFunctionSchema(), cancellationToken).ConfigureAwait(false);
    }

    /// <summary>
    /// Create a kernel function action group for the agent and prepare the agent.
    /// </summary>
    /// <param name="agent">The <see cref="BedrockAgent"/> instance.</param>
    /// <param name="functionSchema">The details of the function schema for the action group.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    public static async Task CreateKernelFunctionActionGroupAsync(
        this BedrockAgent agent,
        FunctionSchema functionSchema,
        CancellationToken cancellationToken = default)
    {
        var createAgentActionGroupRequest = new CreateAgentActionGroupRequest
        {
            AgentId = agent.Id,
            AgentVersion = agent.AgentModel.AgentVersion ?? "DRAFT",
            ActionGroupName = agent.KernelFunctionActionGroupSignature,
            ActionGroupState = ActionGroupState.ENABLED,
            ActionGroupExecutor = new()
            {
                CustomControl = Amazon.BedrockAgent.CustomControlMethod.RETURN_CONTROL,
            },
            FunctionSchema = functionSchema,
        };

        await agent.Client.CreateAgentActionGroupAsync(createAgentActionGroupRequest, cancellationToken).ConfigureAwait(false);
        await agent.Client.PrepareAgentAndWaitUntilPreparedAsync(agent.AgentModel, cancellationToken).ConfigureAwait(false);
    }

    /// <summary>
    /// Enable user input for the agent and prepare the agent.
    /// </summary>
    /// <param name="agent">The <see cref="BedrockAgent"/> instance.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    public static async Task EnableUserInputActionGroupAsync(
        this BedrockAgent agent,
        CancellationToken cancellationToken = default)
    {
        var createAgentActionGroupRequest = new CreateAgentActionGroupRequest
        {
            AgentId = agent.Id,
            AgentVersion = agent.AgentModel.AgentVersion ?? "DRAFT",
            ActionGroupName = agent.UseInputActionGroupSignature,
            ActionGroupState = ActionGroupState.ENABLED,
            ParentActionGroupSignature = new(Amazon.BedrockAgent.ActionGroupSignature.AMAZONUserInput),
        };

        await agent.Client.CreateAgentActionGroupAsync(createAgentActionGroupRequest, cancellationToken).ConfigureAwait(false);
        await agent.Client.PrepareAgentAndWaitUntilPreparedAsync(agent.AgentModel, cancellationToken).ConfigureAwait(false);
    }

    private static async Task<Amazon.BedrockAgent.Model.Agent> PrepareAgentAndWaitUntilPreparedAsync(
        this IAmazonBedrockAgent client,
        Amazon.BedrockAgent.Model.Agent agent,
        CancellationToken cancellationToken = default)
    {
        var prepareAgentResponse = await client.PrepareAgentAsync(new() { AgentId = agent.AgentId }, cancellationToken).ConfigureAwait(false);

        // The agent will take some time to enter the PREPARING status after the prepare operation is called.
        // We need to wait for the agent to reach the PREPARING status before we can proceed, otherwise we
        // will return immediately if the agent is already in PREPARED status.
        await client.WaitForAgentStatusAsync(agent, AgentStatus.PREPARING, cancellationToken: cancellationToken).ConfigureAwait(false);
        // When the agent is prepared, it will enter the PREPARED status.
        return await client.WaitForAgentStatusAsync(agent, AgentStatus.PREPARED, cancellationToken: cancellationToken).ConfigureAwait(false);
    }

    /// <summary>
    /// Wait for the agent to reach the specified status.
    /// </summary>
    /// <param name="client">The <see cref="AmazonBedrockAgentClient"/> instance.</param>
    /// <param name="agent">The <see cref="BedrockAgent"/> to monitor.</param>
    /// <param name="status">The status to wait for.</param>
    /// <param name="interval">The interval in seconds to wait between attempts. The default is 2 seconds.</param>
    /// <param name="maxAttempts">The maximum number of attempts to make. The default is 5 attempts.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests.</param>
    /// <returns>The <see cref="Amazon.BedrockAgent.Model.Agent"/> instance.</returns>
    private static async Task<Amazon.BedrockAgent.Model.Agent> WaitForAgentStatusAsync(
        this IAmazonBedrockAgent client,
        Amazon.BedrockAgent.Model.Agent agent,
        AgentStatus status,
        int interval = 2,
        int maxAttempts = 5,
        CancellationToken cancellationToken = default)
    {
        for (var i = 0; i < maxAttempts; i++)
        {
            var getAgentResponse = await client.GetAgentAsync(new() { AgentId = agent.AgentId }, cancellationToken).ConfigureAwait(false);

            if (getAgentResponse.Agent.AgentStatus == status)
            {
                return getAgentResponse.Agent;
            }

            await Task.Delay(interval * 1000, cancellationToken).ConfigureAwait(false);
        }

        throw new TimeoutException($"Agent did not reach status {status} within the specified time.");
    }
}


===== Bedrock\Extensions\BedrockAgentInvokeExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Amazon.BedrockAgentRuntime;
using Amazon.BedrockAgentRuntime.Model;
using Amazon.Runtime.EventStreams;
using Microsoft.SemanticKernel.Agents.Extensions;
using Microsoft.SemanticKernel.ChatCompletion;
using Microsoft.SemanticKernel.Connectors.FunctionCalling;

namespace Microsoft.SemanticKernel.Agents.Bedrock;

/// <summary>
/// Extensions associated with the status of a <see cref="BedrockAgent"/>.
/// </summary>
internal static class BedrockAgentInvokeExtensions
{
    public static async IAsyncEnumerable<ChatMessageContent> InternalInvokeAsync(
        this BedrockAgent agent,
        InvokeAgentRequest invokeAgentRequest,
        KernelArguments? arguments,
        [EnumeratorCancellation] CancellationToken cancellationToken)
    {
        // This session state is used to store the results of function calls to be passed back to the agent.
        // https://docs.aws.amazon.com/sdkfornet/v3/apidocs/items/BedrockAgentRuntime/TSessionState.html
        SessionState? sessionState = null;
        for (var requestIndex = 0; ; requestIndex++)
        {
            if (sessionState != null)
            {
                invokeAgentRequest.SessionState = sessionState;
                sessionState = null;
            }
            var invokeAgentResponse = await agent.RuntimeClient.InvokeAgentAsync(invokeAgentRequest, cancellationToken).ConfigureAwait(false);

            if (invokeAgentResponse.HttpStatusCode != System.Net.HttpStatusCode.OK)
            {
                throw new HttpOperationException($"Failed to invoke agent. Status code: {invokeAgentResponse.HttpStatusCode}");
            }

            List<FunctionCallContent> functionCallContents = [];
            foreach (var responseEvent in invokeAgentResponse.Completion)
            {
                if (responseEvent is BedrockAgentRuntimeEventStreamException bedrockAgentRuntimeEventStreamException)
                {
                    throw new KernelException("Failed to handle Bedrock Agent stream event.", bedrockAgentRuntimeEventStreamException);
                }

                var chatMessageContent =
                    HandleChunkEvent(agent, responseEvent) ??
                    HandleFilesEvent(agent, responseEvent) ??
                    HandleReturnControlEvent(agent, responseEvent, arguments) ??
                    HandleTraceEvent(agent, responseEvent) ??
                    throw new KernelException($"Failed to handle Bedrock Agent stream event: {responseEvent}");
                if (chatMessageContent.Items.Count > 0 && chatMessageContent.Items[0] is FunctionCallContent functionCallContent)
                {
                    functionCallContents.AddRange(chatMessageContent.Items.Where(item => item is FunctionCallContent).Cast<FunctionCallContent>());
                }
                else
                {
                    yield return chatMessageContent;
                }
            }

            // This is used to cap the auto function invocation loop to prevent infinite loops.
            // It doesn't use the the `FunctionCallsProcessor` to process the functions because we do not need 
            // many of the features it offers and we want to keep the code simple.
            var functionChoiceBehaviorConfiguration = new FunctionCallsProcessor().GetConfiguration(
                FunctionChoiceBehavior.Auto(), [], requestIndex, agent.Kernel);

            if (functionCallContents.Count > 0 && functionChoiceBehaviorConfiguration!.AutoInvoke)
            {
                var functionResults = await InvokeFunctionCallsAsync(agent, functionCallContents, cancellationToken).ConfigureAwait(false);
                sessionState = CreateSessionStateWithFunctionResults(functionResults, agent);
            }
            else
            {
                break;
            }
        }
    }

    private static ChatMessageContent? HandleChunkEvent(
        BedrockAgent agent,
        IEventStreamEvent responseEvent)
    {
        return responseEvent is not PayloadPart payload
            ? null
            : new ChatMessageContent()
            {
                Role = AuthorRole.Assistant,
                AuthorName = agent.GetDisplayName(),
                Content = Encoding.UTF8.GetString(payload.Bytes.ToArray()),
                ModelId = agent.AgentModel.FoundationModel,
                InnerContent = payload,
            };
    }

    private static ChatMessageContent? HandleFilesEvent(
        BedrockAgent agent,
        IEventStreamEvent responseEvent)
    {
        if (responseEvent is not FilePart files)
        {
            return null;
        }

        ChatMessageContentItemCollection binaryContents = [];
        foreach (var file in files.Files)
        {
            binaryContents.Add(new BinaryContent(file.Bytes.ToArray(), file.Type)
            {
                Metadata = new Dictionary<string, object?>()
                {
                    { "Name", file.Name },
                },
            });
        }

        return new ChatMessageContent()
        {
            Role = AuthorRole.Assistant,
            AuthorName = agent.GetDisplayName(),
            Items = binaryContents,
            ModelId = agent.AgentModel.FoundationModel,
            InnerContent = files,
        };
    }

    private static ChatMessageContent? HandleReturnControlEvent(
        BedrockAgent agent,
        IEventStreamEvent responseEvent,
        KernelArguments? arguments)
    {
        if (responseEvent is not ReturnControlPayload returnControlPayload)
        {
            return null;
        }

        ChatMessageContentItemCollection functionCallContents = [];
        foreach (var invocationInput in returnControlPayload.InvocationInputs)
        {
            var functionInvocationInput = invocationInput.FunctionInvocationInput;
            functionCallContents.Add(new FunctionCallContent(
                functionInvocationInput.Function,
                id: returnControlPayload.InvocationId,
                arguments: functionInvocationInput.Parameters.FromFunctionParameters(arguments))
            {
                Metadata = new Dictionary<string, object?>()
                {
                    { "ActionGroup", functionInvocationInput.ActionGroup },
                    { "ActionInvocationType", functionInvocationInput.ActionInvocationType },
                },
            });
        }

        return new ChatMessageContent()
        {
            Role = AuthorRole.Assistant,
            AuthorName = agent.GetDisplayName(),
            Items = functionCallContents,
            ModelId = agent.AgentModel.FoundationModel,
            InnerContent = returnControlPayload,
        };
    }

    private static ChatMessageContent? HandleTraceEvent(
        BedrockAgent agent,
        IEventStreamEvent responseEvent)
    {
        return responseEvent is not TracePart trace
            ? null
            : new ChatMessageContent()
            {
                Role = AuthorRole.Assistant,
                AuthorName = agent.GetDisplayName(),
                ModelId = agent.AgentModel.FoundationModel,
                InnerContent = trace,
            };
    }

    private static async Task<List<FunctionResultContent>> InvokeFunctionCallsAsync(
        BedrockAgent agent,
        List<FunctionCallContent> functionCallContents,
        CancellationToken cancellationToken)
    {
        var functionResults = await Task.WhenAll(functionCallContents.Select(async functionCallContent =>
        {
            return await functionCallContent.InvokeAsync(agent.Kernel, cancellationToken).ConfigureAwait(false);
        })).ConfigureAwait(false);

        return [.. functionResults];
    }

    private static SessionState CreateSessionStateWithFunctionResults(List<FunctionResultContent> functionResults, BedrockAgent agent)
    {
        return functionResults.Count == 0
            ? throw new KernelException("No function results were returned.")
            : new()
            {
                InvocationId = functionResults[0].CallId,
                ReturnControlInvocationResults = [.. functionResults.Select(functionResult =>
                    {
                        return new InvocationResultMember()
                        {
                            FunctionResult = new Amazon.BedrockAgentRuntime.Model.FunctionResult
                            {
                                ActionGroup = agent.KernelFunctionActionGroupSignature,
                                Function = functionResult.FunctionName,
                                ResponseBody = new Dictionary<string, ContentBody>
                                {
                                    { "TEXT", new ContentBody() { Body = FunctionCallsProcessor.ProcessFunctionResult(functionResult.Result ?? string.Empty) } }
                                }
                            }
                        };
                    }
                )],
            };
    }
}


===== Bedrock\Extensions\BedrockAgentToolDefinitionExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;

namespace Microsoft.SemanticKernel.Agents.Bedrock;

/// <summary>
/// Provides extension methods for <see cref="AgentToolDefinition"/>.
/// </summary>
internal static class BedrockAgentToolDefinitionExtensions
{
    internal static Dictionary<string, Amazon.BedrockAgent.Model.ParameterDetail> CreateParameterDetails(
        this AgentToolDefinition agentToolDefinition)
    {
        Dictionary<string, Amazon.BedrockAgent.Model.ParameterDetail> parameterSpec = [];
        var parameters = agentToolDefinition.GetOption<List<object>?>("parameters");
        if (parameters is not null)
        {
            foreach (var parameter in parameters)
            {
                if (parameter is not Dictionary<object, object> parameterDict)
                {
                    throw new ArgumentException($"Invalid parameter type for function {agentToolDefinition.Id}");
                }

                var name = parameterDict.GetRequiredValue("name");
                var type = parameterDict.GetRequiredValue("type");
                var description = parameterDict.GetRequiredValue("description");
                var isRequired = parameterDict.GetRequiredValue("required").Equals("true", StringComparison.OrdinalIgnoreCase);

                parameterSpec.Add(name, new Amazon.BedrockAgent.Model.ParameterDetail
                {
                    Description = description,
                    Required = isRequired,
                    Type = new Amazon.BedrockAgent.Type(type),
                });
            }
        }

        return parameterSpec;
    }

    #region private
    private static string GetRequiredValue(this Dictionary<object, object> parameter, string key)
    {
        return parameter.TryGetValue(key, out var requiredValue) && requiredValue is string requiredString
            ? requiredString
            : throw new ArgumentException($"The option key '{key}' is required for a Bedrock function parameter.");
    }
    #endregion
}


===== Bedrock\Extensions\BedrockFunctionSchemaExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using Amazon.BedrockAgent.Model;
using Amazon.BedrockAgentRuntime.Model;

namespace Microsoft.SemanticKernel.Agents.Bedrock;

/// <summary>
/// Extensions associated with the status of a <see cref="BedrockAgent"/>.
/// </summary>
internal static class BedrockFunctionSchemaExtensions
{
    public static KernelArguments FromFunctionParameters(this List<FunctionParameter> parameters, KernelArguments? arguments)
    {
        KernelArguments kernelArguments = arguments ?? [];
        foreach (var parameter in parameters)
        {
            kernelArguments.Add(parameter.Name, parameter.Value);
        }

        return kernelArguments;
    }

    public static Amazon.BedrockAgent.Model.FunctionSchema ToFunctionSchema(this Kernel kernel)
    {
        var plugins = kernel.Plugins;
        List<Function> functions = [];
        foreach (var plugin in plugins)
        {
            foreach (KernelFunction function in plugin)
            {
                functions.Add(new Function
                {
                    Name = function.Name,
                    Description = function.Description,
                    Parameters = function.Metadata.Parameters.CreateParameterSpec(),
                    // This field controls whether user confirmation is required to invoke the function.
                    // If this is set to "ENABLED", the user will be prompted to confirm the function invocation.
                    // Only after the user confirms, the function call request will be issued by the agent.
                    // If the user denies the confirmation, the agent will act as if the function does not exist.
                    // Currently, we do not support this feature, so we set it to "DISABLED".
                    RequireConfirmation = Amazon.BedrockAgent.RequireConfirmation.DISABLED,
                });
            }
        }

        return new Amazon.BedrockAgent.Model.FunctionSchema
        {
            Functions = functions,
        };
    }

    private static Dictionary<string, Amazon.BedrockAgent.Model.ParameterDetail> CreateParameterSpec(
        this IReadOnlyList<KernelParameterMetadata> parameters)
    {
        Dictionary<string, Amazon.BedrockAgent.Model.ParameterDetail> parameterSpec = [];
        foreach (var parameter in parameters)
        {
            parameterSpec.Add(parameter.Name, new Amazon.BedrockAgent.Model.ParameterDetail
            {
                Description = parameter.Description,
                Required = parameter.IsRequired,
                Type = parameter.ParameterType.ToAmazonType(),
            });
        }

        return parameterSpec;
    }

    private static Amazon.BedrockAgent.Type ToAmazonType(this System.Type? parameterType)
    {
        var typeString = parameterType?.GetFriendlyTypeName();
        return typeString switch
        {
            "String" => Amazon.BedrockAgent.Type.String,
            "Boolean" => Amazon.BedrockAgent.Type.Boolean,
            "Int16" => Amazon.BedrockAgent.Type.Integer,
            "UInt16" => Amazon.BedrockAgent.Type.Integer,
            "Int32" => Amazon.BedrockAgent.Type.Integer,
            "UInt32" => Amazon.BedrockAgent.Type.Integer,
            "Int64" => Amazon.BedrockAgent.Type.Integer,
            "UInt64" => Amazon.BedrockAgent.Type.Integer,
            "Single" => Amazon.BedrockAgent.Type.Number,
            "Double" => Amazon.BedrockAgent.Type.Number,
            "Decimal" => Amazon.BedrockAgent.Type.Number,
            "String[]" => Amazon.BedrockAgent.Type.Array,
            "Boolean[]" => Amazon.BedrockAgent.Type.Array,
            "Int16[]" => Amazon.BedrockAgent.Type.Array,
            "UInt16[]" => Amazon.BedrockAgent.Type.Array,
            "Int32[]" => Amazon.BedrockAgent.Type.Array,
            "UInt32[]" => Amazon.BedrockAgent.Type.Array,
            "Int64[]" => Amazon.BedrockAgent.Type.Array,
            "UInt64[]" => Amazon.BedrockAgent.Type.Array,
            "Single[]" => Amazon.BedrockAgent.Type.Array,
            "Double[]" => Amazon.BedrockAgent.Type.Array,
            "Decimal[]" => Amazon.BedrockAgent.Type.Array,
            _ => throw new ArgumentException($"Unsupported parameter type: {typeString}"),
        };
    }
}


===== Bedrock\Properties\AssemblyInfo.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Diagnostics.CodeAnalysis;

// This assembly is currently experimental.
[assembly: Experimental("SKEXP0110")]


===== Bedrock\README.md =====

# Amazon Bedrock AI Agents in Semantic Kernel

## Overview

AWS Bedrock Agents is a managed service that allows users to stand up and run AI agents in the AWS cloud quickly.

## Tools/Functions

Bedrock Agents allow the use of tools via [action groups](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-action-create.html).

The integration of Bedrock Agents with Semantic Kernel allows users to register kernel functions as tools in Bedrock Agents.

## Enable code interpretation

Bedrock Agents can write and execute code via a feature known as [code interpretation](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-code-interpretation.html) similar to what OpenAI also offers.

## Enable user input

Bedrock Agents can [request user input](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-user-input.html) in case of missing information to invoke a tool. When this is enabled, the agent will prompt the user for the missing information. When this is disabled, the agent will guess the missing information.

## Knowledge base

Bedrock Agents can leverage data saved on AWS to perform RAG tasks, this is referred to as the [knowledge base](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-kb-add.html) in AWS.

## Multi-agent

Bedrock Agents support [multi-agent workflows](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-multi-agent-collaboration.html) for more complex tasks. However, it employs a different pattern than what we have in Semantic Kernel, thus this is not supported in the current integration.


===== Copilot\CopilotStudioAgent.ClientFactory.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Net.Http;
using Microsoft.Agents.CopilotStudio.Client;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;

namespace Microsoft.SemanticKernel.Agents.Copilot;

/// <summary>
/// Provides an <see cref="CopilotClient"/> for use by <see cref="CopilotStudioAgent"/>.
/// </summary>
public sealed partial class CopilotStudioAgent : Agent
{
    private const string CopilotStudioHttpClientName = nameof(CopilotStudioAgent);

    /// <summary>
    /// Creates a new instance of <see cref="CopilotClient"/> configured with the provided settings and an optional logger.
    /// </summary>
    /// <param name="settings">The connection settings for Copilot Studio.</param>
    /// <param name="logger">An optional logger for logging purposes.</param>
    /// <returns>A configured instance of <see cref="CopilotClient"/>.</returns>
    public static CopilotClient CreateClient(CopilotStudioConnectionSettings settings, ILogger? logger = null)
    {
        ServiceCollection services = new();

        services
            .AddSingleton(settings)
            .AddSingleton<CopilotStudioTokenHandler>()
            .AddHttpClient(CopilotStudioHttpClientName)
            .ConfigurePrimaryHttpMessageHandler<CopilotStudioTokenHandler>();

        IHttpClientFactory httpClientFactory =
            services
                .BuildServiceProvider()
                .GetRequiredService<IHttpClientFactory>();

        CopilotClient client = new(settings, httpClientFactory, logger ?? NullLogger.Instance, CopilotStudioHttpClientName);

        return client;
    }
}


===== Copilot\CopilotStudioAgent.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Agents.CopilotStudio.Client;
using Microsoft.Extensions.Logging;
using Microsoft.SemanticKernel.Agents.CopilotStudio.Internal;

namespace Microsoft.SemanticKernel.Agents.Copilot;

/// <summary>
/// Provides a specialized <see cref="Agent"/> for the Copilot Agent service.
/// </summary>
public sealed partial class CopilotStudioAgent : Agent
{
    /// <summary>
    /// The client used to interact with the Copilot Agent service.
    /// </summary>
    public CopilotClient Client { get; }

    /// <summary>
    /// Initializes a new instance of the <see cref="CopilotStudioAgent"/> class.
    /// Unlike other types of agents in Semantic Kernel, prompt templates are not supported for Copilot agents,
    /// since Copilot agents don't support using an alternative instruction in runtime.
    /// </summary>
    /// <param name="client">A client used to interact with the Copilot Agent service.</param>
    public CopilotStudioAgent(CopilotClient client)
    {
        this.Client = client;
    }

    /// <summary>
    /// CopilotStudioAgent does not support instructions like other agents.
    /// </summary>
    internal new string? Instructions => null;

    /// <inheritdoc/>
    public override async IAsyncEnumerable<AgentResponseItem<ChatMessageContent>> InvokeAsync(
        ICollection<ChatMessageContent> messages,
        AgentThread? thread = null,
        AgentInvokeOptions? options = null,
        [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        messages ??= [];

        if (messages.Count == 0)
        {
            throw new InvalidOperationException($"{nameof(CopilotStudioAgent)} requires a message to be invoked.");
        }

        // Create a thread if needed
        CopilotStudioAgentThread agentThread = await this.EnsureThreadExistsWithMessagesAsync(
            messages,
            thread,
            () => new CopilotStudioAgentThread(this.Client) { Logger = this.ActiveLoggerFactory.CreateLogger<CopilotStudioAgentThread>() },
            cancellationToken).ConfigureAwait(false);

        // Invoke the agent
        IAsyncEnumerable<ChatMessageContent> invokeResults = this.InvokeInternalAsync(messages, agentThread, cancellationToken);

        // Return the results to the caller in AgentResponseItems.
        await foreach (ChatMessageContent result in invokeResults.ConfigureAwait(false))
        {
            await this.NotifyThreadOfNewMessage(agentThread, result, cancellationToken).ConfigureAwait(false);

            if (options?.OnIntermediateMessage is not null)
            {
                await options.OnIntermediateMessage(result).ConfigureAwait(false);
            }

            yield return new(result, agentThread);
        }
    }

    /// <inheritdoc/>
    public override async IAsyncEnumerable<AgentResponseItem<StreamingChatMessageContent>> InvokeStreamingAsync(
        ICollection<ChatMessageContent> messages,
        AgentThread? thread = null,
        AgentInvokeOptions? options = null,
        [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        messages ??= [];

        if (messages.Count == 0)
        {
            throw new InvalidOperationException($"{nameof(CopilotStudioAgent)} requires a message to be invoked.");
        }

        // Create a thread if needed
        CopilotStudioAgentThread agentThread = await this.EnsureThreadExistsWithMessagesAsync(
            messages,
            thread,
            () => new CopilotStudioAgentThread(this.Client) { Logger = this.ActiveLoggerFactory.CreateLogger<CopilotStudioAgentThread>() },
            cancellationToken).ConfigureAwait(false);

        // Invoke the agent
        IAsyncEnumerable<ChatMessageContent> invokeResults = this.InvokeInternalAsync(messages, agentThread, cancellationToken);

        // Return the results to the caller in AgentResponseItems.
        await foreach (ChatMessageContent result in invokeResults.ConfigureAwait(false))
        {
            await this.NotifyThreadOfNewMessage(agentThread, result, cancellationToken).ConfigureAwait(false);

            if (options?.OnIntermediateMessage is not null)
            {
                await options.OnIntermediateMessage(result).ConfigureAwait(false);
            }

            StreamingChatMessageContent streamedResult = new(result.Role, content: null)
            {
                Items = [.. ContentProcessor.ConvertToStreaming(result.Items, this.Logger)],
                InnerContent = result.InnerContent,
                Metadata = result.Metadata,
            };

            yield return new(streamedResult, agentThread);
        }
    }

    /// <inheritdoc/>
    protected override IEnumerable<string> GetChannelKeys()
    {
        throw new NotSupportedException($"{nameof(CopilotStudioAgent)} is not for use with {nameof(AgentChat)}.");
    }

    /// <inheritdoc/>
    protected override Task<AgentChannel> CreateChannelAsync(CancellationToken cancellationToken)
    {
        throw new NotSupportedException($"{nameof(CopilotStudioAgent)} is not for use with {nameof(AgentChat)}.");
    }

    /// <inheritdoc/>
    protected override Task<AgentChannel> RestoreChannelAsync(string channelState, CancellationToken cancellationToken)
    {
        throw new NotSupportedException($"{nameof(CopilotStudioAgent)} is not for use with {nameof(AgentChat)}.");
    }

    private IAsyncEnumerable<ChatMessageContent> InvokeInternalAsync(ICollection<ChatMessageContent> messages, CopilotStudioAgentThread thread, CancellationToken cancellationToken)
    {
        string question = string.Join(Environment.NewLine, messages.Select(m => m.Content));

        return ActivityProcessor.ProcessActivity(this.Client.AskQuestionAsync(question, thread.Id, cancellationToken), this.Logger);
    }
}


===== Copilot\CopilotStudioAgentExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Diagnostics.CodeAnalysis;
using System.Text.Json;
using MAAI = Microsoft.Agents.AI;

namespace Microsoft.SemanticKernel.Agents.Copilot;

/// <summary>
/// Exposes a Semantic Kernel Agent Framework <see cref="CopilotStudioAgent"/> as a Microsoft Agent Framework <see cref="MAAI.AIAgent"/>.
/// </summary>
public static class CopilotStudioAgentExtensions
{
    /// <summary>
    /// Exposes a Semantic Kernel Agent Framework <see cref="CopilotStudioAgent"/> as a Microsoft Agent Framework <see cref="MAAI.AIAgent"/>.
    /// </summary>
    /// <param name="copilotStudioAgent">The Semantic Kernel <see cref="CopilotStudioAgent"/> to expose as a Microsoft Agent Framework <see cref="MAAI.AIAgent"/>.</param>
    /// <returns>The Semantic Kernel Agent Framework <see cref="Agent"/> exposed as a Microsoft Agent Framework <see cref="MAAI.AIAgent"/></returns>
    [Experimental("SKEXP0110")]
    public static MAAI.AIAgent AsAIAgent(this CopilotStudioAgent copilotStudioAgent)
        => copilotStudioAgent.AsAIAgent(
            () => new CopilotStudioAgentThread(copilotStudioAgent.Client),
            (json, options) =>
            {
                var agentId = JsonSerializer.Deserialize<string>(json);
                return agentId is null ? new CopilotStudioAgentThread(copilotStudioAgent.Client) : new CopilotStudioAgentThread(copilotStudioAgent.Client, agentId);
            },
            (thread, options) => JsonSerializer.SerializeToElement((thread as CopilotStudioAgentThread)?.Id));
}


===== Copilot\CopilotStudioAgentThread.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Agents.CopilotStudio.Client;
using Microsoft.Agents.Core.Models;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;

namespace Microsoft.SemanticKernel.Agents.Copilot;

/// <summary>
/// Represents a conversation thread for a <see cref="CopilotStudioAgent"/>.
/// </summary>
public sealed class CopilotStudioAgentThread : AgentThread
{
    private readonly CopilotClient _client;

    /// <summary>
    /// Initializes a new instance of the <see cref="CopilotStudioAgentThread"/> class.
    /// </summary>
    /// <param name="client">A client used to interact with the Copilot Agent runtime service.</param>
    /// <param name="conversationId">An optional session Id to continue an existing session.</param>
    /// <exception cref="ArgumentNullException"></exception>
    public CopilotStudioAgentThread(CopilotClient client, string? conversationId = null)
    {
        this._client = client ?? throw new ArgumentNullException(nameof(client));
        this.Id = conversationId;
    }

    internal ILogger Logger { get; init; } = NullLogger.Instance;

    /// <inheritdoc />
    protected override async Task<string?> CreateInternalAsync(CancellationToken cancellationToken)
    {
        try
        {
            await foreach (IActivity activity in this._client.StartConversationAsync(emitStartConversationEvent: true, cancellationToken).ConfigureAwait(false))
            {
                if (activity.Conversation is not null)
                {
                    return activity.Conversation.Id;
                }
            }

            return null;
        }
        catch (Exception exception)
        {
            throw new AgentThreadOperationException("The thread could not be created due to an unexpected error.", exception);
        }
    }

    /// <inheritdoc />
    protected override Task DeleteInternalAsync(CancellationToken cancellationToken)
    {
        this.Logger.LogWarning($"{nameof(CopilotStudioAgent)} does not support thread deletion.");

        return Task.CompletedTask;
    }

    /// <inheritdoc />
    protected override async Task OnNewMessageInternalAsync(ChatMessageContent newMessage, CancellationToken cancellationToken = default)
    {
        // Create the thread if it does not exist.
        // Copilot agents cannot add messages to the thread without invoking so we don't do that here.
        await this.CreateAsync(cancellationToken).ConfigureAwait(false);
    }
}


===== Copilot\CopilotStudioConnectionSettings.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using Microsoft.Agents.CopilotStudio.Client;
using Microsoft.Agents.CopilotStudio.Client.Discovery;
using Microsoft.Extensions.Configuration;

namespace Microsoft.SemanticKernel.Agents.Copilot;

/// <summary>
/// <see cref="ConnectionSettings"/> with additional properties to specify Application (Client) Id,
/// Tenant Id, and optionally the Application Client secret.
/// </summary>
public sealed class CopilotStudioConnectionSettings : ConnectionSettings
{
    /// <summary>
    /// Application ID for creating the authentication for the connection
    /// </summary>
    public string AppClientId { get; }

    /// <summary>
    /// Application secret for creating the authentication for the connection
    /// </summary>
    public string? AppClientSecret { get; }

    /// <summary>
    /// Tenant ID for creating the authentication for the connection
    /// </summary>
    public string TenantId { get; }

    /// <summary>
    /// Use interactive or service connection for authentication.
    /// Defaults to true, meaning interactive authentication will be used.
    /// </summary>
    public bool UseInteractiveAuthentication { get; init; } = true;

    /// <summary>
    /// Instantiate a new instance of the <see cref="CopilotStudioConnectionSettings"/> from provided settings.
    /// </summary>
    public CopilotStudioConnectionSettings(string tenantId, string appClientId, string? appClientSecret = null)
    {
        this.TenantId = tenantId;
        this.AppClientId = appClientId;
        this.AppClientSecret = appClientSecret;
        this.Cloud = PowerPlatformCloud.Prod;
        this.CopilotAgentType = AgentType.Published;
    }

    /// <summary>
    /// Instantiate a new instance of the <see cref="CopilotStudioConnectionSettings"/> from a configuration section.
    /// </summary>
    /// <param name="config"></param>
    /// <exception cref="System.ArgumentException"></exception>
    public CopilotStudioConnectionSettings(IConfigurationSection config)
        : base(config)
    {
        this.AppClientId = config[nameof(this.AppClientId)] ?? throw new ArgumentException($"{nameof(this.AppClientId)} not found in config");
        this.TenantId = config[nameof(this.TenantId)] ?? throw new ArgumentException($"{nameof(this.TenantId)} not found in config");
        this.AppClientSecret = config[nameof(this.AppClientSecret)];
    }
}


===== Copilot\CopilotStudioTokenHandler.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Runtime.InteropServices;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Agents.CopilotStudio.Client;
using Microsoft.Identity.Client;
using Microsoft.Identity.Client.Extensions.Msal;

namespace Microsoft.SemanticKernel.Agents.Copilot;

/// <summary>
/// A <see cref="DelegatingHandler"/> that adds an authentication token to the request headers for Copilot Studio API calls.
/// </summary>
/// <remarks>
///  For more information on how to setup various authentication flows, see the Microsoft Identity documentation at https://aka.ms/msal.
/// </remarks>
internal sealed class CopilotStudioTokenHandler : DelegatingHandler
{
    private const string AuthenticationHeader = "Bearer";
    private const string CacheFolderName = "mcs_client_console";
    private const string KeyChainServiceName = "copilot_studio_client_app";
    private const string KeyChainAccountName = "copilot_studio_client";

    private readonly CopilotStudioConnectionSettings _settings;
    private readonly string[] _scopes;

    private IConfidentialClientApplication? _clientApplication;

    /// <summary>
    /// Initializes a new instance of the <see cref="CopilotStudioTokenHandler"/> class with the specified connection settings.`
    /// </summary>
    /// <param name="settings">The connection settings for Copilot Studio.</param>
    public CopilotStudioTokenHandler(CopilotStudioConnectionSettings settings)
    {
        Verify.NotNull(settings, nameof(settings));

        this._settings = settings;
        this._scopes = [CopilotClient.ScopeFromSettings(this._settings)];
        this.InnerHandler = new HttpClientHandler();
    }

    /// <inheritdoc/>
    protected override async Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
    {
        if (request.Headers.Authorization is null)
        {
            AuthenticationResult authResponse = await this.AuthenticateAsync(cancellationToken).ConfigureAwait(false);

            request.Headers.Authorization = new AuthenticationHeaderValue(AuthenticationHeader, authResponse.AccessToken);
        }

        return await base.SendAsync(request, cancellationToken).ConfigureAwait(false);
    }

    private Task<AuthenticationResult> AuthenticateAsync(CancellationToken cancellationToken) =>
        this._settings.UseInteractiveAuthentication ?
                this.AuthenticateInteractiveAsync(cancellationToken) :
                this.AuthenticateServiceAsync(cancellationToken);

    private async Task<AuthenticationResult> AuthenticateServiceAsync(CancellationToken cancellationToken)
    {
        if (this._clientApplication is null)
        {
            this._clientApplication = ConfidentialClientApplicationBuilder.Create(this._settings.AppClientId)
                .WithAuthority(AzureCloudInstance.AzurePublic, this._settings.TenantId)
                .WithClientSecret(this._settings.AppClientSecret)
                .Build();

            MsalCacheHelper tokenCacheHelper = await CreateCacheHelper("AppTokenCache").ConfigureAwait(false);
            tokenCacheHelper.RegisterCache(this._clientApplication.AppTokenCache);
        }

        AuthenticationResult authResponse;

        authResponse = await this._clientApplication.AcquireTokenForClient(this._scopes).ExecuteAsync(cancellationToken).ConfigureAwait(false);

        return authResponse;
    }

    private async Task<AuthenticationResult> AuthenticateInteractiveAsync(CancellationToken cancellationToken = default!)
    {
        IPublicClientApplication app =
            PublicClientApplicationBuilder.Create(this._settings.AppClientId)
             .WithAuthority(AadAuthorityAudience.AzureAdMyOrg)
             .WithTenantId(this._settings.TenantId)
             .WithRedirectUri("http://localhost")
             .Build();

        MsalCacheHelper tokenCacheHelper = await CreateCacheHelper("TokenCache").ConfigureAwait(false);
        tokenCacheHelper.RegisterCache(app.UserTokenCache);

        IEnumerable<IAccount> accounts = await app.GetAccountsAsync().ConfigureAwait(false);
        IAccount? account = accounts.FirstOrDefault();

        AuthenticationResult authResponse;

        try
        {
            authResponse = await app.AcquireTokenSilent(this._scopes, account).ExecuteAsync(cancellationToken).ConfigureAwait(false);
        }
        catch (MsalUiRequiredException)
        {
            authResponse = await app.AcquireTokenInteractive(this._scopes).ExecuteAsync(cancellationToken).ConfigureAwait(false);
        }

        return authResponse;
    }

    private static async Task<MsalCacheHelper> CreateCacheHelper(string cacheFileName)
    {
        string currentDir = Path.Combine(AppContext.BaseDirectory, CacheFolderName);

        if (!Directory.Exists(currentDir))
        {
            Directory.CreateDirectory(currentDir);
        }

        StorageCreationPropertiesBuilder storageProperties = new(cacheFileName, currentDir);

        if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
        {
            storageProperties.WithLinuxUnprotectedFile();
        }
        else if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
        {
            storageProperties.WithMacKeyChain(KeyChainServiceName, KeyChainAccountName);
        }

        MsalCacheHelper tokenCacheHelper = await MsalCacheHelper.CreateAsync(storageProperties.Build()).ConfigureAwait(false);

        return tokenCacheHelper;
    }
}


===== Copilot\Internal\ActivityProcessor.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Threading.Tasks;
using Microsoft.Agents.Core.Models;
using Microsoft.Extensions.Logging;
using Microsoft.SemanticKernel.ChatCompletion;

namespace Microsoft.SemanticKernel.Agents.CopilotStudio.Internal;

internal static class ActivityProcessor
{
    public static async IAsyncEnumerable<ChatMessageContent> ProcessActivity(IAsyncEnumerable<IActivity> activities, ILogger logger)
    {
        await foreach (IActivity activity in activities.ConfigureAwait(false))
        {
            switch (activity.Type)
            {
                case "message":
                    yield return
                        new(AuthorRole.Assistant, items: [.. GetMessageItems(activity)])
                        {
                            InnerContent = activity
                        };
                    break;
                case "typing":
                    yield return
                        new(AuthorRole.Assistant, items: [new ReasoningContent()])
                        {
                            InnerContent = activity
                        };
                    break;
                case "event":
                    break;
                default:
                    logger.LogWarning("Unknown activity type '{ActivityType}' received.", activity.Type);
                    break;
            }
        }

        static IEnumerable<KernelContent> GetMessageItems(IActivity activity)
        {
            yield return new TextContent(activity.Text);
            foreach (CardAction action in activity.SuggestedActions?.Actions ?? [])
            {
                yield return new ActionContent(action.Title);
            }
        }
    }
}


===== Copilot\Internal\ContentProcessor.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using Microsoft.Extensions.Logging;
using Microsoft.SemanticKernel.ChatCompletion;

namespace Microsoft.SemanticKernel.Agents.CopilotStudio.Internal;

internal static class ContentProcessor
{
    internal static IEnumerable<StreamingKernelContent> ConvertToStreaming(ChatMessageContentItemCollection items, ILogger logger)
    {
        foreach (KernelContent item in items)
        {
            if (item is TextContent textContent)
            {
                yield return new StreamingTextContent(textContent.Text)
                {
                    Encoding = textContent.Encoding,
                    InnerContent = textContent.InnerContent,
                    Metadata = textContent.Metadata,
                };
            }
            else if (item is ReasoningContent reasoningContent)
            {
                yield return new StreamingReasoningContent(reasoningContent.Text);
            }
            else if (item is ActionContent actionContent)
            {
                yield return new StreamingActionContent(actionContent.Text);
            }
            else
            {
                logger.LogWarning("Unknown content type '{ContentType}' received.", item.GetType().Name);
            }
        }
    }
}


===== Copilot\Properties\AssemblyInfo.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Diagnostics.CodeAnalysis;

// This assembly is currently experimental.
[assembly: Experimental("SKEXP0110")]


===== Copilot\README.md =====

# Semantic Kernel - CopilotStudioAgent Quickstart

This README provides an overview on how to use the `CopilotStudioAgent` within Semantic Kernel. 
This agent allows you to interact with Microsoft Copilot Studio agents through programmatic APIs.

>  **Note:** Knowledge sources must be configured **within** Microsoft Copilot Studio first. Streaming responses are **not currently supported**.

---

##  Prerequisites

2. Install `Microsoft.SemanticKernel.Agents.CopilotStudio` package:
     ```bash
     dotnet add package Microsoft.SemanticKernel.Agents.CopilotStudio --prerelease
     ```
3. An agent created in **Microsoft Copilot Studio**
4. Ability to create an application identity in Azure for a **Public Client/Native App Registration**, 
or access to an existing app registration with the `CopilotStudio.Copilots.Invoke` API permission assigned.

## Create a Copilot Agent in Copilot Studio

1. Go to [Microsoft Copilot Studio](https://copilotstudio.microsoft.com).
2. Create a new **Agent**.
3. Publish your newly created Agent.
4. In Copilot Studio, navigate to:  
   `Settings`  `Advanced`  `Metadata`

   Save the following values:
   - `Schema Name` (maps to `agent_identifier`)
   - `Environment ID`

## Create an Application Registration in Entra ID  User Interactive Login

> This step requires permissions to create application identities in your Azure tenant.

You will create a **Native Client Application Identity** (no client secret required).

1. Open [Azure Portal](https://portal.azure.com)
2. Navigate to **Entra ID**
3. Go to **App registrations**  **New registration**
4. Fill out:
   - **Name**: Any name you like
   - **Supported account types**: `Accounts in this organization directory only`
   - **Redirect URI**:  
     - Platform: `Public client/native (mobile & desktop)`
     - URI: `http://localhost`
5. Click **Register**
6. From the **Overview** page, note:
   - `Application (client) ID`
   - `Directory (tenant) ID`
7. Go to: `Manage`  `API permissions`
   - Click **Add permission**
   - Choose **APIs my organization uses**
   - Search for: **Power Platform API**

   If it's not listed, see **Tip** below.

8. Choose:
   - **Delegated Permissions**
   - Expand `CopilotStudio`
   - Select `CopilotStudio.Copilots.Invoke`
9. Click **Add permissions**
10. (Optional) Click **Grant admin consent**

### Tip

If you **do not see Power Platform API**, follow [Step 2 in Power Platform API Authentication](https://learn.microsoft.com/en-us/power-platform/admin/programmability-authentication-v2) to add the API to your tenant.


===== Core\AgentGroupChat.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.SemanticKernel.Agents.Chat;
using Microsoft.SemanticKernel.Agents.Extensions;

namespace Microsoft.SemanticKernel.Agents;

/// <summary>
/// Represents an <see cref="AgentChat"/> that supports multi-turn interactions.
/// </summary>
[Experimental("SKEXP0110")]
public sealed class AgentGroupChat : AgentChat
{
    private readonly HashSet<string> _agentIds; // Efficient existence test O(1) vs O(n) for list.
    private readonly List<Agent> _agents; // Maintain order the agents joined the chat

    /// <summary>
    /// Gets or sets a value that indicates if the completion criteria have been met.
    /// </summary>
    /// <value>
    /// <see langword="true"/> if the completion criteria have been met; otherwise <see langword="false"/>.
    /// The default is <see langword="true"/>. Set to <see langword="false"/> to enable more agent interactions.
    /// </value>
    public bool IsComplete { get; set; }

    /// <summary>
    /// Gets or sets the settings for defining chat behavior.
    /// </summary>
    public AgentGroupChatSettings ExecutionSettings { get; set; } = new AgentGroupChatSettings();

    /// <summary>
    /// Gets the agents participating in the chat.
    /// </summary>
    public override IReadOnlyList<Agent> Agents => this._agents.AsReadOnly();

    /// <summary>
    /// Add an <see cref="Agent"/> to the chat.
    /// </summary>
    /// <param name="agent">The <see cref="Agent"/> to add.</param>
    public void AddAgent(Agent agent)
    {
        if (this._agentIds.Add(agent.Id))
        {
            this._agents.Add(agent);
        }
    }

    /// <summary>
    /// Processes a series of interactions between the <see cref="AgentGroupChat.Agents"/> that have joined this <see cref="AgentGroupChat"/>.
    /// </summary>
    /// <remarks>
    /// The interactions will proceed according to the <see cref="SelectionStrategy"/> and the
    /// <see cref="TerminationStrategy"/> defined via <see cref="AgentGroupChat.ExecutionSettings"/>.
    /// In the absence of an <see cref="AgentGroupChatSettings.SelectionStrategy"/>, this method does not invoke any agents.
    /// Any agent can be explicitly selected by calling <see cref="AgentGroupChat.InvokeAsync(Agent, CancellationToken)"/>.
    /// </remarks>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>An asynchronous enumeration of messages.</returns>
    public override async IAsyncEnumerable<ChatMessageContent> InvokeAsync([EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        this.EnsureStrategyLoggerAssignment();
        this.EnsureCompletionStatus();

        this.Logger.LogAgentGroupChatInvokingAgents(nameof(InvokeAsync), this.Agents);

        for (int index = 0; index < this.ExecutionSettings.TerminationStrategy.MaximumIterations; index++)
        {
            // Identify next agent using strategy
            Agent agent = await this.SelectAgentAsync(cancellationToken).ConfigureAwait(false);

            // Invoke agent and process messages along with termination
            await foreach (var message in this.InvokeAsync(agent, cancellationToken).ConfigureAwait(false))
            {
                yield return message;
            }

            if (this.IsComplete)
            {
                break;
            }
        }

        this.Logger.LogAgentGroupChatYield(nameof(InvokeAsync), this.IsComplete);
    }

    /// <summary>
    /// Processes a series of interactions between the <see cref="AgentGroupChat.Agents"/> that have joined this <see cref="AgentGroupChat"/>.
    /// </summary>
    /// <remarks>
    /// The interactions will proceed according to the <see cref="SelectionStrategy"/> and the
    /// <see cref="TerminationStrategy"/> defined via <see cref="AgentGroupChat.ExecutionSettings"/>.
    /// In the absence of an <see cref="AgentGroupChatSettings.SelectionStrategy"/>, this method does not invoke any agents.
    /// Any agent can be explicitly selected by calling <see cref="AgentGroupChat.InvokeAsync(Agent, CancellationToken)"/>.
    /// </remarks>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>An asynchronous enumeration of streaming messages.</returns>
    public override async IAsyncEnumerable<StreamingChatMessageContent> InvokeStreamingAsync([EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        this.EnsureStrategyLoggerAssignment();
        this.EnsureCompletionStatus();

        this.Logger.LogAgentGroupChatInvokingAgents(nameof(InvokeAsync), this.Agents);

        for (int index = 0; index < this.ExecutionSettings.TerminationStrategy.MaximumIterations; index++)
        {
            // Identify next agent using strategy
            Agent agent = await this.SelectAgentAsync(cancellationToken).ConfigureAwait(false);

            // Invoke agent and process messages along with termination
            await foreach (var message in this.InvokeStreamingAsync(agent, cancellationToken).ConfigureAwait(false))
            {
                yield return message;
            }

            if (this.IsComplete)
            {
                break;
            }
        }

        this.Logger.LogAgentGroupChatYield(nameof(InvokeAsync), this.IsComplete);
    }

    /// <summary>
    /// Processes a single interaction between a given <see cref="Agent"/> and an <see cref="AgentGroupChat"/>.
    /// </summary>
    /// <param name="agent">The agent actively interacting with the chat.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>An asynchronous enumeration of messages.</returns>
    /// <remarks>
    /// The specified agent joins the chat.
    /// </remarks>
    public async IAsyncEnumerable<ChatMessageContent> InvokeAsync(
        Agent agent,
        [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        this.EnsureStrategyLoggerAssignment();

        this.Logger.LogAgentGroupChatInvokingAgent(nameof(InvokeAsync), agent.GetType(), agent.Id, agent.GetDisplayName());

        this.AddAgent(agent);

        await foreach (ChatMessageContent message in base.InvokeAgentAsync(agent, cancellationToken).ConfigureAwait(false))
        {
            yield return message;
        }

        this.IsComplete = await this.ExecutionSettings.TerminationStrategy.ShouldTerminateAsync(agent, this.History, cancellationToken).ConfigureAwait(false);

        this.Logger.LogAgentGroupChatYield(nameof(InvokeAsync), this.IsComplete);
    }

    /// <summary>
    /// Processes a single interaction between a given <see cref="Agent"/> and an <see cref="AgentGroupChat"/>.
    /// </summary>
    /// <param name="agent">The agent actively interacting with the chat.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>An asynchronous enumeration of messages.</returns>
    /// <remarks>
    /// The specified agent joins the chat.
    /// </remarks>
    public async IAsyncEnumerable<StreamingChatMessageContent> InvokeStreamingAsync(
        Agent agent,
        [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        this.EnsureStrategyLoggerAssignment();

        this.Logger.LogAgentGroupChatInvokingAgent(nameof(InvokeAsync), agent.GetType(), agent.Id, agent.GetDisplayName());

        this.AddAgent(agent);

        await foreach (StreamingChatMessageContent message in base.InvokeStreamingAgentAsync(agent, cancellationToken).ConfigureAwait(false))
        {
            yield return message;
        }

        this.IsComplete = await this.ExecutionSettings.TerminationStrategy.ShouldTerminateAsync(agent, this.History, cancellationToken).ConfigureAwait(false);

        this.Logger.LogAgentGroupChatYield(nameof(InvokeAsync), this.IsComplete);
    }

    /// <summary>
    /// Creates a <see cref="KernelFunction"/> for a given strategy without HTML-encoding the specified parameters.
    /// </summary>
    /// <param name="template">The prompt template string that defines the prompt.</param>
    /// <param name="templateFactory">
    /// An optional <see cref="IPromptTemplateFactory"/> to use when interpreting the <paramref name="template"/>.
    /// The default factory is used when none is provided.
    /// </param>
    /// <param name="safeParameterNames">The parameter names to exclude from being HTML encoded.</param>
    /// <returns>A <see cref="KernelFunction"/> created via <see cref="KernelFunctionFactory"/> using the specified template.</returns>
    /// <remarks>
    /// This method is particularly targeted to easily avoid encoding the history used by <see cref="KernelFunctionSelectionStrategy"/>
    /// or <see cref="KernelFunctionTerminationStrategy"/>.
    /// </remarks>
    public static KernelFunction CreatePromptFunctionForStrategy(string template, IPromptTemplateFactory? templateFactory = null, params string[] safeParameterNames)
    {
        PromptTemplateConfig config =
            new(template)
            {
                InputVariables = safeParameterNames.Select(parameterName => new InputVariable { Name = parameterName, AllowDangerouslySetContent = true }).ToList()
            };

        return KernelFunctionFactory.CreateFromPrompt(config, promptTemplateFactory: templateFactory);
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AgentGroupChat"/> class.
    /// </summary>
    /// <param name="agents">The agents initially participating in the chat.</param>
    public AgentGroupChat(params Agent[] agents)
    {
        this._agents = new(agents);
        this._agentIds = new(this._agents.Select(a => a.Id));
    }

    private void EnsureStrategyLoggerAssignment()
    {
        // Only invoke logger factory when required.
        if (this.ExecutionSettings.SelectionStrategy.Logger == NullLogger.Instance)
        {
            this.ExecutionSettings.SelectionStrategy.Logger = this.LoggerFactory.CreateLogger(this.ExecutionSettings.SelectionStrategy.GetType());
        }

        if (this.ExecutionSettings.TerminationStrategy.Logger == NullLogger.Instance)
        {
            this.ExecutionSettings.TerminationStrategy.Logger = this.LoggerFactory.CreateLogger(this.ExecutionSettings.TerminationStrategy.GetType());
        }
    }

    private void EnsureCompletionStatus()
    {
        if (this.IsComplete)
        {
            // Throw exception if chat is completed and automatic-reset is not enabled.
            if (!this.ExecutionSettings.TerminationStrategy.AutomaticReset)
            {
                throw new KernelException("Agent Failure - Chat has completed.");
            }

            this.IsComplete = false;
        }
    }

    private async Task<Agent> SelectAgentAsync(CancellationToken cancellationToken)
    {
        this.Logger.LogAgentGroupChatSelectingAgent(nameof(InvokeAsync), this.ExecutionSettings.SelectionStrategy.GetType());

        Agent agent;
        try
        {
            agent = await this.ExecutionSettings.SelectionStrategy.NextAsync(this.Agents, this.History, cancellationToken).ConfigureAwait(false);
        }
        catch (Exception exception)
        {
            this.Logger.LogAgentGroupChatNoAgentSelected(nameof(InvokeAsync), exception);
            throw;
        }

        this.Logger.LogAgentGroupChatSelectedAgent(nameof(InvokeAsync), agent.GetType(), agent.Id, agent.GetDisplayName(), this.ExecutionSettings.SelectionStrategy.GetType());

        return agent;
    }
}


===== Core\Chat\AgentGroupChatSettings.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Threading;
using System.Threading.Tasks;

namespace Microsoft.SemanticKernel.Agents.Chat;

/// <summary>
/// Provides settings that affect the behavior of <see cref="AgentGroupChat"/> instances.
/// </summary>
/// <remarks>
/// The default behavior results in no agent selection.
/// </remarks>
[Experimental("SKEXP0110")]
public class AgentGroupChatSettings
{
    /// <summary>
    /// Gets the strategy for terminating the agent.
    /// </summary>
    /// <value>
    /// The strategy for terminating the agent. The default strategy a single iteration and no termination criteria.
    /// </value>
    /// <seealso cref="SelectionStrategy"/>
    public TerminationStrategy TerminationStrategy { get; init; } = new DefaultTerminationStrategy();

    /// <summary>
    /// Gets the strategy for selecting the next agent.
    /// </summary>
    /// <value>
    /// The strategy for selecting the next agent. The default is <see cref="SequentialSelectionStrategy"/>.
    /// </value>
    /// <seealso cref="TerminationStrategy"/>
    public SelectionStrategy SelectionStrategy { get; init; } = new SequentialSelectionStrategy();

    /// <summary>
    /// The termination strategy attached to the default state of <see cref="AgentGroupChatSettings.TerminationStrategy"/>.
    /// This strategy will execute without signaling termination.  Execution of <see cref="AgentGroupChat"/> will only be
    /// bound by <see cref="TerminationStrategy.MaximumIterations"/>.
    /// </summary>
    internal sealed class DefaultTerminationStrategy : TerminationStrategy
    {
        /// <inheritdoc/>
        protected override Task<bool> ShouldAgentTerminateAsync(Agent agent, IReadOnlyList<ChatMessageContent> history, CancellationToken cancellationToken = default)
        {
            return Task.FromResult(false);
        }

        public DefaultTerminationStrategy()
        {
            this.MaximumIterations = 1;
        }
    }
}


===== Core\Chat\AggregatorTerminationStrategy.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

namespace Microsoft.SemanticKernel.Agents.Chat;

/// <summary>
/// Defines aggregation behavior for <see cref="AggregatorTerminationStrategy"/>.
/// </summary>
[Experimental("SKEXP0110")]
public enum AggregateTerminationCondition
{
    /// <summary>
    /// All aggregated strategies must agree on termination.
    /// </summary>
    All,

    /// <summary>
    /// Any single aggregated strategy will terminate.
    /// </summary>
    Any,
}

/// <summary>
/// Provides methods to aggregate a set of <see cref="TerminationStrategy"/> objects.
/// </summary>
/// <param name="strategies">The set of strategies upon which to aggregate.</param>
[Experimental("SKEXP0110")]
public sealed class AggregatorTerminationStrategy(params TerminationStrategy[] strategies) : TerminationStrategy
{
    private readonly TerminationStrategy[] _strategies = strategies;

    /// <summary>
    /// Gets the logical operation for aggregation.
    /// </summary>
    /// <value>
    /// The logical operation for aggregation, which can be <see cref="AggregateTerminationCondition.All"/> or <see cref="AggregateTerminationCondition.Any"/>. The default is <see cref="AggregateTerminationCondition.All"/>.
    /// </value>
    public AggregateTerminationCondition Condition { get; init; } = AggregateTerminationCondition.All;

    /// <inheritdoc/>
    protected override async Task<bool> ShouldAgentTerminateAsync(Agent agent, IReadOnlyList<ChatMessageContent> history, CancellationToken cancellationToken = default)
    {
        this.Logger.LogAggregatorTerminationStrategyEvaluating(nameof(ShouldAgentTerminateAsync), this._strategies.Length, this.Condition);

        var strategyExecution = this._strategies.Select(s => s.ShouldTerminateAsync(agent, history, cancellationToken));

        var results = await Task.WhenAll(strategyExecution).ConfigureAwait(false);
        bool shouldTerminate =
            this.Condition == AggregateTerminationCondition.All ?
                results.All(r => r) :
                results.Any(r => r);

        return shouldTerminate;
    }
}


===== Core\Chat\KernelFunctionSelectionStrategy.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.SemanticKernel.Agents.Internal;
using Microsoft.SemanticKernel.ChatCompletion;

namespace Microsoft.SemanticKernel.Agents.Chat;

/// <summary>
/// Determines agent selection based on the evaluation of a <see cref="KernelFunction"/>.
/// </summary>
/// <param name="function">A <see cref="KernelFunction"/> used for selection criteria.</param>
/// <param name="kernel">A kernel instance with services for function execution.</param>
[Experimental("SKEXP0110")]
public class KernelFunctionSelectionStrategy(KernelFunction function, Kernel kernel) : SelectionStrategy
{
    /// <summary>
    /// The default value for <see cref="KernelFunctionSelectionStrategy.AgentsVariableName"/>.
    /// </summary>
    public const string DefaultAgentsVariableName = "_agents_";

    /// <summary>
    /// The default value for <see cref="KernelFunctionSelectionStrategy.HistoryVariableName"/>.
    /// </summary>
    public const string DefaultHistoryVariableName = "_history_";

    /// <summary>
    /// Gets the <see cref="KernelArguments"/> key associated with the list of agent names when
    /// invoking <see cref="KernelFunctionSelectionStrategy.Function"/>.
    /// </summary>
    public string AgentsVariableName { get; init; } = DefaultAgentsVariableName;

    /// <summary>
    /// Gets the <see cref="KernelArguments"/> key associated with the chat history when
    /// invoking <see cref="KernelFunctionSelectionStrategy.Function"/>.
    /// </summary>
    public string HistoryVariableName { get; init; } = DefaultHistoryVariableName;

    /// <summary>
    /// Gets the optional arguments used when invoking <see cref="KernelFunctionSelectionStrategy.Function"/>.
    /// </summary>
    public KernelArguments? Arguments { get; init; }

    /// <summary>
    /// Gets the <see cref="Microsoft.SemanticKernel.Kernel"/> used when invoking <see cref="KernelFunctionSelectionStrategy.Function"/>.
    /// </summary>
    public Kernel Kernel => kernel;

    /// <summary>
    /// Gets the <see cref="KernelFunction"/> invoked as selection criteria.
    /// </summary>
    public KernelFunction Function { get; } = function;

    /// <summary>
    /// Gets a value that indicates whether only the agent name is included in the history when invoking <see cref="KernelFunctionTerminationStrategy.Function"/>.
    /// </summary>
    public bool EvaluateNameOnly { get; init; }

    /// <summary>
    /// Gets an optional <see cref="IChatHistoryReducer"/> to reduce the history.
    /// </summary>
    public IChatHistoryReducer? HistoryReducer { get; init; }

    /// <summary>
    /// Gets a value that indicates whether <see cref="SelectionStrategy.InitialAgent"/> is used in the event of a failure to select an agent.
    /// </summary>
    public bool UseInitialAgentAsFallback { get; init; }

    /// <summary>
    /// Gets a callback responsible for translating the <see cref="FunctionResult"/>
    /// to the termination criteria.
    /// </summary>
    public Func<FunctionResult, string> ResultParser { get; init; } = (result) => result.GetValue<string>() ?? string.Empty;

    /// <inheritdoc/>
    protected sealed override async Task<Agent> SelectAgentAsync(IReadOnlyList<Agent> agents, IReadOnlyList<ChatMessageContent> history, CancellationToken cancellationToken = default)
    {
        history = await history.ReduceAsync(this.HistoryReducer, cancellationToken).ConfigureAwait(false);

        KernelArguments originalArguments = this.Arguments ?? [];
        KernelArguments arguments =
            new(originalArguments, originalArguments.ExecutionSettings?.ToDictionary(kvp => kvp.Key, kvp => kvp.Value))
            {
                { this.AgentsVariableName, string.Join(",", agents.Select(a => a.Name)) },
                { this.HistoryVariableName, ChatMessageForPrompt.Format(history, this.EvaluateNameOnly) },
            };

        this.Logger.LogKernelFunctionSelectionStrategyInvokingFunction(nameof(NextAsync), this.Function.PluginName, this.Function.Name);

        FunctionResult result = await this.Function.InvokeAsync(this.Kernel, arguments, cancellationToken).ConfigureAwait(false);

        this.Logger.LogKernelFunctionSelectionStrategyInvokedFunction(nameof(NextAsync), this.Function.PluginName, this.Function.Name, result.ValueType);

        string? agentName = this.ResultParser.Invoke(result);
        if (string.IsNullOrEmpty(agentName) && (!this.UseInitialAgentAsFallback || this.InitialAgent == null))
        {
            throw new KernelException("Agent Failure - Strategy unable to determine next agent.");
        }

        Agent? agent = agents.FirstOrDefault(a => (a.Name ?? a.Id) == agentName);
        if (agent == null && this.UseInitialAgentAsFallback)
        {
            agent = this.InitialAgent;
        }

        return agent ?? throw new KernelException($"Agent Failure - Strategy unable to select next agent: {agentName}");
    }
}


===== Core\Chat\KernelFunctionTerminationStrategy.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.SemanticKernel.Agents.Internal;
using Microsoft.SemanticKernel.ChatCompletion;

namespace Microsoft.SemanticKernel.Agents.Chat;

/// <summary>
/// Signals termination based on the evaluation of a <see cref="KernelFunction"/>.
/// </summary>
/// <param name="function">A <see cref="KernelFunction"/> used for termination criteria.</param>
/// <param name="kernel">A kernel instance with services for function execution.</param>
[Experimental("SKEXP0110")]
public class KernelFunctionTerminationStrategy(KernelFunction function, Kernel kernel) : TerminationStrategy
{
    /// <summary>
    /// The default value for <see cref="KernelFunctionTerminationStrategy.AgentVariableName"/>.
    /// </summary>
    public const string DefaultAgentVariableName = "_agent_";

    /// <summary>
    /// The default value for <see cref="KernelFunctionTerminationStrategy.HistoryVariableName"/>.
    /// </summary>
    public const string DefaultHistoryVariableName = "_history_";

    /// <summary>
    /// Gets the <see cref="KernelArguments"/> key associated with the agent name when
    /// invoking <see cref="KernelFunctionSelectionStrategy.Function"/>.
    /// </summary>
    public string AgentVariableName { get; init; } = DefaultAgentVariableName;

    /// <summary>
    /// Gets the <see cref="KernelArguments"/> key associated with the chat history when
    /// invoking <see cref="KernelFunctionTerminationStrategy.Function"/>.
    /// </summary>
    public string HistoryVariableName { get; init; } = DefaultHistoryVariableName;

    /// <summary>
    /// Gets optional arguments used when invoking <see cref="KernelFunctionTerminationStrategy.Function"/>.
    /// </summary>
    public KernelArguments? Arguments { get; init; }

    /// <summary>
    /// Gets the <see cref="Microsoft.SemanticKernel.Kernel"/> used when invoking <see cref="KernelFunctionTerminationStrategy.Function"/>.
    /// </summary>
    public Kernel Kernel => kernel;

    /// <summary>
    /// Gets the <see cref="KernelFunction"/> invoked as termination criteria.
    /// </summary>
    public KernelFunction Function { get; } = function;

    /// <summary>
    /// Gets a value that indicates whether only the agent name is included in the history when invoking <see cref="KernelFunctionTerminationStrategy.Function"/>.
    /// </summary>
    public bool EvaluateNameOnly { get; init; }

    /// <summary>
    /// Gets a callback responsible for translating the <see cref="FunctionResult"/>
    /// to the termination criteria.
    /// </summary>
    public Func<FunctionResult, bool> ResultParser { get; init; } = (_) => true;

    /// <summary>
    /// Gets an optional <see cref="IChatHistoryReducer"/> to reduce the history.
    /// </summary>
    public IChatHistoryReducer? HistoryReducer { get; init; }

    /// <inheritdoc/>
    protected sealed override async Task<bool> ShouldAgentTerminateAsync(Agent agent, IReadOnlyList<ChatMessageContent> history, CancellationToken cancellationToken = default)
    {
        history = await history.ReduceAsync(this.HistoryReducer, cancellationToken).ConfigureAwait(false);

        KernelArguments originalArguments = this.Arguments ?? [];
        KernelArguments arguments =
            new(originalArguments, originalArguments.ExecutionSettings?.ToDictionary(kvp => kvp.Key, kvp => kvp.Value))
            {
                { this.AgentVariableName, agent.Name ?? agent.Id },
                { this.HistoryVariableName, ChatMessageForPrompt.Format(history, this.EvaluateNameOnly) },
            };

        this.Logger.LogKernelFunctionTerminationStrategyInvokingFunction(nameof(ShouldAgentTerminateAsync), this.Function.PluginName, this.Function.Name);

        FunctionResult result = await this.Function.InvokeAsync(this.Kernel, arguments, cancellationToken).ConfigureAwait(false);

        this.Logger.LogKernelFunctionTerminationStrategyInvokedFunction(nameof(ShouldAgentTerminateAsync), this.Function.PluginName, this.Function.Name, result.ValueType);

        return this.ResultParser.Invoke(result);
    }
}


===== Core\Chat\RegExTerminationStrategy.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;

namespace Microsoft.SemanticKernel.Agents.Chat;

/// <summary>
/// Signals termination when the most recent message matches against the defined regular expressions
/// for the specified agent (if provided).
/// </summary>
[Experimental("SKEXP0110")]
public sealed class RegexTerminationStrategy : TerminationStrategy
{
    private readonly Regex[] _expressions;

    /// <summary>
    /// Initializes a new instance of the <see cref="RegexTerminationStrategy"/> class.
    /// </summary>
    /// <param name="expressions">
    /// A list of regular expressions to match against an agent's last message to
    /// determine whether processing should terminate.
    /// </param>
    public RegexTerminationStrategy(params string[] expressions)
    {
        Verify.NotNull(expressions);

        this._expressions = expressions
            .Where(s => s is not null)
            .Select(e => new Regex(e, RegexOptions.Compiled))
            .ToArray();
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="RegexTerminationStrategy"/> class.
    /// </summary>
    /// <param name="expressions">
    /// A list of regular expressions to match against an agent's last message to
    /// determine whether processing should terminate.
    /// </param>
    public RegexTerminationStrategy(params Regex[] expressions)
    {
        Verify.NotNull(expressions);

        this._expressions = expressions;
    }

    /// <inheritdoc/>
    protected override Task<bool> ShouldAgentTerminateAsync(Agent agent, IReadOnlyList<ChatMessageContent> history, CancellationToken cancellationToken = default)
    {
        // Most recent message
        if (history.Count > 0 && history[history.Count - 1].Content is string message)
        {
            this.Logger.LogRegexTerminationStrategyEvaluating(nameof(ShouldAgentTerminateAsync), this._expressions.Length);

            // Evaluate expressions for match
            foreach (var expression in this._expressions)
            {
                this.Logger.LogRegexTerminationStrategyEvaluatingExpression(nameof(ShouldAgentTerminateAsync), expression);

                if (expression.IsMatch(message))
                {
                    this.Logger.LogRegexTerminationStrategyMatchedExpression(nameof(ShouldAgentTerminateAsync), expression);

                    return Task.FromResult(true);
                }
            }
        }

        this.Logger.LogRegexTerminationStrategyNoMatch(nameof(ShouldAgentTerminateAsync));

        return Task.FromResult(false);
    }
}


===== Core\Chat\SelectionStrategy.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;

namespace Microsoft.SemanticKernel.Agents.Chat;

/// <summary>
/// Provides a base strategy class for selecting the next agent for an <see cref="AgentGroupChat"/>.
/// </summary>
[Experimental("SKEXP0110")]
public abstract class SelectionStrategy
{
    /// <summary>
    /// Gets a value that indicates if an agent has been selected (first time).
    /// </summary>
    protected bool HasSelected { get; private set; }

    /// <summary>
    /// Gets or sets an optional agent for initial selection.
    /// </summary>
    /// <remarks>
    /// Setting this property is useful to avoid latency in initial agent selection.
    /// </remarks>
    public Agent? InitialAgent { get; set; }

    /// <summary>
    /// Gets the <see cref="ILogger"/> associated with the <see cref="SelectionStrategy"/>.
    /// </summary>
    protected internal ILogger Logger { get; internal set; } = NullLogger.Instance;

    /// <summary>
    /// Determines which agent goes next.
    /// </summary>
    /// <param name="agents">The agents participating in chat.</param>
    /// <param name="history">The chat history.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>The agent that will take the next turn.</returns>
    public async Task<Agent> NextAsync(IReadOnlyList<Agent> agents, IReadOnlyList<ChatMessageContent> history, CancellationToken cancellationToken = default)
    {
        if (agents.Count == 0 && this.InitialAgent == null)
        {
            throw new KernelException("Agent Failure - No agents present to select.");
        }

        Agent agent =
            (!this.HasSelected && this.InitialAgent != null) ?
                this.InitialAgent :
                await this.SelectAgentAsync(agents, history, cancellationToken).ConfigureAwait(false);

        this.HasSelected = true;

        return agent;
    }

    /// <summary>
    /// Determines which agent goes next.
    /// </summary>
    /// <param name="agents">The agents participating in chat.</param>
    /// <param name="history">The chat history.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>The agent that will take the next turn.</returns>
    protected abstract Task<Agent> SelectAgentAsync(IReadOnlyList<Agent> agents, IReadOnlyList<ChatMessageContent> history, CancellationToken cancellationToken = default);
}


===== Core\Chat\SequentialSelectionStrategy.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.SemanticKernel.Agents.Extensions;

namespace Microsoft.SemanticKernel.Agents.Chat;

/// <summary>
/// Represents a round-robin turn-taking strategy. Agent order is based on the order
/// in which they joined <see cref="AgentGroupChat"/>.
/// </summary>
[Experimental("SKEXP0110")]
public sealed class SequentialSelectionStrategy : SelectionStrategy
{
    private int _index = -1;

    /// <summary>
    /// Resets the selection to the initial (first) agent. Agent order is based on the order
    /// in which they joined <see cref="AgentGroupChat"/>.
    /// </summary>
    public void Reset() => this._index = -1;

    /// <inheritdoc/>
    protected override Task<Agent> SelectAgentAsync(IReadOnlyList<Agent> agents, IReadOnlyList<ChatMessageContent> history, CancellationToken cancellationToken = default)
    {
        if (this.HasSelected &&
            this.InitialAgent != null &&
            agents.Count > 0 &&
            agents[0] == this.InitialAgent &&
            this._index < 0)
        {
            // Avoid selecting first agent twice in a row
            IncrementIndex();
        }

        IncrementIndex();

        // Set of agents array may not align with previous execution, constrain index to valid range.
        if (this._index > agents.Count - 1)
        {
            this._index = 0;
        }

        Agent agent = agents[this._index];

        this.Logger.LogSequentialSelectionStrategySelectedAgent(nameof(NextAsync), this._index, agents.Count, agent.Id, agent.GetDisplayName());

        return Task.FromResult(agent);

        void IncrementIndex()
        {
            this._index = (this._index + 1) % agents.Count;
        }
    }
}


===== Core\Chat\TerminationStrategy.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.SemanticKernel.Agents.Extensions;

namespace Microsoft.SemanticKernel.Agents.Chat;

/// <summary>
/// Provides a base strategy class for defining termination criteria for an <see cref="AgentGroupChat"/>.
/// </summary>
[Experimental("SKEXP0110")]
public abstract class TerminationStrategy
{
    /// <summary>
    /// Specifies a reasonable limit on the number of turns.
    /// </summary>
    public const int DefaultMaximumIterations = 99;

    /// <summary>
    /// Gets or sets the maximum number of agent interactions for a given chat invocation.
    /// </summary>
    /// <value>
    /// The default is <see cref="TerminationStrategy.DefaultMaximumIterations"/>.
    /// </value>
    public int MaximumIterations { get; set; } = DefaultMaximumIterations;

    /// <summary>
    /// Gets or sets a value that indicates whether <see cref="AgentGroupChat.IsComplete"/>
    /// is automatically cleared if the caller
    /// proceeds with invocation subsequent to achieving termination criteria.
    /// </summary>
    public bool AutomaticReset { get; set; }

    /// <summary>
    /// Gets or sets the set of agents for which this strategy is applicable.
    /// </summary>
    /// <value>
    /// The default value is that any agent is evaluated.
    /// </value>
    public IReadOnlyList<Agent>? Agents { get; set; }

    /// <summary>
    /// Gets the <see cref="ILogger"/> associated with the <see cref="TerminationStrategy"/>.
    /// </summary>
    protected internal ILogger Logger { get; internal set; } = NullLogger.Instance;

    /// <summary>
    /// Evaluates termination once <see cref="TerminationStrategy.Agents"/> is evaluated.
    /// </summary>
    protected abstract Task<bool> ShouldAgentTerminateAsync(Agent agent, IReadOnlyList<ChatMessageContent> history, CancellationToken cancellationToken);

    /// <summary>
    /// Evaluates the input message and determines if the chat has met its completion criteria.
    /// </summary>
    /// <param name="agent">The agent actively interacting with the chat.</param>
    /// <param name="history">The most recent message.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns><see langword="true"/> if the chat loop should be terminated.</returns>
    public async Task<bool> ShouldTerminateAsync(Agent agent, IReadOnlyList<ChatMessageContent> history, CancellationToken cancellationToken = default)
    {
        this.Logger.LogTerminationStrategyEvaluatingCriteria(nameof(ShouldTerminateAsync), agent.GetType(), agent.Id, agent.GetDisplayName());

        // `Agents` must contain `agent`, if `Agents` not empty.
        if ((this.Agents?.Count ?? 0) > 0 && !this.Agents!.Any(a => a.Id == agent.Id))
        {
            this.Logger.LogTerminationStrategyAgentOutOfScope(nameof(ShouldTerminateAsync), agent.GetType(), agent.Id, agent.GetDisplayName());

            return false;
        }

        bool shouldTerminate = await this.ShouldAgentTerminateAsync(agent, history, cancellationToken).ConfigureAwait(false);

        this.Logger.LogTerminationStrategyEvaluatedCriteria(nameof(ShouldTerminateAsync), agent.GetType(), agent.Id, agent.GetDisplayName(), shouldTerminate);

        return shouldTerminate;
    }
}


===== Core\ChatCompletionAgent.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.SemanticKernel.Agents.Extensions;
using Microsoft.SemanticKernel.Arguments.Extensions;
using Microsoft.SemanticKernel.ChatCompletion;
using Microsoft.SemanticKernel.Diagnostics;

namespace Microsoft.SemanticKernel.Agents;

/// <summary>
/// Represents a <see cref="Agent"/> specialization based on <see cref="IChatCompletionService"/>.
/// </summary>
/// <remarks>
/// NOTE: Enable <see cref="PromptExecutionSettings.FunctionChoiceBehavior"/> for agent plugins
/// (<see cref="Agent.Arguments"/>).
/// </remarks>
public sealed class ChatCompletionAgent : ChatHistoryAgent
{
    /// <summary>
    /// Initializes a new instance of the <see cref="ChatCompletionAgent"/> class.
    /// </summary>
    public ChatCompletionAgent() { }

    /// <summary>
    /// Initializes a new instance of the <see cref="ChatCompletionAgent"/> class from
    /// a <see cref="PromptTemplateConfig"/>.
    /// </summary>
    /// <param name="templateConfig">The prompt template configuration.</param>
    /// <param name="templateFactory">The prompt template factory used to produce the <see cref="IPromptTemplate"/> for the agent.</param>
    public ChatCompletionAgent(
        PromptTemplateConfig templateConfig,
        IPromptTemplateFactory templateFactory)
    {
        this.Name = templateConfig.Name;
        this.Description = templateConfig.Description;
        this.Instructions = templateConfig.Template;
        this.Arguments = new(templateConfig.ExecutionSettings.Values);
        this.Template = templateFactory.Create(templateConfig);
    }

    /// <summary>
    /// Gets the role used for agent instructions.  Defaults to "system".
    /// </summary>
    /// <remarks>
    /// Certain versions of "O*" series (deep reasoning) models require the instructions
    /// to be provided as "developer" role.  Other versions support neither role and
    /// an agent targeting such a model cannot provide instructions.  Agent functionality
    /// will be dictated entirely by the provided plugins.
    /// </remarks>
    public AuthorRole InstructionsRole { get; init; } = AuthorRole.System;

    /// <inheritdoc/>
    public override async IAsyncEnumerable<AgentResponseItem<ChatMessageContent>> InvokeAsync(
        ICollection<ChatMessageContent> messages,
        AgentThread? thread = null,
        AgentInvokeOptions? options = null,
        [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        Verify.NotNull(messages);

        ChatHistoryAgentThread chatHistoryAgentThread = await this.EnsureThreadExistsWithMessagesAsync(
            messages,
            thread,
            () => new ChatHistoryAgentThread(),
            cancellationToken).ConfigureAwait(false);

        Kernel kernel = this.GetKernel(options);
#pragma warning disable SKEXP0110, SKEXP0130 // Type is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.
        if (this.UseImmutableKernel)
        {
            kernel = kernel.Clone();
        }

        // Get the context contributions from the AIContextProviders.
        AIContext providersContext = await chatHistoryAgentThread.AIContextProviders.ModelInvokingAsync(messages, cancellationToken).ConfigureAwait(false);

        // Check for compatibility AIContextProviders and the UseImmutableKernel setting.
        if (providersContext.AIFunctions is { Count: > 0 } && !this.UseImmutableKernel)
        {
            throw new InvalidOperationException("AIContextProviders with AIFunctions are not supported when Agent UseImmutableKernel setting is false.");
        }

        kernel.Plugins.AddFromAIContext(providersContext, "Tools");
#pragma warning restore SKEXP0110, SKEXP0130 // Type is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.

        // Invoke Chat Completion with the updated chat history.
        ChatHistory chatHistory = [];
        await foreach (var existingMessage in chatHistoryAgentThread.GetMessagesAsync(cancellationToken).ConfigureAwait(false))
        {
            chatHistory.Add(existingMessage);
        }
        var invokeResults = this.InternalInvokeAsync(
            this.GetDisplayName(),
            chatHistory,
            async (m) =>
            {
                await this.NotifyThreadOfNewMessage(chatHistoryAgentThread, m, cancellationToken).ConfigureAwait(false);
                if (options?.OnIntermediateMessage is not null)
                {
                    await options.OnIntermediateMessage(m).ConfigureAwait(false);
                }
            },
            options?.KernelArguments,
            kernel,
            FormatAdditionalInstructions(providersContext, options),
            cancellationToken);

        // Notify the thread of new messages and return them to the caller.
        await foreach (var result in invokeResults.ConfigureAwait(false))
        {
            // 1. During AutoInvoke = true, the function call content is provided via the callback
            // above, since it is not returned as part of the regular response to the user.
            // 2. During AutoInvoke = false, the function call content is returned directly as a
            // regular response here.
            // 3. If the user Terminates the function call, via a filter, the function call content
            // is also returned as part of the regular response here.
            //
            // In the first case, we don't want to add the function call content to the thread here
            // since it should already have been added in the callback above.
            // In the second case, we shouldn't add the function call content to the thread, since
            // we don't know if the user will execute the call. They should add it themselves.
            // In the third case, we don't want to add the function call content to the thread either,
            // since the filter terminated the call, and therefore won't get executed.
            if (!result.Items.Any(i => i is FunctionCallContent || i is FunctionResultContent))
            {
                await this.NotifyThreadOfNewMessage(chatHistoryAgentThread, result, cancellationToken).ConfigureAwait(false);

                if (options?.OnIntermediateMessage is not null)
                {
                    await options.OnIntermediateMessage(result).ConfigureAwait(false);
                }
            }

            yield return new(result, chatHistoryAgentThread);
        }
    }

    /// <inheritdoc/>
    /// <remarks>
    /// This method is used by the <see cref="ChatHistoryChannel"/>. Note that if this method is removed, the <see cref="ChatHistoryChannel"/>
    /// would automatically invoke the overload with <see cref="ICollection{ChatMessageContent}"/> since it is interchangeable with <see cref="ChatHistory"/>
    /// but it's behavior is different, so will not work as expected.
    /// </remarks>
    protected internal override IAsyncEnumerable<ChatMessageContent> InvokeAsync(
        ChatHistory history,
        KernelArguments? arguments = null,
        Kernel? kernel = null,
        CancellationToken cancellationToken = default)
    {
        string agentName = this.GetDisplayName();

        return this.InternalInvokeAsync(agentName, history, (m) => Task.CompletedTask, arguments, kernel, null, cancellationToken);
    }

    /// <inheritdoc/>
    public override async IAsyncEnumerable<AgentResponseItem<StreamingChatMessageContent>> InvokeStreamingAsync(
        ICollection<ChatMessageContent> messages,
        AgentThread? thread = null,
        AgentInvokeOptions? options = null,
        [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        Verify.NotNull(messages);

        ChatHistoryAgentThread chatHistoryAgentThread = await this.EnsureThreadExistsWithMessagesAsync(
            messages,
            thread,
            () => new ChatHistoryAgentThread(),
            cancellationToken).ConfigureAwait(false);

        Kernel kernel = this.GetKernel(options);
#pragma warning disable SKEXP0110, SKEXP0130 // Type is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.
        if (this.UseImmutableKernel)
        {
            kernel = kernel.Clone();
        }

        // Get the context contributions from the AIContextProviders.
        AIContext providersContext = await chatHistoryAgentThread.AIContextProviders.ModelInvokingAsync(messages, cancellationToken).ConfigureAwait(false);

        // Check for compatibility AIContextProviders and the UseImmutableKernel setting.
        if (providersContext.AIFunctions is { Count: > 0 } && !this.UseImmutableKernel)
        {
            throw new InvalidOperationException("AIContextProviders with AIFunctions are not supported when Agent UseImmutableKernel setting is false.");
        }

        kernel.Plugins.AddFromAIContext(providersContext, "Tools");
#pragma warning restore SKEXP0110, SKEXP0130 // Type is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.

        // Invoke Chat Completion with the updated chat history.
        ChatHistory chatHistory = [];
        await foreach (var existingMessage in chatHistoryAgentThread.GetMessagesAsync(cancellationToken).ConfigureAwait(false))
        {
            chatHistory.Add(existingMessage);
        }
        string agentName = this.GetDisplayName();
        var invokeResults = this.InternalInvokeStreamingAsync(
            agentName,
            chatHistory,
            async (m) =>
            {
                await this.NotifyThreadOfNewMessage(chatHistoryAgentThread, m, cancellationToken).ConfigureAwait(false);
                if (options?.OnIntermediateMessage is not null)
                {
                    await options.OnIntermediateMessage(m).ConfigureAwait(false);
                }
            },
            options?.KernelArguments,
            kernel,
            FormatAdditionalInstructions(providersContext, options),
            cancellationToken);

        await foreach (var result in invokeResults.ConfigureAwait(false))
        {
            yield return new(result, chatHistoryAgentThread);
        }
    }

    /// <inheritdoc/>
    /// <remarks>
    /// This method is used by the <see cref="ChatHistoryChannel"/>. Note that if this method is removed, the <see cref="ChatHistoryChannel"/>
    /// would automatically invoke the overload with <see cref="ICollection{ChatMessageContent}"/> since it is interchangeable with <see cref="ChatHistory"/>
    /// but it's behavior is different, so will not work as expected.
    /// </remarks>
    protected internal override IAsyncEnumerable<StreamingChatMessageContent> InvokeStreamingAsync(
        ChatHistory history,
        KernelArguments? arguments = null,
        Kernel? kernel = null,
        CancellationToken cancellationToken = default)
    {
        string agentName = this.GetDisplayName();

        return this.InternalInvokeStreamingAsync(
            agentName,
            history,
            (newMessage) => Task.CompletedTask,
            arguments,
            kernel,
            null,
            cancellationToken);
    }

    /// <inheritdoc/>
    [Experimental("SKEXP0110")]
    protected override Task<AgentChannel> RestoreChannelAsync(string channelState, CancellationToken cancellationToken)
    {
        ChatHistory history =
            JsonSerializer.Deserialize<ChatHistory>(channelState) ??
            throw new KernelException("Unable to restore channel: invalid state.");
        return Task.FromResult<AgentChannel>(new ChatHistoryChannel(history));
    }

    internal static (IChatCompletionService service, PromptExecutionSettings? executionSettings) GetChatCompletionService(Kernel kernel, KernelArguments? arguments)
    {
        // Need to provide a KernelFunction to the service selector as a container for the execution-settings.
        KernelFunction nullPrompt = KernelFunctionFactory.CreateFromPrompt("placeholder", arguments?.ExecutionSettings?.Values);

        kernel.ServiceSelector.TrySelectAIService<IChatCompletionService>(kernel, nullPrompt, arguments ?? [], out IChatCompletionService? chatCompletionService, out PromptExecutionSettings? executionSettings);

#pragma warning disable CA2000 // Dispose objects before losing scope
        if (chatCompletionService is null
            && kernel.ServiceSelector is IChatClientSelector chatClientSelector
            && chatClientSelector.TrySelectChatClient<Microsoft.Extensions.AI.IChatClient>(kernel, nullPrompt, arguments ?? [], out var chatClient, out executionSettings)
            && chatClient is not null)
        {
            // This change is temporary until Agents support IChatClient natively in near future.
            chatCompletionService = chatClient!.AsChatCompletionService();
        }
#pragma warning restore CA2000 // Dispose objects before losing scope

        if (chatCompletionService is null)
        {
            var message = new StringBuilder().Append("No service was found for any of the supported types: ").Append(typeof(IChatCompletionService)).Append(", ").Append(typeof(Microsoft.Extensions.AI.IChatClient)).Append('.');
            if (nullPrompt.ExecutionSettings is not null)
            {
                string serviceIds = string.Join("|", nullPrompt.ExecutionSettings.Keys);
                if (!string.IsNullOrEmpty(serviceIds))
                {
                    message.Append(" Expected serviceIds: ").Append(serviceIds).Append('.');
                }

                string modelIds = string.Join("|", nullPrompt.ExecutionSettings.Values.Select(model => model.ModelId));
                if (!string.IsNullOrEmpty(modelIds))
                {
                    message.Append(" Expected modelIds: ").Append(modelIds).Append('.');
                }
            }

            throw new KernelException(message.ToString());
        }

        return (chatCompletionService!, executionSettings);
    }

    #region private

    private async Task<ChatHistory> SetupAgentChatHistoryAsync(
        IReadOnlyList<ChatMessageContent> history,
        KernelArguments? arguments,
        Kernel kernel,
        string? additionalInstructions,
        CancellationToken cancellationToken)
    {
        ChatHistory chat = [];

        string? instructions = await this.RenderInstructionsAsync(kernel, arguments, cancellationToken).ConfigureAwait(false);

        if (!string.IsNullOrWhiteSpace(instructions))
        {
            chat.Add(new ChatMessageContent(this.InstructionsRole, instructions) { AuthorName = this.Name });
        }

        if (!string.IsNullOrWhiteSpace(additionalInstructions))
        {
            chat.Add(new ChatMessageContent(AuthorRole.System, additionalInstructions) { AuthorName = this.Name });
        }

        chat.AddRange(history);

        return chat;
    }

    private async IAsyncEnumerable<ChatMessageContent> InternalInvokeAsync(
        string agentName,
        ChatHistory history,
        Func<ChatMessageContent, Task> onNewToolMessage,
        KernelArguments? arguments = null,
        Kernel? kernel = null,
        string? additionalInstructions = null,
        [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        kernel ??= this.Kernel;

        (IChatCompletionService chatCompletionService, PromptExecutionSettings? executionSettings) = GetChatCompletionService(kernel, this.Arguments.MergeArguments(arguments));

        ChatHistory chat = await this.SetupAgentChatHistoryAsync(history, arguments, kernel, additionalInstructions, cancellationToken).ConfigureAwait(false);

        int messageCount = chat.Count;

        Type serviceType = chatCompletionService.GetType();

        this.Logger.LogAgentChatServiceInvokingAgent(nameof(InvokeAsync), this.Id, agentName, serviceType);

        using var activity = ModelDiagnostics.StartAgentInvocationActivity(this.Id, agentName, this.Description, kernel, chat);

        IReadOnlyList<ChatMessageContent> messages =
            await chatCompletionService.GetChatMessageContentsAsync(
                chat,
                executionSettings,
                kernel,
                cancellationToken).ConfigureAwait(false);

        this.Logger.LogAgentChatServiceInvokedAgent(nameof(InvokeAsync), this.Id, agentName, serviceType, messages.Count);

        // Capture mutated messages related function calling / tools
        for (int messageIndex = messageCount; messageIndex < chat.Count; messageIndex++)
        {
            ChatMessageContent message = chat[messageIndex];

            message.AuthorName = this.Name;

            history.Add(message);
            await onNewToolMessage(message).ConfigureAwait(false);
        }

        foreach (ChatMessageContent message in messages)
        {
            message.AuthorName = this.Name;

            yield return message;
        }

        activity?.SetAgentResponse(messages);
    }

    private async IAsyncEnumerable<StreamingChatMessageContent> InternalInvokeStreamingAsync(
        string agentName,
        ChatHistory history,
        Func<ChatMessageContent, Task> onNewMessage,
        KernelArguments? arguments = null,
        Kernel? kernel = null,
        string? additionalInstructions = null,
        [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        kernel ??= this.Kernel;

        (IChatCompletionService chatCompletionService, PromptExecutionSettings? executionSettings) = GetChatCompletionService(kernel, this.Arguments.MergeArguments(arguments));

        ChatHistory chat = await this.SetupAgentChatHistoryAsync(history, arguments, kernel, additionalInstructions, cancellationToken).ConfigureAwait(false);

        int messageCount = chat.Count;

        Type serviceType = chatCompletionService.GetType();

        this.Logger.LogAgentChatServiceInvokingAgent(nameof(InvokeAsync), this.Id, agentName, serviceType);

        using var activity = ModelDiagnostics.StartAgentInvocationActivity(this.Id, agentName, this.Description, kernel, chat);

        IAsyncEnumerable<StreamingChatMessageContent> messages =
            chatCompletionService.GetStreamingChatMessageContentsAsync(
                chat,
                executionSettings,
                kernel,
                cancellationToken);

        this.Logger.LogAgentChatServiceInvokedStreamingAgent(nameof(InvokeAsync), this.Id, agentName, serviceType);

        int messageIndex = messageCount;
        AuthorRole? role = null;
        StringBuilder builder = new();
        List<StreamingChatMessageContent>? streamedContents = activity is not null ? [] : null;
        await foreach (StreamingChatMessageContent message in messages.ConfigureAwait(false))
        {
            role = message.Role;
            message.Role ??= AuthorRole.Assistant;
            message.AuthorName = this.Name;

            builder.Append(message.ToString());

            // Capture mutated messages related function calling / tools
            for (; messageIndex < chat.Count; messageIndex++)
            {
                ChatMessageContent chatMessage = chat[messageIndex];

                chatMessage.AuthorName = this.Name;

                await onNewMessage(chatMessage).ConfigureAwait(false);
                history.Add(chatMessage);
            }

            streamedContents?.Add(message);
            yield return message;
        }

        // Do not duplicate terminated function result to history
        if (role != AuthorRole.Tool)
        {
            await onNewMessage(new(role ?? AuthorRole.Assistant, builder.ToString()) { AuthorName = this.Name }).ConfigureAwait(false);
            history.Add(new(role ?? AuthorRole.Assistant, builder.ToString()) { AuthorName = this.Name });
        }

        activity?.EndAgentStreamingResponse(streamedContents);
    }

    #endregion
}


===== Core\ChatCompletionAgentExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Diagnostics.CodeAnalysis;
using System.Text.Json;
using Microsoft.SemanticKernel.ChatCompletion;
using MAAI = Microsoft.Agents.AI;

namespace Microsoft.SemanticKernel.Agents;

/// <summary>
/// Exposes a Semantic Kernel <see cref="ChatCompletionAgent"/> as a Microsoft Agent Framework <see cref="MAAI.AIAgent"/>.
/// </summary>
public static class ChatCompletionAgentExtensions
{
    /// <summary>
    /// Exposes a Semantic Kernel Agent Framework <see cref="ChatCompletionAgent"/> as a Microsoft Agent Framework <see cref="MAAI.AIAgent"/>.
    /// </summary>
    /// <param name="chatCompletionAgent">The Semantic Kernel <see cref="ChatCompletionAgent"/> to expose as a Microsoft Agent Framework <see cref="MAAI.AIAgent"/>.</param>
    /// <returns>The Semantic Kernel Agent Framework <see cref="Agent"/> exposed as a Microsoft Agent Framework <see cref="MAAI.AIAgent"/></returns>
    [Experimental("SKEXP0110")]
    public static MAAI.AIAgent AsAIAgent(this ChatCompletionAgent chatCompletionAgent)
        => chatCompletionAgent.AsAIAgent(
            () => new ChatHistoryAgentThread(),
            (json, options) =>
            {
                var chatHistory = JsonSerializer.Deserialize<ChatHistory>(json);
                return chatHistory is null ? new ChatHistoryAgentThread() : new ChatHistoryAgentThread(chatHistory);
            },
            (thread, options) => JsonSerializer.SerializeToElement((thread as ChatHistoryAgentThread)?.ChatHistory));
}


===== Core\ChatHistoryAgent.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.SemanticKernel.ChatCompletion;

namespace Microsoft.SemanticKernel.Agents;

/// <summary>
/// Represents a <see cref="Agent"/> specialization bound to a <see cref="ChatHistoryChannel"/>.
/// </summary>
/// <remarks>
/// NOTE: Enable <see cref="PromptExecutionSettings.FunctionChoiceBehavior"/> for agent plugins
/// (<see cref="Agent.Arguments"/>).
/// </remarks>
[Experimental("SKEXP0110")]
public abstract class ChatHistoryAgent : Agent
{
    /// <summary>
    /// Gets an optional <see cref="IChatHistoryReducer"/> to reduce the history.
    /// </summary>
    /// <remarks>
    /// The reducer is automatically applied to the history before invoking the agent, only when using
    /// an <see cref="AgentChat"/>. It must be explicitly applied via <see cref="ReduceAsync"/>.
    /// </remarks>
    [Experimental("SKEXP0110")]
    public IChatHistoryReducer? HistoryReducer { get; init; }

    /// <summary>
    /// Invokes the assistant to respond to the provided history.
    /// </summary>
    /// <param name="history">The conversation history.</param>
    /// <param name="arguments">Optional arguments to pass to the agents's invocation, including any <see cref="PromptExecutionSettings"/>.</param>
    /// <param name="kernel">The <see cref="Kernel"/> containing services, plugins, and other state for use by the agent.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>An asynchronous enumeration of response messages.</returns>
    protected internal abstract IAsyncEnumerable<ChatMessageContent> InvokeAsync(
        ChatHistory history,
        KernelArguments? arguments = null,
        Kernel? kernel = null,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Invokes the assistant to respond to the provided history with streaming response.
    /// </summary>
    /// <param name="history">The conversation history.</param>
    /// <param name="arguments">Optional arguments to pass to the agents's invocation, including any <see cref="PromptExecutionSettings"/>.</param>
    /// <param name="kernel">The <see cref="Kernel"/> containing services, plugins, and other state for use by the agent.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>An asynchronous enumeration of response messages.</returns>
    protected internal abstract IAsyncEnumerable<StreamingChatMessageContent> InvokeStreamingAsync(
        ChatHistory history,
        KernelArguments? arguments = null,
        Kernel? kernel = null,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Reduces the provided history.
    /// </summary>
    /// <param name="history">The source history.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns><see langword="true"/> if reduction occurred.</returns>
    [Experimental("SKEXP0110")]
    public Task<bool> ReduceAsync(ChatHistory history, CancellationToken cancellationToken = default) =>
        history.ReduceInPlaceAsync(this.HistoryReducer, cancellationToken);

    /// <inheritdoc/>
    [Experimental("SKEXP0110")]
    protected sealed override IEnumerable<string> GetChannelKeys()
    {
        yield return typeof(ChatHistoryChannel).FullName!;

        // Agents with different reducers shall not share the same channel.
        // Agents with the same or equivalent reducer shall share the same channel.
        if (this.HistoryReducer != null)
        {
            // Explicitly include the reducer type to eliminate the possibility of hash collisions
            // with custom implementations of IChatHistoryReducer.
            yield return this.HistoryReducer.GetType().FullName!;

            yield return this.HistoryReducer.GetHashCode().ToString(CultureInfo.InvariantCulture);
        }
    }

    /// <inheritdoc/>
    [Experimental("SKEXP0110")]
    protected sealed override Task<AgentChannel> CreateChannelAsync(CancellationToken cancellationToken)
    {
        ChatHistoryChannel channel =
            new()
            {
                Logger = this.ActiveLoggerFactory.CreateLogger<ChatHistoryChannel>()
            };

        return Task.FromResult<AgentChannel>(channel);
    }
}


===== Core\ChatHistoryAgentThread.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.SemanticKernel.ChatCompletion;

namespace Microsoft.SemanticKernel.Agents;

/// <summary>
/// Represents a conversation thread based on an instance of <see cref="ChatHistory"/> that is managed inside this class.
/// </summary>
public sealed class ChatHistoryAgentThread : AgentThread
{
    private readonly ChatHistory _chatHistory = new();

    /// <summary>
    /// Initializes a new instance of the <see cref="ChatHistoryAgentThread"/> class.
    /// </summary>
    public ChatHistoryAgentThread()
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ChatHistoryAgentThread"/> class that resumes an existing thread.
    /// </summary>
    /// <param name="chatHistory">An existing chat history to base this thread on.</param>
    /// <param name="id">The id of the existing thread. If not provided, a new one will be generated.</param>
    public ChatHistoryAgentThread(ChatHistory chatHistory, string? id = null)
    {
        Verify.NotNull(chatHistory);
        this._chatHistory = chatHistory;
        this.Id = id ?? Guid.NewGuid().ToString("N");
    }

    /// <summary>
    /// Gets the underlying <see cref="Microsoft.SemanticKernel.ChatCompletion.ChatHistory"/> object that stores the chat history for this thread.
    /// </summary>
    public ChatHistory ChatHistory => this._chatHistory;

    /// <summary>
    /// Creates the thread and returns the thread id.
    /// </summary>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>A task that completes when the thread has been created.</returns>
    public new Task CreateAsync(CancellationToken cancellationToken = default)
    {
        return base.CreateAsync(cancellationToken);
    }

    /// <inheritdoc />
    protected override Task<string?> CreateInternalAsync(CancellationToken cancellationToken)
    {
        return Task.FromResult<string?>(Guid.NewGuid().ToString("N"));
    }

    /// <inheritdoc />
    protected override Task DeleteInternalAsync(CancellationToken cancellationToken)
    {
        this._chatHistory.Clear();
        return Task.CompletedTask;
    }

    /// <inheritdoc />
    protected override Task OnNewMessageInternalAsync(ChatMessageContent newMessage, CancellationToken cancellationToken = default)
    {
        this._chatHistory.Add(newMessage);
        return Task.CompletedTask;
    }

    /// <summary>
    /// Asynchronously retrieves all messages in the thread.
    /// </summary>
    /// <remarks>
    /// Messages will be returned in ascending chronological order.
    /// </remarks>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>The messages in the thread.</returns>
    /// <exception cref="InvalidOperationException">The thread has been deleted.</exception>
    [Experimental("SKEXP0110")]
    public async IAsyncEnumerable<ChatMessageContent> GetMessagesAsync([EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        if (this.IsDeleted)
        {
            throw new InvalidOperationException("This thread has been deleted and cannot be used anymore.");
        }

        if (this.Id is null)
        {
            await this.CreateAsync(cancellationToken).ConfigureAwait(false);
        }

        foreach (var message in this._chatHistory)
        {
            yield return message;
        }
    }
}


===== Core\ChatHistoryChannel.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.SemanticKernel.Agents.Extensions;
using Microsoft.SemanticKernel.Agents.Serialization;
using Microsoft.SemanticKernel.ChatCompletion;

namespace Microsoft.SemanticKernel.Agents;

/// <summary>
/// Represents an <see cref="AgentChannel"/> specialization that acts upon a <see cref="ChatHistoryAgent"/>.
/// </summary>
[Experimental("SKEXP0110")]
internal sealed class ChatHistoryChannel : AgentChannel
{
    // Supported content types for <see cref="ReceiveAsync"/> when
    // <see cref="ChatMessageContent.Content"/> is empty.
    private static readonly HashSet<Type> s_contentMap =
        [
            typeof(FunctionCallContent),
            typeof(FunctionResultContent),
            typeof(ImageContent),
        ];

    private readonly ChatHistory _history;

    /// <inheritdoc/>
    protected override async IAsyncEnumerable<(bool IsVisible, ChatMessageContent Message)> InvokeAsync(
        Agent agent,
        [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        if (agent is not ChatHistoryAgent historyAgent)
        {
            throw new KernelException($"Invalid channel binding for agent: {agent.Id} ({agent.GetType().FullName})");
        }

        // Pre-process history reduction.
        await historyAgent.ReduceAsync(this._history, cancellationToken).ConfigureAwait(false);

        // Capture the current message count to evaluate history mutation.
        int messageCount = this._history.Count;
        HashSet<ChatMessageContent> mutatedHistory = [];

        // Utilize a queue as a "read-ahead" cache to evaluate message sequencing (i.e., which message is final).
        Queue<ChatMessageContent> messageQueue = [];

        ChatMessageContent? yieldMessage = null;
        await foreach (ChatMessageContent responseMessage in historyAgent.InvokeAsync(this._history, null, null, cancellationToken).ConfigureAwait(false))
        {
            // Capture all messages that have been included in the mutated the history.
            for (int messageIndex = messageCount; messageIndex < this._history.Count; messageIndex++)
            {
                ChatMessageContent mutatedMessage = this._history[messageIndex];
                mutatedHistory.Add(mutatedMessage);
                messageQueue.Enqueue(mutatedMessage);
            }

            // Update the message count pointer to reflect the current history.
            messageCount = this._history.Count;

            // Avoid duplicating any message included in the mutated history and also returned by the enumeration result.
            if (!mutatedHistory.Contains(responseMessage))
            {
                this._history.Add(responseMessage);
                messageQueue.Enqueue(responseMessage);
            }

            // Dequeue the next message to yield.
            yieldMessage = messageQueue.Dequeue();
            yield return (IsMessageVisible(yieldMessage), yieldMessage);
        }

        // Dequeue any remaining messages to yield.
        while (messageQueue.Count > 0)
        {
            yieldMessage = messageQueue.Dequeue();

            yield return (IsMessageVisible(yieldMessage), yieldMessage);
        }

        // Function content not visible, unless result is the final message.
        bool IsMessageVisible(ChatMessageContent message) =>
            (!message.Items.Any(i => i is FunctionCallContent || i is FunctionResultContent) ||
              messageQueue.Count == 0);
    }

    /// <inheritdoc/>
    protected override async IAsyncEnumerable<StreamingChatMessageContent> InvokeStreamingAsync(Agent agent, IList<ChatMessageContent> messages, [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        if (agent is not ChatHistoryAgent historyAgent)
        {
            throw new KernelException($"Invalid channel binding for agent: {agent.Id} ({agent.GetType().FullName})");
        }

        // Pre-process history reduction.
        await historyAgent.ReduceAsync(this._history, cancellationToken).ConfigureAwait(false);

        int messageCount = this._history.Count;

        await foreach (StreamingChatMessageContent streamingMessage in historyAgent.InvokeStreamingAsync(this._history, null, null, cancellationToken).ConfigureAwait(false))
        {
            yield return streamingMessage;
        }

        for (int index = messageCount; index < this._history.Count; ++index)
        {
            messages.Add(this._history[index]);
        }
    }

    /// <inheritdoc/>
    protected override Task ReceiveAsync(IEnumerable<ChatMessageContent> history, CancellationToken cancellationToken)
    {
        // Only add messages with valid content or supported content-items.
        this._history.AddRange(
            history.Where(
                m => !string.IsNullOrEmpty(m.Content) ||
                m.Items.Where(i => s_contentMap.Contains(i.GetType())).Any()));

        return Task.CompletedTask;
    }

    /// <inheritdoc/>
    protected override IAsyncEnumerable<ChatMessageContent> GetHistoryAsync(CancellationToken cancellationToken)
    {
        return this._history.ToDescendingAsync();
    }

    /// <inheritdoc/>
    protected override Task ResetAsync(CancellationToken cancellationToken = default)
    {
        this._history.Clear();

        return Task.CompletedTask;
    }

    /// <inheritdoc/>
    protected override string Serialize()
        => JsonSerializer.Serialize(ChatMessageReference.Prepare(this._history));

    /// <summary>
    /// Initializes a new instance of the <see cref="ChatHistoryChannel"/> class.
    /// </summary>
    public ChatHistoryChannel(ChatHistory? history = null)
    {
        this._history = history ?? [];
    }
}


===== Core\Definition\ChatCompletionAgentFactory.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Diagnostics.CodeAnalysis;
using System.Threading;
using System.Threading.Tasks;

namespace Microsoft.SemanticKernel.Agents;

/// <summary>
/// Provides a <see cref="AgentFactory"/> which creates instances of <see cref="ChatCompletionAgent"/>.
/// </summary>
[Experimental("SKEXP0110")]
public sealed class ChatCompletionAgentFactory : AgentFactory
{
    /// <summary>
    /// The type of the chat completion agent.
    /// </summary>
    public const string ChatCompletionAgentType = "chat_completion_agent";

    /// <summary>
    /// Initializes a new instance of the <see cref="ChatCompletionAgentFactory"/> class.
    /// </summary>
    public ChatCompletionAgentFactory()
        : base([ChatCompletionAgentType])
    {
    }

    /// <inheritdoc/>
    public override Task<Agent?> TryCreateAsync(Kernel kernel, AgentDefinition agentDefinition, AgentCreationOptions? agentCreationOptions = null, CancellationToken cancellationToken = default)
    {
        Verify.NotNull(agentDefinition);

        ChatCompletionAgent? agent = null;
        if (this.IsSupported(agentDefinition))
        {
            agent = new ChatCompletionAgent()
            {
                Name = agentDefinition.Name,
                Description = agentDefinition.Description,
                Instructions = agentDefinition.Instructions,
                Arguments = agentDefinition.GetDefaultKernelArguments(kernel),
                Kernel = kernel,
                Template = agentDefinition.GetPromptTemplate(kernel, agentCreationOptions?.PromptTemplateFactory),
                LoggerFactory = kernel.LoggerFactory,
            };
        }

        return Task.FromResult<Agent?>(agent);
    }
}


===== Core\Functions\AgentKernelFunctionFactory.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.SemanticKernel.Agents.Extensions;
using Microsoft.SemanticKernel.ChatCompletion;

namespace Microsoft.SemanticKernel.Agents;

/// <summary>
/// Provides factory methods for creating implementations of <see cref="KernelFunction"/> backed by an <see cref="Agent" />.
/// </summary>
[Experimental("SKEXP0110")]
public static class AgentKernelFunctionFactory
{
    /// <summary>
    /// Creates a <see cref="KernelFunction"/> that will invoke the provided Agent.
    /// </summary>
    /// <param name="agent">The <see cref="Agent" /> to be represented via the created <see cref="KernelFunction"/>.</param>
    /// <param name="functionName">The name to use for the function. If null, it will default to the agent name.</param>
    /// <param name="description">The description to use for the function. If null, it will default to agent description.</param>
    /// <param name="parameters">Optional parameter descriptions. If null, it will default to query and additional instructions parameters.</param>
    /// <param name="loggerFactory">The <see cref="ILoggerFactory"/> to use for logging. If null, no logging will be performed.</param>
    /// <returns>The created <see cref="KernelFunction"/> for invoking the <see cref="Agent"/>.</returns>
    [RequiresUnreferencedCode("Uses reflection to handle various aspects of the function creation and invocation, making it incompatible with AOT scenarios.")]
    [RequiresDynamicCode("Uses reflection to handle various aspects of the function creation and invocation, making it incompatible with AOT scenarios.")]
    public static KernelFunction CreateFromAgent(
        Agent agent,
        string? functionName = null,
        string? description = null,
        IEnumerable<KernelParameterMetadata>? parameters = null,
        ILoggerFactory? loggerFactory = null)
    {
        Verify.NotNull(agent);

        async Task<FunctionResult> InvokeAgentAsync(Kernel kernel, KernelFunction function, KernelArguments arguments, CancellationToken cancellationToken)
        {
            arguments.TryGetValue("query", out var query);
            var queryString = query?.ToString() ?? string.Empty;

            AgentInvokeOptions? options = null;

            if (arguments.TryGetValue("instructions", out var instructions) && instructions is not null)
            {
                options = new()
                {
                    AdditionalInstructions = instructions?.ToString() ?? string.Empty
                };
            }

            var response = agent.InvokeAsync(new ChatMessageContent(AuthorRole.User, queryString), null, options, cancellationToken);

            List<ChatMessageContent> chatMessages = [];
            await foreach (var item in response.WithCancellation(cancellationToken).ConfigureAwait(false))
            {
                chatMessages.Add(item.Message);
            }
            return new FunctionResult(function, chatMessages, kernel.Culture);
        }

        KernelFunctionFromMethodOptions options = new()
        {
            FunctionName = functionName ?? agent.GetName(),
            Description = description ?? agent.Description,
            Parameters = parameters ?? GetDefaultKernelParameterMetadata(),
            ReturnParameter = new() { ParameterType = typeof(FunctionResult) },
        };

        return KernelFunctionFactory.CreateFromMethod(
                InvokeAgentAsync,
                options);
    }

    #region private
    [RequiresUnreferencedCode("Uses reflection for generating JSON schema for method parameters and return type, making it incompatible with AOT scenarios.")]
    [RequiresDynamicCode("Uses reflection for generating JSON schema for method parameters and return type, making it incompatible with AOT scenarios.")]
    private static IEnumerable<KernelParameterMetadata> GetDefaultKernelParameterMetadata()
    {
        return s_kernelParameterMetadata ??= [
            new KernelParameterMetadata("query") { Description = "Available information that will guide in performing this operation.", ParameterType = typeof(string), IsRequired = true },
            new KernelParameterMetadata("instructions") { Description = "Additional instructions for the agent.", ParameterType = typeof(string), IsRequired = true },
        ];
    }

    private static IEnumerable<KernelParameterMetadata>? s_kernelParameterMetadata;
    #endregion
}


===== Core\Functions\AgentKernelPluginFactory.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using Microsoft.SemanticKernel.Agents;

namespace Microsoft.SemanticKernel;

/// <summary>
/// Extension methods for creating KernelPlugin instances from agents.
/// </summary>
[Experimental("SKEXP0110")]
public static class AgentKernelPluginFactory
{
    /// <summary>
    /// Creates a plugin from a collection of agents. Each agent is converted into a KernelFunction via AgentKernelFunctionFactory.
    /// </summary>
    /// <param name="pluginName">The name for the plugin.</param>
    /// <param name="description">A description of the plugin.</param>
    /// <param name="agents">A collection of agents to include in the plugin.</param>
    /// <returns>A KernelPlugin with functions derived from the provided agents.</returns>
    /// <exception cref="ArgumentNullException">Thrown when agents is null.</exception>
    public static KernelPlugin CreateFromAgents(string pluginName, string? description, IEnumerable<Agent> agents)
    {
        if (agents == null)
        {
            throw new ArgumentNullException(nameof(agents));
        }

        KernelFunction[] functions = agents
            .Select(agent => AgentKernelFunctionFactory.CreateFromAgent(agent))
            .ToArray();

        return KernelPluginFactory.CreateFromFunctions(pluginName, description, functions);
    }

    /// <summary>
    /// Creates a plugin from an array of agents. Each agent is converted into a KernelFunction via AgentKernelFunctionFactory.
    /// </summary>
    /// <param name="pluginName">The name for the plugin.</param>
    /// <param name="agents">The agents to include in the plugin.</param>
    /// <returns>A KernelPlugin with functions derived from the provided agents.</returns>
    public static KernelPlugin CreateFromAgents(string pluginName, params Agent[] agents) =>
        CreateFromAgents(pluginName, description: null, agents);
}


===== Core\Internal\ChatMessageForPrompt.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace Microsoft.SemanticKernel.Agents.Internal;

/// <summary>
/// Present a <see cref="ChatMessageForPrompt"/> for serialization without metadata.
/// </summary>
/// <param name="message">The referenced message</param>
internal sealed class ChatMessageForPrompt(ChatMessageContent message)
{
    private static readonly JsonSerializerOptions s_jsonOptions = new() { WriteIndented = true };

    /// <summary>
    /// The string representation of the <see cref="ChatMessageContent.Role"/> property.
    /// </summary>
    public string Role => message.Role.Label;

    /// <summary>
    /// The referenced <see cref="ChatMessageContent.AuthorName"/> property.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
#pragma warning disable SKEXP0001
    public string? Name => message.AuthorName;
#pragma warning restore SKEXP0001

    /// <summary>
    /// The referenced <see cref="ChatMessageContent.Content"/> property.
    /// </summary>
    public string Content => message.Content ?? string.Empty;

    /// <summary>
    /// Convenience method to format a set of messages for use in a prompt.
    /// </summary>
    public static string Format(IEnumerable<ChatMessageContent> messages, bool useNameOnly = false) =>
        useNameOnly ?
            JsonSerializer.Serialize(Prepare(messages, m => string.IsNullOrEmpty(m.AuthorName) ? m.Role.Label : m.AuthorName).ToArray(), s_jsonOptions) :
            JsonSerializer.Serialize(Prepare(messages, m => new ChatMessageForPrompt(m)).ToArray(), s_jsonOptions);

    /// <summary>
    /// Convenience method to reference a set of messages.
    /// </summary>
    internal static IEnumerable<TResult> Prepare<TResult>(IEnumerable<ChatMessageContent> messages, Func<ChatMessageContent, TResult> transform) =>
        messages.Where(m => !string.IsNullOrWhiteSpace(m.Content)).Select(m => transform.Invoke(m));
}


===== Core\Internal\CoreKernelArgumentsExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;

namespace Microsoft.SemanticKernel.Arguments.Extensions;

/// <summary>
/// Extensions for <see cref="KernelArguments"/>
/// </summary>
[ExcludeFromCodeCoverage]
internal static class CoreKernelArgumentsExtensions
{
    private static readonly Dictionary<string, PromptExecutionSettings> s_emptySettings = [];

    /// <summary>
    /// Provides a merged instance of <see cref="KernelArguments"/> with precedence for override arguments.
    /// </summary>
    /// <param name="primaryArguments">Primary arguments to merge. This is the base set of arguments.</param>
    /// <param name="overrideArguments">The override arguments.</param>
    /// <remarks>
    /// This merge preserves original <see cref="PromptExecutionSettings"/> and <see cref="KernelArguments"/> parameters.
    /// It allows for incremental addition or replacement of specific parameters while also preserving the ability
    /// to override the execution settings.
    /// </remarks>
    internal static KernelArguments MergeArguments(this KernelArguments? primaryArguments, KernelArguments? overrideArguments)
    {
        // Avoid merge when override arguments are not set.
        if (overrideArguments is null)
        {
            return primaryArguments ?? [];
        }

        // Avoid merge when the Agent arguments are not set.
        if (primaryArguments is null)
        {
            return overrideArguments ?? [];
        }

        // Both instances are not null, merge with precedence for override arguments.

        // Merge execution settings with precedence for override arguments.
        Dictionary<string, PromptExecutionSettings>? settings =
            (overrideArguments.ExecutionSettings ?? s_emptySettings)
                .Concat(primaryArguments.ExecutionSettings ?? s_emptySettings)
                .GroupBy(entry => entry.Key)
                .ToDictionary(entry => entry.Key, entry => entry.First().Value);

        // Merge parameters with precedence for override arguments.
        Dictionary<string, object?>? parameters =
            overrideArguments
                .Concat(primaryArguments)
                .GroupBy(entry => entry.Key)
                .ToDictionary(entry => entry.Key, entry => entry.First().Value);

        return new KernelArguments(parameters, settings);
    }
}


===== Core\Logging\AgentGroupChatLogMessages.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using Microsoft.Extensions.Logging;
using Microsoft.SemanticKernel.Agents.Extensions;

namespace Microsoft.SemanticKernel.Agents;

#pragma warning disable SYSLIB1006 // Multiple logging methods cannot use the same event id within a class

/// <summary>
/// Extensions for logging <see cref="AgentGroupChat"/> invocations.
/// </summary>
/// <remarks>
/// This extension uses the <see cref="LoggerMessageAttribute"/> to
/// generate logging code at compile time to achieve optimized code.
/// </remarks>
[ExcludeFromCodeCoverage]
[Experimental("SKEXP0110")]
internal static partial class AgentGroupChatLogMessages
{
    /// <summary>
    /// Logs <see cref="AgentGroupChat"/> invoking agent (started).
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Debug,
        Message = "[{MethodName}] Invoking chat: {AgentType}: {AgentId}/{AgentName}")]
    public static partial void LogAgentGroupChatInvokingAgent(
        this ILogger logger,
        string methodName,
        Type agentType,
        string agentId,
        string agentName);

    /// <summary>
    /// Logs <see cref="AgentGroupChat"/> invoking agents (started).
    /// </summary>
    private static readonly Action<ILogger, string, string, Exception?> s_logAgentGroupChatInvokingAgents =
        LoggerMessage.Define<string, string>(
            logLevel: LogLevel.Debug,
            eventId: 0,
            "[{MethodName}] Invoking chat: {Agents}");

    public static void LogAgentGroupChatInvokingAgents(
        this ILogger logger,
        string methodName,
        IEnumerable<Agent> agents)
    {
        if (logger.IsEnabled(LogLevel.Debug))
        {
            var agentsMessage = string.Join(", ", agents.Select(a => $"{a.GetType()}:{a.Id}/{a.GetDisplayName()}"));

            s_logAgentGroupChatInvokingAgents(logger, methodName, agentsMessage, null);
        }
    }

    /// <summary>
    /// Logs <see cref="AgentGroupChat"/> selecting agent (started).
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Debug,
        Message = "[{MethodName}] Selecting agent: {StrategyType}.")]
    public static partial void LogAgentGroupChatSelectingAgent(
        this ILogger logger,
        string methodName,
        Type strategyType);

    /// <summary>
    /// Logs <see cref="AgentGroupChat"/> Unable to select agent.
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Error,
        Message = "[{MethodName}] Unable to determine next agent.")]
    public static partial void LogAgentGroupChatNoAgentSelected(
        this ILogger logger,
        string methodName,
        Exception exception);

    /// <summary>
    /// Logs <see cref="AgentGroupChat"/> selected agent (complete).
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Information,
        Message = "[{MethodName}] Agent selected {AgentType}: {AgentId}/{AgentName} by {StrategyType}")]
    public static partial void LogAgentGroupChatSelectedAgent(
        this ILogger logger,
        string methodName,
        Type agentType,
        string agentId,
        string agentName,
        Type strategyType);

    /// <summary>
    /// Logs <see cref="AgentGroupChat"/> yield chat.
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Debug,
        Message = "[{MethodName}] Yield chat - IsComplete: {IsComplete}")]
    public static partial void LogAgentGroupChatYield(
        this ILogger logger,
        string methodName,
        bool isComplete);
}


===== Core\Logging\AggregatorTerminationStrategyLogMessages.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Diagnostics.CodeAnalysis;
using Microsoft.Extensions.Logging;

namespace Microsoft.SemanticKernel.Agents.Chat;

#pragma warning disable SYSLIB1006 // Multiple logging methods cannot use the same event id within a class

/// <summary>
/// Extensions for logging <see cref="AggregatorTerminationStrategy"/> invocations.
/// </summary>
/// <remarks>
/// This extension uses the <see cref="LoggerMessageAttribute"/> to
/// generate logging code at compile time to achieve optimized code.
/// </remarks>
[ExcludeFromCodeCoverage]
[Experimental("SKEXP0110")]
internal static partial class AggregatorTerminationStrategyLogMessages
{
    /// <summary>
    /// Logs <see cref="AggregatorTerminationStrategy"/> invoking agent (started).
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Debug,
        Message = "[{MethodName}] Evaluating termination for {StrategyCount} strategies: {AggregationMode}")]
    public static partial void LogAggregatorTerminationStrategyEvaluating(
        this ILogger logger,
        string methodName,
        int strategyCount,
        AggregateTerminationCondition aggregationMode);
}


===== Core\Logging\ChatCompletionAgentLogMessages.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.Diagnostics.CodeAnalysis;
using Microsoft.Extensions.Logging;

namespace Microsoft.SemanticKernel.Agents;

#pragma warning disable SYSLIB1006 // Multiple logging methods cannot use the same event id within a class

/// <summary>
/// Extensions for logging <see cref="ChatCompletionAgent"/> invocations.
/// </summary>
/// <remarks>
/// This extension uses the <see cref="LoggerMessageAttribute"/> to
/// generate logging code at compile time to achieve optimized code.
/// </remarks>
[ExcludeFromCodeCoverage]
internal static partial class ChatCompletionAgentLogMessages
{
    /// <summary>
    /// Logs <see cref="ChatCompletionAgent"/> invoking agent (started).
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Debug,
        Message = "[{MethodName}] Agent {AgentId}/{AgentName} Invoking service {ServiceType}.")]
    public static partial void LogAgentChatServiceInvokingAgent(
        this ILogger logger,
        string methodName,
        string agentId,
        string agentName,
        Type serviceType);

    /// <summary>
    /// Logs <see cref="ChatCompletionAgent"/> invoked agent (complete).
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Information,
        Message = "[{MethodName}] Agent {AgentId}/{AgentName} Invoked service {ServiceType} with message count: {MessageCount}.")]
    public static partial void LogAgentChatServiceInvokedAgent(
        this ILogger logger,
        string methodName,
        string agentId,
        string agentName,
        Type serviceType,
        int messageCount);

    /// <summary>
    /// Logs <see cref="ChatCompletionAgent"/> invoked streaming agent (complete).
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Information,
        Message = "[{MethodName}] Agent {AgentId}/{AgentName} Invoked service {ServiceType}.")]
    public static partial void LogAgentChatServiceInvokedStreamingAgent(
        this ILogger logger,
        string methodName,
        string agentId,
        string agentName,
        Type serviceType);
}


===== Core\Logging\KernelFunctionSelectionStrategyLogMessages.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.Diagnostics.CodeAnalysis;
using Microsoft.Extensions.Logging;

namespace Microsoft.SemanticKernel.Agents.Chat;

#pragma warning disable SYSLIB1006 // Multiple logging methods cannot use the same event id within a class

/// <summary>
/// Extensions for logging <see cref="KernelFunctionSelectionStrategy"/> invocations.
/// </summary>
/// <remarks>
/// This extension uses the <see cref="LoggerMessageAttribute"/> to
/// generate logging code at compile time to achieve optimized code.
/// </remarks>
[ExcludeFromCodeCoverage]
[Experimental("SKEXP0110")]
internal static partial class KernelFunctionStrategyLogMessages
{
    /// <summary>
    /// Logs <see cref="KernelFunctionSelectionStrategy"/> invoking function (started).
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Debug,
        Message = "[{MethodName}] Invoking function: {PluginName}.{FunctionName}.")]
    public static partial void LogKernelFunctionSelectionStrategyInvokingFunction(
        this ILogger logger,
        string methodName,
        string? pluginName,
        string functionName);

    /// <summary>
    /// Logs <see cref="KernelFunctionSelectionStrategy"/> invoked function (complete).
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Information,
        Message = "[{MethodName}] Invoked function: {PluginName}.{FunctionName}: {ResultType}")]
    public static partial void LogKernelFunctionSelectionStrategyInvokedFunction(
        this ILogger logger,
        string methodName,
        string? pluginName,
        string functionName,
        Type? resultType);
}


===== Core\Logging\KernelFunctionTerminationStrategyLogMessages.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.Diagnostics.CodeAnalysis;
using Microsoft.Extensions.Logging;

namespace Microsoft.SemanticKernel.Agents.Chat;

#pragma warning disable SYSLIB1006 // Multiple logging methods cannot use the same event id within a class

/// <summary>
/// Extensions for logging <see cref="KernelFunctionTerminationStrategy"/> invocations.
/// </summary>
/// <remarks>
/// This extension uses the <see cref="LoggerMessageAttribute"/> to
/// generate logging code at compile time to achieve optimized code.
/// </remarks>
[ExcludeFromCodeCoverage]
[Experimental("SKEXP0110")]
internal static partial class KernelFunctionTerminationStrategyLogMessages
{
    /// <summary>
    /// Logs <see cref="KernelFunctionTerminationStrategy"/> invoking function (started).
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Debug,
        Message = "[{MethodName}] Invoking function: {PluginName}.{FunctionName}.")]
    public static partial void LogKernelFunctionTerminationStrategyInvokingFunction(
        this ILogger logger,
        string methodName,
        string? pluginName,
        string functionName);

    /// <summary>
    /// Logs <see cref="KernelFunctionTerminationStrategy"/> invoked function (complete).
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Information,
        Message = "[{MethodName}] Invoked function: {PluginName}.{FunctionName}: {ResultType}")]
    public static partial void LogKernelFunctionTerminationStrategyInvokedFunction(
        this ILogger logger,
        string methodName,
        string? pluginName,
        string functionName,
        Type? resultType);
}


===== Core\Logging\RegExTerminationStrategyLogMessages.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Diagnostics.CodeAnalysis;
using System.Text.RegularExpressions;
using Microsoft.Extensions.Logging;

namespace Microsoft.SemanticKernel.Agents.Chat;

#pragma warning disable SYSLIB1006 // Multiple logging methods cannot use the same event id within a class

/// <summary>
/// Extensions for logging <see cref="RegexTerminationStrategy"/> invocations.
/// </summary>
/// <remarks>
/// This extension uses the <see cref="LoggerMessageAttribute"/> to
/// generate logging code at compile time to achieve optimized code.
/// </remarks>
[ExcludeFromCodeCoverage]
[Experimental("SKEXP0110")]
internal static partial class RegExTerminationStrategyLogMessages
{
    /// <summary>
    /// Logs <see cref="RegexTerminationStrategy"/> begin evaluation (started).
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Debug,
        Message = "[{MethodName}] Evaluating expressions: {ExpressionCount}")]
    public static partial void LogRegexTerminationStrategyEvaluating(
        this ILogger logger,
        string methodName,
        int expressionCount);

    /// <summary>
    /// Logs <see cref="RegexTerminationStrategy"/> evaluating expression (started).
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Debug,
        Message = "[{MethodName}] Evaluating expression: {Expression}")]
    public static partial void LogRegexTerminationStrategyEvaluatingExpression(
        this ILogger logger,
        string methodName,
        Regex expression);

    /// <summary>
    /// Logs <see cref="RegexTerminationStrategy"/> expression matched (complete).
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Information,
        Message = "[{MethodName}] Expression matched: {Expression}")]
    public static partial void LogRegexTerminationStrategyMatchedExpression(
        this ILogger logger,
        string methodName,
        Regex expression);

    /// <summary>
    /// Logs <see cref="RegexTerminationStrategy"/> no match (complete).
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Information,
        Message = "[{MethodName}] No expression matched.")]
    public static partial void LogRegexTerminationStrategyNoMatch(
        this ILogger logger,
        string methodName);
}


===== Core\Logging\SequentialSelectionStrategyLogMessages.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Diagnostics.CodeAnalysis;
using Microsoft.Extensions.Logging;

namespace Microsoft.SemanticKernel.Agents.Chat;

#pragma warning disable SYSLIB1006 // Multiple logging methods cannot use the same event id within a class

/// <summary>
/// Extensions for logging <see cref="SequentialSelectionStrategy"/> invocations.
/// </summary>
/// <remarks>
/// This extension uses the <see cref="LoggerMessageAttribute"/> to
/// generate logging code at compile time to achieve optimized code.
/// </remarks>
[ExcludeFromCodeCoverage]
[Experimental("SKEXP0110")]
internal static partial class SequentialSelectionStrategyLogMessages
{
    /// <summary>
    /// Logs <see cref="SequentialSelectionStrategy"/> selected agent (complete).
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Information,
        Message = "[{MethodName}] Selected agent ({AgentIndex} / {AgentCount}): {AgentId}/{AgentName}")]
    public static partial void LogSequentialSelectionStrategySelectedAgent(
        this ILogger logger,
        string methodName,
        int agentIndex,
        int agentCount,
        string agentId,
        string agentName);
}


===== Core\Logging\TerminationStrategyLogMessages.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.Diagnostics.CodeAnalysis;
using Microsoft.Extensions.Logging;

namespace Microsoft.SemanticKernel.Agents.Chat;

#pragma warning disable SYSLIB1006 // Multiple logging methods cannot use the same event id within a class

/// <summary>
/// Extensions for logging <see cref="TerminationStrategy"/> invocations.
/// </summary>
/// <remarks>
/// This extension uses the <see cref="LoggerMessageAttribute"/> to
/// generate logging code at compile time to achieve optimized code.
/// </remarks>
[ExcludeFromCodeCoverage]
[Experimental("SKEXP0110")]
internal static partial class TerminationStrategyLogMessages
{
    /// <summary>
    /// Logs <see cref="TerminationStrategy"/> evaluating criteria (started).
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Debug,
        Message = "[{MethodName}] Evaluating termination for agent {AgentType}: {AgentId}/{AgentName}.")]
    public static partial void LogTerminationStrategyEvaluatingCriteria(
        this ILogger logger,
        string methodName,
        Type agentType,
        string agentId,
        string agentName);

    /// <summary>
    /// Logs <see cref="TerminationStrategy"/> agent out of scope.
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Debug,
        Message = "[{MethodName}] {AgentType} agent out of scope for termination: {AgentId}/{AgentName}.")]
    public static partial void LogTerminationStrategyAgentOutOfScope(
        this ILogger logger,
        string methodName,
        Type agentType,
        string agentId,
        string agentName);

    /// <summary>
    /// Logs <see cref="TerminationStrategy"/> evaluated criteria (complete).
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Information,
        Message = "[{MethodName}] Evaluated termination for agent {AgentType}: {AgentId}/{AgentName} - {TerminationResult}")]
    public static partial void LogTerminationStrategyEvaluatedCriteria(
        this ILogger logger,
        string methodName,
        Type agentType,
        string agentId,
        string agentName,
        bool terminationResult);
}


===== Magentic\Internal\PromptExecutionSettingsExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Reflection;

namespace Microsoft.SemanticKernel.Agents.Magentic.Internal;

/// <summary>
/// Extension methods for <see cref="PromptExecutionSettings"/> to support response format operations.
/// </summary>
public static class PromptExecutionSettingsExtensions
{
    private const string ResponseFormatPropertyName = "ResponseFormat";

    /// <summary>
    /// Determines whether the <paramref name="settings"/> object supports a "ResponseFormat" property of type <see cref="object"/>.
    /// </summary>
    /// <param name="settings">The <see cref="PromptExecutionSettings"/> instance to check.</param>
    /// <returns><c>true</c> if the "ResponseFormat" property exists and is of type <see cref="object"/>; otherwise, <c>false</c>.</returns>
    public static bool SupportsResponseFormat(this PromptExecutionSettings settings)
    {
        Type settingsType = settings.GetType();
        PropertyInfo? property = settingsType.GetProperty(ResponseFormatPropertyName);
        return property != null && property.PropertyType == typeof(object);
    }

    /// <summary>
    /// Sets the "ResponseFormat" property of the <paramref name="settings"/> object to the specified response type.
    /// </summary>
    /// <typeparam name="TResponse">The type to set as the response format.</typeparam>
    /// <param name="settings">The <see cref="PromptExecutionSettings"/> instance to update.</param>
    public static void SetResponseFormat<TResponse>(this PromptExecutionSettings settings)
    {
        Type settingsType = settings.GetType();
        PropertyInfo? property = settingsType.GetProperty(ResponseFormatPropertyName);
        property?.SetValue(settings, typeof(TResponse));
    }
}


===== Magentic\Logging\MagenticOrchestrationLogMessages.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Diagnostics.CodeAnalysis;
using Microsoft.Extensions.Logging;
using Microsoft.SemanticKernel.Agents.Orchestration;
using Microsoft.SemanticKernel.Agents.Runtime;

namespace Microsoft.SemanticKernel.Agents.Magentic;

/// <summary>
/// Extensions for logging <see cref="MagenticOrchestration{TInput, TOutput}"/>.
/// </summary>
/// <remarks>
/// This extension uses the <see cref="LoggerMessageAttribute"/> to
/// generate logging code at compile time to achieve optimized code.
/// </remarks>
[ExcludeFromCodeCoverage]
internal static partial class MagenticOrchestrationLogMessages
{
    /// <summary>
    /// Logs pattern actor registration.
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Information,
        Message = "REGISTER ACTOR {Orchestration} {label}: {AgentType}")]
    public static partial void LogRegisterActor(
        this ILogger logger,
        string orchestration,
        AgentType agentType,
        string label);

    /// <summary>
    /// Logs agent actor registration.
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Information,
        Message = "REGISTER ACTOR {Orchestration} {label} #{Count}: {AgentType}")]
    public static partial void LogRegisterActor(
        this ILogger logger,
        string orchestration,
        AgentType agentType,
        string label,
        int count);

    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Trace,
        Message = "MAGENTIC AGENT invoked [{AgentId}]")]
    public static partial void LogMagenticAgentInvoke(
        this ILogger logger,
        AgentId agentId);

    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Trace,
        Message = "MAGENTIC AGENT result [{AgentId}]: {Message}")]
    public static partial void LogMagenticAgentResult(
        this ILogger logger,
        AgentId agentId,
        string? message);

    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Debug,
        Message = "MAGENTIC MANAGER initialized [{AgentId}]")]
    public static partial void LogMagenticManagerInit(
        this ILogger logger,
        AgentId agentId);

    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Debug,
        Message = "MAGENTIC MANAGER invoked [{AgentId}]")]
    public static partial void LogMagenticManagerInvoke(
        this ILogger logger,
        AgentId agentId);

    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Debug,
        Message = "MAGENTIC MANAGER terminate? [{AgentId}]: {Result} ({Reason})")]
    public static partial void LogMagenticManagerTerminate(
        this ILogger logger,
        AgentId agentId,
        bool result,
        string reason);

    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Debug,
        Message = "MAGENTIC MANAGER select: {NextAgent} [{AgentId}]")]
    public static partial void LogMagenticManagerSelect(
        this ILogger logger,
        AgentId agentId,
        AgentType nextAgent);

    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Debug,
        Message = "MAGENTIC MANAGER result [{AgentId}]: '{Result}' ({Reason})")]
    public static partial void LogMagenticManagerResult(
        this ILogger logger,
        AgentId agentId,
        string result,
        string reason);

    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Debug,
        Message = "MAGENTIC MANAGER user-input? [{AgentId}]: {Result} ({Reason})")]
    public static partial void LogMagenticManagerInput(
        this ILogger logger,
        AgentId agentId,
        bool result,
        string reason);

    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Trace,
        Message = "MAGENTIC AGENT user-input [{AgentId}]: {Message}")]
    public static partial void LogMagenticManagerUserInput(
        this ILogger logger,
        AgentId agentId,
        string? message);

    /// <summary>
    /// Logs <see cref="OrchestrationResult{TValue}"/> timeout while awaiting the orchestration.
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Error,
        Message = "MAGENTIC FAILURE: {Topic}")]
    public static partial void LogMagenticManagerStatusFailure(this ILogger logger, TopicId topic, Exception exception);

    /// <summary>
    /// Logs <see cref="OrchestrationResult{TValue}"/> timeout while awaiting the orchestration.
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Error,
        Message = "MAGENTIC MANAGER FAILURE: {Topic}")]
    public static partial void LogMagenticManagerTaskFailed(this ILogger logger, TopicId topic);

    /// <summary>
    /// Logs <see cref="OrchestrationResult{TValue}"/> timeout while awaiting the orchestration.
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Error,
        Message = "MAGENTIC MANAGER RESET: #{ResetCount} - {Topic}")]
    public static partial void LogMagenticManagerTaskReset(
        this ILogger logger,
        TopicId topic,
        int resetCount);
}


===== Magentic\MagenticAgentActor.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.SemanticKernel.Agents.Orchestration;
using Microsoft.SemanticKernel.Agents.Runtime;
using Microsoft.SemanticKernel.Agents.Runtime.Core;

namespace Microsoft.SemanticKernel.Agents.Magentic;

/// <summary>
/// An <see cref="AgentActor"/> used with the <see cref="MagenticOrchestration{TInput, TOutput}"/>.
/// </summary>
internal sealed class MagenticAgentActor :
    AgentActor,
    IHandle<MagenticMessages.Group>,
    IHandle<MagenticMessages.Reset>,
    IHandle<MagenticMessages.Speak>
{
    private readonly List<ChatMessageContent> _cache;

    /// <summary>
    /// Initializes a new instance of the <see cref="MagenticAgentActor"/> class.
    /// </summary>
    /// <param name="id">The unique identifier of the agent.</param>
    /// <param name="runtime">The runtime associated with the agent.</param>
    /// <param name="context">The orchestration context.</param>
    /// <param name="agent">An <see cref="Agent"/>.</param>
    /// <param name="logger">The logger to use for the actor</param>
    public MagenticAgentActor(AgentId id, IAgentRuntime runtime, OrchestrationContext context, Agent agent, ILogger<MagenticAgentActor>? logger = null)
        : base(id, runtime, context, agent, logger)
    {
        this._cache = [];
    }

    /// <inheritdoc/>
    public ValueTask HandleAsync(MagenticMessages.Group item, MessageContext messageContext)
    {
        this._cache.AddRange(item.Messages);

#if !NETCOREAPP
        return Task.CompletedTask.AsValueTask();
#else
        return ValueTask.CompletedTask;
#endif
    }

    /// <inheritdoc/>
    public async ValueTask HandleAsync(MagenticMessages.Reset item, MessageContext messageContext)
    {
        this._cache.Clear();
        await this.DeleteThreadAsync(messageContext.CancellationToken).ConfigureAwait(false);
    }

    /// <inheritdoc/>
    public async ValueTask HandleAsync(MagenticMessages.Speak item, MessageContext messageContext)
    {
        try
        {
            this.Logger.LogMagenticAgentInvoke(this.Id);

            ChatMessageContent response = await this.InvokeAsync(this._cache, messageContext.CancellationToken).ConfigureAwait(false);

            this.Logger.LogMagenticAgentResult(this.Id, response.Content);

            this._cache.Clear();
            await this.PublishMessageAsync(response.AsGroupMessage(), this.Context.Topic).ConfigureAwait(false);
        }
        catch (Exception exception)
        {
            Debug.WriteLine($"ACTOR EXCEPTION: {exception.Message}\n{exception.StackTrace}");
            throw;
        }
    }
}


===== Magentic\MagenticManager.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.SemanticKernel.Agents.Orchestration;

namespace Microsoft.SemanticKernel.Agents.Magentic;

/// <summary>
/// A manager that manages the flow of a Magentic style chat.
/// </summary>
public abstract class MagenticManager
{
    /// <summary>
    /// The default maximum number of resets allowed.
    /// </summary>
    internal const int DefaultMaximumResetsCount = 3;

    /// <summary>
    /// The default maximum number of stalls allowed.
    /// </summary>
    internal const int DefaultMaximumStallCount = 3;

    /// <summary>
    /// Initializes a new instance of the <see cref="MagenticManager"/> class.
    /// </summary>
    protected MagenticManager() { }

    /// <summary>
    /// Gets or sets the maximum number of invocations allowed for the group chat manager.
    /// </summary>
    public int MaximumInvocationCount { get; init; } = int.MaxValue;

    /// <summary>
    /// Gets or sets the maximum number of resets allowed for the group chat manager.
    /// </summary>
    public int MaximumResetCount { get; init; } = DefaultMaximumResetsCount;

    /// <summary>
    /// Gets or sets the maximum number of stalls allowed for the group chat manager.
    /// </summary>
    public int MaximumStallCount { get; init; } = DefaultMaximumStallCount;

    /// <summary>
    /// Gets or sets the callback to be invoked for interactive input.
    /// </summary>
    public OrchestrationInteractiveCallback? InteractiveCallback { get; init; }

    /// <summary>
    /// Prepares the chat messages for the next step in the group chat process.
    /// </summary>
    /// <param name="context">The context for the manager.</param>
    /// <param name="cancellationToken">A cancellation token.</param>
    /// <returns>An array of chat message content to be processed.</returns>
    public abstract ValueTask<IList<ChatMessageContent>> PlanAsync(MagenticManagerContext context, CancellationToken cancellationToken);

    /// <summary>
    /// Resets the group chat state and prepares the initial chat messages.
    /// </summary>
    /// <param name="context">The context for the manager.</param>
    /// <param name="cancellationToken">A cancellation token.</param>
    /// <returns>An array of chat message content representing the reset state.</returns>
    public abstract ValueTask<IList<ChatMessageContent>> ReplanAsync(MagenticManagerContext context, CancellationToken cancellationToken);

    /// <summary>
    /// Evaluates the progress of the current group chat task.
    /// </summary>
    /// <param name="context">The context for the manager.</param>
    /// <param name="cancellationToken">A cancellation token.</param>
    /// <returns>A <see cref="MagenticProgressLedger"/> representing the progress evaluation.</returns>
    public abstract ValueTask<MagenticProgressLedger> EvaluateTaskProgressAsync(MagenticManagerContext context, CancellationToken cancellationToken = default);

    /// <summary>
    /// Prepares the final answer for the group chat task.
    /// </summary>
    /// <param name="context">The context for the manager.</param>
    /// <param name="cancellationToken">A cancellation token.</param>
    /// <returns>A <see cref="ChatMessageContent"/> representing the final answer.</returns>
    /// <remarks>
    /// The return type is <see cref="ChatMessageContent"/> to allow for rich content responses.
    /// </remarks>
    public abstract ValueTask<ChatMessageContent> PrepareFinalAnswerAsync(MagenticManagerContext context, CancellationToken cancellationToken = default);
}


===== Magentic\MagenticManagerActor.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.SemanticKernel.Agents.Orchestration;
using Microsoft.SemanticKernel.Agents.Runtime;
using Microsoft.SemanticKernel.Agents.Runtime.Core;
using Microsoft.SemanticKernel.ChatCompletion;

namespace Microsoft.SemanticKernel.Agents.Magentic;

/// <summary>
/// An <see cref="OrchestrationActor"/> used to manage a <see cref="MagenticOrchestration{TInput, TOutput}"/>.
/// </summary>
internal sealed class MagenticManagerActor :
    OrchestrationActor,
    IHandle<MagenticMessages.InputTask>,
    IHandle<MagenticMessages.Group>
{
    /// <summary>
    /// A common description for the manager.
    /// </summary>
    public const string DefaultDescription = "Orchestrates a team of agents to accomplish a defined task.";

    private readonly AgentType _orchestrationType;
    private readonly MagenticManager _manager;
    private readonly ChatHistory _chat;
    private readonly MagenticTeam _team;

    private IReadOnlyList<ChatMessageContent> _inputTask = [];
    private int _invocationCount;
    private int _stallCount = 0;
    private int _retryCount = 0;

    /// <summary>
    /// Initializes a new instance of the <see cref="MagenticManagerActor"/> class.
    /// </summary>
    /// <param name="id">The unique identifier of the agent.</param>
    /// <param name="runtime">The runtime associated with the agent.</param>
    /// <param name="context">The orchestration context.</param>
    /// <param name="manager">The manages the flow of the group-chat.</param>
    /// <param name="team">The team of agents being orchestrated</param>
    /// <param name="orchestrationType">Identifies the orchestration agent.</param>
    /// <param name="logger">The logger to use for the actor</param>
    public MagenticManagerActor(AgentId id, IAgentRuntime runtime, OrchestrationContext context, MagenticManager manager, MagenticTeam team, AgentType orchestrationType, ILogger? logger = null)
        : base(id, runtime, context, DefaultDescription, logger)
    {
        this._chat = [];
        this._manager = manager;
        this._orchestrationType = orchestrationType;
        this._team = team;

        Debug.WriteLine($"TEAM:\n{team.FormatList()}");
    }

    /// <inheritdoc/>
    public async ValueTask HandleAsync(MagenticMessages.InputTask item, MessageContext messageContext)
    {
        this.Logger.LogMagenticManagerInit(this.Id);

        this._chat.AddRange(item.Messages);
        this._inputTask = item.Messages.ToList().AsReadOnly();

        await this.PublishMessageAsync(item.Messages.AsGroupMessage(), this.Context.Topic).ConfigureAwait(false);
        await this.PrepareAsync(isReset: false, messageContext.CancellationToken).ConfigureAwait(false);
        await this.ManageAsync(messageContext.CancellationToken).ConfigureAwait(false);
    }

    /// <inheritdoc/>
    public async ValueTask HandleAsync(MagenticMessages.Group item, MessageContext messageContext)
    {
        this.Logger.LogMagenticManagerInvoke(this.Id);

        this._chat.AddRange(item.Messages);

        await this.ManageAsync(messageContext.CancellationToken).ConfigureAwait(false);
    }

    private async ValueTask ManageAsync(CancellationToken cancellationToken)
    {
        bool isStalled = false;
        string? stallMessage = null;

        do
        {
            string agentName = string.Empty;
            string agentInstruction = string.Empty;
            try
            {
                MagenticManagerContext context = this.CreateContext();
                MagenticProgressLedger status = await this._manager.EvaluateTaskProgressAsync(context, cancellationToken).ConfigureAwait(false);

                Debug.WriteLine($"STATUS:\n{status.ToJson()}");

                if (status.IsTaskComplete)
                {
                    ChatMessageContent finalAnswer = await this._manager.PrepareFinalAnswerAsync(context, cancellationToken).ConfigureAwait(false);
                    await this.PublishMessageAsync(finalAnswer.AsResultMessage(), this._orchestrationType, cancellationToken).ConfigureAwait(false);
                    break;
                }

                isStalled = !status.IsTaskProgressing || status.IsTaskInLoop;
                agentName = status.Name;
                agentInstruction = status.Instruction;
            }
            catch (Exception exception) when (!exception.IsCriticalException())
            {
                this.Logger.LogMagenticManagerStatusFailure(this.Context.Topic, exception);
                isStalled = true;
                stallMessage = exception.Message;
            }

            bool hasAgent = this._team.TryGetValue(agentName, out (string Type, string Description) agent);
            if (!hasAgent)
            {
                isStalled = true;
                stallMessage = $"Invalid agent selected: {agentName}";
            }

            if (isStalled)
            {
                ++this._stallCount;

                Debug.WriteLine($"TASK STALLED: #{this._stallCount}/{this._manager.MaximumStallCount} [#{this._retryCount}] -  {stallMessage}");
            }
            else
            {
                this._stallCount = Math.Max(0, this._stallCount - 1);
            }

            bool needsReset = this._stallCount >= this._manager.MaximumStallCount;

            if (!needsReset && hasAgent)
            {
                ++this._invocationCount;

                if (this._invocationCount >= this._manager.MaximumInvocationCount)
                {
                    this.Logger.LogMagenticManagerTaskFailed(this.Context.Topic);
                    try
                    {
                        var partialResult = this._chat.Last((message) => message.Role == AuthorRole.Assistant);
                        await this.PublishMessageAsync(partialResult.AsResultMessage(), this._orchestrationType, cancellationToken).ConfigureAwait(false);
                    }
                    catch (InvalidOperationException)
                    {
                        await this.PublishMessageAsync("I've reaches the maximum number of invocations. No partial result available.".AsResultMessage(), this._orchestrationType, cancellationToken).ConfigureAwait(false);
                    }
                    break;
                }

                ChatMessageContent instruction = new(AuthorRole.Assistant, agentInstruction);
                this._chat.Add(instruction);
                await this.PublishMessageAsync(instruction.AsGroupMessage(), this.Context.Topic, messageId: null, cancellationToken).ConfigureAwait(false);
                await this.PublishMessageAsync(new MagenticMessages.Speak(), agent.Type, cancellationToken).ConfigureAwait(false);
                break;
            }

            if (this._stallCount >= this._manager.MaximumStallCount)
            {
                if (this._retryCount >= this._manager.MaximumResetCount)
                {
                    this.Logger.LogMagenticManagerTaskFailed(this.Context.Topic);
                    try
                    {
                        var partialResult = this._chat.Last((message) => message.Role == AuthorRole.Assistant);
                        await this.PublishMessageAsync(partialResult.AsResultMessage(), this._orchestrationType, cancellationToken).ConfigureAwait(false);
                    }
                    catch (InvalidOperationException)
                    {
                        await this.PublishMessageAsync("I've experienced multiple failures and am unable to continue. No partial result available.".AsResultMessage(), this._orchestrationType, cancellationToken).ConfigureAwait(false);
                    }
                    break;
                }

                this._retryCount++;
                this._stallCount = 0;

                this.Logger.LogMagenticManagerTaskReset(this.Context.Topic, this._retryCount);
                Debug.WriteLine($"TASK RESET [#{this._retryCount}]");

                await this.PublishMessageAsync(new MagenticMessages.Reset(), this.Context.Topic, messageId: null, cancellationToken).ConfigureAwait(false);
                await this.PrepareAsync(isReset: true, cancellationToken).ConfigureAwait(false);
            }
        }
        while (isStalled);
    }

    private async ValueTask PrepareAsync(bool isReset, CancellationToken cancellationToken)
    {
        ChatHistory internalChat = [.. this._chat];
        this._chat.Clear();

        MagenticManagerContext context = this.CreateContext(internalChat);

        IList<ChatMessageContent> plan;
        if (isReset)
        {
            plan = await this._manager.PlanAsync(context, cancellationToken).ConfigureAwait(false);
        }
        else
        {
            plan = await this._manager.ReplanAsync(context, cancellationToken).ConfigureAwait(false);
        }

        this._chat.AddRange(plan);
    }

    private MagenticManagerContext CreateContext(ChatHistory? chat = null) =>
        new(this._team, this._inputTask, (chat ?? this._chat), this._invocationCount, this._stallCount, this._retryCount);
}


===== Magentic\MagenticManagerContext.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;

namespace Microsoft.SemanticKernel.Agents.Magentic;

/// <summary>
/// Represents the context for the MagenticManager, encapsulating the team, task, and chat history.
/// </summary>
public sealed class MagenticManagerContext
{
    /// <summary>
    /// Initializes a new instance of the <see cref="MagenticManagerContext"/> class.
    /// </summary>
    /// <param name="team">The team associated with the context.</param>
    /// <param name="task">The current task or objective for the team.</param>
    /// <param name="history">The chat message history relevant to the current context (not agent conversation history).</param>
    /// <param name="responseCount">The number of responses generated in the current context.</param>
    /// <param name="stallCount">The number of times the context has stalled or not progressed.</param>
    /// <param name="resetCount">The number of times the context has been reset.</param>
    internal MagenticManagerContext(
        MagenticTeam team,
        IEnumerable<ChatMessageContent> task,
        IEnumerable<ChatMessageContent> history,
        int responseCount,
        int stallCount,
        int resetCount)
    {
        this.Team = team;
        this.Task = [.. task];
        this.History = [.. history];
        this.ResponseCount = responseCount;
        this.StallCount = stallCount;
        this.ResetCount = resetCount;
    }

    /// <summary>
    /// Gets the chat message history for the current context.
    /// </summary>
    /// <remarks>
    /// This history refers to the overall context history, not the conversation history of a specific agent.
    /// </remarks>
    public IReadOnlyList<ChatMessageContent> History { get; }

    /// <summary>
    /// The number of responses generated in the current context.
    /// </summary>
    public int ResponseCount { get; }

    /// <summary>
    /// The number of times the context has stalled or not progressed.
    /// </summary>
    public int StallCount { get; }

    /// <summary>
    /// The number of times the context has been reset.
    /// </summary>
    public int ResetCount { get; }

    /// <summary>
    /// Gets the team associated with this context.
    /// </summary>
    public MagenticTeam Team { get; }

    /// <summary>
    /// Gets the current task or objective for the team, as provided as orchestration input.
    /// </summary>
    public IReadOnlyList<ChatMessageContent> Task { get; }
}


===== Magentic\MagenticMessages.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using Microsoft.SemanticKernel.ChatCompletion;

namespace Microsoft.SemanticKernel.Agents.Magentic;

/// <summary>
/// Common messages used for agent chat patterns.
/// </summary>
public static class MagenticMessages
{
    /// <summary>
    /// An empty message instance as a default.
    /// </summary>
    internal static readonly ChatMessageContent Empty = new();

    /// <summary>
    /// Broadcast a message to all <see cref="MagenticAgentActor"/>.
    /// </summary>
    public sealed class Group
    {
        /// <summary>
        /// The chat message being broadcast.
        /// </summary>
        public IEnumerable<ChatMessageContent> Messages { get; init; } = [];
    }

    /// <summary>
    /// Reset/clear the conversation history for all <see cref="MagenticAgentActor"/>.
    /// </summary>
    public sealed class Reset;

    /// <summary>
    /// The final result.
    /// </summary>
    public sealed class Result
    {
        /// <summary>
        /// The chat response message.
        /// </summary>
        public ChatMessageContent Message { get; init; } = Empty;
    }

    /// <summary>
    /// Signal a <see cref="MagenticAgentActor"/> to respond.
    /// </summary>
    public sealed class Speak;

    /// <summary>
    /// The input task.
    /// </summary>
    public sealed class InputTask
    {
        /// <summary>
        /// The input that defines the task goal.
        /// </summary>
        public IEnumerable<ChatMessageContent> Messages { get; init; } = [];
    }

    /// <summary>
    /// Extension method to convert a <see cref="ChatMessageContent"/> to a <see cref="Group"/> message.
    /// </summary>
    public static Group AsGroupMessage(this ChatMessageContent message) => new() { Messages = [message] };

    /// <summary>
    /// Extension method to convert a <see cref="ChatMessageContent"/> to a <see cref="Group"/> message.
    /// </summary>
    public static Group AsGroupMessage(this IEnumerable<ChatMessageContent> messages) => new() { Messages = messages };

    /// <summary>
    /// Extension method to convert a <see cref="ChatMessageContent"/> to a <see cref="Result"/> message.
    /// </summary>
    public static InputTask AsInputTaskMessage(this IEnumerable<ChatMessageContent> messages) => new() { Messages = messages };

    /// <summary>
    /// Extension method to convert a <see cref="ChatMessageContent"/> to a <see cref="Result"/> message.
    /// </summary>
    public static Result AsResultMessage(this ChatMessageContent message) => new() { Message = message };

    /// <summary>
    /// Extension method to convert a <see cref="string"/> to a <see cref="Result"/>.
    /// </summary>
    public static Result AsResultMessage(this string text) => new() { Message = new(AuthorRole.Assistant, text) };
}


===== Magentic\MagenticOrchestration.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.SemanticKernel.Agents.Orchestration;
using Microsoft.SemanticKernel.Agents.Orchestration.Extensions;
using Microsoft.SemanticKernel.Agents.Runtime;

namespace Microsoft.SemanticKernel.Agents.Magentic;

/// <summary>
/// An orchestration that coordinates a group-chat.
/// </summary>
public class MagenticOrchestration<TInput, TOutput> :
    AgentOrchestration<TInput, TOutput>
{
    internal const string DefaultAgentDescription = "A helpful agent.";

    private readonly MagenticManager _manager;

    /// <summary>
    /// Initializes a new instance of the <see cref="MagenticOrchestration{TInput, TOutput}"/> class.
    /// </summary>
    /// <param name="manager">The manages the flow of the group-chat.</param>
    /// <param name="agents">The agents participating in the orchestration.</param>
    public MagenticOrchestration(MagenticManager manager, params Agent[] agents)
        : base(agents)
    {
        Verify.NotNull(manager, nameof(manager));

        this._manager = manager;
    }

    /// <inheritdoc />
    protected override ValueTask StartAsync(IAgentRuntime runtime, TopicId topic, IEnumerable<ChatMessageContent> input, AgentType? entryAgent)
    {
        if (!entryAgent.HasValue)
        {
            throw new ArgumentException("Entry agent is not defined.", nameof(entryAgent));
        }
        return runtime.PublishMessageAsync(input.AsInputTaskMessage(), entryAgent.Value);
    }

    /// <inheritdoc />
    protected override async ValueTask<AgentType?> RegisterOrchestrationAsync(IAgentRuntime runtime, OrchestrationContext context, RegistrationContext registrar, ILogger logger)
    {
        AgentType outputType = await registrar.RegisterResultTypeAsync<MagenticMessages.Result>(response => [response.Message]).ConfigureAwait(false);

        int agentCount = 0;
        MagenticTeam team = [];
        foreach (Agent agent in this.Members)
        {
            ++agentCount;
            AgentType agentType = await RegisterAgentAsync(agent, agentCount).ConfigureAwait(false);
            string name = agent.Name ?? agent.Id ?? agentType;
            string? description = agent.Description;

            team[name] = (agentType, description ?? DefaultAgentDescription);

            logger.LogRegisterActor(this.OrchestrationLabel, agentType, "MEMBER", agentCount);

            await runtime.SubscribeAsync(agentType, context.Topic).ConfigureAwait(false);
        }

        AgentType managerType =
            await runtime.RegisterOrchestrationAgentAsync(
                this.FormatAgentType(context.Topic, "Manager"),
                (agentId, runtime) =>
                {
                    MagenticManagerActor actor = new(agentId, runtime, context, this._manager, team, outputType, context.LoggerFactory.CreateLogger<MagenticManagerActor>());
#if !NETCOREAPP
                    return actor.AsValueTask<IHostableAgent>();
#else
                    return ValueTask.FromResult<IHostableAgent>(actor);
#endif
                }).ConfigureAwait(false);
        logger.LogRegisterActor(this.OrchestrationLabel, managerType, "MANAGER");

        await runtime.SubscribeAsync(managerType, context.Topic).ConfigureAwait(false);

        return managerType;

        ValueTask<AgentType> RegisterAgentAsync(Agent agent, int agentCount) =>
            runtime.RegisterOrchestrationAgentAsync(
                this.FormatAgentType(context.Topic, $"Agent_{agentCount}"),
                (agentId, runtime) =>
                {
                    MagenticAgentActor actor = new(agentId, runtime, context, agent, context.LoggerFactory.CreateLogger<MagenticAgentActor>());
#if !NETCOREAPP
                    return actor.AsValueTask<IHostableAgent>();
#else
                    return ValueTask.FromResult<IHostableAgent>(actor);
#endif
                });
    }
}


===== Magentic\MagenticOrchestration.String.cs =====

// Copyright (c) Microsoft. All rights reserved.

namespace Microsoft.SemanticKernel.Agents.Magentic;

/// <summary>
/// An orchestration that broadcasts the input message to each agent.
/// </summary>
public sealed class MagenticOrchestration : MagenticOrchestration<string, string>
{
    /// <summary>
    /// Initializes a new instance of the <see cref="MagenticOrchestration"/> class.
    /// </summary>
    /// <param name="manager">The manages the flow of the group-chat.</param>
    /// <param name="members">The agents to be orchestrated.</param>
    public MagenticOrchestration(MagenticManager manager, params Agent[] members)
        : base(manager, members)
    {
    }
}


===== Magentic\MagenticProgressLedger.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.ComponentModel;
using System.Text.Json;

namespace Microsoft.SemanticKernel.Agents.Magentic;

/// <summary>
/// Structured response for the ledger evaluation.
/// </summary>
public sealed record MagenticProgressLedger(
    [property:Description("The name of who is selected to respond.")]
    string Name,
    [property:Description("Direction to who is responding that is specifically based on its capabilities and ALWAYS phrased in the 2nd person.")]
    string Instruction,
    [property:Description("The reason for selecting the agent.")]
    string Reason,
    [property:Description("Is the task completed?")]
    LedgerState IsTaskComplete,
    [property:Description("Is the task making progress, but not complete?")]
    LedgerState IsTaskProgressing,
    [property:Description("Is the task stuck in a loop?")]
    LedgerState IsTaskInLoop)
{
    private readonly static JsonSerializerOptions JsonOptions =
        new()
        {
            WriteIndented = true
        };

    /// <summary>
    /// Formats the ledger evaluation as a JSON string.
    /// </summary>
    public string ToJson() => JsonSerializer.Serialize(this, JsonOptions);
}

/// <summary>
/// Represents the evaluation state of a specific property in the progress ledger,
/// including the result and the reason for that result.
/// </summary>
public sealed record LedgerState(
    [property:Description("The result for the property being evaluated")]
    bool Result,
    [property:Description("The reason for the result")]
    string Reason)
{
    /// <summary>
    /// Implicitly converts a <see cref="LedgerState"/> to a <see cref="bool"/> by returning the <see cref="Result"/> property.
    /// </summary>
    /// <param name="state">The <see cref="LedgerState"/> instance to convert.</param>
    /// <returns>The <see cref="Result"/> value of the <see cref="LedgerState"/>.</returns>
    public static implicit operator bool(LedgerState state) => state.Result;
}


===== Magentic\MagenticPrompts.cs =====

// Copyright (c) Microsoft. All rights reserved.

namespace Microsoft.SemanticKernel.Agents.Magentic;

internal sealed class MagenticPrompts
{
    private static readonly KernelPromptTemplateFactory TemplateFactory = new() { AllowDangerouslySetContent = true };

    public static readonly IPromptTemplate NewFactsTemplate = InitializePrompt(Templates.AnalyzeFacts);
    public static readonly IPromptTemplate RefreshFactsTemplate = InitializePrompt(Templates.AnalyzeFacts);
    public static readonly IPromptTemplate NewPlanTemplate = InitializePrompt(Templates.AnalyzePlan);
    public static readonly IPromptTemplate RefreshPlanTemplate = InitializePrompt(Templates.AnalyzePlan);
    public static readonly IPromptTemplate LedgerTemplate = InitializePrompt(Templates.GenerateLedger);
    public static readonly IPromptTemplate StatusTemplate = InitializePrompt(Templates.AnalyzeStatus);
    public static readonly IPromptTemplate AnswerTemplate = InitializePrompt(Templates.FinalAnswer);

    private static IPromptTemplate InitializePrompt(string template)
    {
        PromptTemplateConfig templateConfig = new() { Template = template };
        return TemplateFactory.Create(templateConfig);
    }

    public static class Parameters
    {
        public const string Task = "task";
        public const string Team = "team";
        public const string Names = "names";
        public const string Facts = "facts";
        public const string Plan = "plan";
        public const string Ledger = "ledger";
    }

    private static class Templates
    {
        public const string AnalyzeFacts =
            $$$"""
                Respond to the pre-survey in response the following user request:
                
                {{${{{Parameters.Task}}}}}

                Here is the pre-survey:

                    1. Please list any specific facts or figures that are GIVEN in the request itself. It is possible that
                       there are none.
                    2. Please list any facts that may need to be looked up, and WHERE SPECIFICALLY they might be found.
                       In some cases, authoritative sources are mentioned in the request itself.
                    3. Please list any facts that may need to be derived (e.g., via logical deduction, simulation, or computation)
                    4. Please list any facts that are recalled from memory, hunches, well-reasoned guesses, etc.

                When answering this survey, keep in mind that "facts" will typically be specific names, dates, statistics, etc.

                Your answer MUST use these headings:

                    1. GIVEN OR VERIFIED FACTS
                    2. FACTS TO LOOK UP
                    3. FACTS TO DERIVE
                    4. EDUCATED GUESSES

                DO NOT include any other headings or sections in your response. DO NOT list next steps or plans.
                """;

        public const string UpdateFacts =
            $$$"""
                As a reminder, we are working to solve the following request:

                {{${{{Parameters.Task}}}}}
                
                It's clear we aren't making as much progress as we would like, but we may have learned something new.
                Please rewrite the following fact sheet, updating it to include anything new we have learned that may be helpful.

                Example edits can include (but are not limited to) adding new guesses, moving educated guesses to verified facts
                if appropriate, etc. Updates may be made to any section of the fact sheet, and more than one section of the fact
                sheet can be edited. This is an especially good time to update educated guesses, so please at least add or update
                one educated guess or hunch, and explain your reasoning.

                Here is the old fact sheet:

                {{${{{Parameters.Facts}}}}}                
                """;

        public const string AnalyzePlan =
            $$$"""
                To address this request we have assembled the following team:

                {{${{{Parameters.Team}}}}}

                Define the most effective plan that addresses the user request.

                Ensure that the plan:

                - Is formatted as plan as a markdown list of sequential steps with each top-level bullet-point as: "{Agent Name}: {Actions, goals, or sub-list}".
                - Resolves any ambiguity or clarification of the user request
                - Only includes the team members that are required to respond to the request.
                - Excludes extra steps that are not necessary and slow down the process.
                - Does not seek final confirmation from the user.
                """;

        public const string UpdatePlan =
            $$$"""
                Please briefly explain what went wrong on this last run (the root
                cause of the failure), and then come up with a new plan that takes steps and/or includes hints to overcome prior
                challenges and especially avoids repeating the same mistakes. As before, the new plan should be concise, be expressed
                in bullet-point form, and consider the following team composition (do not involve any other outside people since we
                cannot contact anyone else):

                {{${{{Parameters.Team}}}}}                
                """;

        public const string GenerateLedger =
            $$$"""
                We are working to address the following user request:

                {{${{{Parameters.Task}}}}}


                To answer this request we have assembled the following team:

                {{${{{Parameters.Team}}}}}


                Here is an initial fact sheet to consider:

                {{${{{Parameters.Facts}}}}}


                Here is the plan to follow as best as possible:

                {{${{{Parameters.Plan}}}}}
                """;

        public const string AnalyzeStatus =
            $$$"""
                Recall we are working on the following request:

                {{${{{Parameters.Task}}}}}
                
                And we have assembled the following team:

                {{${{{Parameters.Team}}}}}
                
                To make progress on the request, please answer the following questions, including necessary reasoning:

                    - Is the request fully satisfied?  (True if complete, or False if the original request has yet to be SUCCESSFULLY and FULLY addressed)
                    - Are we in a loop where we are repeating the same requests and / or getting the same responses as before?
                      Loops can span multiple responses.
                    - Are we making forward progress? (True if just starting, or recent messages are adding value.
                      False if recent messages show evidence of being stuck in a loop or if there is evidence of the inability to proceed)
                    - Which team member is needed to respond next? (Select only from: {{${{{Parameters.Names}}}}}).
                      Always consider then initial plan but you may deviate from this plan as appropriate based on the conversation.
                    - Do not seek final confirmation from the user if the request is fully satisfied.
                    - What direction would you give this team member? (Always phrase in the 2nd person, speaking directly to them, and
                      include any specific information they may need)                    
                """;

        public const string FinalAnswer =
            $$$"""
                Synthesize a complete response to the user request using markdown format:
                {{${{{Parameters.Task}}}}}

                The complete response MUST:
                - Consider the entire conversation without incorporating information that changed or was corrected
                - NEVER include any new information not already present in the conversation
                - Capture verbatim content instead of summarizing
                - Directly address the request without narrating how the conversation progressed
                - Incorporate images specified in conversation responses
                - Include all citations or references
                - Be phrased to directly address the user
                """;
    }
}


===== Magentic\MagenticTeam.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Linq;

namespace Microsoft.SemanticKernel.Agents.Magentic;

/// <summary>
/// Describes a team of agents participating in a group chat.
/// </summary>
public class MagenticTeam : Dictionary<string, (string Type, string Description)>;

/// <summary>
/// Extensions for <see cref="MagenticTeam"/>.
/// </summary>
public static class MagenticTeamExtensions
{
    /// <summary>
    /// Format the names of the agents in the team as a comma delimimted list.
    /// </summary>
    /// <param name="team">The agent team</param>
    /// <returns>A comma delimimted list of agent name.</returns>
    public static string FormatNames(this MagenticTeam team) => string.Join(",", team.Select(t => t.Key));

    /// <summary>
    /// Format the names and descriptions of the agents in the team as a markdown list.
    /// </summary>
    /// <param name="team">The agent team</param>
    /// <returns>A markdown list of agent names and descriptions.</returns>
    public static string FormatList(this MagenticTeam team) => string.Join("\n", team.Select(t => $"- {t.Key}: {t.Value.Description}"));
}


===== Magentic\Properties\AssemblyInfo.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Diagnostics.CodeAnalysis;

// This assembly is currently experimental.
[assembly: Experimental("SKEXP0110")]


===== Magentic\StandardMagenticManager.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.SemanticKernel.Agents.Magentic.Internal;
using Microsoft.SemanticKernel.ChatCompletion;

namespace Microsoft.SemanticKernel.Agents.Magentic;

/// <summary>
/// A <see cref="MagenticManager"/> that provides orchestration logic for managing magentic agents,
/// including preparing facts, plans, ledgers, evaluating progress, and generating a final answer.
/// </summary>
public sealed class StandardMagenticManager : MagenticManager
{
    private static readonly Kernel EmptyKernel = new();

    private readonly IChatCompletionService _service;
    private readonly PromptExecutionSettings _executionSettings;

    private string _facts = string.Empty;
    private string _plan = string.Empty;

    /// <summary>
    /// Initializes a new instance of the <see cref="StandardMagenticManager"/> class.
    /// </summary>
    /// <param name="service">The chat completion service to use for generating responses.</param>
    /// <param name="executionSettings">The prompt execution settings to use for the chat completion service.</param>
    public StandardMagenticManager(IChatCompletionService service, PromptExecutionSettings executionSettings)
    {
        Verify.NotNull(service, nameof(service));
        Verify.NotNull(executionSettings, nameof(executionSettings));

        if (!executionSettings.SupportsResponseFormat())
        {
            throw new KernelException($"Unable to proceed with {nameof(PromptExecutionSettings)} that does not support structured JSON output.");
        }

        if (executionSettings.IsFrozen)
        {
            throw new KernelException($"Unable to proceed with frozen {nameof(PromptExecutionSettings)}.");
        }

        this._service = service;
        this._executionSettings = executionSettings;
        this._executionSettings.SetResponseFormat<MagenticProgressLedger>();
    }

    /// <inheritdoc/>
    public override async ValueTask<IList<ChatMessageContent>> PlanAsync(MagenticManagerContext context, CancellationToken cancellationToken)
    {
        this._facts = await this.PrepareTaskFactsAsync(context, MagenticPrompts.NewFactsTemplate, cancellationToken).ConfigureAwait(false);
        this._plan = await this.PrepareTaskPlanAsync(context, MagenticPrompts.NewPlanTemplate, cancellationToken).ConfigureAwait(false);

        Debug.WriteLine($"\n<FACTS>:\n{this._facts}\n</FACTS>\n\n<PLAN>:\n{this._plan}\n</PLAN>\n");

        return await this.PrepareTaskLedgerAsync(context, cancellationToken).ConfigureAwait(false);
    }

    /// <inheritdoc/>
    public override async ValueTask<IList<ChatMessageContent>> ReplanAsync(MagenticManagerContext context, CancellationToken cancellationToken)
    {
        this._facts = await this.PrepareTaskFactsAsync(context, MagenticPrompts.RefreshFactsTemplate, cancellationToken).ConfigureAwait(false);
        this._plan = await this.PrepareTaskPlanAsync(context, MagenticPrompts.RefreshPlanTemplate, cancellationToken).ConfigureAwait(false);

        Debug.WriteLine($"\n<FACTS>:\n{this._facts}\n</FACTS>\n\n<PLAN>:\n{this._plan}\n</PLAN>\n");

        return await this.PrepareTaskLedgerAsync(context, cancellationToken).ConfigureAwait(false);
    }

    /// <inheritdoc/>
    public override async ValueTask<MagenticProgressLedger> EvaluateTaskProgressAsync(MagenticManagerContext context, CancellationToken cancellationToken = default)
    {
        ChatHistory internalChat = [.. context.History];
        KernelArguments arguments =
            new()
            {
                { MagenticPrompts.Parameters.Task, this.FormatInputTask(context.Task) },
                { MagenticPrompts.Parameters.Team, context.Team.FormatNames() },
            };
        string response = await this.GetResponseAsync(internalChat, MagenticPrompts.StatusTemplate, arguments, this._executionSettings, cancellationToken).ConfigureAwait(false);
        MagenticProgressLedger status =
            JsonSerializer.Deserialize<MagenticProgressLedger>(response) ??
            throw new InvalidDataException($"Message content does not align with requested type: {nameof(MagenticProgressLedger)}.");

        return status;
    }

    /// <inheritdoc/>
    public override async ValueTask<ChatMessageContent> PrepareFinalAnswerAsync(MagenticManagerContext context, CancellationToken cancellationToken = default)
    {
        KernelArguments arguments =
            new()
            {
                { MagenticPrompts.Parameters.Task, context.Task },
            };
        string response = await this.GetResponseAsync(context.History, MagenticPrompts.AnswerTemplate, arguments, executionSettings: null, cancellationToken).ConfigureAwait(false);

        return new ChatMessageContent(AuthorRole.Assistant, response);
    }

    private async ValueTask<string> PrepareTaskFactsAsync(MagenticManagerContext context, IPromptTemplate promptTemplate, CancellationToken cancellationToken = default)
    {
        KernelArguments arguments =
            new()
            {
                { MagenticPrompts.Parameters.Task, this.FormatInputTask(context.Task) },
                { MagenticPrompts.Parameters.Facts, this._facts },
            };
        return
            await this.GetResponseAsync(
                context.History,
                promptTemplate,
                arguments,
                executionSettings: null,
                cancellationToken).ConfigureAwait(false);
    }

    private async ValueTask<string> PrepareTaskPlanAsync(MagenticManagerContext context, IPromptTemplate promptTemplate, CancellationToken cancellationToken = default)
    {
        KernelArguments arguments =
            new()
            {
                { MagenticPrompts.Parameters.Team, context.Team.FormatList() },
            };

        return
            await this.GetResponseAsync(
                context.History,
                promptTemplate,
                arguments,
                executionSettings: null,
                cancellationToken).ConfigureAwait(false);
    }

    private async ValueTask<IList<ChatMessageContent>> PrepareTaskLedgerAsync(MagenticManagerContext context, CancellationToken cancellationToken = default)
    {
        KernelArguments arguments =
            new()
            {
                { MagenticPrompts.Parameters.Task, this.FormatInputTask(context.Task) },
                { MagenticPrompts.Parameters.Team, context.Team.FormatList() },
                { MagenticPrompts.Parameters.Facts, this._facts },
                { MagenticPrompts.Parameters.Plan, this._plan },
            };
        string ledger = await this.GetMessageAsync(MagenticPrompts.LedgerTemplate, arguments).ConfigureAwait(false);

        return [new ChatMessageContent(AuthorRole.System, ledger)];
    }

    private async ValueTask<string> GetMessageAsync(IPromptTemplate template, KernelArguments arguments)
    {
        return await template.RenderAsync(EmptyKernel, arguments).ConfigureAwait(false);
    }

    private async Task<string> GetResponseAsync(
        IReadOnlyList<ChatMessageContent> internalChat,
        IPromptTemplate template,
        KernelArguments arguments,
        PromptExecutionSettings? executionSettings,
        CancellationToken cancellationToken = default)
    {
        ChatHistory history = [.. internalChat];
        string message = await this.GetMessageAsync(template, arguments).ConfigureAwait(false);
        history.Add(new ChatMessageContent(AuthorRole.User, message));
        ChatMessageContent response = await this._service.GetChatMessageContentAsync(history, executionSettings, kernel: null, cancellationToken).ConfigureAwait(false);
        return response.Content ?? string.Empty;
    }

    private string FormatInputTask(IReadOnlyList<ChatMessageContent> inputTask) => string.Join("\n", inputTask.Select(m => $"{m.Content}"));
}


===== OpenAI\Definition\OpenAIAssistantAgentFactory.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Diagnostics.CodeAnalysis;
using System.Threading;
using System.Threading.Tasks;
using OpenAI.Assistants;

namespace Microsoft.SemanticKernel.Agents.OpenAI;

/// <summary>
/// Provides a <see cref="AgentFactory"/> which creates instances of <see cref="OpenAIAssistantAgent"/>.
/// </summary>
[ExcludeFromCodeCoverage]
[Experimental("SKEXP0110")]
public sealed class OpenAIAssistantAgentFactory : AgentFactory
{
    /// <summary>
    /// The type of the OpenAI assistant agent.
    /// </summary>
    public const string OpenAIAssistantAgentType = "openai_assistant";

    /// <summary>
    /// Initializes a new instance of the <see cref="OpenAIAssistantAgentFactory"/> class.
    /// </summary>
    public OpenAIAssistantAgentFactory()
        : base([OpenAIAssistantAgentType])
    {
    }

    /// <inheritdoc/>
    public override async Task<Agent?> TryCreateAsync(Kernel kernel, AgentDefinition agentDefinition, AgentCreationOptions? agentCreationOptions = null, CancellationToken cancellationToken = default)
    {
        Verify.NotNull(agentDefinition);

        if (this.IsSupported(agentDefinition))
        {
            var client = agentDefinition.GetOpenAIClient(kernel);
            AssistantClient assistantClient = client.GetAssistantClient();

            Assistant model;
            if (!string.IsNullOrEmpty(agentDefinition.Id))
            {
                // Get an existing assistant
                model = await assistantClient.GetAssistantAsync(agentDefinition.Id, cancellationToken).ConfigureAwait(false);

                return new OpenAIAssistantAgent(model, assistantClient)
                {
                    Kernel = kernel,
                    Arguments = agentDefinition.GetDefaultKernelArguments(kernel) ?? [],
                    Template = agentDefinition.GetPromptTemplate(kernel, agentCreationOptions?.PromptTemplateFactory),
                    Instructions = agentDefinition.Instructions ?? model.Instructions,
                };
            }

            // Create a new assistant
            Verify.NotNull(agentDefinition.Model);
            Verify.NotNull(agentDefinition.Model.Id);

            var assistantCreationOptions = agentDefinition.CreateAssistantCreationOptions();
            model = await assistantClient.CreateAssistantAsync(agentDefinition.Model.Id, assistantCreationOptions, cancellationToken).ConfigureAwait(false);

            return new OpenAIAssistantAgent(model, assistantClient)
            {
                Kernel = kernel,
                Arguments = agentDefinition.GetDefaultKernelArguments(kernel) ?? [],
                Template = agentDefinition.GetPromptTemplate(kernel, agentCreationOptions?.PromptTemplateFactory),
            };
        }

        return null;
    }
}


===== OpenAI\Extensions\AgentDefinitionExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using Azure.Core;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.SemanticKernel.Http;
using OpenAI;
using OpenAI.Assistants;

namespace Microsoft.SemanticKernel.Agents.OpenAI;

/// <summary>
/// Provides extension methods for <see cref="AgentDefinition"/>.
/// </summary>
[ExcludeFromCodeCoverage]
internal static class AgentDefinitionExtensions
{
    private const string CodeInterpreterType = "code_interpreter";
    private const string FileSearchType = "file_search";

    private const string FileIds = "file_ids";
    private const string ApiKey = "api_key";
    private const string OpenAI = "openai";
    private const string AzureOpenAI = "azure_openai";

    /// <summary>
    /// Create the <see cref="AssistantCreationOptions"/> which corresponds with the provided <see cref="AgentDefinition"/>.
    /// </summary>
    /// <param name="agentDefinition">Agent definition</param>
    public static AssistantCreationOptions CreateAssistantCreationOptions(this AgentDefinition agentDefinition)
    {
        Verify.NotNull(agentDefinition);
        Verify.NotNull(agentDefinition.Model, nameof(agentDefinition.Model));
        Verify.NotNull(agentDefinition.Model.Id, nameof(agentDefinition.Model.Id));

        var assistantCreationOptions = new AssistantCreationOptions()
        {
            Name = agentDefinition.Name,
            Description = agentDefinition.Description,
            Instructions = agentDefinition.Instructions,
            Temperature = agentDefinition.GetTemperature(),
            NucleusSamplingFactor = agentDefinition.GetTopP(),
        };

        // TODO: Implement
        // ResponseFormat
        // ToolResources
        // Metadata
        // ExecutionOptions

        // Add tools
        if (agentDefinition.Tools is not null)
        {
            foreach (var tool in agentDefinition.Tools)
            {
                switch (tool.Type)
                {
                    case CodeInterpreterType:
                        assistantCreationOptions.Tools.Add(ToolDefinition.CreateCodeInterpreter());
                        break;
                    case FileSearchType:
                        assistantCreationOptions.Tools.Add(ToolDefinition.CreateFileSearch());
                        break;
                    default:
                        throw new System.NotSupportedException($"Tool type '{tool.Type}' is not supported.");
                }
            }
        }

        return assistantCreationOptions;
    }

    /// <summary>
    /// Retrieve the code interpreter file IDs from the agent definition.
    /// </summary>
    /// <param name="agentDefinition">Agent definition</param>
    public static IReadOnlyList<string>? GetCodeInterpreterFileIds(this AgentDefinition agentDefinition)
    {
        Verify.NotNull(agentDefinition);

        var toolDefinition = agentDefinition.GetFirstToolDefinition(CodeInterpreterType);
        if ((toolDefinition?.Options?.TryGetValue(FileIds, out var value) ?? false) && value is List<string> fileIds)
        {
            // TODO: Verify that the fileIds are strings
            return (IReadOnlyList<string>)fileIds;
        }

        return null;
    }

    /// <summary>
    /// Retrieve the vector store ID from the agent definition.
    /// </summary>
    /// <param name="agentDefinition">Agent definition</param>
    public static string? GetVectorStoreId(this AgentDefinition agentDefinition)
    {
        Verify.NotNull(agentDefinition);

        // TODO: Implement
        return null;
    }

    /// <summary>
    /// Retrieve the metadata from the agent definition.
    /// </summary>
    /// <param name="agentDefinition">Agent definition</param>
    public static IReadOnlyDictionary<string, string>? GetMetadata(this AgentDefinition agentDefinition)
    {
        Verify.NotNull(agentDefinition);

        // TODO: Implement
        return null;
    }

    /// <summary>
    /// Return the <see cref="OpenAIClient"/> to be used with the specified <see cref="AgentDefinition"/>.
    /// </summary>
    /// <param name="agentDefinition">Agent definition which will be used to provide connection for the <see cref="OpenAIClient"/>.</param>
    /// <param name="kernel">Kernel instance which will be used to resolve a default <see cref="OpenAIClient"/>.</param>
    public static OpenAIClient GetOpenAIClient(this AgentDefinition agentDefinition, Kernel kernel)
    {
        Verify.NotNull(agentDefinition);

        // Use the agent connection as the first option
        var connection = agentDefinition?.Model?.Connection;
        if (connection is not null)
        {
            if (connection.Type is null)
            {
                throw new InvalidOperationException("Model connection type must be specified.");
            }

#pragma warning disable CA2000 // Dispose objects before losing scope, not applicable because the HttpClient is created and may be used elsewhere
            var httpClient = HttpClientProvider.GetHttpClient(kernel.Services);
#pragma warning restore CA2000 // Dispose objects before losing scope

            if (connection.Type.Equals(OpenAI, StringComparison.OrdinalIgnoreCase))
            {
                return OpenAIAssistantAgent.CreateOpenAIClient(connection.GetApiKeyCredential(), connection.TryGetEndpoint(), httpClient);
            }
            else if (connection.Type.Equals(AzureOpenAI, StringComparison.OrdinalIgnoreCase))
            {
                var endpoint = connection.TryGetEndpoint();
                Verify.NotNull(endpoint, "Endpoint must be specified when using Azure OpenAI.");

                if (connection.ExtensionData.TryGetValue(ApiKey, out var apiKey) && apiKey is not null)
                {
                    return OpenAIAssistantAgent.CreateAzureOpenAIClient(connection.GetApiKeyCredential(), endpoint, httpClient);
                }

                var tokenCredential = kernel.Services.GetRequiredService<TokenCredential>();
                return OpenAIAssistantAgent.CreateAzureOpenAIClient(tokenCredential, endpoint, httpClient);
            }

            throw new InvalidOperationException($"Invalid OpenAI client type '{connection.Type}' was specified.");
        }

        // Use the client registered on the kernel
        var client = kernel.GetAllServices<OpenAIClient>().FirstOrDefault();
        return (OpenAIClient?)client ?? throw new InvalidOperationException("OpenAI client not found.");
    }

    #region private
    private const string Temperature = "temperature";
    private const string TopP = "top_p";

    private static float? GetTemperature(this AgentDefinition agentDefinition)
    {
        Verify.NotNull(agentDefinition);

        if (agentDefinition?.Model?.Options?.TryGetValue(Temperature, out var temperature) ?? false)
        {
            return (float?)temperature;
        }
        return null;
    }

    private static float? GetTopP(this AgentDefinition agentDefinition)
    {
        Verify.NotNull(agentDefinition);

        if (agentDefinition?.Model?.Options?.TryGetValue(TopP, out var topP) ?? false)
        {
            return (float?)topP;
        }
        return null;
    }
    #endregion
}


===== OpenAI\Extensions\AssistantClientExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.SemanticKernel.Agents.OpenAI.Internal;
using OpenAI.Assistants;

namespace Microsoft.SemanticKernel.Agents.OpenAI;

/// <summary>
/// Convenience extensions for <see cref="AssistantClient"/>.
/// </summary>
public static class AssistantClientExtensions
{
    /// <summary>
    /// Creates an assistant asynchronously with the specified options.
    /// </summary>
    /// <param name="client">The assistant client.</param>
    /// <param name="modelId">The model identifier.</param>
    /// <param name="name">The name of the assistant.</param>
    /// <param name="description">The description of the assistant.</param>
    /// <param name="instructions">The instructions for the assistant.</param>
    /// <param name="enableCodeInterpreter">Whether to enable the code interpreter tool.</param>
    /// <param name="codeInterpreterFileIds">The file IDs for the code interpreter tool.</param>
    /// <param name="enableFileSearch">Whether to enable the file search tool.</param>
    /// <param name="vectorStoreId">The vector store identifier.</param>
    /// <param name="temperature">The temperature setting for the assistant.</param>
    /// <param name="topP">The nucleus sampling factor for the assistant.</param>
    /// <param name="responseFormat">The response format for the assistant.</param>
    /// <param name="metadata">The metadata for the assistant.</param>
    /// <param name="cancellationToken">The cancellation token.</param>
    /// <returns>A task that represents the asynchronous operation. The task result contains the created assistant.</returns>
    public static async Task<Assistant> CreateAssistantAsync(
        this AssistantClient client,
        string modelId,
        string? name = null,
        string? description = null,
        string? instructions = null,
        bool enableCodeInterpreter = false,
        IReadOnlyList<string>? codeInterpreterFileIds = null,
        bool enableFileSearch = false,
        string? vectorStoreId = null,
        float? temperature = null,
        float? topP = null,
        AssistantResponseFormat? responseFormat = null,
        IReadOnlyDictionary<string, string>? metadata = null,
        CancellationToken cancellationToken = default)
    {
        AssistantCreationOptions options =
            new()
            {
                Name = name,
                Description = description,
                Instructions = instructions,
                Temperature = temperature,
                NucleusSamplingFactor = topP,
                ResponseFormat = responseFormat,
            };

        if (metadata != null)
        {
            foreach (KeyValuePair<string, string> item in metadata)
            {
                options.Metadata[item.Key] = item.Value;
            }
        }

        if (enableCodeInterpreter || (codeInterpreterFileIds?.Count ?? 0) > 0)
        {
            options.Tools.Add(ToolDefinition.CreateCodeInterpreter());
        }

        if (enableFileSearch || !string.IsNullOrEmpty(vectorStoreId))
        {
            options.Tools.Add(ToolDefinition.CreateFileSearch());
        }

        options.ToolResources = AssistantToolResourcesFactory.GenerateToolResources(vectorStoreId, codeInterpreterFileIds);

        Assistant assistant = await client.CreateAssistantAsync(modelId, options, cancellationToken).ConfigureAwait(false);

        return assistant;
    }

    /// <summary>
    /// Creates an assistant from a template asynchronously with the specified options.
    /// </summary>
    /// <param name="client">The assistant client.</param>
    /// <param name="modelId">The model identifier.</param>
    /// <param name="config">The prompt template configuration.</param>
    /// <param name="enableCodeInterpreter">Whether to enable the code interpreter tool.</param>
    /// <param name="codeInterpreterFileIds">The file IDs for the code interpreter tool.</param>
    /// <param name="enableFileSearch">Whether to enable the file search tool.</param>
    /// <param name="vectorStoreId">The vector store identifier.</param>
    /// <param name="temperature">The temperature setting for the assistant.</param>
    /// <param name="topP">The nucleus sampling factor for the assistant.</param>
    /// <param name="responseFormat">The response format for the assistant.</param>
    /// <param name="metadata">The metadata for the assistant.</param>
    /// <param name="cancellationToken">The cancellation token.</param>
    /// <returns>A task that represents the asynchronous operation. The task result contains the created assistant.</returns>
    public static Task<Assistant> CreateAssistantFromTemplateAsync(
        this AssistantClient client,
        string modelId,
        PromptTemplateConfig config,
        bool enableCodeInterpreter = false,
        IReadOnlyList<string>? codeInterpreterFileIds = null,
        bool enableFileSearch = false,
        string? vectorStoreId = null,
        float? temperature = null,
        float? topP = null,
        AssistantResponseFormat? responseFormat = null,
        IReadOnlyDictionary<string, string>? metadata = null,
        CancellationToken cancellationToken = default)
    {
        return
            client.CreateAssistantAsync(
                modelId,
                config.Name,
                config.Description,
                config.Template,
                enableCodeInterpreter,
                codeInterpreterFileIds,
                enableFileSearch,
                vectorStoreId,
                temperature,
                topP,
                responseFormat,
                metadata,
                cancellationToken);
    }

    /// <summary>
    /// Creates a thread asynchronously with the specified options.
    /// </summary>
    /// <param name="client">The assistant client.</param>
    /// <param name="messages">The initial messages for the thread.</param>
    /// <param name="codeInterpreterFileIds">The file IDs for the code interpreter tool.</param>
    /// <param name="vectorStoreId">The vector store identifier.</param>
    /// <param name="metadata">The metadata for the thread.</param>
    /// <param name="cancellationToken">The cancellation token.</param>
    /// <returns>A task that represents the asynchronous operation. The task result contains the thread ID.</returns>
    public static async Task<string> CreateThreadAsync(
        this AssistantClient client,
        IEnumerable<ChatMessageContent>? messages = null,
        IReadOnlyList<string>? codeInterpreterFileIds = null,
        string? vectorStoreId = null,
        IReadOnlyDictionary<string, string>? metadata = null,
        CancellationToken cancellationToken = default)
    {
        ThreadCreationOptions options = new()
        {
            ToolResources = AssistantToolResourcesFactory.GenerateToolResources(vectorStoreId, codeInterpreterFileIds)
        };

        if (messages != null)
        {
            options.InitialMessages.AddRange(messages.ToThreadInitializationMessages());
        }

        if (metadata != null)
        {
            foreach (KeyValuePair<string, string> item in metadata)
            {
                options.Metadata[item.Key] = item.Value;
            }
        }

        AssistantThread thread = await client.CreateThreadAsync(options, cancellationToken).ConfigureAwait(false);

        return thread.Id;
    }
}


===== OpenAI\Extensions\AuthorRoleExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.
using Microsoft.SemanticKernel.ChatCompletion;
using OpenAI.Assistants;

namespace Microsoft.SemanticKernel.Agents.OpenAI;

internal static class AuthorRoleExtensions
{
    /// <summary>
    /// Convert an <see cref="AuthorRole"/> to a <see cref="MessageRole"/>
    /// within <see cref="OpenAIAssistantChannel"/>.  A thread message may only be of
    /// two roles: User or Assistant.
    /// </summary>
    /// <remarks>
    /// The agent framework disallows any system message for all agents as part
    /// of the agent conversation.  Should this conversation method experience a
    /// system message, it will be converted to assistant role.
    /// </remarks>
    public static MessageRole ToMessageRole(this AuthorRole authorRole) =>
        authorRole == AuthorRole.User ?
            MessageRole.User :
            MessageRole.Assistant;
}


===== OpenAI\Extensions\ChatContentMessageExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.SemanticKernel.Agents.OpenAI.Internal;
using OpenAI.Assistants;
using OpenAI.Responses;

namespace Microsoft.SemanticKernel.Agents.OpenAI;

/// <summary>
/// Convenience extensions for converting <see cref="ChatMessageContent"/>.
/// </summary>
public static class ChatContentMessageExtensions
{
    /// <summary>
    /// Converts a <see cref="ChatMessageContent"/> instance to a <see cref="ThreadInitializationMessage"/>.
    /// </summary>
    /// <param name="message">The chat message content to convert.</param>
    /// <returns>A <see cref="ThreadInitializationMessage"/> instance.</returns>
    public static ThreadInitializationMessage ToThreadInitializationMessage(this ChatMessageContent message)
    {
        return
            new ThreadInitializationMessage(
                role: message.Role.ToMessageRole(),
                content: AssistantMessageFactory.GetMessageContents(message));
    }

    /// <summary>
    /// Converts a collection of <see cref="ChatMessageContent"/> instances to a collection of <see cref="ThreadInitializationMessage"/> instances.
    /// </summary>
    /// <param name="messages">The collection of chat message contents to convert.</param>
    /// <returns>A collection of <see cref="ThreadInitializationMessage"/> instances.</returns>
    public static IEnumerable<ThreadInitializationMessage> ToThreadInitializationMessages(this IEnumerable<ChatMessageContent> messages)
    {
        return messages.Select(message => message.ToThreadInitializationMessage());
    }

    /// <summary>
    /// Converts a <see cref="ChatMessageContent"/> instance to a <see cref="ResponseItem"/>.
    /// </summary>
    /// <param name="message">The chat message content to convert.</param>
    /// <returns>A <see cref="ResponseItem"/> instance.</returns>
    public static ResponseItem ToResponseItem(this ChatMessageContent message)
    {
        var items = message.Items;
        IEnumerable<ResponseContentPart> contentParts = items.Select(item => item.ToResponseContentPart());
        return message.Role.Label.ToUpperInvariant() switch
        {
            "SYSTEM" => ResponseItem.CreateSystemMessageItem(contentParts),
            "USER" => ResponseItem.CreateUserMessageItem(contentParts),
            "DEVELOPER" => ResponseItem.CreateDeveloperMessageItem(contentParts),
            "ASSISTANT" => ResponseItem.CreateAssistantMessageItem(contentParts),
            _ => throw new NotSupportedException($"Unsupported role {message.Role.Label}. Only system, user, developer or assistant roles are allowed."),
        };
    }
}


===== OpenAI\Extensions\KernelContentExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using OpenAI.Responses;

namespace Microsoft.SemanticKernel.Agents.OpenAI;

/// <summary>
/// Extensons methods for <see cref="KernelContent"/>.
/// </summary>
internal static class KernelContentExtensions
{
    internal static ResponseContentPart ToResponseContentPart(this KernelContent content)
    {
        return content switch
        {
            TextContent textContent => textContent.ToResponseContentPart(),
            ImageContent imageContent => imageContent.ToResponseContentPart(),
            BinaryContent binaryContent => binaryContent.ToResponseContentPart(),
            FileReferenceContent fileReferenceContent => fileReferenceContent.ToResponseContentPart(),
            _ => throw new NotSupportedException($"Unsupported content type {content.GetType().Name}. Cannot convert to {nameof(ResponseContentPart)}.")
        };
    }

    internal static ResponseContentPart ToResponseContentPart(this TextContent content)
    {
        return ResponseContentPart.CreateInputTextPart(content.Text);
    }

    internal static ResponseContentPart ToResponseContentPart(this ImageContent content)
    {
        return content.Uri is not null
            ? ResponseContentPart.CreateInputImagePart(content.Uri)
            : content.Data is not null
            ? ResponseContentPart.CreateInputImagePart(new BinaryData(content.Data), content.MimeType)
            : throw new NotSupportedException("ImageContent cannot be converted to ResponseContentPart. Only ImageContent with a uri or binary data is supported.");
    }

    internal static ResponseContentPart ToResponseContentPart(this BinaryContent content)
    {
        return content.Data is not null
            ? ResponseContentPart.CreateInputFilePart(new BinaryData(content.Data), content.MimeType, Guid.NewGuid().ToString())
            : throw new NotSupportedException("AudioContent cannot be converted to ResponseContentPart. Only AudioContent with binary data is supported.");
    }

    internal static ResponseContentPart ToResponseContentPart(this FileReferenceContent content)
    {
        return content.FileId is not null
            ? ResponseContentPart.CreateInputFilePart(content.FileId)
            : throw new NotSupportedException("FileReferenceContent cannot be converted to ResponseContentPart. Only FileReferenceContent with a file id is supported.");
    }
}


===== OpenAI\Extensions\KernelFunctionExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using OpenAI.Assistants;
using OpenAI.Responses;

namespace Microsoft.SemanticKernel.Agents.OpenAI;

/// <summary>
/// Extensions for <see cref="KernelFunction"/> to support OpenAI specific operations.
/// </summary>
public static class KernelFunctionExtensions
{
    /// <summary>
    /// Convert <see cref="KernelFunction"/> to an OpenAI tool model.
    /// </summary>
    /// <param name="function">The source function</param>
    /// <param name="pluginName">The plugin name</param>
    /// <returns>An OpenAI tool definition</returns>
    public static FunctionToolDefinition ToToolDefinition(this KernelFunction function, string? pluginName = null)
    {
        if (function.Metadata.Parameters.Count > 0)
        {
            BinaryData parameterData = function.Metadata.CreateParameterSpec();

            return new FunctionToolDefinition(FunctionName.ToFullyQualifiedName(function.Name, pluginName ?? function.PluginName))
            {
                Description = function.Description,
                Parameters = parameterData,
            };
        }

        return new FunctionToolDefinition(FunctionName.ToFullyQualifiedName(function.Name, pluginName ?? function.PluginName))
        {
            Description = function.Description
        };
    }

    /// <summary>
    /// Converts a <see cref="KernelFunction"/> into a <see cref="ResponseTool"/> representation.
    /// </summary>
    /// <remarks>If the <paramref name="function"/> has parameters, they are included in the resulting <see
    /// cref="ResponseTool"/>  as a serialized parameter specification. Otherwise, the parameters are set to <see
    /// langword="null"/>.</remarks>
    /// <param name="function">The <see cref="KernelFunction"/> to convert.</param>
    /// <param name="pluginName">An optional plugin name to associate with the function. If not provided, the function's default plugin name is
    /// used.</param>
    /// <param name="functionSchemaIsStrict">A value indicating whether the function's schema should be treated as strict.  If <see langword="true"/>, the
    /// schema will enforce stricter validation rules.</param>
    /// <returns>A <see cref="ResponseTool"/> that represents the specified <see cref="KernelFunction"/>.</returns>
    public static ResponseTool ToResponseTool(this KernelFunction function, string? pluginName = null, bool functionSchemaIsStrict = false)
    {
        if (function.Metadata.Parameters.Count > 0)
        {
            BinaryData parameterData = function.Metadata.CreateParameterSpec();
            return ResponseTool.CreateFunctionTool(
                functionName: FunctionName.ToFullyQualifiedName(function.Name, pluginName ?? function.PluginName),
                functionParameters: parameterData,
                strictModeEnabled: functionSchemaIsStrict,
                functionDescription: function.Description);
        }

        return ResponseTool.CreateFunctionTool(
            functionName: FunctionName.ToFullyQualifiedName(function.Name, pluginName ?? function.PluginName),
            functionParameters: s_emptyFunctionParameters,
            null,
            functionDescription: function.Description);
    }

    #region private
    private static readonly BinaryData s_emptyFunctionParameters = BinaryData.FromString("{}");
    #endregion
}


===== OpenAI\Extensions\ModelConnectionExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.ClientModel;
using System.Diagnostics.CodeAnalysis;

namespace Microsoft.SemanticKernel.Agents.OpenAI;

/// <summary>
/// Provides extension methods for <see cref="ModelConnection"/>.
/// </summary>
[ExcludeFromCodeCoverage]
internal static class ModelConnectionExtensions
{
    /// <summary>
    /// Gets the endpoint property as a <see cref="Uri"/> from the specified <see cref="ModelConnection"/>.
    /// </summary>
    /// <param name="connection">Model connection</param>
    internal static Uri? TryGetEndpoint(this ModelConnection connection)
    {
        Verify.NotNull(connection);

        return connection.ExtensionData.TryGetValue("endpoint", out var value) && value is not null && value is string endpoint
            ? new Uri(endpoint)
            : null;
    }

    /// <summary>
    /// Gets the API key property as an <see cref="ApiKeyCredential"/> from the specified <see cref="ModelConnection"/>.
    /// </summary>
    /// <param name="connection">Model connection</param>
    internal static ApiKeyCredential GetApiKeyCredential(this ModelConnection connection)
    {
        Verify.NotNull(connection);

        return !connection.ExtensionData.TryGetValue("api_key", out var apiKey) || apiKey is null
            ? throw new InvalidOperationException("API key was not specified.")
            : new ApiKeyCredential(apiKey.ToString()!);
    }
}


===== OpenAI\Extensions\OpenAIClientExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Collections.Generic;
using System.IO;
using System.Threading;
using System.Threading.Tasks;
using OpenAI;
using OpenAI.Assistants;
using OpenAI.Files;
using OpenAI.VectorStores;

namespace Microsoft.SemanticKernel.Agents.OpenAI;

/// <summary>
/// Convenience extensions for <see cref="AssistantClient"/>.
/// </summary>
public static class OpenAIClientExtensions
{
    /// <summary>
    /// Creates a vector store asynchronously.
    /// </summary>
    /// <param name="client">The OpenAI client instance.</param>
    /// <param name="fileIds">The collection of file identifiers to include in the vector store.</param>
    /// <param name="storeName">The name of the vector store.</param>
    /// <param name="expirationPolicy">The expiration policy for the vector store.</param>
    /// <param name="chunkingStrategy">The chunking strategy for the vector store.</param>
    /// <param name="metadata">The metadata associated with the vector store.</param>
    /// <param name="cancellationToken">The cancellation token to monitor for cancellation requests.</param>
    /// <returns>The identifier of the created vector store.</returns>
    public static async Task<string> CreateVectorStoreAsync(
        this OpenAIClient client,
        IEnumerable<string> fileIds,
        string? storeName = null,
        VectorStoreExpirationPolicy? expirationPolicy = null,
        FileChunkingStrategy? chunkingStrategy = null,
        IReadOnlyDictionary<string, string>? metadata = null,
        CancellationToken cancellationToken = default)
    {
        VectorStoreCreationOptions options = new()
        {
            Name = storeName,
            ChunkingStrategy = chunkingStrategy,
            ExpirationPolicy = expirationPolicy,
        };

        options.FileIds.AddRange(fileIds);

        if (metadata != null)
        {
            foreach (KeyValuePair<string, string> item in metadata)
            {
                options.Metadata[item.Key] = item.Value;
            }
        }

        VectorStoreClient vectorStoreClient = client.GetVectorStoreClient();
        var result = await vectorStoreClient.CreateVectorStoreAsync(options, cancellationToken).ConfigureAwait(false);

        return result.Value.Id;
    }

    /// <summary>
    /// Deletes a vector store asynchronously.
    /// </summary>
    /// <param name="client">The OpenAI client instance.</param>
    /// <param name="vectorStoreId">The identifier of the vector store to delete.</param>
    /// <param name="cancellationToken">The cancellation token to monitor for cancellation requests.</param>
    /// <returns>A boolean indicating whether the vector store was successfully deleted.</returns>
    public static async Task<bool> DeleteVectorStoreAsync(this OpenAIClient client, string vectorStoreId, CancellationToken cancellationToken = default)
    {
        VectorStoreClient vectorStoreClient = client.GetVectorStoreClient();
        VectorStoreDeletionResult result = await vectorStoreClient.DeleteVectorStoreAsync(vectorStoreId, cancellationToken).ConfigureAwait(false);
        return result.Deleted;
    }

    /// <summary>
    /// Uploads a file to use with the assistant.
    /// </summary>
    /// <param name="client">The OpenAI client instance.</param>
    /// <param name="stream">The content to upload.</param>
    /// <param name="name">The name of the file.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>The file identifier.</returns>
    /// <remarks>
    /// Use the <see cref="OpenAIFileClient"/> directly for more advanced file operations.
    /// </remarks>
    public static async Task<string> UploadAssistantFileAsync(this OpenAIClient client, Stream stream, string name, CancellationToken cancellationToken = default)
    {
        OpenAIFileClient fileClient = client.GetOpenAIFileClient();

        OpenAIFile fileInfo = await fileClient.UploadFileAsync(stream, name, FileUploadPurpose.Assistants, cancellationToken).ConfigureAwait(false);

        return fileInfo.Id;
    }

    /// <summary>
    /// Deletes a file asynchronously.
    /// </summary>
    /// <param name="client">The OpenAI client instance.</param>
    /// <param name="fileId">The identifier of the file to delete.</param>
    /// <param name="cancellationToken">The cancellation token to monitor for cancellation requests.</param>
    /// <returns>A boolean indicating whether the file was successfully deleted.</returns>
    public static async Task<bool> DeleteFileAsync(this OpenAIClient client, string fileId, CancellationToken cancellationToken = default)
    {
        OpenAIFileClient fileClient = client.GetOpenAIFileClient();
        FileDeletionResult result = await fileClient.DeleteFileAsync(fileId, cancellationToken).ConfigureAwait(false);
        return result.Deleted;
    }
}


===== OpenAI\Extensions\OpenAIResponseExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.Json;
using Microsoft.SemanticKernel.ChatCompletion;
using OpenAI.Responses;

namespace Microsoft.SemanticKernel.Agents.OpenAI;

internal static class OpenAIResponseExtensions
{
    /// <summary>
    /// Converts a <see cref="OpenAIResponse"/> instance to a <see cref="ChatMessageContent"/>.
    /// </summary>
    /// <param name="response">The response to convert.</param>
    /// <returns>A <see cref="ChatMessageContent"/> instance.</returns>
    public static ChatMessageContent ToChatMessageContent(this OpenAIResponse response)
    {
        var messageItem = response.OutputItems
            .FirstOrDefault(item => item is MessageResponseItem);
        var role = messageItem is MessageResponseItem messageResponseItem
            ? messageResponseItem.Role.ToAuthorRole()
            : AuthorRole.Assistant; // Default to Assistant if no role is specified

        var kernelContents = response.OutputItems
            .SelectMany(item => item.ToChatMessageContentItemCollection())
            .ToList();
        ChatMessageContentItemCollection items = new();
        items.AddRange(kernelContents);

        return new ChatMessageContent(
            role,
            modelId: response.Model,
            items: items,
            innerContent: response
            );
    }

    /// <summary>
    /// Converts a <see cref="ResponseItem"/> instance to a <see cref="ChatMessageContent"/>.
    /// </summary>
    /// <param name="item">The response item to convert.</param>
    /// <returns>A <see cref="ChatMessageContent"/> instance.</returns>
    public static ChatMessageContent? ToChatMessageContent(this ResponseItem item)
    {
        if (item is MessageResponseItem messageResponseItem)
        {
            var role = messageResponseItem.Role.ToAuthorRole();
            return new ChatMessageContent(role, item.ToChatMessageContentItemCollection(), innerContent: messageResponseItem);
        }
        else if (item is ReasoningResponseItem reasoningResponseItem)
        {
            if (reasoningResponseItem.SummaryParts is not null && reasoningResponseItem.SummaryParts.Count > 0)
            {
                return new ChatMessageContent(AuthorRole.Assistant, item.ToChatMessageContentItemCollection(), innerContent: reasoningResponseItem);
            }
        }
        else if (item is FunctionCallResponseItem functionCallResponseItem)
        {
            return new ChatMessageContent(AuthorRole.Assistant, item.ToChatMessageContentItemCollection(), innerContent: functionCallResponseItem);
        }
        return null;
    }

    /// <summary>
    /// Converts a <see cref="ResponseItem"/> instance to a <see cref="ChatMessageContent"/>.
    /// </summary>
    /// <param name="item">The response item to convert.</param>
    /// <returns>A <see cref="ChatMessageContent"/> instance.</returns>
    public static ChatMessageContentItemCollection ToChatMessageContentItemCollection(this ResponseItem item)
    {
        if (item is MessageResponseItem messageResponseItem)
        {
            return messageResponseItem.Content.ToChatMessageContentItemCollection();
        }
        else if (item is ReasoningResponseItem reasoningResponseItem)
        {
            return reasoningResponseItem.SummaryParts.ToChatMessageContentItemCollection();
        }
        else if (item is FunctionCallResponseItem functionCallResponseItem)
        {
            Exception? exception = null;
            KernelArguments? arguments = null;
            try
            {
                arguments = JsonSerializer.Deserialize<KernelArguments>(functionCallResponseItem.FunctionArguments);
            }
            catch (JsonException ex)
            {
                exception = new KernelException("Error: Function call arguments were invalid JSON.", ex);
            }
            var functionName = FunctionName.Parse(functionCallResponseItem.FunctionName, "-");
            var functionCallContent = new FunctionCallContent(
                    functionName: functionName.Name,
                    pluginName: functionName.PluginName,
                    id: functionCallResponseItem.CallId,
                    arguments: arguments)
            {
                InnerContent = functionCallResponseItem,
                Exception = exception
            };
            return [functionCallContent];
        }
        return [];
    }

    /// <summary>
    /// Converts a <see cref="FunctionCallResponseItem"/> to a <see cref="FunctionCallContent"/>.
    /// </summary>
    /// <param name="functionCallResponseItem">The response item to convert.</param>
    /// <returns>A <see cref="FunctionCallContent"/> instance.</returns>
    public static FunctionCallContent ToFunctionCallContent(this FunctionCallResponseItem functionCallResponseItem)
    {
        Exception? exception = null;
        KernelArguments? arguments = null;
        try
        {
            arguments = JsonSerializer.Deserialize<KernelArguments>(functionCallResponseItem.FunctionArguments);
        }
        catch (JsonException ex)
        {
            exception = new KernelException("Error: Function call arguments were invalid JSON.", ex);
        }
        var functionName = FunctionName.Parse(functionCallResponseItem.FunctionName, "-");
        return new FunctionCallContent(
                functionName: functionName.Name,
                pluginName: functionName.PluginName,
                id: functionCallResponseItem.CallId,
                arguments: arguments)
        {
            InnerContent = functionCallResponseItem,
            Exception = exception
        };
    }

    /// <summary>
    /// Converts a <see cref="FunctionCallResponseItem"/> to a <see cref="FunctionCallContent"/>.
    /// </summary>
    /// <param name="functionCallResponseItem">The response item to convert.</param>
    /// <param name="functionArguments"></param>
    /// <returns>A <see cref="FunctionCallContent"/> instance.</returns>
    public static StreamingFunctionCallUpdateContent ToStreamingFunctionCallUpdateContent(this FunctionCallResponseItem functionCallResponseItem, string functionArguments)
    {
        return new StreamingFunctionCallUpdateContent(
                callId: functionCallResponseItem.CallId,
                name: functionCallResponseItem.FunctionName,
                arguments: functionArguments)
        {
            InnerContent = functionCallResponseItem,
        };
    }

    /// <summary>
    /// Converts a <see cref="MessageRole"/> to an <see cref="AuthorRole"/>.
    /// </summary>
    /// <param name="messageRole">The message role to convert.</param>
    /// <returns>An <see cref="AuthorRole"/> corresponding to the message role.</returns>
    public static AuthorRole ToAuthorRole(this MessageRole messageRole)
    {
        return messageRole switch
        {
            MessageRole.Assistant => AuthorRole.Assistant,
            MessageRole.Developer => AuthorRole.Developer,
            MessageRole.System => AuthorRole.System,
            MessageRole.User => AuthorRole.User,
            _ => new AuthorRole("unknown"),
        };
    }

    #region private
    private static ChatMessageContentItemCollection ToChatMessageContentItemCollection(this IList<ResponseContentPart> content)
    {
        var collection = new ChatMessageContentItemCollection();
        foreach (var part in content)
        {
            if (part.Kind == ResponseContentPartKind.OutputText || part.Kind == ResponseContentPartKind.InputText)
            {
                collection.Add(new TextContent(part.Text, innerContent: part));
            }
            else if (part.Kind == ResponseContentPartKind.InputImage)
            {
                collection.Add(new FileReferenceContent(part.InputImageFileId) { InnerContent = part });
            }
            else if (part.Kind == ResponseContentPartKind.InputFile)
            {
                collection.Add(new BinaryContent(part.InputFileBytes.ToArray(), part.InputFileBytes.MediaType) { InnerContent = part });
            }
            else if (part.Kind == ResponseContentPartKind.Refusal)
            {
                collection.Add(new TextContent(part.Refusal, innerContent: part));
            }
        }
        return collection;
    }

    private static ChatMessageContentItemCollection ToChatMessageContentItemCollection(this IList<ReasoningSummaryPart> parts)
    {
        var collection = new ChatMessageContentItemCollection();
        foreach (var part in parts)
        {
            if (part is ReasoningSummaryTextPart text)
            {
                collection.Add(new ReasoningContent(text.Text) { InnerContent = text });
            }
        }
        return collection;
    }
    #endregion

}


===== OpenAI\Extensions\StreamingResponseOutputTextDeltaUpdateExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Diagnostics.CodeAnalysis;
using Microsoft.SemanticKernel.ChatCompletion;
using OpenAI.Responses;

namespace Microsoft.SemanticKernel.Agents.OpenAI;

[ExcludeFromCodeCoverage]
internal static class StreamingResponseOutputTextDeltaUpdateExtensions
{
    /// <summary>
    /// Converts a <see cref="StreamingResponseOutputTextDeltaUpdate"/> instance to a <see cref="StreamingChatMessageContent"/>.
    /// </summary>
    /// <param name="update">Instance of <see cref="StreamingResponseOutputTextDeltaUpdate"/></param>
    /// <param name="modelId"></param>
    /// <param name="role"></param>
    public static StreamingChatMessageContent ToStreamingChatMessageContent(this StreamingResponseOutputTextDeltaUpdate update, string? modelId, AuthorRole? role)
    {
        StreamingChatMessageContent content =
            new(role ?? AuthorRole.Assistant, content: null)
            {
                ModelId = modelId,
                InnerContent = update,
            };

        content.Items.Add(new StreamingTextContent(update.Delta));

        return content;
    }

    /// <summary>
    /// Converts a <see cref="StreamingResponseErrorUpdate"/> instance to a <see cref="StreamingChatMessageContent"/>.
    /// </summary>
    /// <param name="update">Instance of <see cref="StreamingResponseOutputTextDeltaUpdate"/></param>
    /// <param name="modelId"></param>
    /// <param name="role"></param>
    public static StreamingChatMessageContent ToStreamingChatMessageContent(this StreamingResponseErrorUpdate update, string? modelId, AuthorRole? role)
    {
        StreamingChatMessageContent content =
            new(role ?? AuthorRole.Assistant, content: null)
            {
                ModelId = modelId,
                InnerContent = update,
            };

        content.Items.Add(new StreamingTextContent(update.Message));

        return content;
    }

    /// <summary>
    /// Converts a <see cref="StreamingResponseRefusalDoneUpdate"/> instance to a <see cref="StreamingChatMessageContent"/>.
    /// </summary>
    /// <param name="update">Instance of <see cref="StreamingResponseOutputTextDeltaUpdate"/></param>
    /// <param name="modelId"></param>
    /// <param name="role"></param>
    public static StreamingChatMessageContent ToStreamingChatMessageContent(this StreamingResponseRefusalDoneUpdate update, string? modelId, AuthorRole? role)
    {
        StreamingChatMessageContent content =
            new(role ?? AuthorRole.Assistant, content: null)
            {
                ModelId = modelId,
                InnerContent = update,
            };

        content.Items.Add(new StreamingTextContent(update.Refusal));

        return content;
    }
}


===== OpenAI\Internal\AssistantMessageFactory.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Collections.Generic;
using System.Linq;
using Microsoft.SemanticKernel.Connectors.FunctionCalling;
using OpenAI.Assistants;

namespace Microsoft.SemanticKernel.Agents.OpenAI.Internal;

/// <summary>
/// Factory for creating <see cref="MessageContent"/> based on <see cref="ChatMessageContent"/>.
/// Also able to produce <see cref="MessageCreationOptions"/>.
/// </summary>
/// <remarks>
/// Improves testability.
/// </remarks>
internal static class AssistantMessageFactory
{
    /// <summary>
    /// Produces <see cref="MessageCreationOptions"/> based on <see cref="ChatMessageContent"/>.
    /// </summary>
    /// <param name="message">The message content.</param>
    public static MessageCreationOptions CreateOptions(ChatMessageContent message)
    {
        MessageCreationOptions options = new();

        if (message.Metadata != null)
        {
            foreach (var metadata in message.Metadata)
            {
                options.Metadata.Add(metadata.Key, metadata.Value?.ToString() ?? string.Empty);
            }
        }

        return options;
    }

    /// <summary>
    /// Translates <see cref="ChatMessageContent.Items"/> into enumeration of <see cref="MessageContent"/>.
    /// </summary>
    /// <param name="message">The message content.</param>
    public static IEnumerable<MessageContent> GetMessageContents(ChatMessageContent message)
    {
        bool hasTextContent = message.Items.OfType<TextContent>().Any();
        foreach (KernelContent content in message.Items)
        {
            if (content is TextContent textContent)
            {
                var text = content.ToString();
                if (string.IsNullOrWhiteSpace(text))
                {
                    // Message content must be non-empty.
                    continue;
                }
                yield return MessageContent.FromText(text);
            }
            else if (content is ImageContent imageContent)
            {
                if (imageContent.Uri != null)
                {
                    yield return MessageContent.FromImageUri(imageContent.Uri);
                }
                else if (!string.IsNullOrWhiteSpace(imageContent.DataUri))
                {
                    yield return MessageContent.FromImageUri(new(imageContent.DataUri!));
                }
            }
            else if (content is FileReferenceContent fileContent)
            {
                yield return MessageContent.FromImageFileId(fileContent.FileId);
            }
            else if (content is FunctionResultContent resultContent && resultContent.Result != null && !hasTextContent)
            {
                // Only convert a function result when text-content is not already present
                yield return MessageContent.FromText(FunctionCallsProcessor.ProcessFunctionResult(resultContent.Result));
            }
        }
    }
}


===== OpenAI\Internal\AssistantRunOptionsFactory.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using OpenAI.Assistants;

namespace Microsoft.SemanticKernel.Agents.OpenAI.Internal;

/// <summary>
/// Factory for creating <see cref="RunCreationOptions"/> definition.
/// </summary>
internal static class AssistantRunOptionsFactory
{
    public static RunCreationOptions GenerateOptions(RunCreationOptions? defaultOptions, string? agentInstructions, RunCreationOptions? invocationOptions, string? threadExtensionsContext)
    {
        var additionalInstructions = string.Concat(
            (invocationOptions?.AdditionalInstructions ?? defaultOptions?.AdditionalInstructions),
            string.IsNullOrWhiteSpace(threadExtensionsContext) ? string.Empty : string.Concat(Environment.NewLine, Environment.NewLine, threadExtensionsContext));

        RunCreationOptions runOptions =
            new()
            {
                AdditionalInstructions = additionalInstructions,
                InstructionsOverride = invocationOptions?.InstructionsOverride ?? agentInstructions,
                MaxOutputTokenCount = invocationOptions?.MaxOutputTokenCount ?? defaultOptions?.MaxOutputTokenCount,
                MaxInputTokenCount = invocationOptions?.MaxInputTokenCount ?? defaultOptions?.MaxInputTokenCount,
                ModelOverride = invocationOptions?.ModelOverride ?? defaultOptions?.ModelOverride,
                NucleusSamplingFactor = invocationOptions?.NucleusSamplingFactor ?? defaultOptions?.NucleusSamplingFactor,
                AllowParallelToolCalls = invocationOptions?.AllowParallelToolCalls ?? defaultOptions?.AllowParallelToolCalls,
                ResponseFormat = invocationOptions?.ResponseFormat ?? defaultOptions?.ResponseFormat,
                Temperature = invocationOptions?.Temperature ?? defaultOptions?.Temperature,
                ToolConstraint = invocationOptions?.ToolConstraint ?? defaultOptions?.ToolConstraint,
                TruncationStrategy = invocationOptions?.TruncationStrategy ?? defaultOptions?.TruncationStrategy,
            };

        IList<ThreadInitializationMessage>? additionalMessages = invocationOptions?.AdditionalMessages ?? defaultOptions?.AdditionalMessages;
        if (additionalMessages != null)
        {
            runOptions.AdditionalMessages.AddRange(additionalMessages);
        }

        PopulateMetadata(defaultOptions, runOptions);
        PopulateMetadata(invocationOptions, runOptions);

        return runOptions;
    }

    private static void PopulateMetadata(RunCreationOptions? sourceOptions, RunCreationOptions targetOptions)
    {
        if (sourceOptions?.Metadata != null)
        {
            foreach (KeyValuePair<string, string> item in sourceOptions.Metadata)
            {
                targetOptions.Metadata[item.Key] = item.Value ?? string.Empty;
            }
        }
    }
}


===== OpenAI\Internal\AssistantThreadActions.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.ClientModel;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Net;
using System.Runtime.CompilerServices;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Microsoft.Extensions.Logging;
using Microsoft.SemanticKernel.Agents.Extensions;
using Microsoft.SemanticKernel.ChatCompletion;
using Microsoft.SemanticKernel.Connectors.FunctionCalling;
using OpenAI.Assistants;

namespace Microsoft.SemanticKernel.Agents.OpenAI.Internal;

/// <summary>
/// Actions associated with an OpenAI Assistant thread.
/// </summary>
internal static class AssistantThreadActions
{
    private static readonly HashSet<RunStatus> s_pollingStatuses =
    [
        RunStatus.Queued,
        RunStatus.InProgress,
        RunStatus.Cancelling,
    ];

    /// <summary>
    /// Create a message in the specified thread.
    /// </summary>
    /// <param name="client">The assistant client</param>
    /// <param name="threadId">The thread identifier</param>
    /// <param name="message">The message to add</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <throws><see cref="KernelException"/> if a system message is present, without taking any other action</throws>
    public static async Task CreateMessageAsync(AssistantClient client, string threadId, ChatMessageContent message, CancellationToken cancellationToken)
    {
        if (message.Items.Any(i => i is FunctionCallContent))
        {
            return;
        }

        MessageCreationOptions options = AssistantMessageFactory.CreateOptions(message);
        IEnumerable<MessageContent> content = AssistantMessageFactory.GetMessageContents(message);
        if (!content.Any())
        {
            return;
        }

        await client.CreateMessageAsync(
            threadId,
            message.Role == AuthorRole.User ? MessageRole.User : MessageRole.Assistant,
            content,
            options,
            cancellationToken).ConfigureAwait(false);
    }

    /// <summary>
    /// Retrieves the thread messages.
    /// </summary>
    /// <param name="client">The assistant client</param>
    /// <param name="threadId">The thread identifier</param>
    /// <param name="messageOrder">The order to return messages in.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>Asynchronous enumeration of messages.</returns>
    public static async IAsyncEnumerable<ChatMessageContent> GetMessagesAsync(AssistantClient client, string threadId, MessageCollectionOrder? messageOrder, [EnumeratorCancellation] CancellationToken cancellationToken)
    {
        Dictionary<string, string?> agentNames = []; // Cache agent names by their identifier

        await foreach (ThreadMessage message in client.GetMessagesAsync(threadId, new() { Order = messageOrder ?? MessageCollectionOrder.Descending }, cancellationToken).ConfigureAwait(false))
        {
            string? assistantName = null;
            if (!string.IsNullOrWhiteSpace(message.AssistantId) &&
                !agentNames.TryGetValue(message.AssistantId, out assistantName))
            {
                Assistant assistant = await client.GetAssistantAsync(message.AssistantId, cancellationToken).ConfigureAwait(false);
                if (!string.IsNullOrWhiteSpace(assistant.Name))
                {
                    agentNames.Add(assistant.Id, assistant.Name);
                }
            }

            assistantName ??= message.AssistantId;

            ChatMessageContent content = GenerateMessageContent(assistantName, message);

            if (content.Items.Count > 0)
            {
                yield return content;
            }
        }
    }

    /// <summary>
    /// Invoke the assistant on the specified thread.
    /// In the enumeration returned by this method, a message is considered visible if it is intended to be displayed to the user.
    /// Example of a non-visible message is function-content for functions that are automatically executed.
    /// </summary>
    /// <param name="agent">The assistant agent to interact with the thread.</param>
    /// <param name="client">The assistant client</param>
    /// <param name="threadId">The thread identifier</param>
    /// <param name="invocationOptions">Options to utilize for the invocation</param>
    /// <param name="providersAdditionalInstructions">Additional instructions from <see cref="AIContextProvider"/> instances to pass to the invoke method.</param>
    /// <param name="logger">The logger to utilize (might be agent or channel scoped)</param>
    /// <param name="kernel">The <see cref="Kernel"/> plugins and other state.</param>
    /// <param name="arguments">Optional arguments to pass to the agents's invocation, including any <see cref="PromptExecutionSettings"/>.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>Asynchronous enumeration of messages.</returns>
    public static async IAsyncEnumerable<(bool IsVisible, ChatMessageContent Message)> InvokeAsync(
        OpenAIAssistantAgent agent,
        AssistantClient client,
        string threadId,
        RunCreationOptions? invocationOptions,
        string? providersAdditionalInstructions,
        ILogger logger,
        Kernel kernel,
        KernelArguments? arguments,
        [EnumeratorCancellation] CancellationToken cancellationToken)
    {
        logger.LogOpenAIAssistantCreatingRun(nameof(InvokeAsync), threadId);

        List<ToolDefinition> tools = new(agent.Definition.Tools);

        // Add unique functions from the Kernel which are not already present in the agent's tools
        var functionToolNames = new HashSet<string>(tools.OfType<FunctionToolDefinition>().Select(t => t.FunctionName));
        var functionTools = kernel.Plugins
            .SelectMany(kp => kp.Select(kf => kf.ToToolDefinition(kp.Name)))
            .Where(tool => !functionToolNames.Contains(tool.FunctionName));
        tools.AddRange(functionTools);

        string? instructions = await agent.GetInstructionsAsync(kernel, arguments, cancellationToken).ConfigureAwait(false);

        RunCreationOptions options = AssistantRunOptionsFactory.GenerateOptions(agent.RunOptions, instructions, invocationOptions, providersAdditionalInstructions);

        options.ToolsOverride.AddRange(tools);

        ThreadRun run = await client.CreateRunAsync(threadId, agent.Id, options, cancellationToken).ConfigureAwait(false);

        logger.LogOpenAIAssistantCreatedRun(nameof(InvokeAsync), run.Id, threadId);

        FunctionCallsProcessor functionProcessor = new(logger);
        // This matches current behavior.  Will be configurable upon integrating with `FunctionChoice` (#6795/#5200)
        FunctionChoiceBehaviorOptions functionOptions = new() { AllowConcurrentInvocation = true, AllowParallelCalls = true };

        // Evaluate status and process steps and messages, as encountered.
        HashSet<string> processedStepIds = [];
        Dictionary<string, FunctionResultContent> functionSteps = [];
        do
        {
            // Check for cancellation
            cancellationToken.ThrowIfCancellationRequested();

            // Poll run and steps until actionable
            await PollRunStatusAsync().ConfigureAwait(false);

            // Is in terminal state?
            if (run.Status.IsTerminal && run.Status != RunStatus.Completed)
            {
                throw new KernelException($"Agent Failure - Run terminated: {run.Status} [{run.Id}]: {run.LastError?.Message ?? "Unknown"}");
            }

            List<RunStep> steps = [];
            await foreach (var step in client.GetRunStepsAsync(run.ThreadId, run.Id, cancellationToken: cancellationToken).ConfigureAwait(false))
            {
                steps.Add(step);
            }

            // Is tool action required?
            if (run.Status == RunStatus.RequiresAction)
            {
                logger.LogOpenAIAssistantProcessingRunSteps(nameof(InvokeAsync), run.Id, threadId);

                // Execute functions in parallel and post results at once.
                FunctionCallContent[] functionCalls = steps.SelectMany(step => ParseFunctionStep(agent, step)).ToArray();
                if (functionCalls.Length > 0)
                {
                    // Emit function-call content
                    ChatMessageContent functionCallMessage = GenerateFunctionCallContent(agent.GetName(), functionCalls);
                    yield return (IsVisible: false, Message: functionCallMessage);

                    // Invoke functions for each tool-step
                    FunctionResultContent[] functionResults =
                        await functionProcessor.InvokeFunctionCallsAsync(
                            functionCallMessage,
                            (_) => true,
                            functionOptions,
                            kernel,
                            isStreaming: false,
                            cancellationToken).ConfigureAwait(false);

                    // Capture function-call for message processing
                    foreach (FunctionResultContent functionCall in functionResults)
                    {
                        functionSteps.Add(functionCall.CallId!, functionCall);
                    }

                    // Process tool output
                    ToolOutput[] toolOutputs = GenerateToolOutputs(functionResults);

                    await client.SubmitToolOutputsToRunAsync(threadId, run.Id, toolOutputs, cancellationToken).ConfigureAwait(false);
                }

                logger.LogOpenAIAssistantProcessedRunSteps(nameof(InvokeAsync), functionCalls.Length, run.Id, threadId);
            }

            // Enumerate completed messages
            logger.LogOpenAIAssistantProcessingRunMessages(nameof(InvokeAsync), run.Id, threadId);

            IEnumerable<RunStep> completedStepsToProcess =
                steps
                    .Where(s => s.CompletedAt.HasValue && !processedStepIds.Contains(s.Id))
                    .OrderBy(s => s.CreatedAt);

            int messageCount = 0;
            foreach (RunStep completedStep in completedStepsToProcess)
            {
                if (completedStep.Kind == RunStepKind.ToolCall)
                {
                    foreach (RunStepToolCall toolCall in completedStep.Details.ToolCalls)
                    {
                        bool isVisible = false;
                        ChatMessageContent? content = null;

                        // Process code-interpreter content
                        if (toolCall.Kind == RunStepToolCallKind.CodeInterpreter)
                        {
                            content = GenerateCodeInterpreterContent(agent.GetName(), toolCall.CodeInterpreterInput, completedStep);
                            isVisible = true;
                        }
                        // Process function result content
                        else if (toolCall.Kind == RunStepToolCallKind.Function)
                        {
                            FunctionResultContent functionStep = functionSteps[toolCall.Id]; // Function step always captured on invocation
                            content = GenerateFunctionResultContent(agent.GetName(), [functionStep], completedStep);
                        }

                        if (content is not null)
                        {
                            ++messageCount;

                            yield return (isVisible, Message: content);
                        }
                    }
                }
                else if (completedStep.Kind == RunStepKind.CreatedMessage)
                {
                    // Retrieve the message
                    ThreadMessage? message = await RetrieveMessageAsync(client, threadId, completedStep.Details.CreatedMessageId, agent.PollingOptions.MessageSynchronizationDelay, cancellationToken).ConfigureAwait(false);

                    if (message is not null)
                    {
                        ChatMessageContent content = GenerateMessageContent(agent.GetName(), message, completedStep);

                        if (content.Items.Count > 0)
                        {
                            ++messageCount;

                            yield return (IsVisible: true, Message: content);
                        }
                    }
                }

                processedStepIds.Add(completedStep.Id);
            }

            logger.LogOpenAIAssistantProcessedRunMessages(nameof(InvokeAsync), messageCount, run.Id, threadId);
        }
        while (RunStatus.Completed != run.Status);

        logger.LogOpenAIAssistantCompletedRun(nameof(InvokeAsync), run.Id, threadId);

        // Local function to assist in run polling (participates in method closure).
        async Task PollRunStatusAsync()
        {
            logger.LogOpenAIAssistantPollingRunStatus(nameof(PollRunStatusAsync), run.Id, threadId);

            int count = 0;

            do
            {
                cancellationToken.ThrowIfCancellationRequested();

                if (count > 0)
                {
                    // Reduce polling frequency after a couple attempts
                    await Task.Delay(agent.PollingOptions.GetPollingInterval(count), cancellationToken).ConfigureAwait(false);
                }

                ++count;

                try
                {
                    run = await client.GetRunAsync(threadId, run.Id, cancellationToken).ConfigureAwait(false);
                }
                // The presence of a `Status` code means the server responded with error...always fail in that case
                catch (ClientResultException clientException) when (clientException.Status <= 0)
                {
                    // Check maximum retry count
                    if (count >= agent.PollingOptions.MaximumRetryCount)
                    {
                        throw;
                    }

                    // Retry for potential transient failure
                    continue;
                }
                catch (AggregateException aggregateException) when (aggregateException.InnerException is ClientResultException innerClientException)
                {
                    // The presence of a `Status` code means the server responded with error
                    if (innerClientException.Status > 0)
                    {
                        throw;
                    }

                    // Check maximum retry count
                    if (count >= agent.PollingOptions.MaximumRetryCount)
                    {
                        throw;
                    }

                    // Retry for potential transient failure
                    continue;
                }
            }
            while (s_pollingStatuses.Contains(run.Status));

            logger.LogOpenAIAssistantPolledRunStatus(nameof(PollRunStatusAsync), run.Status, run.Id, threadId);
        }
    }

    /// <summary>
    /// Invoke the assistant on the specified thread using streaming.
    /// </summary>
    /// <param name="agent">The assistant agent to interact with the thread.</param>
    /// <param name="client">The assistant client</param>
    /// <param name="threadId">The thread identifier</param>
    /// <param name="messages">The receiver for the completed messages generated</param>
    /// <param name="invocationOptions">Options to utilize for the invocation</param>
    /// <param name="providersAdditionalInstructions">Additional instructions from <see cref="AIContextProvider"/> instances to pass to the invoke method.</param>
    /// <param name="logger">The logger to utilize (might be agent or channel scoped)</param>
    /// <param name="kernel">The <see cref="Kernel"/> plugins and other state.</param>
    /// <param name="arguments">Optional arguments to pass to the agents's invocation, including any <see cref="PromptExecutionSettings"/>.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>Asynchronous enumeration of messages.</returns>
    /// <remarks>
    /// The `arguments` parameter is not currently used by the agent, but is provided for future extensibility.
    /// </remarks>
    [ExcludeFromCodeCoverage]
    public static async IAsyncEnumerable<StreamingChatMessageContent> InvokeStreamingAsync(
        OpenAIAssistantAgent agent,
        AssistantClient client,
        string threadId,
        IList<ChatMessageContent>? messages,
        RunCreationOptions? invocationOptions,
        string? providersAdditionalInstructions,
        ILogger logger,
        Kernel kernel,
        KernelArguments? arguments,
        [EnumeratorCancellation] CancellationToken cancellationToken)
    {
        logger.LogOpenAIAssistantCreatingRun(nameof(InvokeAsync), threadId);

        ToolDefinition[]? tools = [.. agent.Definition.Tools, .. kernel.Plugins.SelectMany(p => p.Select(f => f.ToToolDefinition(p.Name)))];

        string? instructions = await agent.GetInstructionsAsync(kernel, arguments, cancellationToken).ConfigureAwait(false);

        RunCreationOptions options = AssistantRunOptionsFactory.GenerateOptions(agent.RunOptions, instructions, invocationOptions, providersAdditionalInstructions);

        options.ToolsOverride.AddRange(tools);

        // Evaluate status and process steps and messages, as encountered.
        HashSet<string> processedStepIds = [];
        Dictionary<string, FunctionResultContent[]> stepFunctionResults = [];
        List<RunStep> messageCreationStepsToProcess = [];
        ThreadRun? run = null;

        FunctionCallsProcessor functionProcessor = new(logger);
        // This matches current behavior.  Will be configurable upon integrating with `FunctionChoice` (#6795/#5200)
        FunctionChoiceBehaviorOptions functionOptions = new() { AllowConcurrentInvocation = true, AllowParallelCalls = true };

        IAsyncEnumerable<StreamingUpdate> asyncUpdates = client.CreateRunStreamingAsync(threadId, agent.Id, options, cancellationToken);
        do
        {
            // Check for cancellation
            cancellationToken.ThrowIfCancellationRequested();

            messageCreationStepsToProcess.Clear();

            await foreach (StreamingUpdate update in asyncUpdates.ConfigureAwait(false))
            {
                if (update is RunUpdate runUpdate)
                {
                    run = runUpdate.Value;

                    switch (runUpdate.UpdateKind)
                    {
                        case StreamingUpdateReason.RunCreated:
                            logger.LogOpenAIAssistantCreatedRun(nameof(InvokeAsync), run.Id, threadId);
                            break;
                    }
                }
                else if (update is MessageContentUpdate contentUpdate)
                {
                    switch (contentUpdate.UpdateKind)
                    {
                        case StreamingUpdateReason.MessageUpdated:
                            yield return GenerateStreamingMessageContent(agent.GetName(), run!, contentUpdate, logger);
                            break;
                    }
                }
                else if (update is RunStepDetailsUpdate detailsUpdate)
                {
                    StreamingChatMessageContent? toolContent = GenerateStreamingCodeInterpreterContent(agent.GetName(), detailsUpdate);
                    if (toolContent != null)
                    {
                        yield return toolContent;
                    }
                    else if (detailsUpdate.FunctionName != null || detailsUpdate.FunctionArguments != null)
                    {
                        yield return
                            new StreamingChatMessageContent(AuthorRole.Assistant, null)
                            {
                                AuthorName = agent.Name,
                                Items = [new StreamingFunctionCallUpdateContent(detailsUpdate.ToolCallId, detailsUpdate.FunctionName, detailsUpdate.FunctionArguments, detailsUpdate.ToolCallIndex ?? 0)],
                                InnerContent = detailsUpdate,
                            };
                    }
                }
                else if (update is RunStepUpdate stepUpdate)
                {
                    switch (stepUpdate.UpdateKind)
                    {
                        case StreamingUpdateReason.RunStepCompleted:
                            if (!string.IsNullOrEmpty(stepUpdate.Value.Details.CreatedMessageId))
                            {
                                messageCreationStepsToProcess.Add(stepUpdate.Value);
                            }
                            else
                            {
                                ProcessToolCallStep(stepUpdate.Value, agent, messages, threadId, stepFunctionResults);
                            }

                            break;
                        default:
                            break;
                    }
                }
            }

            if (run == null)
            {
                throw new KernelException($"Agent Failure - Run not created for thread: ${threadId}");
            }

            // Is in terminal state?
            if (run.Status.IsTerminal && run.Status != RunStatus.Completed)
            {
                throw new KernelException($"Agent Failure - Run terminated: {run.Status} [{run.Id}]: {run.LastError?.Message ?? "Unknown"}");
            }

            if (run.Status == RunStatus.RequiresAction)
            {
                List<RunStep> activeSteps = [];
                await foreach (var step in client.GetRunStepsAsync(run.ThreadId, run.Id, cancellationToken: cancellationToken).ConfigureAwait(false))
                {
                    if (step.Status == RunStepStatus.InProgress)
                    {
                        activeSteps.Add(step);
                    }
                }

                // Capture map between the tool call and its associated step
                Dictionary<string, string> toolMap = [];
                foreach (RunStep step in activeSteps)
                {
                    foreach (RunStepToolCall stepDetails in step.Details.ToolCalls)
                    {
                        toolMap[stepDetails.Id] = step.Id;
                    }
                }

                // Execute functions in parallel and post results at once.
                FunctionCallContent[] functionCalls = activeSteps.SelectMany(step => ParseFunctionStep(agent, step)).ToArray();
                if (functionCalls.Length > 0)
                {
                    // Emit function-call content
                    ChatMessageContent functionCallMessage = GenerateFunctionCallContent(agent.GetName(), functionCalls);
                    messages?.Add(functionCallMessage);

                    FunctionResultContent[] functionResults =
                        await functionProcessor.InvokeFunctionCallsAsync(
                            functionCallMessage,
                            (_) => true,
                            functionOptions,
                            kernel,
                            isStreaming: true,
                            cancellationToken).ConfigureAwait(false);

                    // Process tool output
                    ToolOutput[] toolOutputs = GenerateToolOutputs(functionResults);
                    asyncUpdates = client.SubmitToolOutputsToRunStreamingAsync(run.ThreadId, run.Id, toolOutputs, cancellationToken);

                    foreach (RunStep step in activeSteps)
                    {
                        stepFunctionResults.Add(step.Id, functionResults.Where(result => step.Id == toolMap[result.CallId!]).ToArray());
                    }
                }
            }

            if (messageCreationStepsToProcess.Count > 0)
            {
                logger.LogOpenAIAssistantProcessingRunMessages(nameof(InvokeAsync), run!.Id, threadId);

                foreach (RunStep step in messageCreationStepsToProcess)
                {
                    await ProcessMessageCreationStepAsync(step, agent, client, messages, threadId, cancellationToken).ConfigureAwait(false);
                }

                logger.LogOpenAIAssistantProcessedRunMessages(nameof(InvokeAsync), messageCreationStepsToProcess.Count, run!.Id, threadId);
            }
        }
        while (run?.Status != RunStatus.Completed);

        logger.LogOpenAIAssistantCompletedRun(nameof(InvokeAsync), run?.Id ?? "Failed", threadId);
    }

    private static async Task ProcessMessageCreationStepAsync(
        RunStep step,
        OpenAIAssistantAgent agent,
        AssistantClient client,
        IList<ChatMessageContent>? messages,
        string threadId,
        CancellationToken cancellationToken)
    {
        ThreadMessage? message =
            await RetrieveMessageAsync(
                client,
                threadId,
                step.Details.CreatedMessageId,
                agent.PollingOptions.MessageSynchronizationDelay,
                cancellationToken).ConfigureAwait(false);

        if (message != null)
        {
            ChatMessageContent content = GenerateMessageContent(agent.GetName(), message, step);
            messages?.Add(content);
        }
    }

    private static void ProcessToolCallStep(
        RunStep step,
        OpenAIAssistantAgent agent,
        IList<ChatMessageContent>? messages,
        string threadId,
        Dictionary<string, FunctionResultContent[]> stepFunctionResults)
    {
        foreach (RunStepToolCall toolCall in step.Details.ToolCalls)
        {
            if (toolCall.Kind == RunStepToolCallKind.Function)
            {
                messages?.Add(GenerateFunctionResultContent(agent.GetName(), stepFunctionResults[step.Id], step));
                stepFunctionResults.Remove(step.Id);
                break;
            }

            if (toolCall.Kind == RunStepToolCallKind.CodeInterpreter)
            {
                messages?.Add(GenerateCodeInterpreterContent(agent.GetName(), toolCall.CodeInterpreterInput, step));
            }
        }
    }

    private static ChatMessageContent GenerateMessageContent(string? assistantName, ThreadMessage message, RunStep? completedStep = null, ILogger? logger = null)
    {
        AuthorRole role = new(message.Role.ToString());

        Dictionary<string, object?>? metadata =
            new()
            {
                { nameof(ThreadMessage.CreatedAt), message.CreatedAt },
                { nameof(ThreadMessage.AssistantId), message.AssistantId },
                { nameof(ThreadMessage.ThreadId), message.ThreadId },
                { nameof(ThreadMessage.RunId), message.RunId },
                { nameof(MessageContentUpdate.MessageId), message.Id },
            };

        if (completedStep != null)
        {
            metadata[nameof(RunStepDetailsUpdate.StepId)] = completedStep.Id;
            metadata[nameof(RunStep.Usage)] = completedStep.Usage;
        }

        ChatMessageContent content =
            new(role, content: null)
            {
                AuthorName = assistantName,
                InnerContent = message,
                Metadata = metadata,
            };

        foreach (MessageContent itemContent in message.Content)
        {
            // Process text content
            if (!string.IsNullOrEmpty(itemContent.Text))
            {
                content.Items.Add(new TextContent(itemContent.Text));

                foreach (TextAnnotation annotation in itemContent.TextAnnotations)
                {
                    AnnotationContent? annotationItem = GenerateAnnotationContent(annotation);
                    if (annotationItem is not null)
                    {
                        content.Items.Add(annotationItem);
                    }
                    else
                    {
                        logger?.LogOpenAIAssistantUnknownAnnotation(nameof(GenerateMessageContent), message.RunId, message.ThreadId, annotation.GetType());
                    }
                }
            }
            // Process image content
            else if (!string.IsNullOrEmpty(itemContent.ImageFileId))
            {
                content.Items.Add(new FileReferenceContent(itemContent.ImageFileId));
            }
        }

        return content;
    }

    [ExcludeFromCodeCoverage]
    private static StreamingChatMessageContent GenerateStreamingMessageContent(string? assistantName, ThreadRun run, MessageContentUpdate update, ILogger? logger)
    {
        StreamingChatMessageContent content =
            new(AuthorRole.Assistant, content: null)
            {
                AuthorName = assistantName,
                InnerContent = update,
            };

        // Process text content
        if (!string.IsNullOrEmpty(update.Text))
        {
            content.Items.Add(new StreamingTextContent(update.Text));
        }
        // Process image content
        else if (!string.IsNullOrEmpty(update.ImageFileId))
        {
            content.Items.Add(new StreamingFileReferenceContent(update.ImageFileId));
        }
        // Process annotations
        else if (update.TextAnnotation != null)
        {
            StreamingAnnotationContent? annotationItem = GenerateStreamingAnnotationContent(update.TextAnnotation);
            if (annotationItem is not null)
            {
                content.Items.Add(annotationItem);
            }
            else
            {
                logger?.LogOpenAIAssistantUnknownAnnotation(nameof(GenerateMessageContent), run.Id, run.ThreadId, update.TextAnnotation.GetType());
            }
        }

        if (update.Role.HasValue && update.Role.Value != MessageRole.User)
        {
            content.Role = new(update.Role.Value.ToString());
        }

        return content;
    }

    [ExcludeFromCodeCoverage]
    private static StreamingChatMessageContent? GenerateStreamingCodeInterpreterContent(string? assistantName, RunStepDetailsUpdate update)
    {
        StreamingChatMessageContent content =
            new(AuthorRole.Assistant, content: null)
            {
                AuthorName = assistantName,
            };

        // Process text content
        if (update.CodeInterpreterInput != null)
        {
            content.Items.Add(new StreamingTextContent(update.CodeInterpreterInput));
            content.Metadata = new Dictionary<string, object?> { { OpenAIAssistantAgent.CodeInterpreterMetadataKey, true } };
        }

        if ((update.CodeInterpreterOutputs?.Count ?? 0) > 0)
        {
            foreach (var output in update.CodeInterpreterOutputs!)
            {
                if (!string.IsNullOrEmpty(output.ImageFileId))
                {
                    content.Items.Add(new StreamingFileReferenceContent(output.ImageFileId));
                }
            }
        }

        return content.Items.Count > 0 ? content : null;
    }

    private static AnnotationContent? GenerateAnnotationContent(TextAnnotation annotation)
    {
        string referenceId;
        AnnotationKind kind;

        if (!string.IsNullOrEmpty(annotation.OutputFileId))
        {
            referenceId = annotation.OutputFileId;
            kind = AnnotationKind.TextCitation;
        }
        else if (!string.IsNullOrEmpty(annotation.InputFileId))
        {
            referenceId = annotation.InputFileId;
            kind = AnnotationKind.FileCitation;
        }
        else
        {
            return null;
        }

        return
            new(kind, label: annotation.TextToReplace, referenceId)
            {
                InnerContent = annotation,
                StartIndex = annotation.StartIndex,
                EndIndex = annotation.EndIndex,
            };
    }

    [ExcludeFromCodeCoverage]
    private static StreamingAnnotationContent? GenerateStreamingAnnotationContent(TextAnnotationUpdate annotation)
    {
        string referenceId;
        AnnotationKind kind;

        if (!string.IsNullOrEmpty(annotation.OutputFileId))
        {
            referenceId = annotation.OutputFileId;
            kind = AnnotationKind.TextCitation;
        }
        else if (!string.IsNullOrEmpty(annotation.InputFileId))
        {
            referenceId = annotation.InputFileId;
            kind = AnnotationKind.FileCitation;
        }
        else
        {
            return null;
        }

        return
            new(kind, referenceId)
            {
                Label = annotation.TextToReplace,
                InnerContent = annotation,
                StartIndex = annotation.StartIndex,
                EndIndex = annotation.EndIndex,
            };
    }

    private static ChatMessageContent GenerateCodeInterpreterContent(string agentName, string pythonCode, RunStep completedStep)
    {
        Dictionary<string, object?> metadata = GenerateToolCallMetadata(completedStep);
        metadata[OpenAIAssistantAgent.CodeInterpreterMetadataKey] = true;

        return
            new ChatMessageContent(
                AuthorRole.Assistant,
                [
                    new TextContent(pythonCode)
                ])
            {
                AuthorName = agentName,
                Metadata = metadata,
            };
    }

    private static IEnumerable<FunctionCallContent> ParseFunctionStep(OpenAIAssistantAgent agent, RunStep step)
    {
        if (step.Status == RunStepStatus.InProgress && step.Kind == RunStepKind.ToolCall)
        {
            foreach (RunStepToolCall toolCall in step.Details.ToolCalls)
            {
                (FunctionName nameParts, KernelArguments functionArguments) = ParseFunctionCall(toolCall.FunctionName, toolCall.FunctionArguments);

                FunctionCallContent content = new(nameParts.Name, nameParts.PluginName, toolCall.Id, functionArguments);

                yield return content;
            }
        }
    }

    private static (FunctionName functionName, KernelArguments arguments) ParseFunctionCall(string functionName, string? functionArguments)
    {
        FunctionName nameParts = FunctionName.Parse(functionName);

        KernelArguments arguments = [];

        if (!string.IsNullOrWhiteSpace(functionArguments))
        {
            foreach (var argumentKvp in JsonSerializer.Deserialize<Dictionary<string, object>>(functionArguments!)!)
            {
                arguments[argumentKvp.Key] = argumentKvp.Value.ToString();
            }
        }

        return (nameParts, arguments);
    }

    private static ChatMessageContent GenerateFunctionCallContent(string agentName, IList<FunctionCallContent> functionCalls)
    {
        ChatMessageContent functionCallContent = new(AuthorRole.Assistant, content: null)
        {
            AuthorName = agentName
        };

        functionCallContent.Items.AddRange(functionCalls);

        return functionCallContent;
    }

    private static ChatMessageContent GenerateFunctionResultContent(string agentName, IEnumerable<FunctionResultContent> functionResults, RunStep completedStep)
    {
        ChatMessageContent functionResultContent = new(AuthorRole.Tool, content: null)
        {
            AuthorName = agentName,
            Metadata = GenerateToolCallMetadata(completedStep),
        };

        foreach (FunctionResultContent functionResult in functionResults)
        {
            functionResultContent.Items.Add(
                new FunctionResultContent(
                    functionResult.FunctionName,
                    functionResult.PluginName,
                    functionResult.CallId,
                    functionResult.Result));
        }

        return functionResultContent;
    }

    private static Dictionary<string, object?> GenerateToolCallMetadata(RunStep completedStep)
    {
        return new()
            {
                { nameof(RunStep.CreatedAt), completedStep.CreatedAt },
                { nameof(RunStep.AssistantId), completedStep.AssistantId },
                { nameof(RunStep.ThreadId), completedStep.ThreadId },
                { nameof(RunStep.RunId), completedStep.RunId },
                { nameof(RunStepDetailsUpdate.StepId), completedStep.Id },
                { nameof(RunStep.Usage), completedStep.Usage },
            };
    }

    private static ToolOutput[] GenerateToolOutputs(FunctionResultContent[] functionResults)
    {
        ToolOutput[] toolOutputs = new ToolOutput[functionResults.Length];

        for (int index = 0; index < functionResults.Length; ++index)
        {
            FunctionResultContent functionResult = functionResults[index];

            object resultValue = functionResult.Result ?? string.Empty;

            if (resultValue is not string textResult)
            {
                textResult = JsonSerializer.Serialize(resultValue);
            }

            toolOutputs[index] = new ToolOutput(functionResult.CallId, textResult!);
        }

        return toolOutputs;
    }

    private static async Task<ThreadMessage?> RetrieveMessageAsync(AssistantClient client, string threadId, string messageId, TimeSpan syncDelay, CancellationToken cancellationToken)
    {
        ThreadMessage? message = null;

        bool retry = false;
        int count = 0;
        do
        {
            try
            {
                message = await client.GetMessageAsync(threadId, messageId, cancellationToken).ConfigureAwait(false);
            }
            catch (RequestFailedException exception)
            {
                // Step has provided the message-id.  Retry on of NotFound/404 exists.
                // Extremely rarely there might be a synchronization issue between the
                // assistant response and message-service.
                retry = exception.Status == (int)HttpStatusCode.NotFound && count < 3;
            }

            if (retry)
            {
                await Task.Delay(syncDelay, cancellationToken).ConfigureAwait(false);
            }

            ++count;
        }
        while (retry);

        return message;
    }
}


===== OpenAI\Internal\AssistantToolResourcesFactory.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Collections.Generic;
using OpenAI.Assistants;

namespace Microsoft.SemanticKernel.Agents.OpenAI.Internal;

/// <summary>
/// Factory for creating <see cref="ToolResources"/> definition.
/// </summary>
/// <remarks>
/// Improves testability.
/// </remarks>
internal static class AssistantToolResourcesFactory
{
    /// <summary>
    /// Produces a <see cref="ToolResources"/> definition based on the provided parameters.
    /// </summary>
    /// <param name="vectorStoreId">An optional vector-store-id for the 'file_search' tool</param>
    /// <param name="codeInterpreterFileIds">An optional list of file-identifiers for the 'code_interpreter' tool.</param>
    public static ToolResources? GenerateToolResources(string? vectorStoreId, IReadOnlyList<string>? codeInterpreterFileIds)
    {
        bool hasVectorStore = !string.IsNullOrWhiteSpace(vectorStoreId);
        bool hasCodeInterpreterFiles = (codeInterpreterFileIds?.Count ?? 0) > 0;

        ToolResources? toolResources = null;

        if (hasVectorStore || hasCodeInterpreterFiles)
        {
            FileSearchToolResources? fileSearch =
                hasVectorStore ?
                    new()
                    {
                        VectorStoreIds = { vectorStoreId! }
                    } :
                    null;

            CodeInterpreterToolResources? codeInterpreter =
                hasCodeInterpreterFiles ?
                    new() :
                    null;
            codeInterpreter?.FileIds.AddRange(codeInterpreterFileIds!);

            toolResources = new ToolResources
            {
                FileSearch = fileSearch,
                CodeInterpreter = codeInterpreter
            };
        }

        return toolResources;
    }
}


===== OpenAI\Internal\ResponseCreationOptionsFactory.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Linq;
using Microsoft.SemanticKernel.Agents.Extensions;
using OpenAI.Responses;

namespace Microsoft.SemanticKernel.Agents.OpenAI.Internal;

/// <summary>
/// Factory for creating instances of <see cref="ResponseCreationOptions"/>.
/// </summary>
internal static class ResponseCreationOptionsFactory
{
    internal static ResponseCreationOptions CreateOptions(
        OpenAIResponseAgent agent,
        AgentThread agentThread,
        AgentInvokeOptions? invokeOptions)
    {
        var instructions = $"{agent.Instructions}{(string.IsNullOrEmpty(agent.Instructions) || string.IsNullOrEmpty(invokeOptions?.AdditionalInstructions) ? "" : "\n")}{invokeOptions?.AdditionalInstructions}";
        ResponseCreationOptions creationOptions;
        if (invokeOptions is OpenAIResponseAgentInvokeOptions responseAgentInvokeOptions &&
            responseAgentInvokeOptions.ResponseCreationOptions is not null)
        {
            creationOptions = new ResponseCreationOptions
            {
                EndUserId = responseAgentInvokeOptions.ResponseCreationOptions.EndUserId ?? agent.GetDisplayName(),
                Instructions = responseAgentInvokeOptions.ResponseCreationOptions.Instructions ?? instructions,
                StoredOutputEnabled = responseAgentInvokeOptions.ResponseCreationOptions.StoredOutputEnabled ?? agent.StoreEnabled,
                BackgroundModeEnabled = responseAgentInvokeOptions.ResponseCreationOptions.BackgroundModeEnabled,
                ReasoningOptions = responseAgentInvokeOptions.ResponseCreationOptions.ReasoningOptions,
                MaxOutputTokenCount = responseAgentInvokeOptions.ResponseCreationOptions.MaxOutputTokenCount,
                TextOptions = responseAgentInvokeOptions.ResponseCreationOptions.TextOptions,
                TruncationMode = responseAgentInvokeOptions.ResponseCreationOptions.TruncationMode,
                ParallelToolCallsEnabled = responseAgentInvokeOptions.ResponseCreationOptions.ParallelToolCallsEnabled,
                ToolChoice = responseAgentInvokeOptions.ResponseCreationOptions.ToolChoice,
                Temperature = responseAgentInvokeOptions.ResponseCreationOptions.Temperature,
                TopP = responseAgentInvokeOptions.ResponseCreationOptions.TopP,
                PreviousResponseId = responseAgentInvokeOptions.ResponseCreationOptions.PreviousResponseId,
            };
            creationOptions.Tools.AddRange(responseAgentInvokeOptions.ResponseCreationOptions.Tools);
            responseAgentInvokeOptions.ResponseCreationOptions.Metadata.ToList().ForEach(kvp => creationOptions.Metadata[kvp.Key] = kvp.Value);
        }
        else
        {
            creationOptions = new ResponseCreationOptions
            {
                EndUserId = agent.GetDisplayName(),
                Instructions = instructions,
                StoredOutputEnabled = agent.StoreEnabled,
            };
        }

        if (agent.StoreEnabled && agentThread.Id is not null)
        {
            creationOptions.PreviousResponseId = agentThread.Id;
        }

        var responseTools = agent.GetKernel(invokeOptions).Plugins
            .SelectMany(kp => kp.Select(kf => kf.ToResponseTool(kp.Name)));
        if (responseTools is not null && responseTools.Any())
        {
            creationOptions.Tools.AddRange(responseTools);
            creationOptions.ToolChoice = ResponseToolChoice.CreateAutoChoice();
            creationOptions.ParallelToolCallsEnabled = true;
        }

        return creationOptions;
    }
}


===== OpenAI\Internal\ResponseThreadActions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.SemanticKernel.Agents.Extensions;
using Microsoft.SemanticKernel.ChatCompletion;
using Microsoft.SemanticKernel.Connectors.FunctionCalling;
using OpenAI.Responses;

namespace Microsoft.SemanticKernel.Agents.OpenAI.Internal;

/// <summary>
/// Actions associated with an OpeAI Responses thread.
/// </summary>
[ExcludeFromCodeCoverage]
internal static class ResponseThreadActions
{
    internal static async IAsyncEnumerable<ChatMessageContent> InvokeAsync(
        OpenAIResponseAgent agent,
        ChatHistory history,
        AgentThread agentThread,
        AgentInvokeOptions options,
        [EnumeratorCancellation] CancellationToken cancellationToken)
    {
        var responseAgentThread = agentThread as OpenAIResponseAgentThread;

        var overrideHistory = history;
        if (!agent.StoreEnabled)
        {
            // Use the thread chat history
            overrideHistory = [.. GetChatHistory(agentThread)];
        }

        var creationOptions = ResponseCreationOptionsFactory.CreateOptions(agent, agentThread, options);

        var inputItems = overrideHistory.Select(c => c.ToResponseItem()).ToList();
        FunctionCallsProcessor functionProcessor = new();
        FunctionChoiceBehaviorOptions functionOptions = new() { AllowConcurrentInvocation = true, AllowParallelCalls = true, RetainArgumentTypes = true };
        for (int requestIndex = 0; ; requestIndex++)
        {
            // Create a response using the OpenAI Responses API
            var clientResult = await agent.Client.CreateResponseAsync(inputItems, creationOptions, cancellationToken).ConfigureAwait(false);
            var response = clientResult.Value;
            ThrowIfIncompleteOrFailed(agent, response);

            // Update the response ID in the creation options
            if (responseAgentThread is not null)
            {
                creationOptions.PreviousResponseId = response.Id;
                responseAgentThread.ResponseId = response.Id;
            }
            else
            {
                var filteredItems = response.OutputItems
                    .Where(item => item is not ReasoningResponseItem); // Keep items that are not ReasoningResponseItem  
                inputItems.AddRange(filteredItems);
            }

            var message = response.ToChatMessageContent();
            overrideHistory.Add(message);
            yield return message;

            // Reached maximum auto invocations
            if (requestIndex == MaximumAutoInvokeAttempts)
            {
                break;
            }

            // Check if there are any functions to invoke.
            var functionCalls = response.OutputItems
                .OfType<FunctionCallResponseItem>()
                .Select(f => f.ToFunctionCallContent())
                .ToList();
            if (functionCalls.Count == 0)
            {
                break;
            }

            // Invoke functions and create function output items for results
            FunctionResultContent[] functionResults =
                await functionProcessor.InvokeFunctionCallsAsync(
                    message,
                    (_) => true,
                    functionOptions,
                    agent.GetKernel(options),
                    isStreaming: false,
                    cancellationToken).ConfigureAwait(false);
            var functionOutputItems = functionResults.Select(fr => ResponseItem.CreateFunctionCallOutputItem(fr.CallId, fr.Result?.ToString() ?? string.Empty)).ToList();

            // If store is enabled we only need to send the function output items
            if (agent.StoreEnabled)
            {
                inputItems = [.. functionOutputItems];
            }
            else
            {
                inputItems.AddRange(functionOutputItems);
            }

            // Return the function results as a message
            ChatMessageContentItemCollection items = [.. functionResults];
            ChatMessageContent functionResultMessage = new()
            {
                Role = AuthorRole.Tool,
                Items = items,
            };
            overrideHistory.Add(functionResultMessage);
            yield return functionResultMessage;
        }
    }

    internal static async IAsyncEnumerable<StreamingChatMessageContent> InvokeStreamingAsync(
        OpenAIResponseAgent agent,
        ChatHistory history,
        AgentThread agentThread,
        AgentInvokeOptions? options,
        [EnumeratorCancellation] CancellationToken cancellationToken)
    {
        var responseAgentThread = agentThread as OpenAIResponseAgentThread;

        var overrideHistory = history;
        if (!agent.StoreEnabled)
        {
            // Use the thread chat history
            overrideHistory = [.. GetChatHistory(agentThread)];
        }

        var inputItems = overrideHistory.Select(m => m.ToResponseItem()).ToList();
        var creationOptions = ResponseCreationOptionsFactory.CreateOptions(agent, agentThread, options);

        FunctionCallsProcessor functionProcessor = new();
        FunctionChoiceBehaviorOptions functionOptions = new() { AllowConcurrentInvocation = true, AllowParallelCalls = true, RetainArgumentTypes = true };
        ChatMessageContent? message = null;
        for (int requestIndex = 0; ; requestIndex++)
        {
            // Make the call to the OpenAIResponseClient and process the streaming results.
            DateTimeOffset? createdAt = null;
            string? responseId = null;
            string? modelId = null;
            AuthorRole? lastRole = null;
            Dictionary<int, MessageResponseItem> outputIndexToMessages = [];
            Dictionary<int, FunctionCallInfo>? functionCallInfos = null;
            StreamingFunctionCallUpdateContent? functionCallUpdateContent = null;
            OpenAIResponse? response = null;
            await foreach (var streamingUpdate in agent.Client.CreateResponseStreamingAsync(inputItems, creationOptions, cancellationToken).ConfigureAwait(false))
            {
                switch (streamingUpdate)
                {
                    case StreamingResponseCreatedUpdate createdUpdate:
                        createdAt = createdUpdate.Response.CreatedAt;
                        responseId = createdUpdate.Response.Id;
                        modelId = createdUpdate.Response.Model;
                        break;

                    case StreamingResponseCompletedUpdate completedUpdate:
                        response = completedUpdate.Response;
                        message = completedUpdate.Response.ToChatMessageContent();
                        overrideHistory.Add(message);
                        break;

                    case StreamingResponseOutputItemAddedUpdate outputItemAddedUpdate:
                        switch (outputItemAddedUpdate.Item)
                        {
                            case MessageResponseItem mri:
                                outputIndexToMessages[outputItemAddedUpdate.OutputIndex] = mri;
                                break;

                            case FunctionCallResponseItem fcri:
                                (functionCallInfos ??= [])[outputItemAddedUpdate.OutputIndex] = new(fcri);
                                break;
                        }

                        break;

                    case StreamingResponseOutputItemDoneUpdate outputItemDoneUpdate:
                        _ = outputIndexToMessages.Remove(outputItemDoneUpdate.OutputIndex);
                        break;

                    case StreamingResponseOutputTextDeltaUpdate outputTextDeltaUpdate:
                        _ = outputIndexToMessages.TryGetValue(outputTextDeltaUpdate.OutputIndex, out MessageResponseItem? messageItem);
                        lastRole = messageItem?.Role.ToAuthorRole();
                        yield return outputTextDeltaUpdate.ToStreamingChatMessageContent(modelId, lastRole);

                        break;

                    case StreamingResponseFunctionCallArgumentsDeltaUpdate functionCallArgumentsDeltaUpdate:
                    {
                        if (functionCallInfos?.TryGetValue(functionCallArgumentsDeltaUpdate.OutputIndex, out FunctionCallInfo? callInfo) is true)
                        {
                            _ = (callInfo.Arguments ??= new()).Append(functionCallArgumentsDeltaUpdate.Delta);
                        }

                        break;
                    }

                    case StreamingResponseFunctionCallArgumentsDoneUpdate functionCallOutputDoneUpdate:
                    {
                        if (functionCallInfos?.TryGetValue(functionCallOutputDoneUpdate.OutputIndex, out FunctionCallInfo? callInfo) is true)
                        {
                            _ = functionCallInfos.Remove(functionCallOutputDoneUpdate.OutputIndex);

                            functionCallUpdateContent = callInfo.ResponseItem.ToStreamingFunctionCallUpdateContent(callInfo.Arguments?.ToString() ?? string.Empty);

                            yield return new StreamingChatMessageContent(
                                lastRole ?? AuthorRole.Assistant,
                                content: null)
                            {
                                ModelId = modelId,
                                InnerContent = functionCallOutputDoneUpdate,
                                Items = [functionCallUpdateContent],
                            };
                        }

                        break;
                    }

                    case StreamingResponseErrorUpdate errorUpdate:
                        yield return errorUpdate.ToStreamingChatMessageContent(modelId, lastRole);
                        break;

                    case StreamingResponseRefusalDoneUpdate refusalDone:
                        yield return refusalDone.ToStreamingChatMessageContent(modelId, lastRole);
                        break;
                }
            }

            // Update the response ID in the creation options
            if (responseAgentThread is not null)
            {
                creationOptions.PreviousResponseId = responseId;
                responseAgentThread.ResponseId = responseId;
            }
            else if (response is not null)
            {
                inputItems.AddRange(response.OutputItems);
            }

            // Reached maximum auto invocations
            if (requestIndex == MaximumAutoInvokeAttempts)
            {
                break;
            }

            // Check if there a function to invoke.
            if (functionCallUpdateContent is null)
            {
                break;
            }

            // Invoke functions and create function output items for results
            FunctionResultContent[] functionResults =
                await functionProcessor.InvokeFunctionCallsAsync(
                    message!,
                    (_) => true,
                    functionOptions,
                    agent.GetKernel(options),
                    isStreaming: true,
                    cancellationToken).ConfigureAwait(false);
            var functionOutputItems = functionResults.Select(fr => ResponseItem.CreateFunctionCallOutputItem(fr.CallId, fr.Result?.ToString() ?? string.Empty)).ToList();

            // If store is enabled we only need to send the function output items
            if (agent.StoreEnabled)
            {
                inputItems = [.. functionOutputItems];
            }
            else
            {
                inputItems.AddRange(functionOutputItems);
            }

            // Return the function results as a message
            ChatMessageContentItemCollection items = [.. functionResults];
            ChatMessageContent functionResultMessage = new()
            {
                Role = AuthorRole.Tool,
                Items = items,
            };
            StreamingChatMessageContent streamingFunctionResultMessage =
                new(AuthorRole.Tool,
                    content: null)
                {
                    ModelId = modelId,
                    InnerContent = functionCallUpdateContent,
                    Items = [functionCallUpdateContent],
                };
            overrideHistory.Add(functionResultMessage);
            yield return streamingFunctionResultMessage;
        }
    }

    private static ChatHistory GetChatHistory(AgentThread agentThread)
    {
        if (agentThread is ChatHistoryAgentThread chatHistoryAgentThread)
        {
            return chatHistoryAgentThread.ChatHistory;
        }

        throw new InvalidOperationException("The agent thread is not a ChatHistoryAgentThread.");
    }

    private static void ThrowIfIncompleteOrFailed(OpenAIResponseAgent agent, OpenAIResponse response)
    {
        if (response.Status == ResponseStatus.Incomplete || response.Status == ResponseStatus.Failed)
        {
            throw new KernelException(
                $"Run failed with status: `{response.Status}` for agent `{agent.Name}` with error: {response.Error.Message} or incomplete details: {response.IncompleteStatusDetails.Reason}");
        }
    }

    /// <summary>POCO representing function calling info.</summary>
    /// <remarks>Used to concatenation information for a single function call from across multiple streaming updates.</remarks>
    private sealed class FunctionCallInfo(FunctionCallResponseItem item)
    {
        public readonly FunctionCallResponseItem ResponseItem = item;
        public StringBuilder? Arguments;
    }

    private const int MaximumAutoInvokeAttempts = 128;
}


===== OpenAI\Logging\AssistantThreadActionsLogMessages.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.Diagnostics.CodeAnalysis;
using Microsoft.Extensions.Logging;
using Microsoft.SemanticKernel.Agents.OpenAI.Internal;
using OpenAI.Assistants;

namespace Microsoft.SemanticKernel.Agents.OpenAI;

#pragma warning disable SYSLIB1006 // Multiple logging methods cannot use the same event id within a class

/// <summary>
/// Extensions for logging <see cref="AssistantThreadActions"/>.
/// </summary>
/// <remarks>
/// This extension uses the <see cref="LoggerMessageAttribute"/> to
/// generate logging code at compile time to achieve optimized code.
/// </remarks>
[ExcludeFromCodeCoverage]
internal static partial class AssistantThreadActionsLogMessages
{
    /// <summary>
    /// Logs <see cref="AssistantThreadActions"/> creating run (started).
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Debug,
        Message = "[{MethodName}] Creating run for thread: {ThreadId}.")]
    public static partial void LogOpenAIAssistantCreatingRun(
        this ILogger logger,
        string methodName,
        string threadId);

    /// <summary>
    /// Logs <see cref="AssistantThreadActions"/> created run (complete).
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Information,
        Message = "[{MethodName}] Created run for thread: {RunId}/{ThreadId}.")]
    public static partial void LogOpenAIAssistantCreatedRun(
        this ILogger logger,
        string methodName,
        string runId,
        string threadId);

    /// <summary>
    /// Logs <see cref="AssistantThreadActions"/> completed run (complete).
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Information,
        Message = "[{MethodName}] Completed run for thread: {RunId}/{ThreadId}.")]
    public static partial void LogOpenAIAssistantCompletedRun(
        this ILogger logger,
        string methodName,
        string runId,
        string threadId);

    /// <summary>
    /// Logs <see cref="AssistantThreadActions"/> processing run steps (started).
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Debug,
        Message = "[{MethodName}] Processing run steps for thread: {RunId}/{ThreadId}.")]
    public static partial void LogOpenAIAssistantProcessingRunSteps(
        this ILogger logger,
        string methodName,
        string runId,
        string threadId);

    /// <summary>
    /// Logs <see cref="AssistantThreadActions"/> processed run steps (complete).
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Information,
        Message = "[{MethodName}] Processed #{stepCount} run steps: {RunId}/{ThreadId}.")]
    public static partial void LogOpenAIAssistantProcessedRunSteps(
        this ILogger logger,
        string methodName,
        int stepCount,
        string runId,
        string threadId);

    /// <summary>
    /// Logs <see cref="AssistantThreadActions"/> processing run messages (started).
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Debug,
        Message = "[{MethodName}] Processing run messages for thread: {RunId}/{ThreadId}.")]
    public static partial void LogOpenAIAssistantProcessingRunMessages(
        this ILogger logger,
        string methodName,
        string runId,
        string threadId);

    /// <summary>
    /// Logs <see cref="AssistantThreadActions"/> processed run messages (complete).
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Information,
        Message = "[{MethodName}] Processed #{MessageCount} run steps: {RunId}/{ThreadId}.")]
    public static partial void LogOpenAIAssistantProcessedRunMessages(
        this ILogger logger,
        string methodName,
        int messageCount,
        string runId,
        string threadId);

    /// <summary>
    /// Logs <see cref="AssistantThreadActions"/> polling run status (started).
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Debug,
        Message = "[{MethodName}] Polling run status for thread: {RunId}/{ThreadId}.")]
    public static partial void LogOpenAIAssistantPollingRunStatus(
        this ILogger logger,
        string methodName,
        string runId,
        string threadId);

    /// <summary>
    /// Logs <see cref="AssistantThreadActions"/> polled run status (complete).
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Information,
        Message = "[{MethodName}] Run status is {RunStatus}: {RunId}/{ThreadId}.")]
    public static partial void LogOpenAIAssistantPolledRunStatus(
        this ILogger logger,
        string methodName,
        RunStatus runStatus,
        string runId,
        string threadId);

    /// <summary>
    /// Logs <see cref="AssistantThreadActions"/> polled run status (complete).
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Warning,
        Message = "[{MethodName}] Unknown annotation '{Type}': {RunId}/{ThreadId}.")]
    public static partial void LogOpenAIAssistantUnknownAnnotation(
        this ILogger logger,
        string methodName,
        string runId,
        string threadId,
        Type type);
}


===== OpenAI\Logging\OpenAIAssistantAgentLogMessages.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Diagnostics.CodeAnalysis;
using Microsoft.Extensions.Logging;

namespace Microsoft.SemanticKernel.Agents.OpenAI;

#pragma warning disable SYSLIB1006 // Multiple logging methods cannot use the same event id within a class

/// <summary>
/// Extensions for logging <see cref="AggregatorAgent"/> invocations.
/// </summary>
/// <remarks>
/// This extension uses the <see cref="LoggerMessageAttribute"/> to
/// generate logging code at compile time to achieve optimized code.
/// </remarks>
[ExcludeFromCodeCoverage]
internal static partial class OpenAIAssistantAgentLogMessages
{
    /// <summary>
    /// Logs <see cref="OpenAIAssistantAgent"/> creating channel (started).
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Debug,
        Message = "[{MethodName}] Creating assistant thread for {ChannelType}.")]
    public static partial void LogOpenAIAssistantAgentCreatingChannel(
        this ILogger logger,
        string methodName,
        string channelType);

    /// <summary>
    /// Logs <see cref="OpenAIAssistantAgent"/> created channel (complete).
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Information,
        Message = "[{MethodName}] Created assistant thread for {ChannelType}: #{ThreadId}.")]
    public static partial void LogOpenAIAssistantAgentCreatedChannel(
        this ILogger logger,
        string methodName,
        string channelType,
        string threadId);

    /// <summary>
    /// Logs <see cref="OpenAIAssistantAgent"/> restoring serialized channel (started).
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Debug,
        Message = "[{MethodName}] Restoring assistant channel for {ChannelType}: #{ThreadId}.")]
    public static partial void LogOpenAIAssistantAgentRestoringChannel(
        this ILogger logger,
        string methodName,
        string channelType,
        string threadId);

    /// <summary>
    /// Logs <see cref="OpenAIAssistantAgent"/> restored serialized channel (complete).
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Information,
        Message = "[{MethodName}] Restored assistant channel for {ChannelType}: #{ThreadId}.")]
    public static partial void LogOpenAIAssistantAgentRestoredChannel(
        this ILogger logger,
        string methodName,
        string channelType,
        string threadId);
}


===== OpenAI\OpenAIAssistantAgent.ClientFactory.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.ClientModel;
using System.ClientModel.Primitives;
using System.Diagnostics.CodeAnalysis;
using System.Net.Http;
using System.Threading;
using Azure.AI.OpenAI;
using Azure.Core;
using Microsoft.SemanticKernel.Http;
using OpenAI;

namespace Microsoft.SemanticKernel.Agents.OpenAI;

public sealed partial class OpenAIAssistantAgent : Agent
{
    /// <summary>
    /// Specifies a key that avoids an exception from OpenAI Client when a custom endpoint is provided without an API key.
    /// </summary>
    private const string SingleSpaceKey = " ";

    /// <summary>
    /// Produces an <see cref="AzureOpenAIClient"/>.
    /// </summary>
    /// <param name="apiKey">The API key.</param>
    /// <param name="endpoint">The service endpoint.</param>
    /// <param name="httpClient">A custom <see cref="HttpClient"/> for HTTP requests.</param>
    [ExcludeFromCodeCoverage]
    public static AzureOpenAIClient CreateAzureOpenAIClient(ApiKeyCredential apiKey, Uri endpoint, HttpClient? httpClient = null)
    {
        Verify.NotNull(apiKey, nameof(apiKey));
        Verify.NotNull(endpoint, nameof(endpoint));

        AzureOpenAIClientOptions clientOptions = CreateAzureClientOptions(httpClient);

        return new AzureOpenAIClient(endpoint, apiKey!, clientOptions);
    }

    /// <summary>
    /// Produces an <see cref="AzureOpenAIClient"/>.
    /// </summary>
    /// <param name="credential">The credentials.</param>
    /// <param name="endpoint">The service endpoint.</param>
    /// <param name="httpClient">A custom <see cref="HttpClient"/> for HTTP requests.</param>
    [ExcludeFromCodeCoverage]
    public static AzureOpenAIClient CreateAzureOpenAIClient(TokenCredential credential, Uri endpoint, HttpClient? httpClient = null)
    {
        Verify.NotNull(credential, nameof(credential));
        Verify.NotNull(endpoint, nameof(endpoint));

        AzureOpenAIClientOptions clientOptions = CreateAzureClientOptions(httpClient);

        return new AzureOpenAIClient(endpoint, credential, clientOptions);
    }

    /// <summary>
    /// Produces an <see cref="OpenAIClient"/>.
    /// </summary>
    /// <param name="endpoint">An optional endpoint.</param>
    /// <param name="httpClient">A custom <see cref="HttpClient"/> for HTTP requests.</param>
    [ExcludeFromCodeCoverage]
    public static OpenAIClient CreateOpenAIClient(Uri? endpoint = null, HttpClient? httpClient = null)
    {
        OpenAIClientOptions clientOptions = CreateOpenAIClientOptions(endpoint, httpClient);
        return new OpenAIClient(new ApiKeyCredential(SingleSpaceKey), clientOptions);
    }

    /// <summary>
    /// Produces an <see cref="OpenAIClient"/>.
    /// </summary>
    /// <param name="apiKey">The API key.</param>
    /// <param name="endpoint">An optional endpoint.</param>
    /// <param name="httpClient">A custom <see cref="HttpClient"/> for HTTP requests.</param>
    public static OpenAIClient CreateOpenAIClient(ApiKeyCredential apiKey, Uri? endpoint = null, HttpClient? httpClient = null)
    {
        OpenAIClientOptions clientOptions = CreateOpenAIClientOptions(endpoint, httpClient);
        return new OpenAIClient(apiKey, clientOptions);
    }

    private static AzureOpenAIClientOptions CreateAzureClientOptions(HttpClient? httpClient)
    {
        AzureOpenAIClientOptions options = new();

        ConfigureClientOptions(httpClient, options);

        return options;
    }

    private static OpenAIClientOptions CreateOpenAIClientOptions(Uri? endpoint, HttpClient? httpClient)
    {
        OpenAIClientOptions options = new()
        {
            Endpoint = endpoint ?? httpClient?.BaseAddress,
        };

        ConfigureClientOptions(httpClient, options);

        return options;
    }

    private static void ConfigureClientOptions(HttpClient? httpClient, ClientPipelineOptions options)
    {
        options.AddPolicy(CreateRequestHeaderPolicy(HttpHeaderConstant.Names.SemanticKernelVersion, HttpHeaderConstant.Values.GetAssemblyVersion(typeof(OpenAIAssistantAgent))), PipelinePosition.PerCall);
        options.AddPolicy(CreateRequestHeaderPolicy(HttpHeaderConstant.Names.UserAgent, $"{HttpHeaderConstant.Values.UserAgent} {nameof(OpenAIAssistantAgent)}"), PipelinePosition.PerCall);

        if (httpClient is not null)
        {
            options.Transport = new HttpClientPipelineTransport(httpClient);
            options.RetryPolicy = new ClientRetryPolicy(maxRetries: 0); // Disable retry policy if and only if a custom HttpClient is provided.
            options.NetworkTimeout = Timeout.InfiniteTimeSpan; // Disable default timeout
        }
    }

    private static GenericActionPipelinePolicy CreateRequestHeaderPolicy(string headerName, string headerValue)
        =>
            new((message) =>
            {
                var headers = message?.Request?.Headers;

                if (headers is not null)
                {
                    var value = !headers.TryGetValue(headerName, out string? existingHeaderValue) || string.IsNullOrWhiteSpace(existingHeaderValue) ?
                        headerValue :
                        $"{headerValue} {existingHeaderValue}";

                    headers.Set(headerName, value);
                }
            });
}


===== OpenAI\OpenAIAssistantAgent.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.SemanticKernel.Agents.Extensions;
using Microsoft.SemanticKernel.Agents.OpenAI.Internal;
using Microsoft.SemanticKernel.ChatCompletion;
using Microsoft.SemanticKernel.Diagnostics;
using OpenAI.Assistants;

namespace Microsoft.SemanticKernel.Agents.OpenAI;

/// <summary>
/// Represents a <see cref="Agent"/> specialization based on Open AI Assistant / GPT.
/// </summary>
public sealed partial class OpenAIAssistantAgent : Agent
{
    /// <summary>
    /// The metadata key that identifies code-interpreter content.
    /// </summary>
    public const string CodeInterpreterMetadataKey = "code";

    internal const string OptionsMetadataKey = "__run_options";
    internal const string TemplateMetadataKey = "__template_format";

    /// <summary>
    /// Initializes a new instance of the <see cref="OpenAIAssistantAgent"/> class.
    /// </summary>
    /// <param name="definition">The assistant definition.</param>
    /// <param name="client">The OpenAI provider for accessing the Assistant API service.</param>
    /// <param name="plugins">Optional collection of plugins to add to the kernel.</param>
    /// <param name="templateFactory">An optional factory to produce the <see cref="IPromptTemplate"/> for the agent.</param>
    /// <param name="templateFormat">The format of the prompt template used when "templateFactory" parameter is supplied.</param>
    public OpenAIAssistantAgent(
        Assistant definition,
        AssistantClient client,
        IEnumerable<KernelPlugin>? plugins = null,
        IPromptTemplateFactory? templateFactory = null,
        string? templateFormat = null)
    {
        this.Client = client;

        this.Definition = definition;

        this.Description = this.Definition.Description;
        this.Id = this.Definition.Id;
        this.Name = this.Definition.Name;
        this.Instructions = this.Definition.Instructions;

        if (templateFactory != null)
        {
            Verify.NotNullOrWhiteSpace(templateFormat);

            PromptTemplateConfig templateConfig = new(this.Instructions)
            {
                TemplateFormat = templateFormat
            };

            this.Template = templateFactory.Create(templateConfig);
        }

        if (plugins != null)
        {
            this.Kernel.Plugins.AddRange(plugins);
        }
    }

    /// <summary>
    /// Expose client for additional use.
    /// </summary>
    public AssistantClient Client { get; }

    /// <summary>
    /// Gets the assistant definition.
    /// </summary>
    public Assistant Definition { get; }

    /// <summary>
    /// Gets the polling behavior for run processing.
    /// </summary>
    public RunPollingOptions PollingOptions { get; } = new();

    /// <summary>
    /// Gets or sets the run creation options for the assistant.
    /// </summary>
    public RunCreationOptions? RunOptions { get; init; }

    /// <inheritdoc/>
    public override IAsyncEnumerable<AgentResponseItem<ChatMessageContent>> InvokeAsync(
        ICollection<ChatMessageContent> messages,
        AgentThread? thread = null,
        AgentInvokeOptions? options = null,
        CancellationToken cancellationToken = default)
    {
        return this.InvokeAsync(
            messages,
            thread,
            options is null ?
                null :
                options is OpenAIAssistantAgentInvokeOptions openAIAssistantAgentInvokeOptions ? openAIAssistantAgentInvokeOptions : new OpenAIAssistantAgentInvokeOptions(options),
            cancellationToken);
    }

    /// <summary>
    /// Invoke the agent with the provided message and arguments.
    /// </summary>
    /// <param name="messages">The messages to pass to the agent.</param>
    /// <param name="thread">The conversation thread to continue with this invocation. If not provided, creates a new thread.</param>
    /// <param name="options">Optional parameters for agent invocation.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>An async list of response items that each contain a <see cref="ChatMessageContent"/> and an <see cref="AgentThread"/>.</returns>
    /// <remarks>
    /// To continue this thread in the future, use an <see cref="AgentThread"/> returned in one of the response items.
    /// </remarks>
    public async IAsyncEnumerable<AgentResponseItem<ChatMessageContent>> InvokeAsync(
        ICollection<ChatMessageContent> messages,
        AgentThread? thread = null,
        OpenAIAssistantAgentInvokeOptions? options = null,
        [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        Verify.NotNull(messages);

        OpenAIAssistantAgentThread openAIAssistantAgentThread = await this.EnsureThreadExistsWithMessagesAsync(
            messages,
            thread,
            () => new OpenAIAssistantAgentThread(this.Client),
            cancellationToken).ConfigureAwait(false);

        // Create options that use the RunCreationOptions from the options param if provided or
        // falls back to creating a new RunCreationOptions if additional instructions is provided
        // separately.
        var internalOptions = options?.RunCreationOptions ?? (string.IsNullOrWhiteSpace(options?.AdditionalInstructions) ? null : new RunCreationOptions()
        {
            AdditionalInstructions = options?.AdditionalInstructions,
        });

        Kernel kernel = this.GetKernel(options);
#pragma warning disable SKEXP0110, SKEXP0130 // Type is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.
        if (this.UseImmutableKernel)
        {
            kernel = kernel.Clone();
        }

        // Get the context contributions from the AIContextProviders.
        AIContext providersContext = await openAIAssistantAgentThread.AIContextProviders.ModelInvokingAsync(messages, cancellationToken).ConfigureAwait(false);

        // Check for compatibility AIContextProviders and the UseImmutableKernel setting.
        if (providersContext.AIFunctions is { Count: > 0 } && !this.UseImmutableKernel)
        {
            throw new InvalidOperationException("AIContextProviders with AIFunctions are not supported when Agent UseImmutableKernel setting is false.");
        }

        kernel.Plugins.AddFromAIContext(providersContext, "Tools");
#pragma warning restore SKEXP0110, SKEXP0130 // Type is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.

        using var activity = ModelDiagnostics.StartAgentInvocationActivity(this.Id, this.GetDisplayName(), this.Description, kernel, messages);
        List<ChatMessageContent>? chatMessageContents = activity is not null ? [] : null;

        // Notify the thread of new messages and return them to the caller.
        await foreach (var result in InternalInvokeAsync().ConfigureAwait(false))
        {
            yield return new(result, openAIAssistantAgentThread);
            chatMessageContents?.Add(result);
        }

        activity?.SetAgentResponse(chatMessageContents);

        async IAsyncEnumerable<ChatMessageContent> InternalInvokeAsync()
        {
            await foreach ((bool isVisible, ChatMessageContent message) in AssistantThreadActions.InvokeAsync(
                this,
                this.Client,
                openAIAssistantAgentThread.Id!,
                internalOptions,
                providersContext.Instructions,
                this.Logger,
                kernel,
                options?.KernelArguments,
                cancellationToken).ConfigureAwait(false))
            {
                // The thread and the caller should be notified of all messages regardless of visibility.
                await this.NotifyThreadOfNewMessage(openAIAssistantAgentThread, message, cancellationToken).ConfigureAwait(false);
                if (options?.OnIntermediateMessage is not null)
                {
                    await options.OnIntermediateMessage(message).ConfigureAwait(false);
                }

                if (isVisible)
                {
                    yield return message;
                }
            }
        }
    }

    /// <inheritdoc/>
    public override IAsyncEnumerable<AgentResponseItem<StreamingChatMessageContent>> InvokeStreamingAsync(
        ICollection<ChatMessageContent> messages,
        AgentThread? thread = null,
        AgentInvokeOptions? options = null,
        CancellationToken cancellationToken = default)
    {
        return this.InvokeStreamingAsync(
            messages,
            thread,
            options is null ?
                null :
                options is OpenAIAssistantAgentInvokeOptions openAIAssistantAgentInvokeOptions ? openAIAssistantAgentInvokeOptions : new OpenAIAssistantAgentInvokeOptions(options),
            cancellationToken);
    }

    /// <summary>
    /// Invoke the agent with the provided message and arguments.
    /// </summary>
    /// <param name="messages">The messages to pass to the agent.</param>
    /// <param name="thread">The conversation thread to continue with this invocation. If not provided, creates a new thread.</param>
    /// <param name="options">Optional parameters for agent invocation.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>An async list of response items that each contain a <see cref="StreamingChatMessageContent"/> and an <see cref="AgentThread"/>.</returns>
    /// <remarks>
    /// To continue this thread in the future, use an <see cref="AgentThread"/> returned in one of the response items.
    /// </remarks>
    public async IAsyncEnumerable<AgentResponseItem<StreamingChatMessageContent>> InvokeStreamingAsync(
        ICollection<ChatMessageContent> messages,
        AgentThread? thread = null,
        OpenAIAssistantAgentInvokeOptions? options = null,
        [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        Verify.NotNull(messages);

        OpenAIAssistantAgentThread openAIAssistantAgentThread = await this.EnsureThreadExistsWithMessagesAsync(
            messages,
            thread,
            () => new OpenAIAssistantAgentThread(this.Client),
            cancellationToken).ConfigureAwait(false);

        Kernel kernel = this.GetKernel(options);
#pragma warning disable SKEXP0110, SKEXP0130 // Type is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.
        if (this.UseImmutableKernel)
        {
            kernel = kernel.Clone();
        }

        // Get the context contributions from the AIContextProviders.
        AIContext providersContext = await openAIAssistantAgentThread.AIContextProviders.ModelInvokingAsync(messages, cancellationToken).ConfigureAwait(false);

        // Check for compatibility AIContextProviders and the UseImmutableKernel setting.
        if (providersContext.AIFunctions is { Count: > 0 } && !this.UseImmutableKernel)
        {
            throw new InvalidOperationException("AIContextProviders with AIFunctions are not supported when Agent UseImmutableKernel setting is false.");
        }

        kernel.Plugins.AddFromAIContext(providersContext, "Tools");
#pragma warning restore SKEXP0110, SKEXP0130 // Type is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.

        // Create options that use the RunCreationOptions from the options param if provided or
        // falls back to creating a new RunCreationOptions if additional instructions is provided
        // separately.
        var internalOptions = options?.RunCreationOptions ?? (string.IsNullOrWhiteSpace(options?.AdditionalInstructions) ? null : new RunCreationOptions()
        {
            AdditionalInstructions = options?.AdditionalInstructions,
        });

#pragma warning disable SKEXP0001 // ModelDiagnostics is marked experimental.
        using var activity = ModelDiagnostics.StartAgentInvocationActivity(this.Id, this.GetDisplayName(), this.Description, kernel, messages);
        List<StreamingChatMessageContent>? streamedContents = activity is not null ? [] : null;

        ChatHistory newMessagesReceiver = [];
        var invokeResults = InternalInvokeStreamingAsync();
#pragma warning restore SKEXP0001 // ModelDiagnostics is marked experimental.

        IAsyncEnumerable<StreamingChatMessageContent> InternalInvokeStreamingAsync()
        {
            return AssistantThreadActions.InvokeStreamingAsync(
                this,
                this.Client,
                openAIAssistantAgentThread.Id!,
                newMessagesReceiver,
                internalOptions,
                providersContext.Instructions,
                this.Logger,
                kernel,
                options?.KernelArguments,
                cancellationToken);
        }

        // Return the chunks to the caller.
        int messageIndex = 0;
        await foreach (var result in invokeResults.ConfigureAwait(false))
        {
            // Notify the thread of any messages that were assembled from the streaming response during this iteration.
            await NotifyMessagesAsync().ConfigureAwait(false);

            yield return new(result, openAIAssistantAgentThread);
            streamedContents?.Add(result);
        }

        // Notify the thread of any remaining messages that were assembled from the streaming response after all iterations are complete.
        await NotifyMessagesAsync().ConfigureAwait(false);

        activity?.EndAgentStreamingResponse(streamedContents);

        async Task NotifyMessagesAsync()
        {
            for (; messageIndex < newMessagesReceiver.Count; messageIndex++)
            {
                ChatMessageContent newMessage = newMessagesReceiver[messageIndex];
                await this.NotifyThreadOfNewMessage(openAIAssistantAgentThread, newMessage, cancellationToken).ConfigureAwait(false);

                if (options?.OnIntermediateMessage is not null)
                {
                    await options.OnIntermediateMessage(newMessage).ConfigureAwait(false);
                }
            }
        }
    }

    /// <inheritdoc/>
    [Experimental("SKEXP0110")]
    protected override IEnumerable<string> GetChannelKeys()
    {
        // Distinguish from other channel types.
        yield return typeof(OpenAIAssistantChannel).FullName!;
        // Distinguish based on client instance.
        yield return this.Client.GetHashCode().ToString();
    }

    /// <inheritdoc/>
    [Experimental("SKEXP0110")]
    protected override async Task<AgentChannel> CreateChannelAsync(CancellationToken cancellationToken)
    {
        this.Logger.LogOpenAIAssistantAgentCreatingChannel(nameof(CreateChannelAsync), nameof(OpenAIAssistantChannel));

        AssistantThread thread = await this.Client.CreateThreadAsync(options: null, cancellationToken).ConfigureAwait(false);

        this.Logger.LogInformation("[{MethodName}] Created assistant thread: {ThreadId}", nameof(CreateChannelAsync), thread.Id);

        OpenAIAssistantChannel channel =
            new(this.Client, thread.Id)
            {
                Logger = this.ActiveLoggerFactory.CreateLogger<OpenAIAssistantChannel>()
            };

        this.Logger.LogOpenAIAssistantAgentCreatedChannel(nameof(CreateChannelAsync), nameof(OpenAIAssistantChannel), thread.Id);

        return channel;
    }

    internal Task<string?> GetInstructionsAsync(Kernel kernel, KernelArguments? arguments, CancellationToken cancellationToken) =>
        this.RenderInstructionsAsync(kernel, arguments, cancellationToken);

    /// <inheritdoc/>
    [Experimental("SKEXP0110")]
    protected override async Task<AgentChannel> RestoreChannelAsync(string channelState, CancellationToken cancellationToken)
    {
        string threadId = channelState;

        this.Logger.LogOpenAIAssistantAgentRestoringChannel(nameof(RestoreChannelAsync), nameof(OpenAIAssistantChannel), threadId);

        AssistantThread thread = await this.Client.GetThreadAsync(threadId, cancellationToken).ConfigureAwait(false);

        this.Logger.LogOpenAIAssistantAgentRestoredChannel(nameof(RestoreChannelAsync), nameof(OpenAIAssistantChannel), threadId);

        return new OpenAIAssistantChannel(this.Client, thread.Id);
    }
}


===== OpenAI\OpenAIAssistantAgentExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Diagnostics.CodeAnalysis;
using System.Text.Json;
using MAAI = Microsoft.Agents.AI;

namespace Microsoft.SemanticKernel.Agents.OpenAI;

/// <summary>
/// Exposes a Semantic Kernel Agent Framework <see cref="OpenAIAssistantAgent"/> as a Microsoft Agent Framework <see cref="MAAI.AIAgent"/>.
/// </summary>
public static class OpenAIAssistantAgentExtensions
{
    /// <summary>
    /// Exposes a Semantic Kernel Agent Framework <see cref="OpenAIAssistantAgent"/> as a Microsoft Agent Framework <see cref="MAAI.AIAgent"/>.
    /// </summary>
    /// <param name="assistantAgent">The Semantic Kernel <see cref="OpenAIAssistantAgent"/> to expose as a Microsoft Agent Framework <see cref="MAAI.AIAgent"/>.</param>
    /// <returns>The Semantic Kernel Agent Framework <see cref="Agent"/> exposed as a Microsoft Agent Framework <see cref="MAAI.AIAgent"/></returns>
    [Experimental("SKEXP0110")]
    public static MAAI.AIAgent AsAIAgent(this OpenAIAssistantAgent assistantAgent)
        => assistantAgent.AsAIAgent(
            () => new OpenAIAssistantAgentThread(assistantAgent.Client),
            (json, options) =>
            {
                var agentId = JsonSerializer.Deserialize<string>(json);
                return agentId is null ? new OpenAIAssistantAgentThread(assistantAgent.Client) : new OpenAIAssistantAgentThread(assistantAgent.Client, agentId);
            },
            (thread, options) => JsonSerializer.SerializeToElement((thread as OpenAIAssistantAgentThread)?.Id));
}


===== OpenAI\OpenAIAssistantAgentInvokeOptions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using OpenAI.Assistants;

namespace Microsoft.SemanticKernel.Agents.OpenAI;

/// <summary>
/// Optional parameters for <see cref="OpenAIAssistantAgent"/> invocation.
/// </summary>
public sealed class OpenAIAssistantAgentInvokeOptions : AgentInvokeOptions
{
    /// <summary>
    /// Initializes a new instance of the <see cref="OpenAIAssistantAgentInvokeOptions"/> class.
    /// </summary>
    public OpenAIAssistantAgentInvokeOptions()
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="OpenAIAssistantAgentInvokeOptions"/> class by cloning the provided options.
    /// </summary>
    /// <param name="options">The options to clone.</param>
    public OpenAIAssistantAgentInvokeOptions(AgentInvokeOptions options)
        : base(options)
    {
        Verify.NotNull(options);
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="OpenAIAssistantAgentInvokeOptions"/> class by cloning the provided options.
    /// </summary>
    /// <param name="options">The options to clone.</param>
    public OpenAIAssistantAgentInvokeOptions(OpenAIAssistantAgentInvokeOptions options)
        : base(options)
    {
        Verify.NotNull(options);

        this.RunCreationOptions = options.RunCreationOptions;
    }

    /// <summary>
    /// Gets or sets the <see cref="RunCreationOptions"/> to use when creating the new run to execute the invocation.
    /// </summary>
    /// <remarks>
    /// If this property is set, then <see cref="AgentInvokeOptions.AdditionalInstructions"/> will not be used.
    /// Instead, please set the <see cref="RunCreationOptions.AdditionalInstructions"/> property to provide the
    /// additional instructions for the run.
    /// </remarks>
    public RunCreationOptions? RunCreationOptions { get; init; } = null;
}


===== OpenAI\OpenAIAssistantAgentThread.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.ClientModel;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.SemanticKernel.Agents.OpenAI.Internal;
using OpenAI.Assistants;

namespace Microsoft.SemanticKernel.Agents.OpenAI;

/// <summary>
/// Represents a conversation thread for an Open AI Assistant agent.
/// </summary>
public sealed class OpenAIAssistantAgentThread : AgentThread
{
    private readonly bool _useThreadConstructorExtension = false;
    private readonly AssistantClient _client;

    private readonly ThreadCreationOptions? _options;

    private readonly IEnumerable<ChatMessageContent>? _messages;
    private readonly IReadOnlyList<string>? _codeInterpreterFileIds;
    private readonly string? _vectorStoreId;
    private readonly IReadOnlyDictionary<string, string>? _metadata;

    /// <summary>
    /// Initializes a new instance of the <see cref="OpenAIAssistantAgentThread"/> class.
    /// </summary>
    /// <param name="client">The assistant client to use for interacting with threads.</param>
    public OpenAIAssistantAgentThread(AssistantClient client)
    {
        Verify.NotNull(client);

        this._client = client;
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="OpenAIAssistantAgentThread"/> class.
    /// </summary>
    /// <param name="client">The assistant client to use for interacting with threads.</param>
    /// <param name="options">The options to use when creating the thread.</param>
    public OpenAIAssistantAgentThread(AssistantClient client, ThreadCreationOptions options)
    {
        Verify.NotNull(client);

        this._client = client;
        this._options = options;
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="OpenAIAssistantAgentThread"/> class.
    /// </summary>
    /// <param name="client">The assistant client to use for interacting with threads.</param>
    /// <param name="messages">The initial messages for the thread.</param>
    /// <param name="codeInterpreterFileIds">The file IDs for the code interpreter tool.</param>
    /// <param name="vectorStoreId">The vector store identifier.</param>
    /// <param name="metadata">The metadata for the thread.</param>
    public OpenAIAssistantAgentThread(
        AssistantClient client,
        IEnumerable<ChatMessageContent>? messages = null,
        IReadOnlyList<string>? codeInterpreterFileIds = null,
        string? vectorStoreId = null,
        IReadOnlyDictionary<string, string>? metadata = null)
    {
        Verify.NotNull(client);

        this._useThreadConstructorExtension = true;

        this._client = client;
        this._messages = messages;
        this._codeInterpreterFileIds = codeInterpreterFileIds;
        this._vectorStoreId = vectorStoreId;
        this._metadata = metadata;
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="OpenAIAssistantAgentThread"/> class that resumes an existing thread.
    /// </summary>
    /// <param name="client">The assistant client to use for interacting with threads.</param>
    /// <param name="id">The ID of an existing thread to resume.</param>
    public OpenAIAssistantAgentThread(AssistantClient client, string id)
    {
        Verify.NotNull(client);
        Verify.NotNull(id);

        this._client = client;
        this.Id = id;
    }

    /// <summary>
    /// Creates the thread and returns the thread id.
    /// </summary>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>A task that completes when the thread has been created.</returns>
    public new Task CreateAsync(CancellationToken cancellationToken = default)
    {
        return base.CreateAsync(cancellationToken);
    }

    /// <inheritdoc />
    protected async override Task<string?> CreateInternalAsync(CancellationToken cancellationToken)
    {
        const string ErrorMessage = "The thread could not be created due to an error response from the service.";

        try
        {
            if (this._useThreadConstructorExtension)
            {
                return await this._client.CreateThreadAsync(this._messages, this._codeInterpreterFileIds, this._vectorStoreId, this._metadata, cancellationToken: cancellationToken).ConfigureAwait(false);
            }

            var assistantThreadResponse = await this._client.CreateThreadAsync(this._options, cancellationToken: cancellationToken).ConfigureAwait(false);
            return assistantThreadResponse.Value.Id;
        }
        catch (ClientResultException ex)
        {
            throw new AgentThreadOperationException(ErrorMessage, ex);
        }
        catch (AggregateException ex)
        {
            throw new AgentThreadOperationException(ErrorMessage, ex);
        }
    }

    /// <inheritdoc />
    protected override async Task DeleteInternalAsync(CancellationToken cancellationToken)
    {
        const string ErrorMessage = "The thread could not be deleted due to an error response from the service.";

        try
        {
            await this._client.DeleteThreadAsync(this.Id, cancellationToken).ConfigureAwait(false);
        }
        catch (ClientResultException ex) when (ex.Status == 404)
        {
            // Do nothing, since the thread was already deleted.
        }
        catch (ClientResultException ex)
        {
            throw new AgentThreadOperationException(ErrorMessage, ex);
        }
        catch (AggregateException ex)
        {
            throw new AgentThreadOperationException(ErrorMessage, ex);
        }
    }

    /// <inheritdoc />
    protected override async Task OnNewMessageInternalAsync(ChatMessageContent newMessage, CancellationToken cancellationToken = default)
    {
        const string ErrorMessage = "The message could not be added to the thread due to an error response from the service.";

        // If the message was generated by this agent, it is already in the thread and we shouldn't add it again.
        if (newMessage.Metadata == null || !newMessage.Metadata.TryGetValue("ThreadId", out var messageThreadId) || !string.Equals(messageThreadId, this.Id))
        {
            try
            {
                await AssistantThreadActions.CreateMessageAsync(this._client, this.Id!, newMessage, cancellationToken).ConfigureAwait(false);
            }
            catch (ClientResultException ex)
            {
                throw new AgentThreadOperationException(ErrorMessage, ex);
            }
            catch (AggregateException ex)
            {
                throw new AgentThreadOperationException(ErrorMessage, ex);
            }
        }
    }

    /// <summary>
    /// Asynchronously retrieves all messages in the thread.
    /// </summary>
    /// <param name="sortOrder">The order to return messages in.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>The messages in the thread.</returns>
    /// <exception cref="InvalidOperationException">The thread has been deleted.</exception>
    [Experimental("SKEXP0110")]
    public async IAsyncEnumerable<ChatMessageContent> GetMessagesAsync(MessageCollectionOrder? sortOrder = default, [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        if (this.IsDeleted)
        {
            throw new InvalidOperationException("This thread has been deleted and cannot be used anymore.");
        }

        if (this.Id is null)
        {
            await this.CreateAsync(cancellationToken).ConfigureAwait(false);
        }

        await foreach (var message in AssistantThreadActions.GetMessagesAsync(this._client, this.Id!, sortOrder, cancellationToken).ConfigureAwait(false))
        {
            yield return message;
        }
    }
}


===== OpenAI\OpenAIAssistantCapabilities.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Text.Json.Serialization;

namespace Microsoft.SemanticKernel.Agents.OpenAI;

/// <summary>
/// Defines the capabilities of an assistant.
/// </summary>
[Experimental("SKEXP0110")]
[Obsolete("Use the OpenAI.Assistants.AssistantClient.CreateAssistantAsync() to create an assistant definition.")]
public class OpenAIAssistantCapabilities
{
    /// <summary>
    /// Gets the AI model targeted by the agent.
    /// </summary>
    public string ModelId { get; }

    /// <summary>
    /// Gets the assistant's unique ID. (Ignored on create.)
    /// </summary>
    public string Id { get; init; } = string.Empty;

    /// <summary>
    /// Gets optional file IDs made available to the code-interpreter tool, if enabled.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public IReadOnlyList<string>? CodeInterpreterFileIds { get; init; }

    /// <summary>
    /// Gets a value that indicates whether the code-interpreter tool is enabled.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public bool EnableCodeInterpreter { get; init; }

    /// <summary>
    /// Gets a value that indicates whether the file_search tool is enabled.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public bool EnableFileSearch { get; init; }

    /// <summary>
    /// Gets a value that indicates whether the JSON response format is enabled.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public bool EnableJsonResponse { get; init; }

    /// <summary>
    /// Gets a set of up to 16 key/value pairs that can be attached to an agent, used for
    /// storing additional information about that object in a structured format.
    /// </summary>
    /// <remarks>
    /// Keys can be up to 64 characters in length, and values can be up to 512 characters in length.
    /// </remarks>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public IReadOnlyDictionary<string, string>? Metadata { get; init; }

    /// <summary>
    /// Gets the sampling temperature to use, between 0 and 2.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public float? Temperature { get; init; }

    /// <summary>
    /// Gets the probability mass of tokens whose results are considered in nucleus sampling.
    /// </summary>
    /// <remarks>
    /// It's recommended to set this property or <see cref="Temperature"/>, but not both.
    ///
    /// Nucleus sampling is an alternative to sampling with temperature where the model
    /// considers the results of the tokens with <see cref="TopP"/> probability mass.
    /// For example, 0.1 means only the tokens comprising the top 10% probability mass are considered.
    /// </remarks>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public float? TopP { get; init; }

    /// <summary>
    /// Gets the vector store ID. Requires file-search if specified.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public string? VectorStoreId { get; init; }

    /// <summary>
    /// Gets the default execution options for each agent invocation.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public OpenAIAssistantExecutionOptions? ExecutionOptions { get; init; }

    /// <summary>
    /// Initializes a new instance of the <see cref="OpenAIAssistantDefinition"/> class.
    /// </summary>
    /// <param name="modelId">The targeted model.</param>
    [JsonConstructor]
    public OpenAIAssistantCapabilities(string modelId)
    {
        Verify.NotNullOrWhiteSpace(modelId);

        this.ModelId = modelId;
    }
}


===== OpenAI\OpenAIAssistantChannel.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.ClientModel;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.SemanticKernel.Agents.Extensions;
using Microsoft.SemanticKernel.Agents.OpenAI.Internal;
using Microsoft.SemanticKernel.Diagnostics;
using OpenAI.Assistants;

namespace Microsoft.SemanticKernel.Agents.OpenAI;

/// <summary>
/// A <see cref="AgentChannel"/> specialization for use with <see cref="OpenAIAssistantAgent"/>.
/// </summary>
[Experimental("SKEXP0110")]
internal sealed class OpenAIAssistantChannel(AssistantClient client, string threadId)
    : AgentChannel<OpenAIAssistantAgent>
{
    private readonly AssistantClient _client = client;
    private readonly string _threadId = threadId;

    /// <inheritdoc/>
    protected override async Task ReceiveAsync(IEnumerable<ChatMessageContent> history, CancellationToken cancellationToken)
    {
        const string ErrorMessage = "The message could not be added to the thread due to an error response from the service.";

        foreach (ChatMessageContent message in history)
        {
            try
            {
                await AssistantThreadActions.CreateMessageAsync(this._client, this._threadId, message, cancellationToken).ConfigureAwait(false);
            }
            catch (ClientResultException ex)
            {
                throw new AgentThreadOperationException(ErrorMessage, ex);
            }
            catch (AggregateException ex)
            {
                throw new AgentThreadOperationException(ErrorMessage, ex);
            }
        }
    }

    /// <inheritdoc/>
    protected override IAsyncEnumerable<(bool IsVisible, ChatMessageContent Message)> InvokeAsync(
        OpenAIAssistantAgent agent,
        CancellationToken cancellationToken)
    {
        return ActivityExtensions.RunWithActivityAsync(
            () => ModelDiagnostics.StartAgentInvocationActivity(agent.Id, agent.GetDisplayName(), agent.Description, agent.Kernel, []),
            () => AssistantThreadActions.InvokeAsync(agent, this._client, this._threadId, invocationOptions: null, providersAdditionalInstructions: null, this.Logger, agent.Kernel, agent.Arguments, cancellationToken),
            cancellationToken);
    }

    /// <inheritdoc/>
    protected override IAsyncEnumerable<StreamingChatMessageContent> InvokeStreamingAsync(OpenAIAssistantAgent agent, IList<ChatMessageContent> messages, CancellationToken cancellationToken = default)
    {
        return ActivityExtensions.RunWithActivityAsync(
            () => ModelDiagnostics.StartAgentInvocationActivity(agent.Id, agent.GetDisplayName(), agent.Description, agent.Kernel, messages),
            () => AssistantThreadActions.InvokeStreamingAsync(agent, this._client, this._threadId, messages, invocationOptions: null, providersAdditionalInstructions: null, this.Logger, agent.Kernel, agent.Arguments, cancellationToken),
            cancellationToken);
    }

    /// <inheritdoc/>
    protected override IAsyncEnumerable<ChatMessageContent> GetHistoryAsync(CancellationToken cancellationToken)
    {
        return AssistantThreadActions.GetMessagesAsync(this._client, this._threadId, null, cancellationToken);
    }

    /// <inheritdoc/>
    protected override Task ResetAsync(CancellationToken cancellationToken = default) =>
        this._client.DeleteThreadAsync(this._threadId, cancellationToken);

    /// <inheritdoc/>
    protected override string Serialize() => this._threadId;
}


===== OpenAI\OpenAIAssistantDefinition.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.Diagnostics.CodeAnalysis;
using System.Text.Json.Serialization;

namespace Microsoft.SemanticKernel.Agents.OpenAI;

/// <summary>
/// Defines an assistant.
/// </summary>
[Experimental("SKEXP0110")]
[Obsolete("Use the OpenAI.Assistants.AssistantClient.CreateAssistantAsync() to create an assistant definition.")]
public sealed class OpenAIAssistantDefinition : OpenAIAssistantCapabilities
{
    /// <summary>
    /// Gets the description of the assistant.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public string? Description { get; init; }

    /// <summary>
    /// Gets the system instructions for the assistant to use.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public string? Instructions { get; init; }

    /// <summary>
    /// Gets the name of the assistant.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public string? Name { get; init; }

    /// <summary>
    /// Gets the captured template format for the assistant if needed for agent retrieval
    /// </summary>
    [JsonIgnore]
    public string? TemplateFactoryFormat
    {
        get
        {
            if (this.Metadata == null)
            {
                return null;
            }

            this.Metadata.TryGetValue(OpenAIAssistantAgent.TemplateMetadataKey, out string? templateFormat);

            return templateFormat;
        }
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="OpenAIAssistantDefinition"/> class.
    /// </summary>
    /// <param name="modelId">The targeted model.</param>
    [JsonConstructor]
    public OpenAIAssistantDefinition(string modelId)
        : base(modelId) { }
}


===== OpenAI\OpenAIAssistantExecutionOptions.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.Diagnostics.CodeAnalysis;
using System.Text.Json.Serialization;

namespace Microsoft.SemanticKernel.Agents.OpenAI;

/// <summary>
/// Defines assistant execution options for each invocation.
/// </summary>
/// <remarks>
/// These options are persisted as a single entry of the assistant's metadata with key: "__run_options".
/// </remarks>
[Experimental("SKEXP0110")]
[Obsolete("Use RunCreationOptions to specify assistant invocation behavior.")]
public sealed class OpenAIAssistantExecutionOptions
{
    /// <summary>
    /// Gets the additional instructions.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public string? AdditionalInstructions { get; init; }

    /// <summary>
    /// Gets the maximum number of completion tokens that can be used over the course of the run.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public int? MaxCompletionTokens { get; init; }

    /// <summary>
    /// Gets the maximum number of prompt tokens that can be used over the course of the run.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public int? MaxPromptTokens { get; init; }

    /// <summary>
    /// Gets a value that indicates whether parallel function calling is enabled during tool use.
    /// </summary>
    /// <value>
    /// <see langword="true"/> if parallel function calling is enabled during tool use; otherwise, <see langword="false"/>. The default is <see langword="true"/>.
    /// </value>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public bool? ParallelToolCallsEnabled { get; init; }

    /// <summary>
    /// Gets the number of recent messages that the thread will be truncated to.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public int? TruncationMessageCount { get; init; }
}


===== OpenAI\OpenAIAssistantInvocationOptions.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Text.Json.Serialization;

namespace Microsoft.SemanticKernel.Agents.OpenAI;

/// <summary>
/// Defines per-invocation execution options that override the assistant definition.
/// </summary>
/// <remarks>
/// This class is not applicable to <see cref="AgentChat"/> usage.
/// </remarks>
[Experimental("SKEXP0110")]
[Obsolete("Use RunCreationOptions to specify assistant invocation behavior.")]
public sealed class OpenAIAssistantInvocationOptions
{
    /// <summary>
    /// Gets the AI model targeted by the agent.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public string? ModelName { get; init; }

    /// <summary>
    /// Gets the additional instructions.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public string? AdditionalInstructions { get; init; }

    /// <summary>
    /// Gets additional messages to add to the thread.
    /// </summary>
    /// <remarks>
    /// This property only supports messages with <see href="https://platform.openai.com/docs/api-reference/runs/createRun#runs-createrun-additional_messages">role = User or Assistant</see>.
    /// </remarks>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public IReadOnlyList<ChatMessageContent>? AdditionalMessages { get; init; }

    /// <summary>
    /// Gets a value that indicates if the code_interpreter tool is enabled.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public bool EnableCodeInterpreter { get; init; }

    /// <summary>
    /// Gets a value that indicates if the file_search tool is enabled.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public bool EnableFileSearch { get; init; }

    /// <summary>
    /// Gets a value that indicates if the JSON response format is enabled.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public bool? EnableJsonResponse { get; init; }

    /// <summary>
    /// Gets the maximum number of completion tokens that can be used over the course of the run.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public int? MaxCompletionTokens { get; init; }

    /// <summary>
    /// Gets the maximum number of prompt tokens that can be used over the course of the run.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public int? MaxPromptTokens { get; init; }

    /// <summary>
    /// Gets a value that indicates whether parallel function calling is enabled during tool use.
    /// </summary>
    /// <value>
    /// <see langword="true"/> if parallel function calling is enabled during tool use; otherwise, <see langword="false"/>. The default is <see langword="true"/>.
    /// </value>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public bool? ParallelToolCallsEnabled { get; init; }

    /// <summary>
    /// Gets the number of recent messages that the thread will be truncated to.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public int? TruncationMessageCount { get; init; }

    /// <summary>
    /// Gets the sampling temperature to use, between 0 and 2.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public float? Temperature { get; init; }

    /// <summary>
    /// Gets the probability mass of tokens whose results are considered in nucleus sampling.
    /// </summary>
    /// <remarks>
    /// It's recommended to set this property or <see cref="Temperature"/>, but not both.
    ///
    /// Nucleus sampling is an alternative to sampling with temperature where the model
    /// considers the results of the tokens with <see cref="TopP"/> probability mass.
    /// For example, 0.1 means only the tokens comprising the top 10% probability mass are considered.
    /// </remarks>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public float? TopP { get; init; }

    /// <summary>
    /// Gets a set of up to 16 key/value pairs that can be attached to an agent, used for
    /// storing additional information about that object in a structured format.
    /// </summary>
    /// <remarks>
    /// Keys can be up to 64 characters in length, and values can be up to 512 characters in length.
    /// </remarks>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public IReadOnlyDictionary<string, string>? Metadata { get; init; }
}


===== OpenAI\OpenAIClientProvider.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.ClientModel;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Net.Http;
using System.Threading;
using Azure.AI.OpenAI;
using Azure.Core;
using Microsoft.SemanticKernel.Http;
using OpenAI;
using OpenAI.Assistants;

namespace Microsoft.SemanticKernel.Agents.OpenAI;

/// <summary>
/// Provides an <see cref="OpenAIClient"/> for use by <see cref="OpenAIAssistantAgent"/>.
/// </summary>
[Experimental("SKEXP0110")]
[Obsolete("Use OpenAIAssistantAgent.CreateAzureOpenAIClient(...) or OpenAIAssistantAgent.CreateOpenAIClient(...)")]
public sealed class OpenAIClientProvider
{
    /// <summary>
    /// Specifies a key that avoids an exception from OpenAI Client when a custom endpoint is provided without an API key.
    /// </summary>
    private const string SingleSpaceKey = " ";
    private AssistantClient? _assistantClient;

    /// <summary>
    /// Gets an active client instance.
    /// </summary>
    public OpenAIClient Client { get; }

    /// <summary>
    /// Gets an active assistant client instance.
    /// </summary>
    public AssistantClient AssistantClient => this._assistantClient ??= this.Client.GetAssistantClient();

    /// <summary>
    /// Gets configuration keys required for <see cref="AgentChannel"/> management.
    /// </summary>
    internal IReadOnlyList<string> ConfigurationKeys { get; }

    private OpenAIClientProvider(OpenAIClient client, IEnumerable<string> keys)
    {
        this.Client = client;
        this.ConfigurationKeys = [.. keys];
    }

    /// <summary>
    /// Produces an <see cref="OpenAIClientProvider"/> based on <see cref="AzureOpenAIClient"/>.
    /// </summary>
    /// <param name="apiKey">The API key.</param>
    /// <param name="endpoint">The service endpoint.</param>
    /// <param name="httpClient">A custom <see cref="HttpClient"/> for HTTP requests.</param>
    public static OpenAIClientProvider ForAzureOpenAI(ApiKeyCredential apiKey, Uri endpoint, HttpClient? httpClient = null)
    {
        Verify.NotNull(apiKey, nameof(apiKey));
        Verify.NotNull(endpoint, nameof(endpoint));

        AzureOpenAIClientOptions clientOptions = CreateAzureClientOptions(httpClient);

        return new(new AzureOpenAIClient(endpoint, apiKey!, clientOptions), CreateConfigurationKeys(endpoint, httpClient));
    }

    /// <summary>
    /// Produces an <see cref="OpenAIClientProvider"/> based on <see cref="AzureOpenAIClient"/>.
    /// </summary>
    /// <param name="credential">The credentials.</param>
    /// <param name="endpoint">The service endpoint.</param>
    /// <param name="httpClient">A custom <see cref="HttpClient"/> for HTTP requests.</param>
    public static OpenAIClientProvider ForAzureOpenAI(TokenCredential credential, Uri endpoint, HttpClient? httpClient = null)
    {
        Verify.NotNull(credential, nameof(credential));
        Verify.NotNull(endpoint, nameof(endpoint));

        AzureOpenAIClientOptions clientOptions = CreateAzureClientOptions(httpClient);

        return new(new AzureOpenAIClient(endpoint, credential, clientOptions), CreateConfigurationKeys(endpoint, httpClient));
    }

    /// <summary>
    /// Produces an <see cref="OpenAIClientProvider"/> based on <see cref="OpenAIClient"/>.
    /// </summary>
    /// <param name="endpoint">An optional endpoint.</param>
    /// <param name="httpClient">A custom <see cref="HttpClient"/> for HTTP requests.</param>
    public static OpenAIClientProvider ForOpenAI(Uri? endpoint = null, HttpClient? httpClient = null)
    {
        OpenAIClientOptions clientOptions = CreateOpenAIClientOptions(endpoint, httpClient);
        return new(new OpenAIClient(new ApiKeyCredential(SingleSpaceKey), clientOptions), CreateConfigurationKeys(endpoint, httpClient));
    }

    /// <summary>
    /// Produces an <see cref="OpenAIClientProvider"/> based on <see cref="OpenAIClient"/>.
    /// </summary>
    /// <param name="apiKey">The API key.</param>
    /// <param name="endpoint">An optional endpoint.</param>
    /// <param name="httpClient">A custom <see cref="HttpClient"/> for HTTP requests.</param>
    public static OpenAIClientProvider ForOpenAI(ApiKeyCredential apiKey, Uri? endpoint = null, HttpClient? httpClient = null)
    {
        OpenAIClientOptions clientOptions = CreateOpenAIClientOptions(endpoint, httpClient);
        return new(new OpenAIClient(apiKey, clientOptions), CreateConfigurationKeys(endpoint, httpClient));
    }

    /// <summary>
    /// Provides a client instance directly.
    /// </summary>
    public static OpenAIClientProvider FromClient(OpenAIClient client)
    {
        return new(client, [client.GetType().FullName!, client.GetHashCode().ToString()]);
    }

    internal static AzureOpenAIClientOptions CreateAzureClientOptions(HttpClient? httpClient)
    {
        AzureOpenAIClientOptions options = new()
        {
            UserAgentApplicationId = HttpHeaderConstant.Values.UserAgent
        };

        ConfigureClientOptions(httpClient, options);

        return options;
    }

    internal static OpenAIClientOptions CreateOpenAIClientOptions(Uri? endpoint, HttpClient? httpClient)
    {
        OpenAIClientOptions options = new()
        {
            UserAgentApplicationId = HttpHeaderConstant.Values.UserAgent,
            Endpoint = endpoint ?? httpClient?.BaseAddress,
        };

        ConfigureClientOptions(httpClient, options);

        return options;
    }

    private static void ConfigureClientOptions(HttpClient? httpClient, ClientPipelineOptions options)
    {
        options.AddPolicy(CreateRequestHeaderPolicy(HttpHeaderConstant.Names.SemanticKernelVersion, HttpHeaderConstant.Values.GetAssemblyVersion(typeof(OpenAIAssistantAgent))), PipelinePosition.PerCall);

        if (httpClient is not null)
        {
            options.Transport = new HttpClientPipelineTransport(httpClient);
            options.RetryPolicy = new ClientRetryPolicy(maxRetries: 0); // Disable retry policy if and only if a custom HttpClient is provided.
            options.NetworkTimeout = Timeout.InfiniteTimeSpan; // Disable default timeout
        }
    }

    private static GenericActionPipelinePolicy CreateRequestHeaderPolicy(string headerName, string headerValue)
        =>
            new((message) =>
            {
                if (message?.Request?.Headers?.TryGetValue(headerName, out string? _) == false)
                {
                    message.Request.Headers.Set(headerName, headerValue);
                }
            });

    private static IEnumerable<string> CreateConfigurationKeys(Uri? endpoint, HttpClient? httpClient)
    {
        if (endpoint != null)
        {
            yield return endpoint.ToString();
        }

        if (httpClient is not null)
        {
            if (httpClient.BaseAddress is not null)
            {
                yield return httpClient.BaseAddress.AbsoluteUri;
            }

            foreach (string header in httpClient.DefaultRequestHeaders.SelectMany(h => h.Value))
            {
                yield return header;
            }
        }
    }
}


===== OpenAI\OpenAIResponseAgent.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.SemanticKernel.Agents.Extensions;
using Microsoft.SemanticKernel.Agents.OpenAI.Internal;
using Microsoft.SemanticKernel.ChatCompletion;
using OpenAI.Responses;

namespace Microsoft.SemanticKernel.Agents.OpenAI;

/// <summary>
/// Represents a <see cref="Agent"/> specialization based on OpenAI Response API.
/// </summary>
public sealed class OpenAIResponseAgent : Agent
{
    /// <summary>
    /// Initializes a new instance of the <see cref="OpenAIResponseAgent"/> class.
    /// </summary>
    /// <param name="client">The OpenAI provider for accessing the Responses API service.</param>
    public OpenAIResponseAgent(OpenAIResponseClient client)
    {
        Verify.NotNull(client);

        this.Client = client;
    }

    /// <summary>
    /// Expose client for additional use.
    /// </summary>
    public OpenAIResponseClient Client { get; }

    /// <summary>
    /// Storing of messages is enabled.
    /// </summary>
    public bool StoreEnabled { get; init; } = false;

    /// <inheritdoc/>
    public override async IAsyncEnumerable<AgentResponseItem<ChatMessageContent>> InvokeAsync(ICollection<ChatMessageContent> messages, AgentThread? thread = null, AgentInvokeOptions? options = null, [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        Verify.NotNull(messages);

        AgentThread agentThread = await this.EnsureThreadExistsWithMessagesAsync(messages, thread, cancellationToken).ConfigureAwait(false);

        // Get the context contributions from the AIContextProviders.
        OpenAIResponseAgentInvokeOptions extensionsContextOptions = await this.FinalizeInvokeOptionsAsync(messages, options, agentThread, cancellationToken).ConfigureAwait(false);

        // Invoke responses with the updated chat history.
        ChatHistory chatHistory = [.. messages];
        var invokeResults = ResponseThreadActions.InvokeAsync(
            this,
            chatHistory,
            agentThread,
            extensionsContextOptions,
            cancellationToken);

        // Notify the thread of new messages and return them to the caller.
        await foreach (var result in invokeResults.ConfigureAwait(false))
        {
            if (options?.OnIntermediateMessage is not null)
            {
                await options.OnIntermediateMessage(result).ConfigureAwait(false);
            }

            await this.NotifyThreadOfNewMessage(agentThread, result, cancellationToken).ConfigureAwait(false);
            yield return new(result, agentThread);
        }
    }

    /// <inheritdoc/>
    public override async IAsyncEnumerable<AgentResponseItem<StreamingChatMessageContent>> InvokeStreamingAsync(ICollection<ChatMessageContent> messages, AgentThread? thread = null, AgentInvokeOptions? options = null, [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        Verify.NotNull(messages);

        AgentThread agentThread = await this.EnsureThreadExistsWithMessagesAsync(messages, thread, cancellationToken).ConfigureAwait(false);

        // Get the context contributions from the AIContextProviders.
        OpenAIResponseAgentInvokeOptions extensionsContextOptions = await this.FinalizeInvokeOptionsAsync(messages, options, agentThread, cancellationToken).ConfigureAwait(false);

        // Invoke responses with the updated chat history.
        ChatHistory chatHistory = [.. messages];
        int messageCount = chatHistory.Count;
        int messageIndex = chatHistory.Count;
        var invokeResults = ResponseThreadActions.InvokeStreamingAsync(
            this,
            chatHistory,
            agentThread,
            extensionsContextOptions,
            cancellationToken);

        // Return streaming chat message content to the caller.
        await foreach (var result in invokeResults.ConfigureAwait(false))
        {
            // Notify the thread of any messages that were assembled from the streaming response during this iteration.
            await NotifyMessagesAsync().ConfigureAwait(false);

            yield return new(result, agentThread);
        }

        // Notify the thread of any remaining messages that were assembled from the streaming response after all iterations are complete.
        await NotifyMessagesAsync().ConfigureAwait(false);

        async Task NotifyMessagesAsync()
        {
            for (; messageIndex < chatHistory.Count; messageIndex++)
            {
                ChatMessageContent newMessage = chatHistory[messageIndex];
                await this.NotifyThreadOfNewMessage(agentThread, newMessage, cancellationToken).ConfigureAwait(false);

                if (options?.OnIntermediateMessage is not null)
                {
                    await options.OnIntermediateMessage(newMessage).ConfigureAwait(false);
                }
            }
        }
    }

    /// <inheritdoc/>
    [Experimental("SKEXP0110")]
    [ExcludeFromCodeCoverage]
    protected override Task<AgentChannel> CreateChannelAsync(CancellationToken cancellationToken)
    {
        throw new NotSupportedException($"{nameof(OpenAIResponseAgent)} is not for use with {nameof(AgentChat)}.");
    }

    /// <inheritdoc/>
    [Experimental("SKEXP0110")]
    [ExcludeFromCodeCoverage]
    protected override IEnumerable<string> GetChannelKeys()
    {
        throw new NotSupportedException($"{nameof(OpenAIResponseAgent)} is not for use with {nameof(AgentChat)}.");
    }

    /// <inheritdoc/>
    [Experimental("SKEXP0110")]
    [ExcludeFromCodeCoverage]
    protected override Task<AgentChannel> RestoreChannelAsync(string channelState, CancellationToken cancellationToken)
    {
        throw new NotSupportedException($"{nameof(OpenAIResponseAgent)} is not for use with {nameof(AgentChat)}.");
    }

    private async Task<AgentThread> EnsureThreadExistsWithMessagesAsync(ICollection<ChatMessageContent> messages, AgentThread? thread, CancellationToken cancellationToken)
    {
        if (this.StoreEnabled)
        {
            return await this.EnsureThreadExistsWithMessagesAsync(messages, thread, () => new OpenAIResponseAgentThread(this.Client), cancellationToken).ConfigureAwait(false);
        }

        return await this.EnsureThreadExistsWithMessagesAsync(messages, thread, () => new ChatHistoryAgentThread(), cancellationToken).ConfigureAwait(false);
    }

    private async Task<OpenAIResponseAgentInvokeOptions> FinalizeInvokeOptionsAsync(ICollection<ChatMessageContent> messages, AgentInvokeOptions? options, AgentThread agentThread, CancellationToken cancellationToken)
    {
        Kernel kernel = this.GetKernel(options);
#pragma warning disable SKEXP0110, SKEXP0130 // Type is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.
        if (this.UseImmutableKernel)
        {
            kernel = kernel.Clone();
        }

        // Get the AIContextProviders contributions to the kernel.
        AIContext providersContext = await agentThread.AIContextProviders.ModelInvokingAsync(messages, cancellationToken).ConfigureAwait(false);

        // Check for compatibility AIContextProviders and the UseImmutableKernel setting.
        if (providersContext.AIFunctions is { Count: > 0 } && !this.UseImmutableKernel)
        {
            throw new InvalidOperationException("AIContextProviders with AIFunctions are not supported when Agent UseImmutableKernel setting is false.");
        }

        kernel.Plugins.AddFromAIContext(providersContext, "Tools");
#pragma warning restore SKEXP0130 // Type is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.

        string mergedAdditionalInstructions = FormatAdditionalInstructions(providersContext, options);
        OpenAIResponseAgentInvokeOptions extensionsContextOptions =
            options is null ?
                new()
                {
                    AdditionalInstructions = mergedAdditionalInstructions,
                    Kernel = kernel,
                } :
                new(options)
                {
                    AdditionalInstructions = mergedAdditionalInstructions,
                    Kernel = kernel,
                };
        return extensionsContextOptions;
    }
}


===== OpenAI\OpenAIResponseAgentExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Diagnostics.CodeAnalysis;
using System.Text.Json;
using Microsoft.SemanticKernel.ChatCompletion;
using MAAI = Microsoft.Agents.AI;

namespace Microsoft.SemanticKernel.Agents.OpenAI;

/// <summary>
/// Exposes a Semantic Kernel Agent Framework <see cref="OpenAIResponseAgent"/> as a Microsoft Agent Framework <see cref="MAAI.AIAgent"/>.
/// </summary>
public static class OpenAIResponseAgentExtensions
{
    /// <summary>
    /// Exposes a Semantic Kernel Agent Framework <see cref="OpenAIResponseAgent"/> as a Microsoft Agent Framework <see cref="MAAI.AIAgent"/>.
    /// </summary>
    /// <param name="responseAgent">The Semantic Kernel <see cref="OpenAIResponseAgent"/> to expose as a Microsoft Agent Framework <see cref="MAAI.AIAgent"/>.</param>
    /// <returns>The Semantic Kernel Agent Framework <see cref="Agent"/> exposed as a Microsoft Agent Framework <see cref="MAAI.AIAgent"/></returns>
    [Experimental("SKEXP0110")]
    public static MAAI.AIAgent AsAIAgent(this OpenAIResponseAgent responseAgent)
        => responseAgent.AsAIAgent(
            () => responseAgent.StoreEnabled ? new OpenAIResponseAgentThread(responseAgent.Client) : new ChatHistoryAgentThread(),
            (json, options) =>
            {
                if (responseAgent.StoreEnabled)
                {
                    var agentId = JsonSerializer.Deserialize<string>(json);
                    return agentId is null ? new OpenAIResponseAgentThread(responseAgent.Client) : new OpenAIResponseAgentThread(responseAgent.Client, agentId);
                }

                var chatHistory = JsonSerializer.Deserialize<ChatHistory>(json);
                return chatHistory is null ? new ChatHistoryAgentThread() : new ChatHistoryAgentThread(chatHistory);
            },
            (thread, options) => responseAgent.StoreEnabled
                ? JsonSerializer.SerializeToElement((thread as OpenAIResponseAgentThread)?.Id)
                : JsonSerializer.SerializeToElement((thread as ChatHistoryAgentThread)?.ChatHistory));
}


===== OpenAI\OpenAIResponseAgentInvokeOptions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using OpenAI.Responses;

namespace Microsoft.SemanticKernel.Agents.OpenAI;

/// <summary>
/// Optional parameters for <see cref="OpenAIResponseAgent"/> invocation.
/// </summary>
public sealed class OpenAIResponseAgentInvokeOptions : AgentInvokeOptions
{
    /// <summary>
    /// Initializes a new instance of the <see cref="OpenAIResponseAgentInvokeOptions"/> class.
    /// </summary>
    public OpenAIResponseAgentInvokeOptions()
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="OpenAIResponseAgentInvokeOptions"/> class by cloning the provided options.
    /// </summary>
    /// <param name="options">The options to clone.</param>
    public OpenAIResponseAgentInvokeOptions(AgentInvokeOptions options)
        : base(options)
    {
        Verify.NotNull(options);

        if (options is OpenAIResponseAgentInvokeOptions responseAgentInvokeOptions)
        {
            this.ResponseCreationOptions = responseAgentInvokeOptions.ResponseCreationOptions;
        }
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="OpenAIResponseAgentInvokeOptions"/> class by cloning the provided options.
    /// </summary>
    /// <param name="options">The options to clone.</param>
    public OpenAIResponseAgentInvokeOptions(OpenAIResponseAgentInvokeOptions options)
        : base(options)
    {
        Verify.NotNull(options);

        this.ResponseCreationOptions = options.ResponseCreationOptions;
    }

    /// <summary>
    /// Gets or initializes the options used for creating a response.
    /// </summary>
    public ResponseCreationOptions? ResponseCreationOptions { get; set; }
}


===== OpenAI\OpenAIResponseAgentThread.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using OpenAI.Responses;

namespace Microsoft.SemanticKernel.Agents.OpenAI;

/// <summary>
/// Represents a conversation thread for an OpenAI Response API based agent when store is enabled.
/// </summary>
public sealed class OpenAIResponseAgentThread : AgentThread
{
    private readonly OpenAIResponseClient _client;
    private bool _isDeleted = false;

    /// <summary>
    /// Initializes a new instance of the <see cref="OpenAIResponseAgentThread"/> class.
    /// </summary>
    /// <param name="client">The agents client to use for interacting with responses.</param>
    public OpenAIResponseAgentThread(OpenAIResponseClient client)
    {
        Verify.NotNull(client);

        this._client = client;
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="OpenAIResponseAgentThread"/> class that resumes an existing response.
    /// </summary>
    /// <param name="client">The agents client to use for interacting with responses.</param>
    /// <param name="responseId">The ID of an existing response to resume.</param>
    public OpenAIResponseAgentThread(OpenAIResponseClient client, string responseId)
    {
        Verify.NotNull(client);
        Verify.NotNull(responseId);

        this._client = client;
        this.ResponseId = responseId;
    }

    /// <summary>
    /// The current response id.
    /// </summary>
    internal string? ResponseId { get; set; }

    /// <inheritdoc />
    public override string? Id => this.ResponseId;

    /// <inheritdoc />
    protected override Task<string?> CreateInternalAsync(CancellationToken cancellationToken = default)
    {
        if (this._isDeleted)
        {
            throw new InvalidOperationException("This thread has been deleted and cannot be recreated.");
        }

        // Id will not be available until after a message is sent
        return Task.FromResult<string?>(null);
    }

    /// <inheritdoc />
    protected async override Task DeleteInternalAsync(CancellationToken cancellationToken = default)
    {
        if (this._isDeleted)
        {
            return;
        }

        if (this.ResponseId is null)
        {
            throw new InvalidOperationException("This thread cannot be deleted, since it has not been created.");
        }

        try
        {
            await this._client.DeleteResponseAsync(this.ResponseId, cancellationToken).ConfigureAwait(false);
        }
        catch (Exception ex)
        {
            throw new AgentThreadOperationException("The thread could not be deleted due to an error response from the service.", ex);
        }

        this._isDeleted = true;
    }

    /// <inheritdoc/>
    protected override Task OnNewMessageInternalAsync(ChatMessageContent newMessage, CancellationToken cancellationToken = default)
    {
        if (this._isDeleted)
        {
            throw new InvalidOperationException("This thread has been deleted and cannot be used anymore.");
        }

        return Task.CompletedTask;
    }

    /// <inheritdoc />
    public async IAsyncEnumerable<ChatMessageContent> GetMessagesAsync([EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        if (this._isDeleted)
        {
            throw new InvalidOperationException("This thread has been deleted and cannot be used anymore.");
        }

        if (!string.IsNullOrEmpty(this.ResponseId))
        {
            var collectionResult = this._client.GetResponseInputItemsAsync(this.ResponseId, default, cancellationToken).ConfigureAwait(false);
            await foreach (var responseItem in collectionResult)
            {
                var messageContent = responseItem.ToChatMessageContent();
                if (messageContent is not null)
                {
                    yield return messageContent;
                }
            }
        }
    }
}


===== OpenAI\OpenAIThreadCreationOptions.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Text.Json.Serialization;

namespace Microsoft.SemanticKernel.Agents.OpenAI;

/// <summary>
/// Specifies thread creation options.
/// </summary>
[Experimental("SKEXP0110")]
[Obsolete("Use the OpenAI.Assistants.AssistantClient.CreateThreadAsync() to create a thread.")]
public sealed class OpenAIThreadCreationOptions
{
    /// <summary>
    /// Gets the optional file IDs made available to the code_interpreter tool, if enabled.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public IReadOnlyList<string>? CodeInterpreterFileIds { get; init; }

    /// <summary>
    /// Gets the optional messages to initialize the thread with.
    /// </summary>
    /// <remarks>
    /// This property only supports messages with <see href="https://platform.openai.com/docs/api-reference/runs/createRun#runs-createrun-additional_messages">role = User or Assistant</see>.
    /// </remarks>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public IReadOnlyList<ChatMessageContent>? Messages { get; init; }

    /// <summary>
    /// Gets the vector store ID that enables file-search.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public string? VectorStoreId { get; init; }

    /// <summary>
    /// Gets a set of up to 16 key/value pairs that can be attached to an agent, used for
    /// storing additional information about that object in a structured format.
    /// </summary>
    /// <remarks>
    /// Keys can be up to 64 characters in length, and values can be up to 512 characters in length.
    /// </remarks>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public IReadOnlyDictionary<string, string>? Metadata { get; init; }
}


===== OpenAI\RunPollingOptions.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;

namespace Microsoft.SemanticKernel.Agents.OpenAI;

/// <summary>
/// Provides configuration and defaults associated with polling behavior for Assistant API run processing.
/// </summary>
public sealed class RunPollingOptions
{
    /// <summary>
    /// Gets the default maximum number or retries when monitoring thread-run status.
    /// </summary>
    public static int DefaultMaximumRetryCount { get; } = 3;

    /// <summary>
    /// Gets the default polling interval when monitoring thread-run status.
    /// </summary>
    public static TimeSpan DefaultPollingInterval { get; } = TimeSpan.FromMilliseconds(500);

    /// <summary>
    /// Gets the default back-off interval when monitoring thread-run status.
    /// </summary>
    public static TimeSpan DefaultPollingBackoff { get; } = TimeSpan.FromSeconds(1);

    /// <summary>
    /// Gets the default number of polling iterations before using <see cref="RunPollingBackoff"/>.
    /// </summary>
    public static int DefaultPollingBackoffThreshold { get; } = 2;

    /// <summary>
    /// Gets the default polling delay when retrying message retrieval due to a 404/NotFound from synchronization lag.
    /// </summary>
    public static TimeSpan DefaultMessageSynchronizationDelay { get; } = TimeSpan.FromMilliseconds(500);

    /// <summary>
    /// Gets or sets the maximum retry count when polling thread-run status.
    /// </summary>
    /// <remarks>
    /// This value only affects failures that have the potential to be transient.
    /// Explicit server error responses will result in immediate failure.
    /// </remarks>
    public int MaximumRetryCount { get; set; } = DefaultMaximumRetryCount;

    /// <summary>
    /// Gets or sets the polling interval when monitoring thread-run status.
    /// </summary>
    public TimeSpan RunPollingInterval { get; set; } = DefaultPollingInterval;

    /// <summary>
    /// Gets or sets the back-off interval when monitoring thread-run status.
    /// </summary>
    public TimeSpan RunPollingBackoff { get; set; } = DefaultPollingBackoff;

    /// <summary>
    /// Gets or sets the number of polling iterations before using <see cref="RunPollingBackoff"/>.
    /// </summary>
    public int RunPollingBackoffThreshold { get; set; } = DefaultPollingBackoffThreshold;

    /// <summary>
    /// Gets or sets the polling delay when retrying message retrieval due to a 404/NotFound from synchronization lag.
    /// </summary>
    public TimeSpan MessageSynchronizationDelay { get; set; } = DefaultMessageSynchronizationDelay;

    /// <summary>
    /// Gets the polling interval for the specified iteration count.
    /// </summary>
    /// <param name="iterationCount">The number of polling iterations already attempted.</param>
    public TimeSpan GetPollingInterval(int iterationCount) =>
        iterationCount > this.RunPollingBackoffThreshold ? this.RunPollingBackoff : this.RunPollingInterval;
}


===== Orchestration\AgentActor.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.SemanticKernel.Agents.Runtime;
using Microsoft.SemanticKernel.ChatCompletion;

namespace Microsoft.SemanticKernel.Agents.Orchestration;

/// <summary>
/// An actor that represents an <see cref="Agents.Agent"/>.
/// </summary>
public abstract class AgentActor : OrchestrationActor
{
    private AgentInvokeOptions? _options;
    private ChatMessageContent? _lastResponse;

    /// <summary>
    /// Initializes a new instance of the <see cref="AgentActor"/> class.
    /// </summary>
    /// <param name="id">The unique identifier of the agent.</param>
    /// <param name="runtime">The runtime associated with the agent.</param>
    /// <param name="context">The orchestration context.</param>
    /// <param name="agent">An <see cref="Agents.Agent"/>.</param>
    /// <param name="logger">The logger to use for the actor</param>
    protected AgentActor(AgentId id, IAgentRuntime runtime, OrchestrationContext context, Agent agent, ILogger? logger = null)
        : base(
            id,
            runtime,
            context,
            VerifyDescription(agent),
            logger)
    {
        this.Agent = agent;
    }

    /// <summary>
    /// Gets the associated agent.
    /// </summary>
    protected Agent Agent { get; }

    /// <summary>
    /// Gets or sets the current conversation thread used during agent communication.
    /// </summary>
    protected AgentThread? Thread { get; set; }

    /// <summary>
    /// Optionally overridden to create custom invocation options for the agent.
    /// </summary>
    protected virtual AgentInvokeOptions CreateInvokeOptions(Func<ChatMessageContent, Task> messageHandler) => new() { OnIntermediateMessage = messageHandler };

    /// <summary>
    /// Optionally overridden to introduce customer filtering logic for the response callback.
    /// </summary>
    /// <param name="response">The agent response</param>
    /// <returns>true if the response should be filtered (hidden)</returns>
    protected virtual bool ResponseCallbackFilter(ChatMessageContent response) => false;

    /// <summary>
    /// Deletes the agent thread.
    /// </summary>
    /// <param name="cancellationToken">A cancellation token that can be used to cancel the operation.</param>
    protected async ValueTask DeleteThreadAsync(CancellationToken cancellationToken)
    {
        if (this.Thread != null)
        {
            await this.Thread.DeleteAsync(cancellationToken).ConfigureAwait(false);
            this.Thread = null;
        }
    }

    /// <summary>
    /// Invokes the agent with a single chat message.
    /// This method sets the message role to <see cref="AuthorRole.User"/> and delegates to the overload accepting multiple messages.
    /// </summary>
    /// <param name="input">The chat message content to send.</param>
    /// <param name="cancellationToken">A cancellation token that can be used to cancel the operation.</param>
    /// <returns>A task that returns the response <see cref="ChatMessageContent"/>.</returns>
    protected ValueTask<ChatMessageContent> InvokeAsync(ChatMessageContent input, CancellationToken cancellationToken)
    {
        return this.InvokeAsync([input], cancellationToken);
    }

    /// <summary>
    /// Invokes the agent with input messages and respond with both streamed and regular messages.
    /// </summary>
    /// <param name="input">The list of chat messages to send.</param>
    /// <param name="cancellationToken">A cancellation token that can be used to cancel the operation.</param>
    /// <returns>A task that returns the response <see cref="ChatMessageContent"/>.</returns>
    protected async ValueTask<ChatMessageContent> InvokeAsync(IList<ChatMessageContent> input, CancellationToken cancellationToken)
    {
        try
        {
            this.Context.Cancellation.ThrowIfCancellationRequested();

            this._lastResponse = null;

            AgentInvokeOptions options = this.GetInvokeOptions(HandleMessageAsync);
            if (this.Context.StreamingResponseCallback == null)
            {
                // No need to utilize streaming if no callback is provided
                await this.InvokeAsync(input, options, cancellationToken).ConfigureAwait(false);
            }
            else
            {
                await this.InvokeStreamingAsync(input, options, cancellationToken).ConfigureAwait(false);
            }

            return this._lastResponse ?? new ChatMessageContent(AuthorRole.Assistant, string.Empty);
        }
        catch (Exception exception)
        {
            this.Context.FailureCallback.Invoke(exception);
            throw;
        }

        async Task HandleMessageAsync(ChatMessageContent message)
        {
            this._lastResponse = message; // Keep track of most recent response for both invocation modes

            if (this.Context.ResponseCallback is not null && !this.ResponseCallbackFilter(message))
            {
                await this.Context.ResponseCallback.Invoke(message).ConfigureAwait(false);
            }
        }
    }

    private async Task InvokeAsync(IList<ChatMessageContent> input, AgentInvokeOptions options, CancellationToken cancellationToken)
    {
        var last = default(AgentResponseItem<ChatMessageContent>)!;
        var hasLast = false;

        await foreach (var item in this.Agent.InvokeAsync(input, this.Thread, options, cancellationToken).ConfigureAwait(false))
        {
            hasLast = true;
            last = item;
        }

        if (this.Thread is null && hasLast)
        {
            this.Thread = last.Thread;
        }
    }

    private async Task InvokeStreamingAsync(IList<ChatMessageContent> input, AgentInvokeOptions options, CancellationToken cancellationToken)
    {
        IAsyncEnumerable<AgentResponseItem<StreamingChatMessageContent>> streamedResponses =
            this.Agent.InvokeStreamingAsync(
                input,
                this.Thread,
                options,
                cancellationToken);

        StreamingChatMessageContent? lastStreamedResponse = null;
        await foreach (AgentResponseItem<StreamingChatMessageContent> streamedResponse in streamedResponses.ConfigureAwait(false))
        {
            this.Context.Cancellation.ThrowIfCancellationRequested();

            this.Thread ??= streamedResponse.Thread;

            await HandleStreamedMessage(lastStreamedResponse, isFinal: false).ConfigureAwait(false);

            lastStreamedResponse = streamedResponse.Message;
        }

        await HandleStreamedMessage(lastStreamedResponse, isFinal: true).ConfigureAwait(false);

        async ValueTask HandleStreamedMessage(StreamingChatMessageContent? streamedResponse, bool isFinal)
        {
            if (this.Context.StreamingResponseCallback != null && streamedResponse != null)
            {
                await this.Context.StreamingResponseCallback.Invoke(streamedResponse, isFinal).ConfigureAwait(false);
            }
        }
    }

    private AgentInvokeOptions GetInvokeOptions(Func<ChatMessageContent, Task> messageHandler) => this._options ??= this.CreateInvokeOptions(messageHandler);

    private static string VerifyDescription(Agent agent)
    {
        return agent.Description ?? throw new ArgumentException($"Missing agent description: {agent.Name ?? agent.Id}", nameof(agent));
    }
}


===== Orchestration\AgentOrchestration.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.SemanticKernel.Agents.Orchestration.Extensions;
using Microsoft.SemanticKernel.Agents.Orchestration.Transforms;
using Microsoft.SemanticKernel.Agents.Runtime;

namespace Microsoft.SemanticKernel.Agents.Orchestration;

/// <summary>
/// Called for every response is produced by any agent.
/// </summary>
/// <param name="response">The agent response</param>
public delegate ValueTask OrchestrationResponseCallback(ChatMessageContent response);

/// <summary>
/// Called to expose the streamed response produced by any agent.
/// </summary>
/// <param name="response">The agent response</param>
/// <param name="isFinal">Indicates if streamed content is final chunk of the message.</param>
public delegate ValueTask OrchestrationStreamingCallback(StreamingChatMessageContent response, bool isFinal);

/// <summary>
/// Called when human interaction is requested.
/// </summary>
public delegate ValueTask<ChatMessageContent> OrchestrationInteractiveCallback();

/// <summary>
/// Base class for multi-agent agent orchestration patterns.
/// </summary>
/// <typeparam name="TInput">The type of the input to the orchestration.</typeparam>
/// <typeparam name="TOutput">The type of the result output by the orchestration.</typeparam>
public abstract partial class AgentOrchestration<TInput, TOutput>
{
    /// <summary>
    /// Initializes a new instance of the <see cref="AgentOrchestration{TInput, TOutput}"/> class.
    /// </summary>
    /// <param name="members">Specifies the member agents or orchestrations participating in this orchestration.</param>
    protected AgentOrchestration(params Agent[] members)
    {
        // Capture orchestration root name without generic parameters for use in
        // agent type and topic formatting as well as logging.
        this.OrchestrationLabel = this.GetType().Name.Split('`').First();

        this.Members = members;
    }

    /// <summary>
    /// Gets the description of the orchestration.
    /// </summary>
    public string Description { get; init; } = string.Empty;

    /// <summary>
    /// Gets the name of the orchestration.
    /// </summary>
    public string Name { get; init; } = string.Empty;

    /// <summary>
    /// Gets the associated logger.
    /// </summary>
    public ILoggerFactory LoggerFactory { get; init; } = NullLoggerFactory.Instance;

    /// <summary>
    /// Transforms the orchestration input into a source input suitable for processing.
    /// </summary>
    public OrchestrationInputTransform<TInput> InputTransform { get; init; } = DefaultTransforms.FromInput<TInput>;

    /// <summary>
    /// Transforms the processed result into the final output form.
    /// </summary>
    public OrchestrationOutputTransform<TOutput> ResultTransform { get; init; } = DefaultTransforms.ToOutput<TOutput>;

    /// <summary>
    /// Optional callback that is invoked for every agent response.
    /// </summary>
    public OrchestrationResponseCallback? ResponseCallback { get; init; }

    /// <summary>
    /// Optional callback that is invoked for every agent response.
    /// </summary>
    public OrchestrationStreamingCallback? StreamingResponseCallback { get; init; }

    /// <summary>
    /// Gets the list of member targets involved in the orchestration.
    /// </summary>
    protected IReadOnlyList<Agent> Members { get; }

    /// <summary>
    /// Orchestration identifier without generic parameters for use in
    /// agent type and topic formatting as well as logging.
    /// </summary>
    protected string OrchestrationLabel { get; }

    /// <summary>
    /// Initiates processing of the orchestration.
    /// </summary>
    /// <param name="input">The input message.</param>
    /// <param name="runtime">The runtime associated with the orchestration.</param>
    /// <param name="cancellationToken">A cancellation token that can be used to cancel the operation.</param>
    public async ValueTask<OrchestrationResult<TOutput>> InvokeAsync(
        TInput input,
        IAgentRuntime runtime,
        CancellationToken cancellationToken = default)
    {
        Verify.NotNull(input, nameof(input));

        TopicId topic = new($"{this.OrchestrationLabel}_{Guid.NewGuid().ToString().Replace("-", string.Empty)}");

        CancellationTokenSource orchestrationCancelSource = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);

        TaskCompletionSource<TOutput> completion = new();

        OrchestrationContext context =
            new(this.OrchestrationLabel,
                topic,
                this.ResponseCallback,
                this.StreamingResponseCallback,
                exception => completion.SetException(exception),
                this.LoggerFactory,
                cancellationToken);

        ILogger logger = this.LoggerFactory.CreateLogger(this.GetType());

        AgentType orchestrationType = await this.RegisterAsync(runtime, context, completion, handoff: null).ConfigureAwait(false);

        cancellationToken.ThrowIfCancellationRequested();

        logger.LogOrchestrationInvoke(this.OrchestrationLabel, topic);

        Task task = runtime.PublishMessageAsync(input, orchestrationType, cancellationToken).AsTask();

        logger.LogOrchestrationYield(this.OrchestrationLabel, topic);

        return new OrchestrationResult<TOutput>(context, completion, orchestrationCancelSource, logger);
    }

    /// <summary>
    /// Initiates processing according to the orchestration pattern.
    /// </summary>
    /// <param name="runtime">The runtime associated with the orchestration.</param>
    /// <param name="topic">The unique identifier for the orchestration session.</param>
    /// <param name="input">The input to be transformed and processed.</param>
    /// <param name="entryAgent">The initial agent type used for starting the orchestration.</param>
    protected abstract ValueTask StartAsync(IAgentRuntime runtime, TopicId topic, IEnumerable<ChatMessageContent> input, AgentType? entryAgent);

    /// <summary>
    /// Orchestration specific registration, including members and returns an optional entry agent.
    /// </summary>
    /// <param name="runtime">The runtime targeted for registration.</param>
    /// <param name="context">The orchestration context.</param>
    /// <param name="registrar">A registration context.</param>
    /// <param name="logger">The logger to use during registration</param>
    /// <returns>The entry AgentType for the orchestration, if any.</returns>
    protected abstract ValueTask<AgentType?> RegisterOrchestrationAsync(IAgentRuntime runtime, OrchestrationContext context, RegistrationContext registrar, ILogger logger);

    /// <summary>
    /// Formats and returns a unique AgentType based on the provided topic and suffix.
    /// </summary>
    /// <param name="topic">The topic identifier used in formatting the agent type.</param>
    /// <param name="suffix">A suffix to differentiate the agent type.</param>
    /// <returns>A formatted AgentType object.</returns>
    protected AgentType FormatAgentType(TopicId topic, string suffix) => new($"{topic.Type}_{suffix}");

    /// <summary>
    /// Registers the orchestration's root and boot agents, setting up completion and target routing.
    /// </summary>
    /// <param name="runtime">The runtime targeted for registration.</param>
    /// <param name="context">The orchestration context.</param>
    /// <param name="completion">A TaskCompletionSource for the orchestration.</param>
    /// <param name="handoff">The actor type used for handoff.  Only defined for nested orchestrations.</param>
    /// <returns>The AgentType representing the orchestration entry point.</returns>
    private async ValueTask<AgentType> RegisterAsync(IAgentRuntime runtime, OrchestrationContext context, TaskCompletionSource<TOutput> completion, AgentType? handoff)
    {
        // Create a logger for the orchestration registration.
        ILogger logger = context.LoggerFactory.CreateLogger(this.GetType());
        logger.LogOrchestrationRegistrationStart(context.Orchestration, context.Topic);

        // Register orchestration
        RegistrationContext registrar = new(this.FormatAgentType(context.Topic, "Root"), runtime, context, completion, this.ResultTransform);
        AgentType? entryAgent = await this.RegisterOrchestrationAsync(runtime, context, registrar, logger).ConfigureAwait(false);

        // Register actor for orchestration entry-point
        AgentType orchestrationEntry =
            await runtime.RegisterOrchestrationAgentAsync(
                this.FormatAgentType(context.Topic, "Boot"),
                    (agentId, runtime) =>
                    {
                        RequestActor actor =
                            new(agentId,
                                runtime,
                                context,
                                this.InputTransform,
                                completion,
                                StartAsync,
                                context.LoggerFactory.CreateLogger<RequestActor>());
#if !NETCOREAPP
                        return actor.AsValueTask<IHostableAgent>();
#else
                        return ValueTask.FromResult<IHostableAgent>(actor);
#endif
                    }).ConfigureAwait(false);

        logger.LogOrchestrationRegistrationDone(context.Orchestration, context.Topic);

        return orchestrationEntry;

        ValueTask StartAsync(IEnumerable<ChatMessageContent> input) => this.StartAsync(runtime, context.Topic, input, entryAgent);
    }

    /// <summary>
    /// A context used during registration (<see cref="RegisterAsync"/>).
    /// </summary>
    public sealed class RegistrationContext(
        AgentType agentType,
        IAgentRuntime runtime,
        OrchestrationContext context,
        TaskCompletionSource<TOutput> completion,
        OrchestrationOutputTransform<TOutput> outputTransform)
    {
        /// <summary>
        /// Register the final result type.
        /// </summary>
        public async ValueTask<AgentType> RegisterResultTypeAsync<TResult>(OrchestrationResultTransform<TResult> resultTransform)
        {
            // Register actor for final result
            AgentType registeredType =
                await runtime.RegisterOrchestrationAgentAsync(
                    agentType,
                    (agentId, runtime) =>
                    {
                        ResultActor<TResult> actor =
                            new(agentId,
                                runtime,
                                context,
                                resultTransform,
                                outputTransform,
                                completion,
                                context.LoggerFactory.CreateLogger<ResultActor<TResult>>());
#if !NETCOREAPP
                        return actor.AsValueTask<IHostableAgent>();
#else
                        return ValueTask.FromResult<IHostableAgent>(actor);
#endif
                    }).ConfigureAwait(false);

            return registeredType;
        }
    }
}


===== Orchestration\AgentOrchestration.RequestActor.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.SemanticKernel.Agents.Orchestration.Transforms;
using Microsoft.SemanticKernel.Agents.Runtime;
using Microsoft.SemanticKernel.Agents.Runtime.Core;

namespace Microsoft.SemanticKernel.Agents.Orchestration;

public abstract partial class AgentOrchestration<TInput, TOutput>
{
    /// <summary>
    /// Actor responsible for receiving final message and transforming it into the output type.
    /// </summary>
    private sealed class RequestActor : OrchestrationActor, IHandle<TInput>
    {
        private readonly OrchestrationInputTransform<TInput> _transform;
        private readonly Func<IEnumerable<ChatMessageContent>, ValueTask> _action;
        private readonly TaskCompletionSource<TOutput> _completionSource;

        /// <summary>
        /// Initializes a new instance of the <see cref="AgentOrchestration{TInput, TOutput}"/> class.
        /// </summary>
        /// <param name="id">The unique identifier of the agent.</param>
        /// <param name="runtime">The runtime associated with the agent.</param>
        /// <param name="context">The orchestration context.</param>
        /// <param name="transform">A function that transforms an input of type TInput into a source type TSource.</param>
        /// <param name="completionSource">Optional TaskCompletionSource to signal orchestration completion.</param>
        /// <param name="action">An asynchronous function that processes the resulting source.</param>
        /// <param name="logger">The logger to use for the actor</param>
        public RequestActor(
            AgentId id,
            IAgentRuntime runtime,
            OrchestrationContext context,
            OrchestrationInputTransform<TInput> transform,
            TaskCompletionSource<TOutput> completionSource,
            Func<IEnumerable<ChatMessageContent>, ValueTask> action,
            ILogger<RequestActor>? logger = null)
            : base(id, runtime, context, $"{id.Type}_Actor", logger)
        {
            this._transform = transform;
            this._action = action;
            this._completionSource = completionSource;
        }

        /// <summary>
        /// Handles the incoming message by transforming the input and executing the corresponding action asynchronously.
        /// </summary>
        /// <param name="item">The input message of type TInput.</param>
        /// <param name="messageContext">The context of the message, providing additional details.</param>
        /// <returns>A ValueTask representing the asynchronous operation.</returns>
        public async ValueTask HandleAsync(TInput item, MessageContext messageContext)
        {
            this.Logger.LogOrchestrationRequestInvoke(this.Context.Orchestration, this.Id);
            try
            {
                IEnumerable<ChatMessageContent> input = await this._transform.Invoke(item).ConfigureAwait(false);
                Task task = this._action.Invoke(input).AsTask();
                this.Logger.LogOrchestrationStart(this.Context.Orchestration, this.Id);
                await task.ConfigureAwait(false);
            }
            catch (Exception exception) when (!exception.IsCriticalException())
            {
                // Log exception details and allow orchestration to fail
                this.Logger.LogOrchestrationRequestFailure(this.Context.Orchestration, this.Id, exception);
                this._completionSource.SetException(exception);
                throw;
            }
        }
    }
}


===== Orchestration\AgentOrchestration.ResultActor.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.SemanticKernel.Agents.Orchestration.Transforms;
using Microsoft.SemanticKernel.Agents.Runtime;
using Microsoft.SemanticKernel.Agents.Runtime.Core;

namespace Microsoft.SemanticKernel.Agents.Orchestration;

public abstract partial class AgentOrchestration<TInput, TOutput>
{
    /// <summary>
    /// Actor responsible for receiving the resultant message, transforming it, and handling further orchestration.
    /// </summary>
    private sealed class ResultActor<TResult> : OrchestrationActor, IHandle<TResult>
    {
        private readonly TaskCompletionSource<TOutput> _completionSource;
        private readonly OrchestrationResultTransform<TResult> _transformResult;
        private readonly OrchestrationOutputTransform<TOutput> _transform;

        /// <summary>
        /// Initializes a new instance of the <see cref="AgentOrchestration{TInput, TOutput}.ResultActor{TResult}"/> class.
        /// </summary>
        /// <param name="id">The unique identifier of the agent.</param>
        /// <param name="runtime">The runtime associated with the agent.</param>
        /// <param name="context">The orchestration context.</param>
        /// <param name="transformResult">A delegate that transforms a TResult instance into a ChatMessageContent.</param>
        /// <param name="transformOutput">A delegate that transforms a ChatMessageContent into a TOutput instance.</param>
        /// <param name="completionSource">Optional TaskCompletionSource to signal orchestration completion.</param>
        /// <param name="logger">The logger to use for the actor</param>
        public ResultActor(
            AgentId id,
            IAgentRuntime runtime,
            OrchestrationContext context,
            OrchestrationResultTransform<TResult> transformResult,
            OrchestrationOutputTransform<TOutput> transformOutput,
            TaskCompletionSource<TOutput> completionSource,
            ILogger<ResultActor<TResult>>? logger = null)
            : base(id, runtime, context, $"{id.Type}_Actor", logger)
        {
            this._completionSource = completionSource;
            this._transformResult = transformResult;
            this._transform = transformOutput;
        }

        /// <summary>
        /// Processes the received TResult message by transforming it into a TOutput message.
        /// If a CompletionTarget is defined, it sends the transformed message to the corresponding agent.
        /// Additionally, it signals completion via the provided TaskCompletionSource if available.
        /// </summary>
        /// <param name="item">The result item to process.</param>
        /// <param name="messageContext">The context associated with the message.</param>
        /// <returns>A ValueTask representing asynchronous operation.</returns>
        public async ValueTask HandleAsync(TResult item, MessageContext messageContext)
        {
            this.Logger.LogOrchestrationResultInvoke(this.Context.Orchestration, this.Id);

            try
            {
                if (!this._completionSource.Task.IsCompleted)
                {
                    IList<ChatMessageContent> result = this._transformResult.Invoke(item);
                    TOutput output = await this._transform.Invoke(result).ConfigureAwait(false);
                    this._completionSource.TrySetResult(output);
                }
            }
            catch (Exception exception)
            {
                // Log exception details and fail orchestration as per design.
                this.Logger.LogOrchestrationResultFailure(this.Context.Orchestration, this.Id, exception);
                this._completionSource.SetException(exception);
                throw;
            }
        }
    }
}


===== Orchestration\Concurrent\ConcurrentActor.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.SemanticKernel.Agents.Runtime;
using Microsoft.SemanticKernel.Agents.Runtime.Core;

namespace Microsoft.SemanticKernel.Agents.Orchestration.Concurrent;

/// <summary>
/// An <see cref="AgentActor"/> used with the <see cref="ConcurrentOrchestration{TInput, TOutput}"/>.
/// </summary>
internal sealed class ConcurrentActor : AgentActor, IHandle<ConcurrentMessages.Request>
{
    private readonly AgentType _handoffActor;

    /// <summary>
    /// Initializes a new instance of the <see cref="ConcurrentActor"/> class.
    /// </summary>
    /// <param name="id">The unique identifier of the agent.</param>
    /// <param name="runtime">The runtime associated with the agent.</param>
    /// <param name="context">The orchestration context.</param>
    /// <param name="agent">An <see cref="Agent"/>.</param>
    /// <param name="resultActor">Identifies the actor collecting results.</param>
    /// <param name="logger">The logger to use for the actor</param>
    public ConcurrentActor(AgentId id, IAgentRuntime runtime, OrchestrationContext context, Agent agent, AgentType resultActor, ILogger<ConcurrentActor>? logger = null)
        : base(id, runtime, context, agent, logger)
    {
        this._handoffActor = resultActor;
    }

    /// <inheritdoc/>
    public async ValueTask HandleAsync(ConcurrentMessages.Request item, MessageContext messageContext)
    {
        this.Logger.LogConcurrentAgentInvoke(this.Id);

        ChatMessageContent response = await this.InvokeAsync(item.Messages, messageContext.CancellationToken).ConfigureAwait(false);

        this.Logger.LogConcurrentAgentResult(this.Id, response.Content);

        await this.PublishMessageAsync(response.AsResultMessage(), this._handoffActor, messageContext.CancellationToken).ConfigureAwait(false);
    }
}


===== Orchestration\Concurrent\ConcurrentMessages.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using Microsoft.SemanticKernel.ChatCompletion;

namespace Microsoft.SemanticKernel.Agents.Orchestration.Concurrent;

/// <summary>
/// Common messages used by the <see cref="ConcurrentOrchestration{TInput, TOutput}"/>.
/// </summary>
internal static class ConcurrentMessages
{
    /// <summary>
    /// An empty message instance as a default.
    /// </summary>
    public static readonly ChatMessageContent Empty = new();

    /// <summary>
    /// The input task for a <see cref="ConcurrentOrchestration{TInput, TOutput}"/>.
    /// </summary>
    public sealed class Request
    {
        /// <summary>
        /// The request input.
        /// </summary>
        public IList<ChatMessageContent> Messages { get; init; } = [];
    }

    /// <summary>
    /// A result from a <see cref="ConcurrentOrchestration{TInput, TOutput}"/>.
    /// </summary>
    public sealed class Result
    {
        /// <summary>
        /// The result message.
        /// </summary>
        public ChatMessageContent Message { get; init; } = Empty;
    }

    /// <summary>
    /// Extension method to convert a <see cref="string"/> to a <see cref="Result"/>.
    /// </summary>
    public static Result AsResultMessage(this string text, AuthorRole? role = null) => new() { Message = new ChatMessageContent(role ?? AuthorRole.Assistant, text) };

    /// <summary>
    /// Extension method to convert a <see cref="ChatMessageContent"/> to a <see cref="Result"/>.
    /// </summary>
    public static Result AsResultMessage(this ChatMessageContent message) => new() { Message = message };

    /// <summary>
    /// Extension method to convert a collection of <see cref="ChatMessageContent"/> to a <see cref="ConcurrentMessages.Request"/>.
    /// </summary>
    public static Request AsInputMessage(this IEnumerable<ChatMessageContent> messages) => new() { Messages = [.. messages] };
}


===== Orchestration\Concurrent\ConcurrentOrchestration.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.SemanticKernel.Agents.Orchestration.Extensions;
using Microsoft.SemanticKernel.Agents.Runtime;

namespace Microsoft.SemanticKernel.Agents.Orchestration.Concurrent;

/// <summary>
/// An orchestration that broadcasts the input message to each agent.
/// </summary>
/// <remarks>
/// <c>TOutput</c> must be an array type for <see cref="ConcurrentOrchestration"/>.
/// </remarks>
public class ConcurrentOrchestration<TInput, TOutput>
    : AgentOrchestration<TInput, TOutput>
{
    /// <summary>
    /// Initializes a new instance of the <see cref="ConcurrentOrchestration{TInput, TOutput}"/> class.
    /// </summary>
    /// <param name="agents">The agents participating in the orchestration.</param>
    public ConcurrentOrchestration(params Agent[] agents)
        : base(agents)
    {
    }

    /// <inheritdoc />
    protected override ValueTask StartAsync(IAgentRuntime runtime, TopicId topic, IEnumerable<ChatMessageContent> input, AgentType? entryAgent)
    {
        return runtime.PublishMessageAsync(input.AsInputMessage(), topic);
    }

    /// <inheritdoc />
    protected override async ValueTask<AgentType?> RegisterOrchestrationAsync(IAgentRuntime runtime, OrchestrationContext context, RegistrationContext registrar, ILogger logger)
    {
        AgentType outputType = await registrar.RegisterResultTypeAsync<ConcurrentMessages.Result[]>(response => [.. response.Select(r => r.Message)]).ConfigureAwait(false);

        // Register result actor
        AgentType resultType = this.FormatAgentType(context.Topic, "Results");
        await runtime.RegisterOrchestrationAgentAsync(
            resultType,
            (agentId, runtime) =>
            {
                ConcurrentResultActor actor = new(agentId, runtime, context, outputType, this.Members.Count, context.LoggerFactory.CreateLogger<ConcurrentResultActor>());
#if !NETCOREAPP
                return actor.AsValueTask<IHostableAgent>();
#else
                return ValueTask.FromResult<IHostableAgent>(actor);
#endif
            }).ConfigureAwait(false);
        logger.LogRegisterActor(this.OrchestrationLabel, resultType, "RESULTS");

        // Register member actors - All agents respond to the same message.
        int agentCount = 0;
        foreach (Agent agent in this.Members)
        {
            ++agentCount;

            AgentType agentType =
                await runtime.RegisterAgentFactoryAsync(
                    this.FormatAgentType(context.Topic, $"Agent_{agentCount}"),
                    (agentId, runtime) =>
                    {
                        ConcurrentActor actor = new(agentId, runtime, context, agent, resultType, context.LoggerFactory.CreateLogger<ConcurrentActor>());
#if !NETCOREAPP
                        return actor.AsValueTask<IHostableAgent>();
#else
                        return ValueTask.FromResult<IHostableAgent>(actor);
#endif
                    }).ConfigureAwait(false);

            logger.LogRegisterActor(this.OrchestrationLabel, agentType, "MEMBER", agentCount);

            await runtime.SubscribeAsync(agentType, context.Topic).ConfigureAwait(false);
        }

        return null;
    }
}


===== Orchestration\Concurrent\ConcurrentOrchestration.String.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Linq;

#if NETCOREAPP
using System.Threading.Tasks;
#endif

namespace Microsoft.SemanticKernel.Agents.Orchestration.Concurrent;

/// <summary>
/// An orchestration that broadcasts the input message to each agent.
/// </summary>
public sealed class ConcurrentOrchestration : ConcurrentOrchestration<string, string[]>
{
    /// <summary>
    /// Initializes a new instance of the <see cref="ConcurrentOrchestration"/> class.
    /// </summary>
    /// <param name="members">The agents to be orchestrated.</param>
    public ConcurrentOrchestration(params Agent[] members)
        : base(members)
    {
        this.ResultTransform =
            (response, cancellationToken) =>
            {
                string[] result = [.. response.Select(r => r.Content ?? string.Empty)];
#if !NETCOREAPP
                return result.AsValueTask();
#else
                return ValueTask.FromResult(result);
#endif
            };
    }
}


===== Orchestration\Concurrent\ConcurrentResultActor.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Concurrent;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.SemanticKernel.Agents.Runtime;
using Microsoft.SemanticKernel.Agents.Runtime.Core;

namespace Microsoft.SemanticKernel.Agents.Orchestration.Concurrent;

/// <summary>
/// Actor for capturing each <see cref="ConcurrentMessages.Result"/> message.
/// </summary>
internal sealed class ConcurrentResultActor :
    OrchestrationActor,
    IHandle<ConcurrentMessages.Result>
{
    private readonly ConcurrentQueue<ConcurrentMessages.Result> _results;
    private readonly AgentType _orchestrationType;
    private readonly int _expectedCount;
    private int _resultCount;

    /// <summary>
    /// Initializes a new instance of the <see cref="ConcurrentResultActor"/> class.
    /// </summary>
    /// <param name="id">The unique identifier of the agent.</param>
    /// <param name="runtime">The runtime associated with the agent.</param>
    /// <param name="context">The orchestration context.</param>
    /// <param name="orchestrationType">Identifies the orchestration agent.</param>
    /// <param name="expectedCount">The expected number of messages to be received.</param>
    /// <param name="logger">The logger to use for the actor</param>
    public ConcurrentResultActor(
        AgentId id,
        IAgentRuntime runtime,
        OrchestrationContext context,
        AgentType orchestrationType,
        int expectedCount,
        ILogger logger)
        : base(id, runtime, context, "Captures the results of the ConcurrentOrchestration", logger)
    {
        this._orchestrationType = orchestrationType;
        this._expectedCount = expectedCount;
        this._results = [];
    }

    /// <inheritdoc/>
    public async ValueTask HandleAsync(ConcurrentMessages.Result item, MessageContext messageContext)
    {
        this.Logger.LogConcurrentResultCapture(this.Id, this._resultCount + 1, this._expectedCount);

        this._results.Enqueue(item);

        if (Interlocked.Increment(ref this._resultCount) == this._expectedCount)
        {
            await this.PublishMessageAsync(this._results.ToArray(), this._orchestrationType, messageContext.CancellationToken).ConfigureAwait(false);
        }
    }
}


===== Orchestration\Extensions\RuntimeExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.SemanticKernel.Agents.Runtime;
using Microsoft.SemanticKernel.Agents.Runtime.Core;

namespace Microsoft.SemanticKernel.Agents.Orchestration.Extensions;

/// <summary>
/// Extension methods for <see cref="IAgentRuntime"/>.
/// </summary>
public static class RuntimeExtensions
{
    /// <summary>
    /// Sends a message to the specified agent.
    /// </summary>
    public static async ValueTask PublishMessageAsync(this IAgentRuntime runtime, object message, AgentType agentType, CancellationToken cancellationToken = default)
    {
        await runtime.PublishMessageAsync(message, new TopicId(agentType), sender: null, messageId: null, cancellationToken).ConfigureAwait(false);
    }

    /// <summary>
    /// Registers an agent factory for the specified agent type and associates it with the runtime.
    /// </summary>
    /// <param name="runtime">The runtime targeted for registration.</param>
    /// <param name="agentType">The type of agent to register.</param>
    /// <param name="factoryFunc">The factory function for creating the agent.</param>
    /// <returns>The registered agent type.</returns>
    public static async ValueTask<AgentType> RegisterOrchestrationAgentAsync(this IAgentRuntime runtime, AgentType agentType, Func<AgentId, IAgentRuntime, ValueTask<IHostableAgent>> factoryFunc)
    {
        AgentType registeredType = await runtime.RegisterAgentFactoryAsync(agentType, factoryFunc).ConfigureAwait(false);

        // Subscribe agent to its own unique topic
        await runtime.SubscribeAsync(registeredType).ConfigureAwait(false);

        return registeredType;
    }

    /// <summary>
    /// Subscribes the specified agent type to its own dedicated topic.
    /// </summary>
    /// <param name="runtime">The runtime for managing the subscription.</param>
    /// <param name="agentType">The agent type to subscribe.</param>
    public static async Task SubscribeAsync(this IAgentRuntime runtime, string agentType)
    {
        await runtime.AddSubscriptionAsync(new TypeSubscription(agentType, agentType)).ConfigureAwait(false);
    }

    /// <summary>
    /// Subscribes the specified agent type to the provided topics.
    /// </summary>
    /// <param name="runtime">The runtime for managing the subscription.</param>
    /// <param name="agentType">The agent type to subscribe.</param>
    /// <param name="topics">A variable list of topics for subscription.</param>
    public static async Task SubscribeAsync(this IAgentRuntime runtime, string agentType, params TopicId[] topics)
    {
        for (int index = 0; index < topics.Length; ++index)
        {
            await runtime.AddSubscriptionAsync(new TypeSubscription(topics[index].Type, agentType)).ConfigureAwait(false);
        }
    }
}


===== Orchestration\GroupChat\GroupChatAgentActor.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.SemanticKernel.Agents.Runtime;
using Microsoft.SemanticKernel.Agents.Runtime.Core;

namespace Microsoft.SemanticKernel.Agents.Orchestration.GroupChat;

/// <summary>
/// An <see cref="AgentActor"/> used with the <see cref="GroupChatOrchestration{TInput, TOutput}"/>.
/// </summary>
internal sealed class GroupChatAgentActor :
    AgentActor,
    IHandle<GroupChatMessages.Group>,
    IHandle<GroupChatMessages.Reset>,
    IHandle<GroupChatMessages.Speak>
{
    private readonly List<ChatMessageContent> _cache;

    /// <summary>
    /// Initializes a new instance of the <see cref="GroupChatAgentActor"/> class.
    /// </summary>
    /// <param name="id">The unique identifier of the agent.</param>
    /// <param name="runtime">The runtime associated with the agent.</param>
    /// <param name="context">The orchestration context.</param>
    /// <param name="agent">An <see cref="Agent"/>.</param>
    /// <param name="logger">The logger to use for the actor</param>
    public GroupChatAgentActor(AgentId id, IAgentRuntime runtime, OrchestrationContext context, Agent agent, ILogger<GroupChatAgentActor>? logger = null)
        : base(id, runtime, context, agent, logger)
    {
        this._cache = [];
    }

    /// <inheritdoc/>
    public ValueTask HandleAsync(GroupChatMessages.Group item, MessageContext messageContext)
    {
        this._cache.AddRange(item.Messages);

#if !NETCOREAPP
        return Task.CompletedTask.AsValueTask();
#else
        return ValueTask.CompletedTask;
#endif
    }

    /// <inheritdoc/>
    public async ValueTask HandleAsync(GroupChatMessages.Reset item, MessageContext messageContext)
    {
        await this.DeleteThreadAsync(messageContext.CancellationToken).ConfigureAwait(false);
    }

    /// <inheritdoc/>
    public async ValueTask HandleAsync(GroupChatMessages.Speak item, MessageContext messageContext)
    {
        this.Logger.LogChatAgentInvoke(this.Id);

        ChatMessageContent response = await this.InvokeAsync(this._cache, messageContext.CancellationToken).ConfigureAwait(false);

        this.Logger.LogChatAgentResult(this.Id, response.Content);

        this._cache.Clear();
        await this.PublishMessageAsync(response.AsGroupMessage(), this.Context.Topic).ConfigureAwait(false);
    }
}


===== Orchestration\GroupChat\GroupChatManager.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Threading;
using System.Threading.Tasks;
using Microsoft.SemanticKernel.ChatCompletion;

namespace Microsoft.SemanticKernel.Agents.Orchestration.GroupChat;

/// <summary>
/// Represents the result of a group chat manager operation, including a value and a reason.
/// </summary>
/// <typeparam name="TValue">The type of the value returned by the operation.</typeparam>
/// <param name="value">The value returned by the operation.</param>
public sealed class GroupChatManagerResult<TValue>(TValue value)
{
    /// <summary>
    /// The reason for the result, providing additional context or explanation.
    /// </summary>
    public string Reason { get; init; } = string.Empty;

    /// <summary>
    /// The value returned by the group chat manager operation.
    /// </summary>
    public TValue Value { get; } = value;
}

/// <summary>
/// A manager that manages the flow of a group chat.
/// </summary>
public abstract class GroupChatManager
{
    private int _invocationCount;

    /// <summary>
    /// Initializes a new instance of the <see cref="GroupChatManager"/> class.
    /// </summary>
    protected GroupChatManager() { }

    /// <summary>
    /// Gets the number of times the group chat manager has been invoked.
    /// </summary>
    public int InvocationCount => this._invocationCount;

    /// <summary>
    /// Gets or sets the maximum number of invocations allowed for the group chat manager.
    /// </summary>
    public int MaximumInvocationCount { get; init; } = int.MaxValue;

    /// <summary>
    /// Gets or sets the callback to be invoked for interactive input.
    /// </summary>
    public OrchestrationInteractiveCallback? InteractiveCallback { get; init; }

    /// <summary>
    /// Filters the results of the group chat based on the provided chat history.
    /// </summary>
    /// <param name="history">The chat history to filter.</param>
    /// <param name="cancellationToken">A cancellation token that can be used to cancel the operation.</param>
    /// <returns>A <see cref="GroupChatManagerResult{TValue}"/> containing the filtered result as a string.</returns>
    public abstract ValueTask<GroupChatManagerResult<string>> FilterResults(ChatHistory history, CancellationToken cancellationToken = default);

    /// <summary>
    /// Selects the next agent to participate in the group chat based on the provided chat history and team.
    /// </summary>
    /// <param name="history">The chat history to consider.</param>
    /// <param name="team">The group of agents participating in the chat.</param>
    /// <param name="cancellationToken">A cancellation token that can be used to cancel the operation.</param>
    /// <returns>A <see cref="GroupChatManagerResult{TValue}"/> containing the identifier of the next agent as a string.</returns>
    public abstract ValueTask<GroupChatManagerResult<string>> SelectNextAgent(ChatHistory history, GroupChatTeam team, CancellationToken cancellationToken = default);

    /// <summary>
    /// Determines whether user input should be requested based on the provided chat history.
    /// </summary>
    /// <param name="history">The chat history to consider.</param>
    /// <param name="cancellationToken">A cancellation token that can be used to cancel the operation.</param>
    /// <returns>A <see cref="GroupChatManagerResult{TValue}"/> indicating whether user input should be requested.</returns>
    public abstract ValueTask<GroupChatManagerResult<bool>> ShouldRequestUserInput(ChatHistory history, CancellationToken cancellationToken = default);

    /// <summary>
    /// Determines whether the group chat should be terminated based on the provided chat history and invocation count.
    /// </summary>
    /// <param name="history">The chat history to consider.</param>
    /// <param name="cancellationToken">A cancellation token that can be used to cancel the operation.</param>
    /// <returns>A <see cref="GroupChatManagerResult{TValue}"/> indicating whether the chat should be terminated.</returns>
    public virtual ValueTask<GroupChatManagerResult<bool>> ShouldTerminate(ChatHistory history, CancellationToken cancellationToken = default)
    {
        Interlocked.Increment(ref this._invocationCount);

        bool resultValue = false;
        string reason = "Maximum number of invocations has not been reached.";
        if (this.InvocationCount > this.MaximumInvocationCount)
        {
            resultValue = true;
            reason = "Maximum number of invocations reached.";
        }

        GroupChatManagerResult<bool> result = new(resultValue) { Reason = reason };

#if !NETCOREAPP
        return result.AsValueTask();
#else
        return ValueTask.FromResult(result);
#endif
    }
}


===== Orchestration\GroupChat\GroupChatManagerActor.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.SemanticKernel.Agents.Runtime;
using Microsoft.SemanticKernel.Agents.Runtime.Core;
using Microsoft.SemanticKernel.ChatCompletion;

namespace Microsoft.SemanticKernel.Agents.Orchestration.GroupChat;

/// <summary>
/// An <see cref="OrchestrationActor"/> used to manage a <see cref="GroupChatOrchestration{TInput, TOutput}"/>.
/// </summary>
internal sealed class GroupChatManagerActor :
    OrchestrationActor,
    IHandle<GroupChatMessages.InputTask>,
    IHandle<GroupChatMessages.Group>
{
    /// <summary>
    /// A common description for the manager.
    /// </summary>
    public const string DefaultDescription = "Orchestrates a team of agents to accomplish a defined task.";

    private readonly AgentType _orchestrationType;
    private readonly GroupChatManager _manager;
    private readonly ChatHistory _chat;
    private readonly GroupChatTeam _team;

    /// <summary>
    /// Initializes a new instance of the <see cref="GroupChatManagerActor"/> class.
    /// </summary>
    /// <param name="id">The unique identifier of the agent.</param>
    /// <param name="runtime">The runtime associated with the agent.</param>
    /// <param name="context">The orchestration context.</param>
    /// <param name="manager">The manages the flow of the group-chat.</param>
    /// <param name="team">The team of agents being orchestrated</param>
    /// <param name="orchestrationType">Identifies the orchestration agent.</param>
    /// <param name="logger">The logger to use for the actor</param>
    public GroupChatManagerActor(AgentId id, IAgentRuntime runtime, OrchestrationContext context, GroupChatManager manager, GroupChatTeam team, AgentType orchestrationType, ILogger? logger = null)
        : base(id, runtime, context, DefaultDescription, logger)
    {
        this._chat = [];
        this._manager = manager;
        this._orchestrationType = orchestrationType;
        this._team = team;
    }

    /// <inheritdoc/>
    public async ValueTask HandleAsync(GroupChatMessages.InputTask item, MessageContext messageContext)
    {
        this.Logger.LogChatManagerInit(this.Id);

        this._chat.AddRange(item.Messages);

        await this.PublishMessageAsync(item.Messages.AsGroupMessage(), this.Context.Topic).ConfigureAwait(false);

        await this.ManageAsync(messageContext).ConfigureAwait(false);
    }

    /// <inheritdoc/>
    public async ValueTask HandleAsync(GroupChatMessages.Group item, MessageContext messageContext)
    {
        this.Logger.LogChatManagerInvoke(this.Id);

        this._chat.AddRange(item.Messages);

        await this.ManageAsync(messageContext).ConfigureAwait(false);
    }

    private async ValueTask ManageAsync(MessageContext messageContext)
    {
        if (this._manager.InteractiveCallback != null)
        {
            GroupChatManagerResult<bool> inputResult = await this._manager.ShouldRequestUserInput(this._chat, messageContext.CancellationToken).ConfigureAwait(false);
            this.Logger.LogChatManagerInput(this.Id, inputResult.Value, inputResult.Reason);
            if (inputResult.Value)
            {
                ChatMessageContent input = await this._manager.InteractiveCallback.Invoke().ConfigureAwait(false);
                this.Logger.LogChatManagerUserInput(this.Id, input.Content);
                this._chat.Add(input);
                await this.PublishMessageAsync(input.AsGroupMessage(), this.Context.Topic).ConfigureAwait(false);
            }
        }

        GroupChatManagerResult<bool> terminateResult = await this._manager.ShouldTerminate(this._chat, messageContext.CancellationToken).ConfigureAwait(false);
        this.Logger.LogChatManagerTerminate(this.Id, terminateResult.Value, terminateResult.Reason);
        if (terminateResult.Value)
        {
            GroupChatManagerResult<string> filterResult = await this._manager.FilterResults(this._chat, messageContext.CancellationToken).ConfigureAwait(false);
            this.Logger.LogChatManagerResult(this.Id, filterResult.Value, filterResult.Reason);
            await this.PublishMessageAsync(filterResult.Value.AsResultMessage(), this._orchestrationType, messageContext.CancellationToken).ConfigureAwait(false);
            return;
        }

        GroupChatManagerResult<string> selectionResult = await this._manager.SelectNextAgent(this._chat, this._team, messageContext.CancellationToken).ConfigureAwait(false);
        AgentType selectionType = this._team[selectionResult.Value].Type;
        this.Logger.LogChatManagerSelect(this.Id, selectionType);
        await this.PublishMessageAsync(new GroupChatMessages.Speak(), selectionType, messageContext.CancellationToken).ConfigureAwait(false);
    }
}


===== Orchestration\GroupChat\GroupChatMessages.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using Microsoft.SemanticKernel.ChatCompletion;

namespace Microsoft.SemanticKernel.Agents.Orchestration.GroupChat;

/// <summary>
/// Common messages used for agent chat patterns.
/// </summary>
internal static class GroupChatMessages
{
    /// <summary>
    /// An empty message instance as a default.
    /// </summary>
    internal static readonly ChatMessageContent Empty = new();

    /// <summary>
    /// Broadcast a message to all <see cref="GroupChatAgentActor"/>.
    /// </summary>
    public sealed class Group
    {
        /// <summary>
        /// The chat message being broadcast.
        /// </summary>
        public IEnumerable<ChatMessageContent> Messages { get; init; } = [];
    }

    /// <summary>
    /// Reset/clear the conversation history for all <see cref="GroupChatAgentActor"/>.
    /// </summary>
    public sealed class Reset;

    /// <summary>
    /// The final result.
    /// </summary>
    public sealed class Result
    {
        /// <summary>
        /// The chat response message.
        /// </summary>
        public ChatMessageContent Message { get; init; } = Empty;
    }

    /// <summary>
    /// Signal a <see cref="GroupChatAgentActor"/> to respond.
    /// </summary>
    public sealed class Speak;

    /// <summary>
    /// The input task.
    /// </summary>
    public sealed class InputTask
    {
        /// <summary>
        /// A task that does not require any action.
        /// </summary>
        public static readonly InputTask None = new();

        /// <summary>
        /// The input that defines the task goal.
        /// </summary>
        public IEnumerable<ChatMessageContent> Messages { get; init; } = [];
    }

    /// <summary>
    /// Extension method to convert a <see cref="ChatMessageContent"/> to a <see cref="Group"/>.
    /// </summary>
    public static Group AsGroupMessage(this ChatMessageContent message) => new() { Messages = [message] };

    /// <summary>
    /// Extension method to convert a <see cref="ChatMessageContent"/> to a <see cref="Group"/>.
    /// </summary>
    public static Group AsGroupMessage(this IEnumerable<ChatMessageContent> messages) => new() { Messages = messages };

    /// <summary>
    /// Extension method to convert a <see cref="ChatMessageContent"/> to a <see cref="Result"/>.
    /// </summary>
    public static InputTask AsInputTaskMessage(this IEnumerable<ChatMessageContent> messages) => new() { Messages = messages };

    /// <summary>
    /// Extension method to convert a <see cref="string"/> to a <see cref="Result"/>.
    /// </summary>
    public static Result AsResultMessage(this string text) => new() { Message = new(AuthorRole.Assistant, text) };
}


===== Orchestration\GroupChat\GroupChatOrchestration.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.SemanticKernel.Agents.Orchestration.Extensions;
using Microsoft.SemanticKernel.Agents.Runtime;

namespace Microsoft.SemanticKernel.Agents.Orchestration.GroupChat;

/// <summary>
/// An orchestration that coordinates a group-chat.
/// </summary>
public class GroupChatOrchestration<TInput, TOutput> :
    AgentOrchestration<TInput, TOutput>
{
    internal const string DefaultAgentDescription = "A helpful agent.";

    private readonly GroupChatManager _manager;

    /// <summary>
    /// Initializes a new instance of the <see cref="GroupChatOrchestration{TInput, TOutput}"/> class.
    /// </summary>
    /// <param name="manager">The manages the flow of the group-chat.</param>
    /// <param name="agents">The agents participating in the orchestration.</param>
    public GroupChatOrchestration(GroupChatManager manager, params Agent[] agents)
        : base(agents)
    {
        Verify.NotNull(manager, nameof(manager));

        this._manager = manager;
    }

    /// <inheritdoc />
    protected override ValueTask StartAsync(IAgentRuntime runtime, TopicId topic, IEnumerable<ChatMessageContent> input, AgentType? entryAgent)
    {
        if (!entryAgent.HasValue)
        {
            throw new ArgumentException("Entry agent is not defined.", nameof(entryAgent));
        }
        return runtime.PublishMessageAsync(input.AsInputTaskMessage(), entryAgent.Value);
    }

    /// <inheritdoc />
    protected override async ValueTask<AgentType?> RegisterOrchestrationAsync(IAgentRuntime runtime, OrchestrationContext context, RegistrationContext registrar, ILogger logger)
    {
        AgentType outputType = await registrar.RegisterResultTypeAsync<GroupChatMessages.Result>(response => [response.Message]).ConfigureAwait(false);

        int agentCount = 0;
        GroupChatTeam team = [];
        foreach (Agent agent in this.Members)
        {
            ++agentCount;
            AgentType agentType = await RegisterAgentAsync(agent, agentCount).ConfigureAwait(false);
            string name = agent.Name ?? agent.Id ?? agentType;
            string? description = agent.Description;

            team[name] = (agentType, description ?? DefaultAgentDescription);

            logger.LogRegisterActor(this.OrchestrationLabel, agentType, "MEMBER", agentCount);

            await runtime.SubscribeAsync(agentType, context.Topic).ConfigureAwait(false);
        }

        AgentType managerType =
            await runtime.RegisterOrchestrationAgentAsync(
                this.FormatAgentType(context.Topic, "Manager"),
                (agentId, runtime) =>
                {
                    GroupChatManagerActor actor = new(agentId, runtime, context, this._manager, team, outputType, context.LoggerFactory.CreateLogger<GroupChatManagerActor>());
#if !NETCOREAPP
                    return actor.AsValueTask<IHostableAgent>();
#else
                    return ValueTask.FromResult<IHostableAgent>(actor);
#endif
                }).ConfigureAwait(false);
        logger.LogRegisterActor(this.OrchestrationLabel, managerType, "MANAGER");

        await runtime.SubscribeAsync(managerType, context.Topic).ConfigureAwait(false);

        return managerType;

        ValueTask<AgentType> RegisterAgentAsync(Agent agent, int agentCount) =>
            runtime.RegisterOrchestrationAgentAsync(
                this.FormatAgentType(context.Topic, $"Agent_{agentCount}"),
                (agentId, runtime) =>
                {
                    GroupChatAgentActor actor = new(agentId, runtime, context, agent, context.LoggerFactory.CreateLogger<GroupChatAgentActor>());
#if !NETCOREAPP
                    return actor.AsValueTask<IHostableAgent>();
#else
                    return ValueTask.FromResult<IHostableAgent>(actor);
#endif
                });
    }
}


===== Orchestration\GroupChat\GroupChatOrchestration.String.cs =====

// Copyright (c) Microsoft. All rights reserved.

namespace Microsoft.SemanticKernel.Agents.Orchestration.GroupChat;

/// <summary>
/// An orchestration that broadcasts the input message to each agent.
/// </summary>
public sealed class GroupChatOrchestration : GroupChatOrchestration<string, string>
{
    /// <summary>
    /// Initializes a new instance of the <see cref="GroupChatOrchestration"/> class.
    /// </summary>
    /// <param name="manager">The manages the flow of the group-chat.</param>
    /// <param name="members">The agents to be orchestrated.</param>
    public GroupChatOrchestration(GroupChatManager manager, params Agent[] members)
        : base(manager, members)
    {
    }
}


===== Orchestration\GroupChat\GroupChatTeam.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Linq;

namespace Microsoft.SemanticKernel.Agents.Orchestration.GroupChat;

/// <summary>
/// Describes a team of agents participating in a group chat.
/// </summary>
public class GroupChatTeam : Dictionary<string, (string Type, string Description)>;

/// <summary>
/// Extensions for <see cref="GroupChatTeam"/>.
/// </summary>
public static class ChatGroupExtensions
{
    /// <summary>
    /// Format the names of the agents in the team as a comma delimimted list.
    /// </summary>
    /// <param name="team">The agent team</param>
    /// <returns>A comma delimimted list of agent name.</returns>
    public static string FormatNames(this GroupChatTeam team) => string.Join(",", team.Select(t => t.Key));

    /// <summary>
    /// Format the names and descriptions of the agents in the team as a markdown list.
    /// </summary>
    /// <param name="team">The agent team</param>
    /// <returns>A markdown list of agent names and descriptions.</returns>
    public static string FormatList(this GroupChatTeam team) => string.Join("\n", team.Select(t => $"- {t.Key}: {t.Value.Description}"));
}


===== Orchestration\GroupChat\RoundRobinGroupChatManager.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.SemanticKernel.ChatCompletion;

namespace Microsoft.SemanticKernel.Agents.Orchestration.GroupChat;

/// <summary>
/// A <see cref="GroupChatManager"/> that selects agents in a round-robin fashion.
/// </summary>
/// <remarks>
/// Subclass this class to customize filter, termination, and user interaction behaviors.
/// </remarks>
public class RoundRobinGroupChatManager : GroupChatManager
{
    private int _currentAgentIndex;

    /// <inheritdoc/>
    public override ValueTask<GroupChatManagerResult<string>> FilterResults(ChatHistory history, CancellationToken cancellationToken = default)
    {
        GroupChatManagerResult<string> result = new(history.LastOrDefault()?.Content ?? string.Empty) { Reason = "Default result filter provides the final chat message." };
#if !NETCOREAPP
        return result.AsValueTask();
#else
        return ValueTask.FromResult(result);
#endif
    }

    /// <inheritdoc/>
    public override ValueTask<GroupChatManagerResult<string>> SelectNextAgent(ChatHistory history, GroupChatTeam team, CancellationToken cancellationToken = default)
    {
        string nextAgent = team.Skip(this._currentAgentIndex).First().Key;
        this._currentAgentIndex = (this._currentAgentIndex + 1) % team.Count;
        GroupChatManagerResult<string> result = new(nextAgent) { Reason = $"Selected agent at index: {this._currentAgentIndex}" };
#if !NETCOREAPP
        return result.AsValueTask();
#else
        return ValueTask.FromResult(result);
#endif
    }

    /// <inheritdoc/>
    public override ValueTask<GroupChatManagerResult<bool>> ShouldRequestUserInput(ChatHistory history, CancellationToken cancellationToken = default)
    {
        GroupChatManagerResult<bool> result = new(false) { Reason = "The default round-robin group chat manager does not request user input." };
#if !NETCOREAPP
        return result.AsValueTask();
#else
        return ValueTask.FromResult(result);
#endif
    }
}


===== Orchestration\Handoff\HandoffActor.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.SemanticKernel.Agents.Runtime;
using Microsoft.SemanticKernel.Agents.Runtime.Core;
using Microsoft.SemanticKernel.ChatCompletion;

namespace Microsoft.SemanticKernel.Agents.Orchestration.Handoff;

/// <summary>
/// An actor used with the <see cref="HandoffOrchestration{TInput,TOutput}"/>.
/// </summary>
internal sealed class HandoffActor :
    AgentActor,
    IHandle<HandoffMessages.InputTask>,
    IHandle<HandoffMessages.Request>,
    IHandle<HandoffMessages.Response>
{
    private readonly HandoffLookup _handoffs;
    private readonly AgentType _resultHandoff;
    private readonly List<ChatMessageContent> _cache;

    private string? _handoffAgent;
    private string? _taskSummary;

    /// <summary>
    /// Initializes a new instance of the <see cref="HandoffActor"/> class.
    /// </summary>
    /// <param name="id">The unique identifier of the agent.</param>
    /// <param name="runtime">The runtime associated with the agent.</param>
    /// <param name="context">The orchestration context.</param>
    /// <param name="agent">An <see cref="Agent"/>.</param>
    /// <param name="handoffs">The handoffs available to this agent</param>
    /// <param name="resultHandoff">The handoff agent for capturing the result.</param>
    /// <param name="logger">The logger to use for the actor</param>
    public HandoffActor(AgentId id, IAgentRuntime runtime, OrchestrationContext context, Agent agent, HandoffLookup handoffs, AgentType resultHandoff, ILogger<HandoffActor>? logger = null)
        : base(id, runtime, context, agent, logger)
    {
        if (handoffs.ContainsKey(agent.Name ?? agent.Id))
        {
            throw new ArgumentException($"The agent {agent.Name ?? agent.Id} cannot have a handoff to itself.", nameof(handoffs));
        }

        this._cache = [];
        this._handoffs = handoffs;
        this._resultHandoff = resultHandoff;
    }

    /// <summary>
    /// Gets or sets the callback to be invoked for interactive input.
    /// </summary>
    public OrchestrationInteractiveCallback? InteractiveCallback { get; init; }

    /// <inheritdoc/>
    protected override bool ResponseCallbackFilter(ChatMessageContent response) => response.Role == AuthorRole.Tool;

    /// <inheritdoc/>
    protected override AgentInvokeOptions CreateInvokeOptions(Func<ChatMessageContent, Task> messageHandler)
    {
        // Clone kernel to avoid modifying the original
        Kernel kernel = this.Agent.Kernel.Clone();
        kernel.AutoFunctionInvocationFilters.Add(new HandoffInvocationFilter());
        kernel.Plugins.Add(this.CreateHandoffPlugin());

        // Create invocation options that use auto-function invocation and our modified kernel.
        AgentInvokeOptions options =
            new()
            {
                Kernel = kernel,
                KernelArguments = new(new PromptExecutionSettings
                {
                    FunctionChoiceBehavior = FunctionChoiceBehavior.Auto(options: new()
                    {
                        RetainArgumentTypes = true,
                    })
                }),
                OnIntermediateMessage = messageHandler,
            };

        return options;
    }

    /// <inheritdoc/>
    public ValueTask HandleAsync(HandoffMessages.InputTask item, MessageContext messageContext)
    {
        this._taskSummary = null;
        this._cache.AddRange(item.Messages);

#if !NETCOREAPP
        return Task.CompletedTask.AsValueTask();
#else
        return ValueTask.CompletedTask;
#endif
    }

    /// <inheritdoc/>
    public ValueTask HandleAsync(HandoffMessages.Response item, MessageContext messageContext)
    {
        this._cache.Add(item.Message);

#if !NETCOREAPP
        return Task.CompletedTask.AsValueTask();
#else
        return ValueTask.CompletedTask;
#endif
    }

    /// <inheritdoc/>
    public async ValueTask HandleAsync(HandoffMessages.Request item, MessageContext messageContext)
    {
        this.Logger.LogHandoffAgentInvoke(this.Id);

        while (this._taskSummary == null)
        {
            ChatMessageContent response = await this.InvokeAsync(this._cache, messageContext.CancellationToken).ConfigureAwait(false);
            this._cache.Clear();

            this.Logger.LogHandoffAgentResult(this.Id, response.Content);

            // The response can potentially be a TOOL message from the Handoff plugin due to the filter
            // which will terminate the conversation when a function from the handoff plugin is called.
            // Since we don't want to publish that message, so we only publish if the response is an ASSISTANT message.
            if (response.Role == AuthorRole.Assistant)
            {
                await this.PublishMessageAsync(new HandoffMessages.Response { Message = response }, this.Context.Topic, messageId: null, messageContext.CancellationToken).ConfigureAwait(false);
            }

            if (this._handoffAgent != null)
            {
                AgentType handoffType = this._handoffs[this._handoffAgent].AgentType;
                await this.PublishMessageAsync(new HandoffMessages.Request(), handoffType, messageContext.CancellationToken).ConfigureAwait(false);

                this._handoffAgent = null;
                break;
            }

            if (this.InteractiveCallback != null && this._taskSummary == null)
            {
                ChatMessageContent input = await this.InteractiveCallback().ConfigureAwait(false);
                await this.PublishMessageAsync(new HandoffMessages.Response { Message = input }, this.Context.Topic, messageId: null, messageContext.CancellationToken).ConfigureAwait(false);
                this._cache.Add(input);
                continue;
            }

            await this.EndAsync(response.Content ?? "No handoff or human response function requested. Ending task.", messageContext.CancellationToken).ConfigureAwait(false);
        }
    }

    private KernelPlugin CreateHandoffPlugin()
    {
        return KernelPluginFactory.CreateFromFunctions(HandoffInvocationFilter.HandoffPlugin, CreateHandoffFunctions());

        IEnumerable<KernelFunction> CreateHandoffFunctions()
        {
            yield return KernelFunctionFactory.CreateFromMethod(
                this.EndAsync,
                functionName: "end_task_with_summary",
                description: "Complete the task with a summary when no further requests are given.");

            foreach (KeyValuePair<string, (AgentType _, string Description)> handoff in this._handoffs)
            {
                KernelFunction kernelFunction =
                    KernelFunctionFactory.CreateFromMethod(
                        (CancellationToken cancellationToken) => this.HandoffAsync(handoff.Key, cancellationToken),
                        functionName: $"transfer_to_{handoff.Key}",
                        description: handoff.Value.Description);

                yield return kernelFunction;
            }
        }
    }

    private ValueTask HandoffAsync(string agentName, CancellationToken cancellationToken = default)
    {
        this.Logger.LogHandoffFunctionCall(this.Id, agentName);
        this._handoffAgent = agentName;

#if !NETCOREAPP
        return Task.CompletedTask.AsValueTask();
#else
        return ValueTask.CompletedTask;
#endif
    }

    private async ValueTask EndAsync(string summary, CancellationToken cancellationToken)
    {
        this.Logger.LogHandoffSummary(this.Id, summary);
        this._taskSummary = summary;
        await this.PublishMessageAsync(new HandoffMessages.Result { Message = new ChatMessageContent(AuthorRole.Assistant, summary) }, this._resultHandoff, cancellationToken).ConfigureAwait(false);
    }
}


===== Orchestration\Handoff\HandoffInvocationFilter.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Threading.Tasks;

namespace Microsoft.SemanticKernel.Agents.Orchestration.Handoff;

internal sealed class HandoffInvocationFilter() : IAutoFunctionInvocationFilter
{
    public const string HandoffPlugin = nameof(HandoffPlugin);

    public async Task OnAutoFunctionInvocationAsync(AutoFunctionInvocationContext context, Func<AutoFunctionInvocationContext, Task> next)
    {
        // Execution the function
        await next(context).ConfigureAwait(false);

        // Signal termination if the function is part of the handoff plugin
        if (context.Function.PluginName == HandoffPlugin)
        {
            context.Terminate = true;
        }
    }
}


===== Orchestration\Handoff\HandoffMessages.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;

namespace Microsoft.SemanticKernel.Agents.Orchestration.Handoff;

/// <summary>
/// A message that describes the input task and captures results for a <see cref="HandoffOrchestration{TInput,TOutput}"/>.
/// </summary>
internal static class HandoffMessages
{
    /// <summary>
    /// An empty message instance as a default.
    /// </summary>
    internal static readonly ChatMessageContent Empty = new();

    /// <summary>
    /// The input message.
    /// </summary>
    public sealed class InputTask
    {
        /// <summary>
        /// The orchestration input messages.
        /// </summary>
        public IList<ChatMessageContent> Messages { get; init; } = [];
    }

    /// <summary>
    /// The final result.
    /// </summary>
    public sealed class Result
    {
        /// <summary>
        /// The orchestration result message.
        /// </summary>
        public ChatMessageContent Message { get; init; } = Empty;
    }

    /// <summary>
    /// Signals the handoff to another agent.
    /// </summary>
    public sealed class Request;

    /// <summary>
    /// Broadcast an agent response to all actors in the orchestration.
    /// </summary>
    public sealed class Response
    {
        /// <summary>
        /// The chat response message.
        /// </summary>
        public ChatMessageContent Message { get; init; } = Empty;
    }

    /// <summary>
    /// Extension method to convert a <see cref="ChatMessageContent"/> to a <see cref="Result"/>.
    /// </summary>
    public static InputTask AsInputTaskMessage(this IEnumerable<ChatMessageContent> messages) => new() { Messages = [.. messages] };

    /// <summary>
    /// Extension method to convert a <see cref="ChatMessageContent"/> to a <see cref="Result"/>.
    /// </summary>
    public static Result AsResultMessage(this ChatMessageContent message) => new() { Message = message };
}


===== Orchestration\Handoff\HandoffOrchestration.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.SemanticKernel.Agents.Orchestration.Extensions;
using Microsoft.SemanticKernel.Agents.Runtime;

namespace Microsoft.SemanticKernel.Agents.Orchestration.Handoff;

/// <summary>
/// An orchestration that provides the input message to the first agent
/// and Handoffly passes each agent result to the next agent.
/// </summary>
public class HandoffOrchestration<TInput, TOutput> : AgentOrchestration<TInput, TOutput>
{
    private readonly OrchestrationHandoffs _handoffs;

    /// <summary>
    /// Initializes a new instance of the <see cref="HandoffOrchestration{TInput, TOutput}"/> class.
    /// </summary>
    /// <param name="handoffs">Defines the handoff connections for each agent.</param>
    /// <param name="agents">The agents participating in the orchestration.</param>
    public HandoffOrchestration(OrchestrationHandoffs handoffs, params Agent[] agents)
        : base(agents)
    {
        // Create list of distinct agent names
        HashSet<string> agentNames = new(agents.Select(a => a.Name ?? a.Id), StringComparer.Ordinal);
        agentNames.Add(handoffs.FirstAgentName);
        // Extract names from handoffs that don't align with a member agent.
        string[] badNames = [.. handoffs.Keys.Concat(handoffs.Values.SelectMany(h => h.Keys)).Where(name => !agentNames.Contains(name))];
        // Fail fast if invalid names are present.
        if (badNames.Length > 0)
        {
            throw new ArgumentException($"The following agents are not defined in the orchestration: {string.Join(", ", badNames)}", nameof(handoffs));
        }

        this._handoffs = handoffs;
    }

    /// <summary>
    /// Gets or sets the callback to be invoked for interactive input.
    /// </summary>
    public OrchestrationInteractiveCallback? InteractiveCallback { get; init; }

    /// <inheritdoc />
    protected override async ValueTask StartAsync(IAgentRuntime runtime, TopicId topic, IEnumerable<ChatMessageContent> input, AgentType? entryAgent)
    {
        if (!entryAgent.HasValue)
        {
            throw new ArgumentException("Entry agent is not defined.", nameof(entryAgent));
        }
        await runtime.PublishMessageAsync(input.AsInputTaskMessage(), topic).ConfigureAwait(false);
        await runtime.PublishMessageAsync(new HandoffMessages.Request(), entryAgent.Value).ConfigureAwait(false);
    }

    /// <inheritdoc />
    protected override async ValueTask<AgentType?> RegisterOrchestrationAsync(IAgentRuntime runtime, OrchestrationContext context, RegistrationContext registrar, ILogger logger)
    {
        AgentType outputType = await registrar.RegisterResultTypeAsync<HandoffMessages.Result>(response => [response.Message]).ConfigureAwait(false);

        // Each agent handsoff its result to the next agent.
        Dictionary<string, AgentType> agentMap = [];
        Dictionary<string, HandoffLookup> handoffMap = [];
        AgentType agentType = outputType;
        for (int index = this.Members.Count - 1; index >= 0; --index)
        {
            Agent agent = this.Members[index];
            HandoffLookup map = [];
            handoffMap[agent.Name ?? agent.Id] = map;
            agentType =
                await runtime.RegisterOrchestrationAgentAsync(
                    this.GetAgentType(context.Topic, index),
                    (agentId, runtime) =>
                    {
                        HandoffActor actor =
                            new(agentId, runtime, context, agent, map, outputType, context.LoggerFactory.CreateLogger<HandoffActor>())
                            {
                                InteractiveCallback = this.InteractiveCallback
                            };
#if !NETCOREAPP
                        return actor.AsValueTask<IHostableAgent>();
#else
                        return ValueTask.FromResult<IHostableAgent>(actor);
#endif
                    }).ConfigureAwait(false);
            agentMap[agent.Name ?? agent.Id] = agentType;

            await runtime.SubscribeAsync(agentType, context.Topic).ConfigureAwait(false);

            logger.LogRegisterActor(this.OrchestrationLabel, agentType, "MEMBER", index + 1);
        }

        // Complete the handoff model
        foreach (KeyValuePair<string, AgentHandoffs> handoffs in this._handoffs)
        {
            // Retrieve the map for the agent (every agent had an empty map created)
            HandoffLookup agentHandoffs = handoffMap[handoffs.Key];
            foreach (KeyValuePair<string, string> handoff in handoffs.Value)
            {
                // name = (type,description)
                agentHandoffs[handoff.Key] = (agentMap[handoff.Key], handoff.Value);
            }
        }

        return agentMap[this._handoffs.FirstAgentName];
    }

    private AgentType GetAgentType(TopicId topic, int index) => this.FormatAgentType(topic, $"Agent_{index + 1}");
}


===== Orchestration\Handoff\HandoffOrchestration.String.cs =====

// Copyright (c) Microsoft. All rights reserved.

namespace Microsoft.SemanticKernel.Agents.Orchestration.Handoff;

/// <summary>
/// An orchestration that passes the input message to the first agent, and
/// then the subsequent result to the next agent, etc...
/// </summary>
public sealed class HandoffOrchestration : HandoffOrchestration<string, string>
{
    /// <summary>
    /// Initializes a new instance of the <see cref="HandoffOrchestration"/> class.
    /// </summary>
    /// <param name="handoffs">Defines the handoff connections for each agent.</param>
    /// <param name="members">The agents to be orchestrated.</param>
    public HandoffOrchestration(OrchestrationHandoffs handoffs, params Agent[] members)
        : base(handoffs, members)
    {
    }
}


===== Orchestration\Handoff\Handoffs.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using Microsoft.SemanticKernel.Agents.Runtime;

namespace Microsoft.SemanticKernel.Agents.Orchestration.Handoff;

/// <summary>
/// Defines the handoff relationships for a given agent.
/// Maps target agent names/IDs to handoff descriptions.
/// </summary>
public sealed class AgentHandoffs : Dictionary<string, string>
{
    /// <summary>
    /// Initializes a new instance of the <see cref="AgentHandoffs"/> class with no handoff relationships.
    /// </summary>
    public AgentHandoffs() { }

    /// <summary>
    /// Initializes a new instance of the <see cref="AgentHandoffs"/> class with the specified handoff relationships.
    /// </summary>
    /// <param name="handoffs">A dictionary mapping target agent names/IDs to handoff descriptions.</param>
    public AgentHandoffs(Dictionary<string, string> handoffs) : base(handoffs) { }
}

/// <summary>
/// Defines the orchestration handoff relationships for all agents in the system.
/// Maps source agent names/IDs to their <see cref="AgentHandoffs"/>.
/// </summary>
public sealed class OrchestrationHandoffs : Dictionary<string, AgentHandoffs>
{
    /// <summary>
    /// Initializes a new instance of the <see cref="OrchestrationHandoffs"/> class with no handoff relationships.
    /// </summary>
    /// <param name="firstAgent">The first agent to be invoked (prior to any handoff).</param>
    public OrchestrationHandoffs(Agent firstAgent)
        : this(firstAgent.Name ?? firstAgent.Id)
    { }

    /// <summary>
    /// Initializes a new instance of the <see cref="OrchestrationHandoffs"/> class with no handoff relationships.
    /// </summary>
    /// <param name="firstAgentName">The name of the first agent to be invoked (prior to any handoff).</param>
    public OrchestrationHandoffs(string firstAgentName)
    {
        Verify.NotNullOrWhiteSpace(firstAgentName, nameof(firstAgentName));
        this.FirstAgentName = firstAgentName;
    }

    /// <summary>
    /// The name of the first agent to be invoked (prior to any handoff).
    /// </summary>
    public string FirstAgentName { get; }

    /// <summary>
    /// Adds handoff relationships from a source agent to one or more target agents.
    /// Each target agent's name or ID is mapped to its description.
    /// </summary>
    /// <param name="source">The source agent.</param>
    /// <returns>The updated <see cref="OrchestrationHandoffs"/> instance.</returns>
    public static OrchestrationHandoffs StartWith(Agent source) => new(source);
}

/// <summary>
/// Extension methods for building and modifying <see cref="OrchestrationHandoffs"/> relationships.
/// </summary>
public static class OrchestrationHandoffsExtensions
{
    /// <summary>
    /// Adds handoff relationships from a source agent to one or more target agents.
    /// Each target agent's name or ID is mapped to its description.
    /// </summary>
    /// <param name="handoffs">The orchestration handoffs collection to update.</param>
    /// <param name="source">The source agent.</param>
    /// <param name="targets">The target agents to add as handoff targets for the source agent.</param>
    /// <returns>The updated <see cref="OrchestrationHandoffs"/> instance.</returns>
    public static OrchestrationHandoffs Add(this OrchestrationHandoffs handoffs, Agent source, params Agent[] targets)
    {
        string key = source.Name ?? source.Id;

        AgentHandoffs agentHandoffs = handoffs.GetAgentHandoffs(key);

        foreach (Agent target in targets)
        {
            agentHandoffs[target.Name ?? target.Id] = target.Description ?? string.Empty;
        }

        return handoffs;
    }

    /// <summary>
    /// Adds a handoff relationship from a source agent to a target agent with a custom description.
    /// </summary>
    /// <param name="handoffs">The orchestration handoffs collection to update.</param>
    /// <param name="source">The source agent.</param>
    /// <param name="target">The target agent.</param>
    /// <param name="description">The handoff description.</param>
    /// <returns>The updated <see cref="OrchestrationHandoffs"/> instance.</returns>
    public static OrchestrationHandoffs Add(this OrchestrationHandoffs handoffs, Agent source, Agent target, string description)
        => handoffs.Add(source.Name ?? source.Id, target.Name ?? target.Id, description);

    /// <summary>
    /// Adds a handoff relationship from a source agent to a target agent name/ID with a custom description.
    /// </summary>
    /// <param name="handoffs">The orchestration handoffs collection to update.</param>
    /// <param name="source">The source agent.</param>
    /// <param name="targetName">The target agent's name or ID.</param>
    /// <param name="description">The handoff description.</param>
    /// <returns>The updated <see cref="OrchestrationHandoffs"/> instance.</returns>
    public static OrchestrationHandoffs Add(this OrchestrationHandoffs handoffs, Agent source, string targetName, string description)
        => handoffs.Add(source.Name ?? source.Id, targetName, description);

    /// <summary>
    /// Adds a handoff relationship from a source agent name/ID to a target agent name/ID with a custom description.
    /// </summary>
    /// <param name="handoffs">The orchestration handoffs collection to update.</param>
    /// <param name="sourceName">The source agent's name or ID.</param>
    /// <param name="targetName">The target agent's name or ID.</param>
    /// <param name="description">The handoff description.</param>
    /// <returns>The updated <see cref="OrchestrationHandoffs"/> instance.</returns>
    public static OrchestrationHandoffs Add(this OrchestrationHandoffs handoffs, string sourceName, string targetName, string description)
    {
        AgentHandoffs agentHandoffs = handoffs.GetAgentHandoffs(sourceName);
        agentHandoffs[targetName] = description;

        return handoffs;
    }

    private static AgentHandoffs GetAgentHandoffs(this OrchestrationHandoffs handoffs, string key)
    {
        if (!handoffs.TryGetValue(key, out AgentHandoffs? agentHandoffs))
        {
            agentHandoffs = [];
            handoffs[key] = agentHandoffs;
        }

        return agentHandoffs;
    }
}

/// <summary>
/// Handoff relationships post-processed into a name-based lookup table that includes the agent type and handoff description.
/// Maps agent names/IDs to a tuple of <see cref="AgentType"/> and handoff description.
/// </summary>
internal sealed class HandoffLookup : Dictionary<string, (AgentType AgentType, string Description)>;


===== Orchestration\Logging\AgentOrchestrationLogMessages.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Diagnostics.CodeAnalysis;
using Microsoft.Extensions.Logging;
using Microsoft.SemanticKernel.Agents.Runtime;

namespace Microsoft.SemanticKernel.Agents.Orchestration;

/// <summary>
/// Extensions for logging <see cref="AgentOrchestration{TInput, TOutput}"/>.
/// </summary>
/// <remarks>
/// This extension uses the <see cref="LoggerMessageAttribute"/> to
/// generate logging code at compile time to achieve optimized code.
/// </remarks>
[ExcludeFromCodeCoverage]
internal static partial class AgentOrchestrationLogMessages
{
    /// <summary>
    /// Logs the start of the registration phase for an orchestration.
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Trace,
        Message = "REGISTER {Orchestration} Start: {Topic}")]
    public static partial void LogOrchestrationRegistrationStart(
        this ILogger logger,
        string orchestration,
        TopicId topic);

    /// <summary>
    /// Logs pattern actor registration.
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Information,
        Message = "REGISTER ACTOR {Orchestration} {label}: {AgentType}")]
    public static partial void LogRegisterActor(
        this ILogger logger,
        string orchestration,
        AgentType agentType,
        string label);

    /// <summary>
    /// Logs agent actor registration.
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Information,
        Message = "REGISTER ACTOR {Orchestration} {label} #{Count}: {AgentType}")]
    public static partial void LogRegisterActor(
        this ILogger logger,
        string orchestration,
        AgentType agentType,
        string label,
        int count);

    /// <summary>
    /// Logs the end of the registration phase for an orchestration.
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Trace,
        Message = "REGISTER {Orchestration} Complete: {Topic}")]
    public static partial void LogOrchestrationRegistrationDone(
        this ILogger logger,
        string orchestration,
        TopicId topic);

    /// <summary>
    /// Logs an orchestration invocation
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Information,
        Message = "INVOKE {Orchestration}: {Topic}")]
    public static partial void LogOrchestrationInvoke(
        this ILogger logger,
        string orchestration,
        TopicId topic);

    /// <summary>
    /// Logs that the orchestration has started successfully and
    /// yielded control back to the caller.
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Trace,
        Message = "YIELD {Orchestration}: {Topic}")]
    public static partial void LogOrchestrationYield(
        this ILogger logger,
        string orchestration,
        TopicId topic);

    /// <summary>
    /// Logs the start an orchestration (top/outer).
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Information,
        Message = "START {Orchestration}: {AgentId}")]
    public static partial void LogOrchestrationStart(
        this ILogger logger,
        string orchestration,
        AgentId agentId);

    /// <summary>
    /// Logs that orchestration request actor is active
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Information,
        Message = "INIT {Orchestration}: {AgentId}")]
    public static partial void LogOrchestrationRequestInvoke(
        this ILogger logger,
        string orchestration,
        AgentId agentId);

    /// <summary>
    /// Logs that orchestration request actor experienced an unexpected failure.
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Error,
        Message = "FAILURE {Orchestration}: {AgentId}")]
    public static partial void LogOrchestrationRequestFailure(
        this ILogger logger,
        string orchestration,
        AgentId agentId,
        Exception exception);

    /// <summary>
    /// Logs that orchestration result actor is active
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Information,
        Message = "EXIT {Orchestration}: {AgentId}")]
    public static partial void LogOrchestrationResultInvoke(
        this ILogger logger,
        string orchestration,
        AgentId agentId);

    /// <summary>
    /// Logs that orchestration result actor experienced an unexpected failure.
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Error,
        Message = "FAILURE {Orchestration}: {AgentId}")]
    public static partial void LogOrchestrationResultFailure(
        this ILogger logger,
        string orchestration,
        AgentId agentId,
        Exception exception);
}


===== Orchestration\Logging\ConcurrentOrchestrationLogMessages.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Diagnostics.CodeAnalysis;
using Microsoft.Extensions.Logging;
using Microsoft.SemanticKernel.Agents.Orchestration.Concurrent;
using Microsoft.SemanticKernel.Agents.Runtime;

namespace Microsoft.SemanticKernel.Agents.Orchestration;

/// <summary>
/// Extensions for logging <see cref="ConcurrentOrchestration{TInput, TOutput}"/>.
/// </summary>
/// <remarks>
/// This extension uses the <see cref="LoggerMessageAttribute"/> to
/// generate logging code at compile time to achieve optimized code.
/// </remarks>
[ExcludeFromCodeCoverage]
internal static partial class ConcurrentOrchestrationLogMessages
{
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Trace,
        Message = "REQUEST Concurrent agent [{AgentId}]")]
    public static partial void LogConcurrentAgentInvoke(
        this ILogger logger,
        AgentId agentId);

    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Trace,
        Message = "RESULT Concurrent agent [{AgentId}]: {Message}")]
    public static partial void LogConcurrentAgentResult(
        this ILogger logger,
        AgentId agentId,
        string? message);

    /// <summary>
    /// Logs result capture.
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Information,
        Message = "COLLECT Concurrent result [{AgentId}]: #{ResultCount} / {ExpectedCount}")]
    public static partial void LogConcurrentResultCapture(
        this ILogger logger,
        AgentId agentId,
        int resultCount,
        int expectedCount);
}


===== Orchestration\Logging\GroupChatOrchestrationLogMessages.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Diagnostics.CodeAnalysis;
using Microsoft.Extensions.Logging;
using Microsoft.SemanticKernel.Agents.Orchestration.GroupChat;
using Microsoft.SemanticKernel.Agents.Runtime;

namespace Microsoft.SemanticKernel.Agents.Orchestration;

/// <summary>
/// Extensions for logging <see cref="GroupChatOrchestration{TInput, TOutput}"/>.
/// </summary>
/// <remarks>
/// This extension uses the <see cref="LoggerMessageAttribute"/> to
/// generate logging code at compile time to achieve optimized code.
/// </remarks>
[ExcludeFromCodeCoverage]
internal static partial class GroupChatOrchestrationLogMessages
{
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Trace,
        Message = "CHAT AGENT invoked [{AgentId}]")]
    public static partial void LogChatAgentInvoke(
        this ILogger logger,
        AgentId agentId);

    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Trace,
        Message = "CHAT AGENT result [{AgentId}]: {Message}")]
    public static partial void LogChatAgentResult(
        this ILogger logger,
        AgentId agentId,
        string? message);

    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Debug,
        Message = "CHAT MANAGER initialized [{AgentId}]")]
    public static partial void LogChatManagerInit(
        this ILogger logger,
        AgentId agentId);

    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Debug,
        Message = "CHAT MANAGER invoked [{AgentId}]")]
    public static partial void LogChatManagerInvoke(
        this ILogger logger,
        AgentId agentId);

    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Debug,
        Message = "CHAT MANAGER terminate? [{AgentId}]: {Result} ({Reason})")]
    public static partial void LogChatManagerTerminate(
        this ILogger logger,
        AgentId agentId,
        bool result,
        string reason);

    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Debug,
        Message = "CHAT MANAGER select: {NextAgent} [{AgentId}]")]
    public static partial void LogChatManagerSelect(
        this ILogger logger,
        AgentId agentId,
        AgentType nextAgent);

    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Debug,
        Message = "CHAT MANAGER result [{AgentId}]: '{Result}' ({Reason})")]
    public static partial void LogChatManagerResult(
        this ILogger logger,
        AgentId agentId,
        string result,
        string reason);

    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Debug,
        Message = "CHAT MANAGER user-input? [{AgentId}]: {Result} ({Reason})")]
    public static partial void LogChatManagerInput(
        this ILogger logger,
        AgentId agentId,
        bool result,
        string reason);

    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Trace,
        Message = "CHAT AGENT user-input [{AgentId}]: {Message}")]
    public static partial void LogChatManagerUserInput(
        this ILogger logger,
        AgentId agentId,
        string? message);
}


===== Orchestration\Logging\HandoffOrchestrationLogMessages.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Diagnostics.CodeAnalysis;
using Microsoft.Extensions.Logging;
using Microsoft.SemanticKernel.Agents.Orchestration.Handoff;
using Microsoft.SemanticKernel.Agents.Runtime;

namespace Microsoft.SemanticKernel.Agents.Orchestration;

/// <summary>
/// Extensions for logging <see cref="HandoffOrchestration{TInput, TOutput}"/>.
/// </summary>
/// <remarks>
/// This extension uses the <see cref="LoggerMessageAttribute"/> to
/// generate logging code at compile time to achieve optimized code.
/// </remarks>
[ExcludeFromCodeCoverage]
internal static partial class HandoffOrchestrationLogMessages
{
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Trace,
        Message = "REQUEST Handoff agent [{AgentId}]")]
    public static partial void LogHandoffAgentInvoke(
        this ILogger logger,
        AgentId agentId);

    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Trace,
        Message = "RESULT Handoff agent [{AgentId}]: {Message}")]
    public static partial void LogHandoffAgentResult(
        this ILogger logger,
        AgentId agentId,
        string? message);

    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Trace,
        Message = "TOOL Handoff [{AgentId}]: {Name}")]
    public static partial void LogHandoffFunctionCall(
        this ILogger logger,
        AgentId agentId,
        string name);

    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Trace,
        Message = "RESULT Handoff summary [{AgentId}]: {Summary}")]
    public static partial void LogHandoffSummary(
        this ILogger logger,
        AgentId agentId,
        string? summary);
}


===== Orchestration\Logging\OrchestrationResultLogMessages.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Diagnostics.CodeAnalysis;
using Microsoft.Extensions.Logging;
using Microsoft.SemanticKernel.Agents.Runtime;

namespace Microsoft.SemanticKernel.Agents.Orchestration;

/// <summary>
/// Extensions for logging <see cref="OrchestrationResult{TValue}"/>.
/// </summary>
/// <remarks>
/// This extension uses the <see cref="LoggerMessageAttribute"/> to
/// generate logging code at compile time to achieve optimized code.
/// </remarks>
[ExcludeFromCodeCoverage]
internal static partial class OrchestrationResultLogMessages
{
    /// <summary>
    /// Logs <see cref="OrchestrationResult{TValue}"/> awaiting the orchestration.
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Trace,
        Message = "AWAIT {Orchestration}: {Topic}")]
    public static partial void LogOrchestrationResultAwait(
        this ILogger logger,
        string orchestration,
        TopicId topic);

    /// <summary>
    /// Logs <see cref="OrchestrationResult{TValue}"/> timeout while awaiting the orchestration.
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Error,
        Message = "TIMEOUT {Orchestration}: {Topic}")]
    public static partial void LogOrchestrationResultTimeout(
        this ILogger logger,
        string orchestration,
        TopicId topic);

    /// <summary>
    /// Logs <see cref="OrchestrationResult{TValue}"/> cancelled the orchestration.
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Error,
        Message = "CANCELLED {Orchestration}: {Topic}")]
    public static partial void LogOrchestrationResultCancelled(
        this ILogger logger,
        string orchestration,
        TopicId topic);

    /// <summary>
    /// Logs <see cref="OrchestrationResult{TValue}"/> the awaited the orchestration has completed.
    /// </summary>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Trace,
        Message = "COMPLETE {Orchestration}: {Topic}")]
    public static partial void LogOrchestrationResultComplete(
        this ILogger logger,
        string orchestration,
        TopicId topic);
}


===== Orchestration\Logging\SequentialOrchestrationLogMessages.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Diagnostics.CodeAnalysis;
using Microsoft.Extensions.Logging;
using Microsoft.SemanticKernel.Agents.Orchestration.Sequential;
using Microsoft.SemanticKernel.Agents.Runtime;

namespace Microsoft.SemanticKernel.Agents.Orchestration;

/// <summary>
/// Extensions for logging <see cref="SequentialOrchestration{TInput, TOutput}"/>.
/// </summary>
/// <remarks>
/// This extension uses the <see cref="LoggerMessageAttribute"/> to
/// generate logging code at compile time to achieve optimized code.
/// </remarks>
[ExcludeFromCodeCoverage]
internal static partial class SequentialOrchestrationLogMessages
{
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Trace,
        Message = "REQUEST Sequential agent [{AgentId}]")]
    public static partial void LogSequentialAgentInvoke(
        this ILogger logger,
        AgentId agentId);

    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Trace,
        Message = "RESULT Sequential agent [{AgentId}]: {Message}")]
    public static partial void LogSequentialAgentResult(
        this ILogger logger,
        AgentId agentId,
        string? message);
}


===== Orchestration\OrchestrationActor.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.SemanticKernel.Agents.Runtime;
using Microsoft.SemanticKernel.Agents.Runtime.Core;

namespace Microsoft.SemanticKernel.Agents.Orchestration;

/// <summary>
/// Base abstractions for any actor that participates in an orchestration.
/// </summary>
public abstract class OrchestrationActor : BaseAgent
{
    /// <summary>
    /// Initializes a new instance of the <see cref="OrchestrationActor"/> class.
    /// </summary>
    protected OrchestrationActor(AgentId id, IAgentRuntime runtime, OrchestrationContext context, string description, ILogger? logger = null)
        : base(id, runtime, description, logger)
    {
        this.Context = context;
    }

    /// <summary>
    /// The orchestration context.
    /// </summary>
    protected OrchestrationContext Context { get; }

    /// <summary>
    /// Sends a message to a specified recipient agent-type through the runtime.
    /// </summary>
    /// <param name="message">The message object to send.</param>
    /// <param name="agentType">The recipient agent's type.</param>
    /// <param name="cancellationToken">A token used to cancel the operation if needed.</param>
    /// <returns>The agent identifier, if it exists.</returns>
    protected async ValueTask PublishMessageAsync(
        object message,
        AgentType agentType,
        CancellationToken cancellationToken = default)
    {
        await base.PublishMessageAsync(message, new TopicId(agentType), messageId: null, cancellationToken).ConfigureAwait(false);
    }
}


===== Orchestration\OrchestrationContext.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Threading;
using Microsoft.Extensions.Logging;
using Microsoft.SemanticKernel.Agents.Runtime;

namespace Microsoft.SemanticKernel.Agents.Orchestration;

/// <summary>
/// Provides contextual information for an orchestration operation, including topic, cancellation, logging, and response callback.
/// </summary>
public sealed class OrchestrationContext
{
    internal OrchestrationContext(
        string orchestration,
        TopicId topic,
        OrchestrationResponseCallback? responseCallback,
        OrchestrationStreamingCallback? streamingCallback,
        Action<Exception> failureCallback,
        ILoggerFactory loggerFactory,
        CancellationToken cancellation)
    {
        this.Orchestration = orchestration;
        this.Topic = topic;
        this.FailureCallback = failureCallback;
        this.ResponseCallback = responseCallback;
        this.StreamingResponseCallback = streamingCallback;
        this.LoggerFactory = loggerFactory;
        this.Cancellation = cancellation;
    }

    /// <summary>
    /// Gets the name or identifier of the orchestration.
    /// </summary>
    public string Orchestration { get; }

    /// <summary>
    /// Gets the identifier associated with orchestration topic.
    /// </summary>
    /// <remarks>
    /// All orchestration actors are subscribed to this topic.
    /// </remarks>
    public TopicId Topic { get; }

    /// <summary>
    /// Gets the cancellation token that can be used to observe cancellation requests for the orchestration.
    /// </summary>
    public CancellationToken Cancellation { get; }

    /// <summary>
    /// Gets the associated logger factory for creating loggers within the orchestration context.
    /// </summary>
    public ILoggerFactory LoggerFactory { get; }

    /// <summary>
    /// Optional callback that is invoked for every agent response.
    /// </summary>
    public OrchestrationResponseCallback? ResponseCallback { get; }

    /// <summary>
    /// Optional callback that is invoked for every agent response.
    /// </summary>
    public OrchestrationStreamingCallback? StreamingResponseCallback { get; }

    /// <summary>
    /// Gets the callback that is invoked when an operation fails due to an exception.
    /// </summary>
    public Action<Exception> FailureCallback { get; }
}


===== Orchestration\OrchestrationResult.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.SemanticKernel.Agents.Runtime;

namespace Microsoft.SemanticKernel.Agents.Orchestration;

/// <summary>
/// Represents the result of an orchestration operation that yields a value of type <typeparamref name="TValue"/>.
/// This class encapsulates the asynchronous completion of an orchestration process.
/// </summary>
/// <typeparam name="TValue">The type of the value produced by the orchestration.</typeparam>
public sealed class OrchestrationResult<TValue> : IDisposable
{
    private readonly OrchestrationContext _context;
    private readonly CancellationTokenSource _cancelSource;
    private readonly TaskCompletionSource<TValue> _completion;
    private readonly ILogger _logger;
    private bool _isDisposed;

    internal OrchestrationResult(OrchestrationContext context, TaskCompletionSource<TValue> completion, CancellationTokenSource orchestrationCancelSource, ILogger logger)
    {
        this._cancelSource = orchestrationCancelSource;
        this._context = context;
        this._completion = completion;
        this._logger = logger;
    }

    /// <summary>
    /// Releases all resources used by the <see cref="OrchestrationResult{TValue}"/> instance.
    /// </summary>
    public void Dispose()
    {
        this.Dispose(disposing: true);
        GC.SuppressFinalize(this);
    }

    /// <summary>
    /// Gets the orchestration name associated with this orchestration result.
    /// </summary>
    public string Orchestration => this._context.Orchestration;

    /// <summary>
    /// Gets the topic identifier associated with this orchestration result.
    /// </summary>
    public TopicId Topic => this._context.Topic;

    /// <summary>
    /// Asynchronously retrieves the orchestration result value.
    /// If a timeout is specified, the method will throw a <see cref="TimeoutException"/>
    /// if the orchestration does not complete within the allotted time.
    /// </summary>
    /// <param name="timeout">An optional <see cref="TimeSpan"/> representing the maximum wait duration.</param>
    /// <param name="cancellationToken">A cancellation token that can be used to cancel the operation.</param>
    /// <returns>A <see cref="ValueTask{TValue}"/> representing the result of the orchestration.</returns>
    /// <exception cref="ObjectDisposedException">Thrown if this instance has been disposed.</exception>
    /// <exception cref="TimeoutException">Thrown if the orchestration does not complete within the specified timeout period.</exception>
    public async ValueTask<TValue> GetValueAsync(TimeSpan? timeout = null, CancellationToken cancellationToken = default)
    {
#if !NETCOREAPP
        if (this._isDisposed)
        {
            throw new ObjectDisposedException(this.GetType().Name);
        }
#else
        ObjectDisposedException.ThrowIf(this._isDisposed, this);
#endif

        this._logger.LogOrchestrationResultAwait(this.Orchestration, this.Topic);

        if (timeout.HasValue)
        {
#if NET
            try
            {
                await this._completion.Task.WaitAsync(timeout.Value, cancellationToken).ConfigureAwait(false);
            }
            catch (TimeoutException)
            {
                this._logger.LogOrchestrationResultTimeout(this.Orchestration, this.Topic);
                throw;
            }
#else
            Task completedTask = await Task.WhenAny(this._completion.Task, Task.Delay(timeout.Value, cancellationToken)).ConfigureAwait(false);
            if (completedTask != this._completion.Task)
            {
                this._logger.LogOrchestrationResultTimeout(this.Orchestration, this.Topic);
                throw new TimeoutException($"Orchestration did not complete within the allowed duration ({timeout}).");
            }
#endif
        }

        this._logger.LogOrchestrationResultComplete(this.Orchestration, this.Topic);

        return await this._completion.Task.ConfigureAwait(false);
    }

    /// <summary>
    /// Cancel the orchestration associated with this result.
    /// </summary>
    /// <exception cref="ObjectDisposedException">Thrown if this instance has been disposed.</exception>
    /// <remarks>
    /// Cancellation is not expected to immediately halt the orchestration.  Messages that
    /// are already in-flight may still be processed.
    /// </remarks>
    public void Cancel()
    {
#if !NETCOREAPP
        if (this._isDisposed)
        {
            throw new ObjectDisposedException(this.GetType().Name);
        }
#else
        ObjectDisposedException.ThrowIf(this._isDisposed, this);
#endif

        this._logger.LogOrchestrationResultCancelled(this.Orchestration, this.Topic);
        this._cancelSource.Cancel();
        this._completion.SetCanceled();
    }

    private void Dispose(bool disposing)
    {
        if (!this._isDisposed)
        {
            if (disposing)
            {
                this._cancelSource.Dispose();
            }

            this._isDisposed = true;
        }
    }
}


===== Orchestration\Properties\AssemblyInfo.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Diagnostics.CodeAnalysis;

// This assembly is currently experimental.
[assembly: Experimental("SKEXP0110")]


===== Orchestration\Sequential\SequentialActor.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.SemanticKernel.Agents.Runtime;
using Microsoft.SemanticKernel.Agents.Runtime.Core;

namespace Microsoft.SemanticKernel.Agents.Orchestration.Sequential;

/// <summary>
/// An actor used with the <see cref="SequentialOrchestration{TInput,TOutput}"/>.
/// </summary>
internal sealed class SequentialActor :
    AgentActor,
    IHandle<SequentialMessages.Request>,
    IHandle<SequentialMessages.Response>
{
    private readonly AgentType _nextAgent;

    /// <summary>
    /// Initializes a new instance of the <see cref="SequentialActor"/> class.
    /// </summary>
    /// <param name="id">The unique identifier of the agent.</param>
    /// <param name="runtime">The runtime associated with the agent.</param>
    /// <param name="context">The orchestration context.</param>
    /// <param name="agent">An <see cref="Agent"/>.</param>
    /// <param name="nextAgent">The identifier of the next agent for which to handoff the result</param>
    /// <param name="logger">The logger to use for the actor</param>
    public SequentialActor(AgentId id, IAgentRuntime runtime, OrchestrationContext context, Agent agent, AgentType nextAgent, ILogger<SequentialActor>? logger = null)
        : base(id, runtime, context, agent, logger)
    {
        logger?.LogInformation("ACTOR {ActorId} {NextAgent}", this.Id, nextAgent);
        this._nextAgent = nextAgent;
    }

    /// <inheritdoc/>
    public async ValueTask HandleAsync(SequentialMessages.Request item, MessageContext messageContext)
    {
        await this.InvokeAgentAsync(item.Messages, messageContext).ConfigureAwait(false);
    }

    /// <inheritdoc/>
    public async ValueTask HandleAsync(SequentialMessages.Response item, MessageContext messageContext)
    {
        await this.InvokeAgentAsync([item.Message], messageContext).ConfigureAwait(false);
    }

    private async ValueTask InvokeAgentAsync(IList<ChatMessageContent> input, MessageContext messageContext)
    {
        this.Logger.LogInformation("INVOKE {ActorId} {NextAgent}", this.Id, this._nextAgent);

        this.Logger.LogSequentialAgentInvoke(this.Id);

        ChatMessageContent response = await this.InvokeAsync(input, messageContext.CancellationToken).ConfigureAwait(false);

        this.Logger.LogSequentialAgentResult(this.Id, response.Content);

        await this.PublishMessageAsync(response.AsResponseMessage(), this._nextAgent, messageContext.CancellationToken).ConfigureAwait(false);
    }
}


===== Orchestration\Sequential\SequentialMessages.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;

namespace Microsoft.SemanticKernel.Agents.Orchestration.Sequential;

/// <summary>
/// A message that describes the input task and captures results for a <see cref="SequentialOrchestration{TInput,TOutput}"/>.
/// </summary>
internal static class SequentialMessages
{
    /// <summary>
    /// An empty message instance as a default.
    /// </summary>
    public static readonly ChatMessageContent Empty = new();

    /// <summary>
    /// Represents a request containing a sequence of chat messages to be processed by the sequential orchestration.
    /// </summary>
    public sealed class Request
    {
        /// <summary>
        /// The request input.
        /// </summary>
        public IList<ChatMessageContent> Messages { get; init; } = [];
    }

    /// <summary>
    /// Represents a response containing the result message from the sequential orchestration.
    /// </summary>
    public sealed class Response
    {
        /// <summary>
        /// The response message.
        /// </summary>
        public ChatMessageContent Message { get; init; } = Empty;
    }

    /// <summary>
    /// Extension method to convert a <see cref="ChatMessageContent"/> to a <see cref="SequentialMessages.Request"/>.
    /// </summary>
    /// <param name="message">The chat message to include in the request.</param>
    /// <returns>A <see cref="SequentialMessages.Request"/> containing the provided messages.</returns>
    public static Request AsRequestMessage(this ChatMessageContent message) => new() { Messages = [message] };

    /// <summary>
    /// Extension method to convert a collection of <see cref="ChatMessageContent"/> to a <see cref="SequentialMessages.Request"/>.
    /// </summary>
    /// <param name="messages">The collection of chat messages to include in the request.</param>
    /// <returns>A <see cref="SequentialMessages.Request"/> containing the provided messages.</returns>
    public static Request AsRequestMessage(this IEnumerable<ChatMessageContent> messages) => new() { Messages = [.. messages] };

    /// <summary>
    /// Extension method to convert a <see cref="ChatMessageContent"/> to a <see cref="SequentialMessages.Response"/>.
    /// </summary>
    /// <param name="message">The chat message to include in the response.</param>
    /// <returns>A <see cref="SequentialMessages.Response"/> containing the provided message.</returns>
    public static Response AsResponseMessage(this ChatMessageContent message) => new() { Message = message };
}


===== Orchestration\Sequential\SequentialOrchestration.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.SemanticKernel.Agents.Orchestration.Extensions;
using Microsoft.SemanticKernel.Agents.Runtime;

namespace Microsoft.SemanticKernel.Agents.Orchestration.Sequential;

/// <summary>
/// An orchestration that provides the input message to the first agent
/// and sequentially passes each agent result to the next agent.
/// </summary>
public class SequentialOrchestration<TInput, TOutput> : AgentOrchestration<TInput, TOutput>
{
    /// <summary>
    /// Initializes a new instance of the <see cref="SequentialOrchestration{TInput, TOutput}"/> class.
    /// </summary>
    /// <param name="agents">The agents participating in the orchestration.</param>
    public SequentialOrchestration(params Agent[] agents)
        : base(agents)
    {
    }

    /// <inheritdoc />
    protected override async ValueTask StartAsync(IAgentRuntime runtime, TopicId topic, IEnumerable<ChatMessageContent> input, AgentType? entryAgent)
    {
        if (!entryAgent.HasValue)
        {
            throw new ArgumentException("Entry agent is not defined.", nameof(entryAgent));
        }
        await runtime.PublishMessageAsync(input.AsRequestMessage(), entryAgent.Value).ConfigureAwait(false);
    }

    /// <inheritdoc />
    protected override async ValueTask<AgentType?> RegisterOrchestrationAsync(IAgentRuntime runtime, OrchestrationContext context, RegistrationContext registrar, ILogger logger)
    {
        AgentType outputType = await registrar.RegisterResultTypeAsync<SequentialMessages.Response>(response => [response.Message]).ConfigureAwait(false);

        // Each agent handsoff its result to the next agent.
        AgentType nextAgent = outputType;
        for (int index = this.Members.Count - 1; index >= 0; --index)
        {
            Agent agent = this.Members[index];
            nextAgent = await RegisterAgentAsync(agent, index, nextAgent).ConfigureAwait(false);

            logger.LogRegisterActor(this.OrchestrationLabel, nextAgent, "MEMBER", index + 1);
        }

        return nextAgent;

        ValueTask<AgentType> RegisterAgentAsync(Agent agent, int index, AgentType nextAgent) =>
            runtime.RegisterOrchestrationAgentAsync(
                this.GetAgentType(context.Topic, index),
                (agentId, runtime) =>
                {
                    SequentialActor actor = new(agentId, runtime, context, agent, nextAgent, context.LoggerFactory.CreateLogger<SequentialActor>());

#if !NETCOREAPP
                    return actor.AsValueTask<IHostableAgent>();
#else
                    return ValueTask.FromResult<IHostableAgent>(actor);
#endif
                });
    }

    private AgentType GetAgentType(TopicId topic, int index) => this.FormatAgentType(topic, $"Agent_{index + 1}");
}


===== Orchestration\Sequential\SequentialOrchestration.String.cs =====

// Copyright (c) Microsoft. All rights reserved.

namespace Microsoft.SemanticKernel.Agents.Orchestration.Sequential;

/// <summary>
/// An orchestration that passes the input message to the first agent, and
/// then the subsequent result to the next agent, etc...
/// </summary>
public sealed class SequentialOrchestration : SequentialOrchestration<string, string>
{
    /// <summary>
    /// Initializes a new instance of the <see cref="SequentialOrchestration"/> class.
    /// </summary>
    /// <param name="members">The agents to be orchestrated.</param>
    public SequentialOrchestration(params Agent[] members)
        : base(members)
    {
    }
}


===== Orchestration\Transforms\DefaultTransforms.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.SemanticKernel.ChatCompletion;

namespace Microsoft.SemanticKernel.Agents.Orchestration.Transforms;

internal static class DefaultTransforms
{
    public static ValueTask<IEnumerable<ChatMessageContent>> FromInput<TInput>(TInput input, CancellationToken cancellationToken = default)
    {
#if !NETCOREAPP
        return TransformInput().AsValueTask();
#else
        return ValueTask.FromResult(TransformInput());
#endif

        IEnumerable<ChatMessageContent> TransformInput() =>
            input switch
            {
                IEnumerable<ChatMessageContent> messages => messages,
                ChatMessageContent message => [message],
                string text => [new ChatMessageContent(AuthorRole.User, text)],
                _ => [new ChatMessageContent(AuthorRole.User, JsonSerializer.Serialize(input))]
            };
    }

    public static ValueTask<TOutput> ToOutput<TOutput>(IList<ChatMessageContent> result, CancellationToken cancellationToken = default)
    {
        bool isSingleResult = result.Count == 1;

        TOutput output =
            GetDefaultOutput() ??
            GetObjectOutput() ??
            throw new InvalidOperationException($"Unable to transform output to {typeof(TOutput)}.");

        return new ValueTask<TOutput>(output);

        TOutput? GetObjectOutput()
        {
            if (!isSingleResult)
            {
                return default;
            }

            try
            {
                return JsonSerializer.Deserialize<TOutput>(result[0].Content ?? string.Empty);
            }
            catch (JsonException)
            {
                return default;
            }
        }

        TOutput? GetDefaultOutput()
        {
            object? output = null;
            if (typeof(TOutput).IsAssignableFrom(result.GetType()))
            {
                output = (object)result;
            }
            else if (isSingleResult && typeof(ChatMessageContent).IsAssignableFrom(typeof(TOutput)))
            {
                output = (object)result[0];
            }
            else if (isSingleResult && typeof(string) == typeof(TOutput))
            {
                output = result[0].Content ?? string.Empty;
            }

            return (TOutput?)output;
        }
    }
}


===== Orchestration\Transforms\OrchestrationTransforms.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;

namespace Microsoft.SemanticKernel.Agents.Orchestration.Transforms;

/// <summary>
/// Delegate for transforming an input of type <typeparamref name="TInput"/> into a collection of <see cref="ChatMessageContent"/>.
/// This is typically used to convert user or system input into a format suitable for chat orchestration.
/// </summary>
/// <param name="input">The input object to transform.</param>
/// <param name="cancellationToken">A cancellation token that can be used to cancel the operation.</param>
/// <returns>A <see cref="ValueTask{TResult}"/> containing an enumerable of <see cref="ChatMessageContent"/> representing the transformed input.</returns>
public delegate ValueTask<IEnumerable<ChatMessageContent>> OrchestrationInputTransform<TInput>(TInput input, CancellationToken cancellationToken = default);

/// <summary>
/// Delegate for transforming a <see cref="ChatMessageContent"/> into an output of type <typeparamref name="TOutput"/>.
/// This is typically used to convert a chat response into a desired output format.
/// </summary>
/// <param name="result">The result messages to transform.</param>
/// <param name="cancellationToken">A cancellation token that can be used to cancel the operation.</param>
/// <returns>A <see cref="ValueTask{TResult}"/> containing the transformed output of type <typeparamref name="TOutput"/>.</returns>
public delegate ValueTask<TOutput> OrchestrationOutputTransform<TOutput>(IList<ChatMessageContent> result, CancellationToken cancellationToken = default);

/// <summary>
/// Delegate for transforming the internal result message for an orchestration into a <see cref="ChatMessageContent"/>.
/// </summary>
/// <typeparam name="TResult">The result message type</typeparam>
/// <param name="result">The result messages</param>
/// <returns>The orchestration result as a <see cref="ChatMessageContent"/>.</returns>
public delegate IList<ChatMessageContent> OrchestrationResultTransform<TResult>(TResult result);


===== Orchestration\Transforms\StructuredOutputTransform.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.SemanticKernel.ChatCompletion;

namespace Microsoft.SemanticKernel.Agents.Orchestration.Transforms;

/// <summary>
/// Populates the target result type  <see cref="ChatMessageContent"/> into a structured output.
/// </summary>
/// <typeparam name="TOutput">The .NET type of the structured-output to deserialization target.</typeparam>
public sealed class StructuredOutputTransform<TOutput>
{
    internal const string DefaultInstructions = "Respond with JSON that is populated by using the information in this conversation.";

    private readonly IChatCompletionService _service;
    private readonly PromptExecutionSettings _executionSettings;

    /// <summary>
    /// Initializes a new instance of the <see cref="StructuredOutputTransform{TOutput}"/> class.
    /// </summary>
    /// <param name="service">The chat completion service to use for generating responses.</param>
    /// <param name="executionSettings">The prompt execution settings to use for the chat completion service.</param>
    public StructuredOutputTransform(IChatCompletionService service, PromptExecutionSettings executionSettings)
    {
        Verify.NotNull(service, nameof(service));
        Verify.NotNull(executionSettings, nameof(executionSettings));

        this._service = service;
        this._executionSettings = executionSettings;
    }

    /// <summary>
    /// Gets or sets the instructions to be used as the system message for the chat completion.
    /// </summary>
    public string Instructions { get; init; } = DefaultInstructions;

    /// <summary>
    /// Transforms the provided <see cref="ChatMessageContent"/> into a strongly-typed structured output by invoking the chat completion service and deserializing the response.
    /// </summary>
    /// <param name="messages">The chat messages to process.</param>
    /// <param name="cancellationToken">A cancellation token to observe while waiting for the task to complete.</param>
    /// <returns>The structured output of type <typeparamref name="TOutput"/>.</returns>
    /// <exception cref="InvalidOperationException">Thrown if the response cannot be deserialized into <typeparamref name="TOutput"/>.</exception>
    public async ValueTask<TOutput> TransformAsync(IList<ChatMessageContent> messages, CancellationToken cancellationToken = default)
    {
        ChatHistory history =
            [
                new ChatMessageContent(AuthorRole.System, this.Instructions),
                .. messages,
            ];
        ChatMessageContent response = await this._service.GetChatMessageContentAsync(history, this._executionSettings, kernel: null, cancellationToken).ConfigureAwait(false);
        return
            JsonSerializer.Deserialize<TOutput>(response.Content ?? string.Empty) ??
            throw new InvalidOperationException($"Unable to transform result into {typeof(TOutput).Name}");
    }
}


===== Runtime\Abstractions.Tests\AgentIdTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using FluentAssertions;
using Xunit;

namespace Microsoft.SemanticKernel.Agents.Runtime.Abstractions.Tests;

[Trait("Category", "Unit")]
public class AgentIdTests()
{
    [Theory]
    [InlineData(null)]
    [InlineData("")]
    [InlineData(" ")]
    [InlineData("invalid\u007Fkey")] // DEL character (127) is outside ASCII 32-126 range
    [InlineData("invalid\u0000key")] // NULL character is outside ASCII 32-126 range
    [InlineData("invalid\u0010key")] // Control character is outside ASCII 32-126 range
    [InlineData("InvalidKey")] // Control character is outside ASCII 32-126 range
    public void AgentIdShouldThrowArgumentExceptionWithInvalidKey(string? invalidKey)
    {
        // Act & Assert
        ArgumentException exception = Assert.Throws<ArgumentException>(() => new AgentId("validType", invalidKey!));
        Assert.Contains("Invalid AgentId key", exception.Message);
    }

    [Fact]
    public void AgentIdShouldInitializeCorrectlyTest()
    {
        AgentId agentId = new("TestType", "TestKey");

        agentId.Type.Should().Be("TestType");
        agentId.Key.Should().Be("TestKey");
    }

    [Fact]
    public void AgentIdShouldConvertFromTupleTest()
    {
        (string, string) agentTuple = ("TupleType", "TupleKey");
        AgentId agentId = new(agentTuple);

        agentId.Type.Should().Be("TupleType");
        agentId.Key.Should().Be("TupleKey");
    }

    [Fact]
    public void AgentIdShouldConvertFromAgentType()
    {
        AgentType agentType = "TestType";
        AgentId agentId = new(agentType, "TestKey");

        agentId.Type.Should().Be("TestType");
        agentId.Key.Should().Be("TestKey");
    }

    [Fact]
    public void AgentIdShouldParseFromStringTest()
    {
        AgentId agentId = AgentId.FromStr("ParsedType/ParsedKey");

        agentId.Type.Should().Be("ParsedType");
        agentId.Key.Should().Be("ParsedKey");
    }

    [Fact]
    public void AgentIdShouldCompareEqualityCorrectlyTest()
    {
        AgentId agentId1 = new("SameType", "SameKey");
        AgentId agentId2 = new("SameType", "SameKey");
        AgentId agentId3 = new("DifferentType", "DifferentKey");

        agentId1.Should().Be(agentId2);
        agentId1.Should().NotBe(agentId3);
        (agentId1 == agentId2).Should().BeTrue();
        (agentId1 != agentId3).Should().BeTrue();
    }

    [Fact]
    public void AgentIdShouldGenerateCorrectHashCodeTest()
    {
        AgentId agentId1 = new("HashType", "HashKey");
        AgentId agentId2 = new("HashType", "HashKey");
        AgentId agentId3 = new("DifferentType", "DifferentKey");

        agentId1.GetHashCode().Should().Be(agentId2.GetHashCode());
        agentId1.GetHashCode().Should().NotBe(agentId3.GetHashCode());
    }

    [Fact]
    public void AgentIdShouldConvertExplicitlyFromStringTest()
    {
        AgentId agentId = (AgentId)"ConvertedType/ConvertedKey";

        agentId.Type.Should().Be("ConvertedType");
        agentId.Key.Should().Be("ConvertedKey");
    }

    [Fact]
    public void AgentIdShouldReturnCorrectToStringTest()
    {
        AgentId agentId = new("ToStringType", "ToStringKey");

        agentId.ToString().Should().Be("ToStringType/ToStringKey");
    }

    [Fact]
    public void AgentIdShouldCompareInequalityForWrongTypeTest()
    {
        AgentId agentId1 = new("Type1", "Key1");

        (!agentId1.Equals(Guid.NewGuid())).Should().BeTrue();
    }

    [Fact]
    public void AgentIdShouldCompareInequalityCorrectlyTest()
    {
        AgentId agentId1 = new("Type1", "Key1");
        AgentId agentId2 = new("Type2", "Key2");

        (agentId1 != agentId2).Should().BeTrue();
    }
}


===== Runtime\Abstractions.Tests\AgentMetaDataTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using FluentAssertions;
using Xunit;

namespace Microsoft.SemanticKernel.Agents.Runtime.Abstractions.Tests;

[Trait("Category", "Unit")]
public class AgentMetadataTests()
{
    [Fact]
    public void AgentMetadataShouldInitializeCorrectlyTest()
    {
        // Arrange & Act
        AgentMetadata metadata = new("TestType", "TestKey", "TestDescription");

        // Assert
        metadata.Type.Should().Be("TestType");
        metadata.Key.Should().Be("TestKey");
        metadata.Description.Should().Be("TestDescription");
    }
}


===== Runtime\Abstractions.Tests\AgentProxyTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Moq;
using Xunit;

namespace Microsoft.SemanticKernel.Agents.Runtime.Abstractions.Tests;

[Trait("Category", "Unit")]
public class AgentProxyTests
{
    private readonly Mock<IAgentRuntime> mockRuntime;
    private readonly AgentId agentId;
    private readonly AgentProxy agentProxy;

    public AgentProxyTests()
    {
        this.mockRuntime = new Mock<IAgentRuntime>();
        this.agentId = new AgentId("testType", "testKey");
        this.agentProxy = new AgentProxy(this.agentId, this.mockRuntime.Object);
    }

    [Fact]
    public void IdMatchesAgentIdTest()
    {
        // Assert
        Assert.Equal(this.agentId, this.agentProxy.Id);
    }

    [Fact]
    public void MetadataShouldMatchAgentTest()
    {
        AgentMetadata expectedMetadata = new("testType", "testKey", "testDescription");
        this.mockRuntime.Setup(r => r.GetAgentMetadataAsync(this.agentId))
            .ReturnsAsync(expectedMetadata);

        Assert.Equal(expectedMetadata, this.agentProxy.Metadata);
    }

    [Fact]
    public async Task SendMessageResponseTest()
    {
        // Arrange
        object message = new { Content = "Hello" };
        AgentId sender = new("senderType", "senderKey");
        object response = new { Content = "Response" };

        this.mockRuntime.Setup(r => r.SendMessageAsync(message, this.agentId, sender, null, It.IsAny<CancellationToken>()))
            .ReturnsAsync(response);

        // Act
        object? result = await this.agentProxy.SendMessageAsync(message, sender);

        // Assert
        Assert.Equal(response, result);
    }

    [Fact]
    public async Task LoadStateTest()
    {
        // Arrange
        JsonElement state = JsonDocument.Parse("{\"key\":\"value\"}").RootElement;

        this.mockRuntime.Setup(r => r.LoadAgentStateAsync(this.agentId, state))
            .Returns(ValueTask.CompletedTask);

        // Act
        await this.agentProxy.LoadStateAsync(state);

        // Assert
        this.mockRuntime.Verify(r => r.LoadAgentStateAsync(this.agentId, state), Times.Once);
    }

    [Fact]
    public async Task SaveStateTest()
    {
        // Arrange
        JsonElement expectedState = JsonDocument.Parse("{\"key\":\"value\"}").RootElement;

        this.mockRuntime.Setup(r => r.SaveAgentStateAsync(this.agentId))
            .ReturnsAsync(expectedState);

        // Act
        JsonElement result = await this.agentProxy.SaveStateAsync();

        // Assert
        Assert.Equal(expectedState, result);
    }
}


===== Runtime\Abstractions.Tests\AgentTypeTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using Xunit;

namespace Microsoft.SemanticKernel.Agents.Runtime.Abstractions.Tests;

[Trait("Category", "Unit")]
public class AgentTypeTests
{
    [Theory]
    [InlineData(null)]
    [InlineData("")]
    [InlineData(" ")]
    [InlineData("invalid type")] // Agent type must only contain alphanumeric letters or underscores
    [InlineData("123invalidType")] // Agent type cannot start with a number
    [InlineData("invalid@type")] // Agent type must only contain alphanumeric letters or underscores
    [InlineData("invalid-type")] // Agent type cannot alphanumeric underscores.
    public void AgentIdShouldThrowArgumentExceptionWithInvalidType(string? invalidType)
    {
        // Act & Assert
        ArgumentException exception = Assert.Throws<ArgumentException>(() => new AgentType(invalidType!));
        Assert.Contains("Invalid AgentId type", exception.Message);
    }

    [Fact]
    public void ImplicitConversionFromStringTest()
    {
        // Arrange
        string agentTypeName = "TestAgent";

        // Act
        AgentType agentType = agentTypeName;

        // Assert
        Assert.Equal(agentTypeName, agentType.Name);
    }

    [Fact]
    public void ImplicitConversionToStringTest()
    {
        // Arrange
        AgentType agentType = "TestAgent";

        // Act
        string agentTypeName = agentType;

        // Assert
        Assert.Equal("TestAgent", agentTypeName);
    }

    [Fact]
    public void ExplicitConversionFromTypeTest()
    {
        // Arrange
        Type type = typeof(string);

        // Act
        AgentType agentType = (AgentType)type;

        // Assert
        Assert.Equal(type.Name, agentType.Name);
    }
}


===== Runtime\Abstractions.Tests\MessageContextTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Threading;
using Xunit;

namespace Microsoft.SemanticKernel.Agents.Runtime.Abstractions.Tests;

[Trait("Category", "Unit")]
public class MessageContextTests
{
    [Fact]
    public void ConstructWithMessageIdAndCancellationTokenTest()
    {
        // Arrange
        string messageId = Guid.NewGuid().ToString();
        CancellationToken cancellationToken = new();

        // Act
        MessageContext messageContext = new(messageId, cancellationToken);

        // Assert
        Assert.Equal(messageId, messageContext.MessageId);
        Assert.Equal(cancellationToken, messageContext.CancellationToken);
    }

    [Fact]
    public void ConstructWithCancellationTokenTest()
    {
        // Arrange
        CancellationToken cancellationToken = new();

        // Act
        MessageContext messageContext = new(cancellationToken);

        // Assert
        Assert.NotNull(messageContext.MessageId);
        Assert.Equal(cancellationToken, messageContext.CancellationToken);
    }

    [Fact]
    public void AssignSenderTest()
    {
        // Arrange
        MessageContext messageContext = new(new CancellationToken());
        AgentId sender = new("type", "key");

        // Act
        messageContext.Sender = sender;

        // Assert
        Assert.Equal(sender, messageContext.Sender);
    }

    [Fact]
    public void AssignTopicTest()
    {
        // Arrange
        MessageContext messageContext = new(new CancellationToken());
        TopicId topic = new("type", "source");

        // Act
        messageContext.Topic = topic;

        // Assert
        Assert.Equal(topic, messageContext.Topic);
    }

    [Fact]
    public void AssignIsRpcPropertyTest()
    {
        // Arrange
        MessageContext messageContext = new(new CancellationToken())
        {
            // Act
            IsRpc = true
        };

        // Assert
        Assert.True(messageContext.IsRpc);
    }
}


===== Runtime\Abstractions.Tests\TopicIdTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using Xunit;

namespace Microsoft.SemanticKernel.Agents.Runtime.Abstractions.Tests;

[Trait("Category", "Unit")]
public class TopicIdTests
{
    [Fact]
    public void ConstrWithTypeOnlyTest()
    {
        // Arrange & Act
        TopicId topicId = new("testtype");

        // Assert
        Assert.Equal("testtype", topicId.Type);
        Assert.Equal(TopicId.DefaultSource, topicId.Source);
    }

    [Fact]
    public void ConstructWithTypeAndSourceTest()
    {
        // Arrange & Act
        TopicId topicId = new("testtype", "customsource");

        // Assert
        Assert.Equal("testtype", topicId.Type);
        Assert.Equal("customsource", topicId.Source);
    }

    [Fact]
    public void ConstructWithTupleTest()
    {
        // Arrange
        (string, string) tuple = ("testtype", "customsource");

        // Act
        TopicId topicId = new(tuple);

        // Assert
        Assert.Equal("testtype", topicId.Type);
        Assert.Equal("customsource", topicId.Source);
    }

    [Fact]
    public void ConvertFromStringTest()
    {
        // Arrange
        const string topicIdStr = "testtype/customsource";

        // Act
        TopicId topicId = TopicId.FromStr(topicIdStr);

        // Assert
        Assert.Equal("testtype", topicId.Type);
        Assert.Equal("customsource", topicId.Source);
    }

    [Theory]
    [InlineData("invalid-format")]
    [InlineData("too/many/parts")]
    [InlineData("")]
    public void InvalidFormatFromStringThrowsTest(string invalidInput)
    {
        // Act & Assert
        Assert.Throws<FormatException>(() => TopicId.FromStr(invalidInput));
    }

    [Fact]
    public void ToStringTest()
    {
        // Arrange
        TopicId topicId = new("testtype", "customsource");

        // Act
        string result = topicId.ToString();

        // Assert
        Assert.Equal("testtype/customsource", result);
    }

    [Fact]
    public void EqualityTest()
    {
        // Arrange
        TopicId topicId1 = new("testtype", "customsource");
        TopicId topicId2 = new("testtype", "customsource");

        // Act & Assert
        Assert.True(topicId1.Equals(topicId2));
        Assert.True(topicId1.Equals((object)topicId2));
    }

    [Fact]
    public void InequalityTest()
    {
        // Arrange
        TopicId topicId1 = new("testtype1", "source1");
        TopicId topicId2 = new("testtype2", "source2");
        TopicId topicId3 = new("testtype1", "source2");
        TopicId topicId4 = new("testtype2", "source1");

        // Act & Assert
        Assert.False(topicId1.Equals(topicId2));
        Assert.False(topicId1.Equals(topicId3));
        Assert.False(topicId1.Equals(topicId4));
    }

    [Fact]
    public void NullEqualityTest()
    {
        // Arrange
        TopicId topicId = new("testtype", "customsource");

        // Act & Assert
        Assert.False(topicId.Equals(null));
    }

    [Fact]
    public void DifferentTypeEqualityTest()
    {
        // Arrange
        TopicId topicId = new("testtype", "customsource");
        const string differentType = "not-a-topic-id";

        // Act & Assert
        Assert.False(topicId.Equals(differentType));
    }

    [Fact]
    public void GetHashCodeTest()
    {
        // Arrange
        TopicId topicId1 = new("testtype", "customsource");
        TopicId topicId2 = new("testtype", "customsource");

        // Act
        int hash1 = topicId1.GetHashCode();
        int hash2 = topicId2.GetHashCode();

        // Assert
        Assert.Equal(hash1, hash2);
    }

    [Fact]
    public void ExplicitConversionTest()
    {
        // Arrange
        string topicIdStr = "testtype/customsource";

        // Act
        TopicId topicId = (TopicId)topicIdStr;

        // Assert
        Assert.Equal("testtype", topicId.Type);
        Assert.Equal("customsource", topicId.Source);
    }

    [Fact]
    public void IsWildcardMatchTest()
    {
        // Arrange
        TopicId topicId1 = new("testtype", "source1");
        TopicId topicId2 = new("testtype", "source2");

        // Act & Assert
        Assert.True(topicId1.IsWildcardMatch(topicId2));
        Assert.True(topicId2.IsWildcardMatch(topicId1));
    }

    [Fact]
    public void IsWildcardMismatchTest()
    {
        // Arrange
        TopicId topicId1 = new("testtype1", "source");
        TopicId topicId2 = new("testtype2", "source");

        // Act & Assert
        Assert.False(topicId1.IsWildcardMatch(topicId2));
        Assert.False(topicId2.IsWildcardMatch(topicId1));
    }
}


===== Runtime\Abstractions\AgentId.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Text.RegularExpressions;
using Microsoft.SemanticKernel.Agents.Runtime.Internal;

namespace Microsoft.SemanticKernel.Agents.Runtime;

/// <summary>
/// Agent ID uniquely identifies an agent instance within an agent runtime, including a distributed runtime.
/// It serves as the "address" of the agent instance for receiving messages.
/// </summary>\
/// <remarks>
/// See the Python equivalent:
/// <see href="https://github.com/microsoft/agent-runtime/blob/main/python/agent_runtime/core/agent_id.py">AgentId in AutoGen (Python)</see>.
/// </remarks>
[DebuggerDisplay($"AgentId(type=\"{{{nameof(Type)}}}\", key=\"{{{nameof(Key)}}}\")")]
public struct AgentId : IEquatable<AgentId>
{
    /// <summary>
    /// The default source value used when no source is explicitly provided.
    /// </summary>
    public const string DefaultKey = "default";

    private static readonly Regex KeyRegex = new(@"^[\x20-\x7E]+$", RegexOptions.Compiled); // ASCII 32-126

    /// <summary>
    /// An identifier that associates an agent with a specific factory function.
    /// Strings may only be composed of alphanumeric letters (a-z) and (0-9), or underscores (_).
    /// </summary>
    public string Type { get; }

    /// <summary>
    /// Agent instance identifier.
    /// Strings may only be composed of alphanumeric letters (a-z) and (0-9), or underscores (_).
    /// </summary>
    public string Key { get; }

    internal static Regex KeyRegex1 => KeyRegex2;

    internal static Regex KeyRegex2 => KeyRegex;

    /// <summary>
    /// Initializes a new instance of the <see cref="AgentId"/> struct.
    /// </summary>
    /// <param name="type">The agent type.</param>
    /// <param name="key">Agent instance identifier.</param>
    public AgentId(string type, string key)
    {
        AgentType.Validate(type);

        if (string.IsNullOrWhiteSpace(key) || !KeyRegex.IsMatch(key))
        {
            throw new ArgumentException($"Invalid AgentId key: '{key}'. Must only contain ASCII characters 32-126.");
        }

        this.Type = type;
        this.Key = key;
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AgentId"/> struct from a tuple.
    /// </summary>
    /// <param name="kvPair">A tuple containing the agent type and key.</param>
    public AgentId((string Type, string Key) kvPair)
        : this(kvPair.Type, kvPair.Key)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AgentId"/> struct from an <see cref="AgentType"/>.
    /// </summary>
    /// <param name="type">The agent type.</param>
    /// <param name="key">Agent instance identifier.</param>
    public AgentId(AgentType type, string key)
        : this(type.Name, key)
    {
    }

    /// <summary>
    /// Convert a string of the format "type/key" into an <see cref="AgentId"/>.
    /// </summary>
    /// <param name="maybeAgentId">The agent ID string.</param>
    /// <returns>An instance of <see cref="AgentId"/>.</returns>
    public static AgentId FromStr(string maybeAgentId) => new(maybeAgentId.ToKeyValuePair(nameof(Type), nameof(Key)));

    /// <summary>
    /// Returns the string representation of the <see cref="AgentId"/>.
    /// </summary>
    /// <returns>A string in the format "type/key".</returns>
    public override readonly string ToString() => $"{this.Type}/{this.Key}";

    /// <summary>
    /// Determines whether the specified object is equal to the current <see cref="AgentId"/>.
    /// </summary>
    /// <param name="obj">The object to compare with the current instance.</param>
    /// <returns><c>true</c> if the specified object is equal to the current <see cref="AgentId"/>; otherwise, <c>false</c>.</returns>
    public override readonly bool Equals([NotNullWhen(true)] object? obj)
    {
        return (obj is AgentId other && this.Equals(other));
    }

    /// <inheritdoc/>
    public readonly bool Equals(AgentId other)
    {
        return this.Type == other.Type && this.Key == other.Key;
    }

    /// <summary>
    /// Returns a hash code for this <see cref="AgentId"/>.
    /// </summary>
    /// <returns>A hash code for the current instance.</returns>
    public override readonly int GetHashCode()
    {
        return HashCode.Combine(this.Type, this.Key);
    }

    /// <summary>
    /// Explicitly converts a string to an <see cref="AgentId"/>.
    /// </summary>
    /// <param name="id">The string representation of an agent ID.</param>
    /// <returns>An instance of <see cref="AgentId"/>.</returns>
    public static explicit operator AgentId(string id) => FromStr(id);

    /// <summary>
    /// Equality operator for <see cref="AgentId"/>.
    /// </summary>
    public static bool operator ==(AgentId left, AgentId right) => left.Equals(right);

    /// <summary>
    /// Inequality operator for <see cref="AgentId"/>.
    /// </summary>
    public static bool operator !=(AgentId left, AgentId right) => !left.Equals(right);
}


===== Runtime\Abstractions\AgentMetadata.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;

namespace Microsoft.SemanticKernel.Agents.Runtime;

/// <summary>
/// Represents metadata associated with an agent, including its type, unique key, and description.
/// </summary>
public readonly struct AgentMetadata(string type, string key, string description) : IEquatable<AgentMetadata>
{
    /// <summary>
    /// An identifier that associates an agent with a specific factory function.
    /// Strings may only be composed of alphanumeric letters (a-z, 0-9), or underscores (_).
    /// </summary>
    public string Type { get; } = type;

    /// <summary>
    /// A unique key identifying the agent instance.
    /// Strings may only be composed of alphanumeric letters (a-z, 0-9), or underscores (_).
    /// </summary>
    public string Key { get; } = key;

    /// <summary>
    /// A brief description of the agent's purpose or functionality.
    /// </summary>
    public string Description { get; } = description;

    /// <inheritdoc/>
    public override readonly bool Equals(object? obj)
    {
        return obj is AgentMetadata agentMetadata && this.Equals(agentMetadata);
    }

    /// <inheritdoc/>
    public readonly bool Equals(AgentMetadata other)
    {
        return this.Type.Equals(other.Type, StringComparison.Ordinal) && this.Key.Equals(other.Key, StringComparison.Ordinal);
    }

    /// <inheritdoc/>
    public override readonly int GetHashCode()
    {
        return HashCode.Combine(this.Type, this.Key);
    }

    /// <inheritdoc/>
    public static bool operator ==(AgentMetadata left, AgentMetadata right)
    {
        return left.Equals(right);
    }

    /// <inheritdoc/>
    public static bool operator !=(AgentMetadata left, AgentMetadata right)
    {
        return !(left == right);
    }
}


===== Runtime\Abstractions\AgentProxy.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;

namespace Microsoft.SemanticKernel.Agents.Runtime;

/// <summary>
/// A proxy that allows you to use an <see cref="AgentId"/> in place of its associated <see cref="IAgent"/>.
/// </summary>
public class AgentProxy
{
    /// <summary>
    /// The runtime instance used to interact with agents.
    /// </summary>
    private readonly IAgentRuntime _runtime;
    private AgentMetadata? _metadata;

    /// <summary>
    /// Initializes a new instance of the <see cref="AgentProxy"/> class.
    /// </summary>
    public AgentProxy(AgentId agentId, IAgentRuntime runtime)
    {
        this.Id = agentId;
        this._runtime = runtime;
    }

    /// <summary>
    /// The target agent for this proxy.
    /// </summary>
    public AgentId Id { get; }

    /// <summary>
    /// Gets the metadata of the agent.
    /// </summary>
    /// <value>
    /// An instance of <see cref="AgentMetadata"/> containing details about the agent.
    /// </value>
    public AgentMetadata Metadata => this._metadata ??= this.QueryMetadataAndUnwrap();

    /// <summary>
    /// Sends a message to the agent and processes the response.
    /// </summary>
    /// <param name="message">The message to send to the agent.</param>
    /// <param name="sender">The agent that is sending the message.</param>
    /// <param name="messageId">
    /// The message ID. If <c>null</c>, a new message ID will be generated.
    /// This message ID must be unique and is recommended to be a UUID.
    /// </param>
    /// <param name="cancellationToken">
    /// A token used to cancel an in-progress operation. Defaults to <c>null</c>.
    /// </param>
    /// <returns>A task representing the asynchronous operation, returning the response from the agent.</returns>
    public ValueTask<object?> SendMessageAsync(object message, AgentId sender, string? messageId = null, CancellationToken cancellationToken = default)
    {
        return this._runtime.SendMessageAsync(message, this.Id, sender, messageId, cancellationToken);
    }

    /// <summary>
    /// Loads the state of the agent from a previously saved state.
    /// </summary>
    /// <param name="state">A dictionary representing the state of the agent. Must be JSON serializable.</param>
    /// <returns>A task representing the asynchronous operation.</returns>
    public ValueTask LoadStateAsync(JsonElement state)
    {
        return this._runtime.LoadAgentStateAsync(this.Id, state);
    }

    /// <summary>
    /// Saves the state of the agent. The result must be JSON serializable.
    /// </summary>
    /// <returns>A task representing the asynchronous operation, returning a dictionary containing the saved state.</returns>
    public ValueTask<JsonElement> SaveStateAsync()
    {
        return this._runtime.SaveAgentStateAsync(this.Id);
    }

    private AgentMetadata QueryMetadataAndUnwrap()
    {
#pragma warning disable VSTHRD002 // Avoid problematic synchronous waits
        return this._runtime.GetAgentMetadataAsync(this.Id).AsTask().ConfigureAwait(false).GetAwaiter().GetResult();
#pragma warning restore VSTHRD002 // Avoid problematic synchronous waits
    }
}


===== Runtime\Abstractions\AgentType.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Text.RegularExpressions;

namespace Microsoft.SemanticKernel.Agents.Runtime;

/// <summary>
/// Represents the type of an agent as a string.
/// This is a strongly-typed wrapper around a string, ensuring type safety when working with agent types.
/// </summary>
/// <remarks>
/// This struct is immutable and provides implicit conversion to and from <see cref="string"/>.
/// </remarks>
public readonly partial struct AgentType : IEquatable<AgentType>
{
#if NET
    [GeneratedRegex("^[a-zA-Z_][a-zA-Z0-9_]*$")]
    private static partial Regex TypeRegex();
#else
    private static Regex TypeRegex() => new("^[a-zA-Z_][a-zA-Z0-9_]*$", RegexOptions.Compiled);
#endif

    internal static void Validate(string type)
    {
        if (string.IsNullOrWhiteSpace(type) || !TypeRegex().IsMatch(type))
        {
            throw new ArgumentException($"Invalid AgentId type: '{type}'. Must be alphanumeric (a-z, 0-9, _) and cannot start with a number or contain spaces.");
        }
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AgentId"/> struct.
    /// </summary>
    /// <param name="type">The agent type.</param>
    public AgentType(string type)
    {
        Validate(type);
        this.Name = type;
    }

    /// <summary>
    /// The string representation of this agent type.
    /// </summary>
    public string Name { get; }

    /// <summary>
    /// Returns the string representation of the <see cref="AgentType"/>.
    /// </summary>
    /// <returns>A string in the format "type/source".</returns>
    public override readonly string ToString() => this.Name;

    /// <summary>
    /// Explicitly converts a <see cref="Type"/> to an <see cref="AgentType"/>.
    /// </summary>
    /// <param name="type">The .NET <see cref="Type"/> to convert.</param>
    /// <returns>An <see cref="AgentType"/> instance with the name of the provided type.</returns>
    public static explicit operator AgentType(Type type) => new(type.Name);

    /// <summary>
    /// Implicitly converts a <see cref="string"/> to an <see cref="AgentType"/>.
    /// </summary>
    /// <param name="type">The string representation of the agent type.</param>
    /// <returns>An <see cref="AgentType"/> instance with the given name.</returns>
    public static implicit operator AgentType(string type) => new(type);

    /// <summary>
    /// Implicitly converts an <see cref="AgentType"/> to a <see cref="string"/>.
    /// </summary>
    /// <param name="type">The <see cref="AgentType"/> instance.</param>
    /// <returns>The string representation of the agent type.</returns>
    public static implicit operator string(AgentType type) => type.ToString();

    /// <inheritdoc/>
    public override bool Equals(object? obj)
    {
        return obj is AgentType other && this.Equals(other);
    }

    /// <inheritdoc/>
    public bool Equals(AgentType other)
    {
        return this.Name.Equals(other.Name, StringComparison.Ordinal);
    }

    /// <inheritdoc/>
    public override int GetHashCode()
    {
        return this.Name.GetHashCode();
    }

    /// <inheritdoc/>
    public static bool operator ==(AgentType left, AgentType right)
    {
        return left.Equals(right);
    }

    /// <inheritdoc/>
    public static bool operator !=(AgentType left, AgentType right)
    {
        return !(left == right);
    }
}


===== Runtime\Abstractions\Exceptions\CantHandleException.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Diagnostics.CodeAnalysis;

namespace Microsoft.SemanticKernel.Agents.Runtime;

/// <summary>
/// Exception thrown when a handler cannot process the given message.
/// </summary>
[ExcludeFromCodeCoverage]
public class CantHandleException : Exception
{
    /// <summary>
    /// Initializes a new instance of the <see cref="CantHandleException"/> class.
    /// </summary>
    public CantHandleException() : base("The handler cannot process the given message.") { }

    /// <summary>
    /// Initializes a new instance of the <see cref="CantHandleException"/> class with a custom error message.
    /// </summary>
    /// <param name="message">The custom error message.</param>
    public CantHandleException(string message) : base(message) { }

    /// <summary>
    /// Initializes a new instance of the <see cref="CantHandleException"/> class with a custom error message and an inner exception.
    /// </summary>
    /// <param name="message">The custom error message.</param>
    /// <param name="innerException">The inner exception that caused this error.</param>
    public CantHandleException(string message, Exception innerException) : base(message, innerException) { }
}


===== Runtime\Abstractions\Exceptions\MessageDroppedException.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Diagnostics.CodeAnalysis;

namespace Microsoft.SemanticKernel.Agents.Runtime;

/// <summary>
/// Exception thrown when a message is dropped.
/// </summary>
[ExcludeFromCodeCoverage]
public class MessageDroppedException : Exception
{
    /// <summary>
    /// Initializes a new instance of the <see cref="MessageDroppedException"/> class.
    /// </summary>
    public MessageDroppedException() : base("The message was dropped.") { }

    /// <summary>
    /// Initializes a new instance of the <see cref="MessageDroppedException"/> class with a custom error message.
    /// </summary>
    /// <param name="message">The custom error message.</param>
    public MessageDroppedException(string message) : base(message) { }

    /// <summary>
    /// Initializes a new instance of the <see cref="MessageDroppedException"/> class with a custom error message and an inner exception.
    /// </summary>
    /// <param name="message">The custom error message.</param>
    /// <param name="innerException">The inner exception that caused this error.</param>
    public MessageDroppedException(string message, Exception innerException) : base(message, innerException) { }
}


===== Runtime\Abstractions\Exceptions\NotAccessibleException.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Diagnostics.CodeAnalysis;

namespace Microsoft.SemanticKernel.Agents.Runtime;

/// <summary>
/// Exception thrown when an attempt is made to access an unavailable value, such as a remote resource.
/// </summary>
[ExcludeFromCodeCoverage]
public class NotAccessibleException : Exception
{
    /// <summary>
    /// Initializes a new instance of the <see cref="NotAccessibleException"/> class.
    /// </summary>
    public NotAccessibleException() : base("The requested value is not accessible.") { }

    /// <summary>
    /// Initializes a new instance of the <see cref="NotAccessibleException"/> class with a custom error message.
    /// </summary>
    /// <param name="message">The custom error message.</param>
    public NotAccessibleException(string message) : base(message) { }

    /// <summary>
    /// Initializes a new instance of the <see cref="NotAccessibleException"/> class with a custom error message and an inner exception.
    /// </summary>
    /// <param name="message">The custom error message.</param>
    /// <param name="innerException">The inner exception that caused this error.</param>
    public NotAccessibleException(string message, Exception innerException) : base(message, innerException) { }
}


===== Runtime\Abstractions\Exceptions\UndeliverableException.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Diagnostics.CodeAnalysis;
namespace Microsoft.SemanticKernel.Agents.Runtime;

/// <summary>
/// Exception thrown when a message cannot be delivered.
/// </summary>
[ExcludeFromCodeCoverage]
public class UndeliverableException : Exception
{
    /// <summary>
    /// Initializes a new instance of the <see cref="UndeliverableException"/> class.
    /// </summary>
    public UndeliverableException() : base("The message cannot be delivered.") { }

    /// <summary>
    /// Initializes a new instance of the <see cref="UndeliverableException"/> class with a custom error message.
    /// </summary>
    /// <param name="message">The custom error message.</param>
    public UndeliverableException(string message) : base(message) { }

    /// <summary>
    /// Initializes a new instance of the <see cref="UndeliverableException"/> class with a custom error message and an inner exception.
    /// </summary>
    /// <param name="message">The custom error message.</param>
    /// <param name="innerException">The inner exception that caused this error.</param>
    public UndeliverableException(string message, Exception innerException) : base(message, innerException) { }
}


===== Runtime\Abstractions\IAgent.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Threading.Tasks;

namespace Microsoft.SemanticKernel.Agents.Runtime;

/// <summary>
/// Represents an agent within the runtime that can process messages, maintain state, and be closed when no longer needed.
/// </summary>
public interface IAgent : ISaveState
{
    /// <summary>
    /// Gets the unique identifier of the agent.
    /// </summary>
    AgentId Id { get; }

    /// <summary>
    /// Gets metadata associated with the agent.
    /// </summary>
    AgentMetadata Metadata { get; }

    /// <summary>
    /// Handles an incoming message for the agent.
    /// This should only be called by the runtime, not by other agents.
    /// </summary>
    /// <param name="message">The received message. The type should match one of the expected subscription types.</param>
    /// <param name="messageContext">The context of the message, providing additional metadata.</param>
    /// <returns>
    /// A task representing the asynchronous operation, returning a response to the message.
    /// The response can be <c>null</c> if no reply is necessary.
    /// </returns>
    /// <exception cref="OperationCanceledException">Thrown if the message was cancelled.</exception>
    /// <exception cref="CantHandleException">Thrown if the agent cannot handle the message.</exception>
    ValueTask<object?> OnMessageAsync(object message, MessageContext messageContext); // TODO: How do we express this properly in .NET?
}


===== Runtime\Abstractions\IAgentRuntime.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Hosting;

namespace Microsoft.SemanticKernel.Agents.Runtime;

/// <summary>
/// Defines the runtime environment for agents, managing message sending, subscriptions, agent resolution, and state persistence.
/// </summary>
public interface IAgentRuntime : IHostedService, ISaveState
{
    /// <summary>
    /// Sends a message to an agent and gets a response.
    /// This method should be used to communicate directly with an agent.
    /// </summary>
    /// <param name="message">The message to send.</param>
    /// <param name="recipient">The agent to send the message to.</param>
    /// <param name="sender">The agent sending the message. Should be <c>null</c> if sent from an external source.</param>
    /// <param name="messageId">A unique identifier for the message. If <c>null</c>, a new ID will be generated.</param>
    /// <param name="cancellationToken">A token to cancel the operation if needed.</param>
    /// <returns>A task representing the asynchronous operation, returning the response from the agent.</returns>
    /// <exception cref="CantHandleException">Thrown if the recipient cannot handle the message.</exception>
    /// <exception cref="UndeliverableException">Thrown if the message cannot be delivered.</exception>
    ValueTask<object?> SendMessageAsync(object message, AgentId recipient, AgentId? sender = null, string? messageId = null, CancellationToken cancellationToken = default);

    /// <summary>
    /// Publishes a message to all agents subscribed to the given topic.
    /// No responses are expected from publishing.
    /// </summary>
    /// <param name="message">The message to publish.</param>
    /// <param name="topic">The topic to publish the message to.</param>
    /// <param name="sender">The agent sending the message. Defaults to <c>null</c>.</param>
    /// <param name="messageId">A unique message ID. If <c>null</c>, a new one will be generated.</param>
    /// <param name="cancellationToken">A token to cancel the operation if needed.</param>
    /// <returns>A task representing the asynchronous operation.</returns>
    /// <exception cref="UndeliverableException">Thrown if the message cannot be delivered.</exception>
    ValueTask PublishMessageAsync(object message, TopicId topic, AgentId? sender = null, string? messageId = null, CancellationToken cancellationToken = default);

    /// <summary>
    /// Retrieves an agent by its unique identifier.
    /// </summary>
    /// <param name="agentId">The unique identifier of the agent.</param>
    /// <param name="lazy">If <c>true</c>, the agent is fetched lazily.</param>
    /// <returns>A task representing the asynchronous operation, returning the agent's ID.</returns>
    ValueTask<AgentId> GetAgentAsync(AgentId agentId, bool lazy = true/*, CancellationToken? = default*/);

    /// <summary>
    /// Retrieves an agent by its type.
    /// </summary>
    /// <param name="agentType">The type of the agent.</param>
    /// <param name="key">An optional key to specify variations of the agent. Defaults to "default".</param>
    /// <param name="lazy">If <c>true</c>, the agent is fetched lazily.</param>
    /// <returns>A task representing the asynchronous operation, returning the agent's ID.</returns>
    ValueTask<AgentId> GetAgentAsync(AgentType agentType, string key = "default", bool lazy = true/*, CancellationToken? = default*/);

    /// <summary>
    /// Retrieves an agent by its string representation.
    /// </summary>
    /// <param name="agent">The string representation of the agent.</param>
    /// <param name="key">An optional key to specify variations of the agent. Defaults to "default".</param>
    /// <param name="lazy">If <c>true</c>, the agent is fetched lazily.</param>
    /// <returns>A task representing the asynchronous operation, returning the agent's ID.</returns>
    ValueTask<AgentId> GetAgentAsync(string agent, string key = "default", bool lazy = true/*, CancellationToken? = default*/);

    /// <summary>
    /// Saves the state of an agent.
    /// The result must be JSON serializable.
    /// </summary>
    /// <param name="agentId">The ID of the agent whose state is being saved.</param>
    /// <returns>A task representing the asynchronous operation, returning a dictionary of the saved state.</returns>
    ValueTask<JsonElement> SaveAgentStateAsync(AgentId agentId/*, CancellationToken? cancellationToken = default*/);

    /// <summary>
    /// Loads the saved state into an agent.
    /// </summary>
    /// <param name="agentId">The ID of the agent whose state is being restored.</param>
    /// <param name="state">The state dictionary to restore.</param>
    /// <returns>A task representing the asynchronous operation.</returns>
    ValueTask LoadAgentStateAsync(AgentId agentId, JsonElement state/*, CancellationToken? cancellationToken = default*/);

    /// <summary>
    /// Retrieves metadata for an agent.
    /// </summary>
    /// <param name="agentId">The ID of the agent.</param>
    /// <returns>A task representing the asynchronous operation, returning the agent's metadata.</returns>
    ValueTask<AgentMetadata> GetAgentMetadataAsync(AgentId agentId/*, CancellationToken? cancellationToken = default*/);

    /// <summary>
    /// Adds a new subscription for the runtime to handle when processing published messages.
    /// </summary>
    /// <param name="subscription">The subscription to add.</param>
    /// <returns>A task representing the asynchronous operation.</returns>
    ValueTask AddSubscriptionAsync(ISubscriptionDefinition subscription/*, CancellationToken? cancellationToken = default*/);

    /// <summary>
    /// Removes a subscription from the runtime.
    /// </summary>
    /// <param name="subscriptionId">The unique identifier of the subscription to remove.</param>
    /// <returns>A task representing the asynchronous operation.</returns>
    /// <exception cref="KeyNotFoundException">Thrown if the subscription does not exist.</exception>
    ValueTask RemoveSubscriptionAsync(string subscriptionId/*, CancellationToken? cancellationToken = default*/);

    /// <summary>
    /// Registers an agent factory with the runtime, associating it with a specific agent type.
    /// The type must be unique.
    /// </summary>
    /// <param name="type">The agent type to associate with the factory.</param>
    /// <param name="factoryFunc">A function that asynchronously creates the agent instance.</param>
    /// <returns>A task representing the asynchronous operation, returning the registered <see cref="AgentType"/>.</returns>
    ValueTask<AgentType> RegisterAgentFactoryAsync(AgentType type, Func<AgentId, IAgentRuntime, ValueTask<IHostableAgent>> factoryFunc);

    /// <summary>
    /// Attempts to retrieve an <see cref="AgentProxy"/> for the specified agent.
    /// </summary>
    /// <param name="agentId">The ID of the agent.</param>
    /// <returns>A task representing the asynchronous operation, returning an <see cref="AgentProxy"/> if successful.</returns>
    ValueTask<AgentProxy> TryGetAgentProxyAsync(AgentId agentId);
}


===== Runtime\Abstractions\IHostableAgent.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Threading.Tasks;

namespace Microsoft.SemanticKernel.Agents.Runtime;

/// <summary>
/// Represents an agent that can be explicitly hosted and closed when the runtime shuts down.
/// </summary>
public interface IHostableAgent : IAgent
{
    /// <summary>
    /// Called when the runtime is closing.
    /// </summary>
    /// <returns>A task representing the asynchronous operation.</returns>
    ValueTask CloseAsync();
}


===== Runtime\Abstractions\Internal\KeyValueParserExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Text.RegularExpressions;

namespace Microsoft.SemanticKernel.Agents.Runtime.Internal;

/// <summary>
/// Provides helper methods for parsing key-value string representations.
/// </summary>
internal static class KeyValueParserExtensions
{
    /// <summary>
    /// The regular expression pattern used to match key-value pairs in the format "key/value".
    /// </summary>
    private const string KVPairPattern = @"^(?<key>\w+)/(?<value>\w+)$";

    /// <summary>
    /// The compiled regex used for extracting key-value pairs from a string.
    /// </summary>
    private static readonly Regex KVPairRegex = new(KVPairPattern, RegexOptions.Compiled);

    /// <summary>
    /// Parses a string in the format "key/value" into a tuple containing the key and value.
    /// </summary>
    /// <param name="inputPair">The input string containing a key-value pair.</param>
    /// <param name="keyName">The expected name of the key component.</param>
    /// <param name="valueName">The expected name of the value component.</param>
    /// <returns>A tuple containing the extracted key and value.</returns>
    /// <exception cref="FormatException">
    /// Thrown if the input string does not match the expected "key/value" format.
    /// </exception>
    /// <example>
    /// Example usage:
    /// <code>
    /// string input = "agent1/12345";
    /// var result = input.ToKVPair("Type", "Key");
    /// Console.WriteLine(result.Item1); // Outputs: agent1
    /// Console.WriteLine(result.Item2); // Outputs: 12345
    /// </code>
    /// </example>
    public static (string, string) ToKeyValuePair(this string inputPair, string keyName, string valueName)
    {
        Match match = KVPairRegex.Match(inputPair);
        if (match.Success)
        {
            return (match.Groups["key"].Value, match.Groups["value"].Value);
        }

        throw new FormatException($"Invalid key-value pair format: {inputPair}; expecting \"{{{keyName}}}/{{{valueName}}}\"");
    }
}


===== Runtime\Abstractions\ISaveState.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Text.Json;
using System.Threading.Tasks;

namespace Microsoft.SemanticKernel.Agents.Runtime;

/// <summary>
/// Defines a contract for saving and loading the state of an object.
/// The state must be JSON serializable.
/// </summary>
public interface ISaveState
{
    /// <summary>
    /// Saves the current state of the object.
    /// </summary>
    /// <returns>
    /// A task representing the asynchronous operation, returning a dictionary
    /// containing the saved state. The structure of the state is implementation-defined
    /// but must be JSON serializable.
    /// </returns>
    ValueTask<JsonElement> SaveStateAsync();

    /// <summary>
    /// Loads a previously saved state into the object.
    /// </summary>
    /// <param name="state">
    /// A dictionary representing the saved state. The structure of the state
    /// is implementation-defined but must be JSON serializable.
    /// </param>
    /// <returns>A task representing the asynchronous operation.</returns>
    ValueTask LoadStateAsync(JsonElement state);
}


===== Runtime\Abstractions\ISubscriptionDefinition.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Diagnostics.CodeAnalysis;

namespace Microsoft.SemanticKernel.Agents.Runtime;

/// <summary>
/// Defines a subscription that matches topics and maps them to agents.
/// </summary>
public interface ISubscriptionDefinition
{
    /// <summary>
    /// Gets the unique identifier of the subscription.
    /// </summary>
    string Id { get; }

    /// <summary>
    /// Determines whether the specified object is equal to the current subscription.
    /// </summary>
    /// <param name="obj">The object to compare with the current instance.</param>
    /// <returns><c>true</c> if the specified object is equal to this instance; otherwise, <c>false</c>.</returns>
    bool Equals([NotNullWhen(true)] object? obj);

    /// <summary>
    /// Determines whether the specified subscription is equal to the current subscription.
    /// </summary>
    /// <param name="other">The subscription to compare.</param>
    /// <returns><c>true</c> if the subscriptions are equal; otherwise, <c>false</c>.</returns>
    bool Equals(ISubscriptionDefinition? other);

    /// <summary>
    /// Returns a hash code for this subscription.
    /// </summary>
    /// <returns>A hash code for the subscription.</returns>
    int GetHashCode();

    /// <summary>
    /// Checks if a given <see cref="TopicId"/> matches the subscription.
    /// </summary>
    /// <param name="topic">The topic to check.</param>
    /// <returns><c>true</c> if the topic matches the subscription; otherwise, <c>false</c>.</returns>
    bool Matches(TopicId topic);

    /// <summary>
    /// Maps a <see cref="TopicId"/> to an <see cref="AgentId"/>.
    /// Should only be called if <see cref="Matches"/> returns <c>true</c>.
    /// </summary>
    /// <param name="topic">The topic to map.</param>
    /// <returns>The <see cref="AgentId"/> that should handle the topic.</returns>
    AgentId MapToAgent(TopicId topic);
}


===== Runtime\Abstractions\MessageContext.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Threading;

namespace Microsoft.SemanticKernel.Agents.Runtime;

/// <summary>
/// Represents the context of a message being sent within the agent runtime.
/// This includes metadata such as the sender, topic, RPC status, and cancellation handling.
/// </summary>
public class MessageContext(string messageId, CancellationToken cancellationToken)
{
    /// <summary>
    /// Initializes a new instance of the <see cref="MessageContext"/> class.
    /// </summary>
    public MessageContext(CancellationToken cancellation) : this(Guid.NewGuid().ToString(), cancellation)
    { }

    /// <summary>
    /// Gets or sets the unique identifier for this message.
    /// </summary>
    public string MessageId { get; } = messageId;

    /// <summary>
    /// Gets or sets the cancellation token associated with this message.
    /// This can be used to cancel the operation if necessary.
    /// </summary>
    public CancellationToken CancellationToken { get; } = cancellationToken;

    /// <summary>
    /// Gets or sets the sender of the message.
    /// If <c>null</c>, the sender is unspecified.
    /// </summary>
    public AgentId? Sender { get; set; }

    /// <summary>
    /// Gets or sets the topic associated with the message.
    /// If <c>null</c>, the message is not tied to a specific topic.
    /// </summary>
    public TopicId? Topic { get; set; }

    /// <summary>
    /// Gets or sets a value indicating whether this message is part of an RPC (Remote Procedure Call).
    /// </summary>
    public bool IsRpc { get; set; }
}


===== Runtime\Abstractions\TopicId.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Diagnostics.CodeAnalysis;
using Microsoft.SemanticKernel.Agents.Runtime.Internal;

namespace Microsoft.SemanticKernel.Agents.Runtime;

/// <summary>
/// Represents a topic identifier that defines the scope of a broadcast message.
/// The agent runtime implements a publish-subscribe model through its broadcast API,
/// where messages must be published with a specific topic.
///
/// See the Python equivalent:
/// <see href="https://github.com/cloudevents/spec/blob/main/cloudevents/spec.md#type">CloudEvents Type Specification</see>.
/// </summary>
public struct TopicId : IEquatable<TopicId>
{
    /// <summary>
    /// The default source value used when no source is explicitly provided.
    /// </summary>
    public const string DefaultSource = "default";

    /// <summary>
    /// The separator character for the string representation of the topic.
    /// </summary>
    public const string Separator = "/";

    /// <summary>
    /// Gets the type of the event that this <see cref="TopicId"/> represents.
    /// This adheres to the CloudEvents specification.
    ///
    /// Must match the pattern: <c>^[\w\-\.\:\=]+$</c>.
    ///
    /// Learn more here:
    /// <see href="https://github.com/cloudevents/spec/blob/main/cloudevents/spec.md#type">CloudEvents Type</see>.
    /// </summary>
    public string Type { get; }

    /// <summary>
    /// Gets the source that identifies the context in which an event happened.
    /// This adheres to the CloudEvents specification.
    ///
    /// Learn more here:
    /// <see href="https://github.com/cloudevents/spec/blob/main/cloudevents/spec.md#source-1">CloudEvents Source</see>.
    /// </summary>
    public string Source { get; }

    /// <summary>
    /// Initializes a new instance of the <see cref="TopicId"/> struct.
    /// </summary>
    /// <param name="type">The type of the topic.</param>
    /// <param name="source">The source of the event. Defaults to <see cref="DefaultSource"/> if not specified.</param>
    public TopicId(string type, string source = DefaultSource)
    {
        this.Type = type;
        this.Source = source;
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="TopicId"/> struct from a tuple.
    /// </summary>
    /// <param name="kvPair">A tuple containing the topic type and source.</param>
    public TopicId((string Type, string Source) kvPair) : this(kvPair.Type, kvPair.Source)
    {
    }

    /// <summary>
    /// Converts a string in the format "type/source" into a <see cref="TopicId"/>.
    /// </summary>
    /// <param name="maybeTopicId">The topic ID string.</param>
    /// <returns>An instance of <see cref="TopicId"/>.</returns>
    /// <exception cref="FormatException">Thrown when the string is not in the valid "type/source" format.</exception>
    public static TopicId FromStr(string maybeTopicId) => new(maybeTopicId.ToKeyValuePair(nameof(Type), nameof(Source)));

    /// <summary>
    /// Returns the string representation of the <see cref="TopicId"/>.
    /// </summary>
    /// <returns>A string in the format "type/source".</returns>
    public override readonly string ToString() => $"{this.Type}{Separator}{this.Source}";

    /// <summary>
    /// Determines whether the specified object is equal to the current <see cref="TopicId"/>.
    /// </summary>
    /// <param name="obj">The object to compare with the current instance.</param>
    /// <returns><c>true</c> if the specified object is equal to the current <see cref="TopicId"/>; otherwise, <c>false</c>.</returns>
    public override readonly bool Equals([NotNullWhen(true)] object? obj)
    {
        if (obj is TopicId other)
        {
            return this.Type == other.Type && this.Source == other.Source;
        }

        return false;
    }

    /// <summary>
    /// Determines whether the specified object is equal to the current <see cref="TopicId"/>.
    /// </summary>
    /// <param name="other">The object to compare with the current instance.</param>
    /// <returns><c>true</c> if the specified object is equal to the current <see cref="TopicId"/>; otherwise, <c>false</c>.</returns>
    public readonly bool Equals([NotNullWhen(true)] TopicId other)
    {
        return this.Type == other.Type && this.Source == other.Source;
    }

    /// <summary>
    /// Returns a hash code for this <see cref="TopicId"/>.
    /// </summary>
    /// <returns>A hash code for the current instance.</returns>
    public override readonly int GetHashCode()
    {
        return HashCode.Combine(this.Type, this.Source);
    }

    /// <summary>
    /// Explicitly converts a string to a <see cref="TopicId"/>.
    /// </summary>
    /// <param name="id">The string representation of a topic ID.</param>
    /// <returns>An instance of <see cref="TopicId"/>.</returns>
    public static explicit operator TopicId(string id) => FromStr(id);

    // TODO: Implement < for wildcard matching (type, *)
    // == => <
    // Type == other.Type => <
    /// <summary>
    /// Determines whether the given <see cref="TopicId"/> matches another topic.
    /// </summary>
    /// <param name="other">The topic ID to compare against.</param>
    /// <returns>
    /// <c>true</c> if the topic types are equal; otherwise, <c>false</c>.
    /// </returns>
    public readonly bool IsWildcardMatch(TopicId other)
    {
        return this.Type == other.Type;
    }

    /// <inheritdoc/>
    public static bool operator ==(TopicId left, TopicId right)
    {
        return left.Equals(right);
    }

    /// <inheritdoc/>
    public static bool operator !=(TopicId left, TopicId right)
    {
        return !(left == right);
    }
}


===== Runtime\Core.Tests\AgentRuntimeExtensionsTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Threading.Tasks;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.SemanticKernel.Agents.Runtime.InProcess;
using Xunit;

namespace Microsoft.SemanticKernel.Agents.Runtime.Core.Tests;

[Trait("Category", "Unit")]
public class AgentRuntimeExtensionsTests
{
    private const string TestTopic1 = "test.1.topic";
    private const string TestTopic2 = "test.2.topic";
    private const string TestTopicPrefix = "test.2";

    [Fact]
    public async Task RegisterAgentTypeWithStringAsync_WithBaseAgent()
    {
        // Arrange
        string agentTypeName = nameof(TestAgent);
        Guid value = Guid.NewGuid();
        ServiceProvider serviceProvider = new ServiceCollection().BuildServiceProvider();

        await using InProcessRuntime runtime = new();

        // Act
        AgentType registeredType = await runtime.RegisterAgentTypeAsync<TestAgent>(agentTypeName, serviceProvider, [value]);
        AgentId registeredId = await runtime.GetAgentAsync(agentTypeName, lazy: false);

        // Assert
        Assert.Equal(agentTypeName, registeredType.Name);
        Assert.Equal(agentTypeName, registeredId.Type);

        // Act
        TestAgent agent = await runtime.TryGetUnderlyingAgentInstanceAsync<TestAgent>(registeredId);

        // Assert
        Assert.NotNull(agent);
        Assert.Equal(agentTypeName, agent.Id.Type);
        TestAgent testAgent = Assert.IsType<TestAgent>(agent);
        Assert.Equal(value, testAgent.Value);
    }

    [Fact]
    public async Task RegisterAgentTypeWithStringAsync_NotWithBaseAgent()
    {
        // Arrange
        string agentTypeName = nameof(NotBaseAgent);
        ServiceProvider serviceProvider = new ServiceCollection().BuildServiceProvider();

        await using InProcessRuntime runtime = new();

        // Act
        AgentType registeredType = await runtime.RegisterAgentTypeAsync(agentTypeName, typeof(NotBaseAgent), serviceProvider);

        // Assert
        await Assert.ThrowsAsync<InvalidOperationException>(async () => await runtime.GetAgentAsync(agentTypeName, lazy: false));
    }

    [Fact]
    public async Task RegisterImplicitAgentSubscriptionsAsync()
    {
        // Arrange
        string agentTypeName = nameof(TestAgent);
        TopicId topic1 = new(TestTopic1);
        TopicId topic2 = new(TestTopic2);

        ServiceProvider serviceProvider = new ServiceCollection().BuildServiceProvider();
        await using InProcessRuntime runtime = new();

        // Act
        AgentType registeredType = await runtime.RegisterAgentTypeAsync<TestAgent>(agentTypeName, serviceProvider, [Guid.Empty]);
        await runtime.RegisterImplicitAgentSubscriptionsAsync<TestAgent>(agentTypeName);

        // Arrange
        await runtime.StartAsync();

        try
        {
            // Act - publish messages to each topic
            string messageText1 = "Test message #1";
            string messageText2 = "Test message #1";
            await runtime.PublishMessageAsync(messageText1, topic1);
            await runtime.PublishMessageAsync(messageText2, topic2);
            await runtime.RunUntilIdleAsync();

            // Get agent and verify it received messages
            AgentId registeredId = await runtime.GetAgentAsync(agentTypeName, lazy: false);
            TestAgent agent = await runtime.TryGetUnderlyingAgentInstanceAsync<TestAgent>(registeredId);

            // Assert
            Assert.NotNull(agent);
            Assert.Equal(2, agent.ReceivedMessages.Count);
            Assert.Contains(messageText1, agent.ReceivedMessages);
            Assert.Contains(messageText2, agent.ReceivedMessages);
        }
        finally
        {
            // Arrange
            await runtime.StopAsync();
        }
    }

    [TypeSubscription(TestTopic1)]
    [TypePrefixSubscription(TestTopicPrefix)]
    private sealed class TestAgent : BaseAgent, IHandle<string>
    {
        public List<string> ReceivedMessages { get; } = [];

        public TestAgent(AgentId id, IAgentRuntime runtime, Guid value)
            : base(id, runtime, "Test Subscribing Agent", null)
        {
            this.Value = value;
        }

        public Guid Value { get; }

        public ValueTask HandleAsync(string item, MessageContext messageContext)
        {
            this.ReceivedMessages.Add(item);

            return ValueTask.CompletedTask;
        }
    }

    private sealed class NotBaseAgent : IHostableAgent
    {
        public AgentId Id => throw new NotImplementedException();

        public AgentMetadata Metadata => throw new NotImplementedException();

        public ValueTask CloseAsync()
        {
            throw new NotImplementedException();
        }

        public ValueTask LoadStateAsync(JsonElement state)
        {
            throw new NotImplementedException();
        }

        public ValueTask<object?> OnMessageAsync(object message, MessageContext messageContext)
        {
            throw new NotImplementedException();
        }

        public ValueTask<JsonElement> SaveStateAsync()
        {
            throw new NotImplementedException();
        }
    }
}


===== Runtime\Core.Tests\AgentsAppBuilderTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Reflection;
using System.Threading.Tasks;
using FluentAssertions;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using Microsoft.SemanticKernel.Agents.Runtime.InProcess;
using Xunit;

namespace Microsoft.SemanticKernel.Agents.Runtime.Core.Tests;

[Trait("Category", "Unit")]
public class AgentsAppBuilderTests
{
    [Fact]
    public void Constructor_WithoutParameters_ShouldCreateNewHostApplicationBuilder()
    {
        // Act
        AgentsAppBuilder builder = new();

        // Assert
        builder.Services.Should().NotBeNull();
        builder.Configuration.Should().NotBeNull();
    }

    [Fact]
    public void Constructor_WithBaseBuilder_ShouldUseProvidedBuilder()
    {
        // Arrange
        HostApplicationBuilder baseBuilder = new();

        // Add a test service to verify it's the same builder
        baseBuilder.Services.AddSingleton<ITestService, TestService>();

        // Act
        AgentsAppBuilder builder = new(baseBuilder);

        // Assert
        builder.Services.Should().BeSameAs(baseBuilder.Services);
        builder.Services.BuildServiceProvider().GetService<ITestService>().Should().NotBeNull();
    }

    [Fact]
    public void Services_ShouldReturnBuilderServices()
    {
        // Arrange
        AgentsAppBuilder builder = new();

        // Act
        IServiceCollection services = builder.Services;

        // Assert
        services.Should().NotBeNull();
    }

    [Fact]
    public void Configuration_ShouldReturnBuilderConfiguration()
    {
        // Arrange
        AgentsAppBuilder builder = new();

        // Act
        IConfiguration configuration = builder.Configuration;

        // Assert
        configuration.Should().NotBeNull();
    }

    [Fact]
    public async Task UseRuntime_ShouldRegisterRuntimeInServices()
    {
        // Arrange
        AgentsAppBuilder builder = new();
        await using InProcessRuntime runtime = new();

        // Act
        AgentsAppBuilder result = builder.UseRuntime(runtime);

        // Assert
        result.Should().BeSameAs(builder);
        IAgentRuntime? resolvedRuntime = builder.Services.BuildServiceProvider().GetService<IAgentRuntime>();
        resolvedRuntime.Should().BeSameAs(runtime);

        // Verify it's also registered as a hosted service
        IHostedService? hostedService = builder.Services.BuildServiceProvider().GetService<IHostedService>();
        hostedService.Should().BeSameAs(runtime);
    }

    [Fact]
    public void AddAgentsFromAssemblies_WithoutParameters_ShouldScanCurrentDomain()
    {
        // Arrange
        AgentsAppBuilder builder = new();

        // Act - using the parameterless version calls AppDomain.CurrentDomain.GetAssemblies()
        builder.AddAgentsFromAssemblies();

        // Assert
        // We just verify it doesn't throw, as the actual agents registered depend on the loaded assemblies
    }

    [Fact]
    public void AddAgentsFromAssemblies_WithAssemblies_ShouldRegisterAgentsFromProvidedAssemblies()
    {
        // Arrange
        AgentsAppBuilder builder = new();
        Assembly testAssembly = typeof(TestAgent).Assembly;

        // Act
        AgentsAppBuilder result = builder.AddAgentsFromAssemblies(testAssembly);

        // Assert
        result.Should().BeSameAs(builder);
        // The assertion on actual agent registration is done in BuildAsync test
    }

    [Fact]
    public void AddAgent_ShouldRegisterAgentType()
    {
        // Arrange
        AgentsAppBuilder builder = new();
        AgentType agentType = new("TestAgent");

        // Act
        AgentsAppBuilder result = builder.AddAgent<TestAgent>(agentType);

        // Assert
        result.Should().BeSameAs(builder);
        // Actual agent registration is tested in BuildAsync
    }

    [Fact]
    public async Task BuildAsync_ShouldReturnAgentsAppWithRegisteredAgents()
    {
        // Arrange
        AgentsAppBuilder builder = new();
        await using InProcessRuntime runtime = new();
        builder.UseRuntime(runtime);

        AgentType testAgentType = new("TestAgent");
        builder.AddAgent<TestAgent>(testAgentType);

        // Act
        AgentsApp app = await builder.BuildAsync();
        AgentId agentId = await runtime.GetAgentAsync(testAgentType);

        // Assert
        app.Should().NotBeNull();
        app.Host.Should().NotBeNull();
        app.AgentRuntime.Should().BeSameAs(runtime);
        agentId.Type.Should().BeSameAs(testAgentType.Name);
    }

    // Private test interfaces and classes to support the tests
    private interface ITestService { }

    private sealed class TestService : ITestService { }

    private sealed class TestAgent : BaseAgent
    {
        public TestAgent(AgentId id, IAgentRuntime runtime, string description, ILogger<BaseAgent>? logger = null)
            : base(id, runtime, description, logger) { }
    }
}


===== Runtime\Core.Tests\AgentsAppTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Threading;
using System.Threading.Tasks;
using FluentAssertions;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Moq;
using Xunit;

namespace Microsoft.SemanticKernel.Agents.Runtime.Core.Tests;

[Trait("Category", "Unit")]
public class AgentsAppTests
{
    [Fact]
    public void Constructor_ShouldInitializeHost()
    {
        // Arrange
        Mock<IHost> mockHost = new();

        // Act
        AgentsApp agentsApp = new(mockHost.Object);

        // Assert
        agentsApp.Host.Should().BeSameAs(mockHost.Object);
    }

    [Fact]
    public void Services_ShouldReturnHostServices()
    {
        // Arrange
        Mock<IServiceProvider> mockServiceProvider = new();
        Mock<IHost> mockHost = new();
        mockHost.Setup(h => h.Services).Returns(mockServiceProvider.Object);
        AgentsApp agentsApp = new(mockHost.Object);

        // Act
        IServiceProvider result = agentsApp.Services;

        // Assert
        result.Should().BeSameAs(mockServiceProvider.Object);
    }

    [Fact]
    public void ApplicationLifetime_ShouldGetFromServices()
    {
        // Arrange
        Mock<IHostApplicationLifetime> mockLifetime = new();
        ServiceProvider serviceProvider = new ServiceCollection()
            .AddSingleton(mockLifetime.Object)
            .BuildServiceProvider();

        Mock<IHost> mockHost = new();
        mockHost.Setup(h => h.Services).Returns(serviceProvider);

        AgentsApp agentsApp = new(mockHost.Object);

        // Act
        IHostApplicationLifetime result = agentsApp.ApplicationLifetime;

        // Assert
        result.Should().BeSameAs(mockLifetime.Object);
    }

    [Fact]
    public void AgentRuntime_ShouldGetFromServices()
    {
        // Arrange
        Mock<IAgentRuntime> mockAgentRuntime = new();
        ServiceProvider serviceProvider = new ServiceCollection()
            .AddSingleton(mockAgentRuntime.Object)
            .BuildServiceProvider();

        Mock<IHost> mockHost = new();
        mockHost.Setup(h => h.Services).Returns(serviceProvider);

        AgentsApp agentsApp = new(mockHost.Object);

        // Act
        IAgentRuntime result = agentsApp.AgentRuntime;

        // Assert
        result.Should().BeSameAs(mockAgentRuntime.Object);
    }

    [Fact]
    public async Task StartAsync_ShouldStartHost()
    {
        // Arrange
        Mock<IHost> mockHost = new();
        mockHost.Setup(h => h.StartAsync(It.IsAny<CancellationToken>()))
            .Returns(Task.CompletedTask);

        AgentsApp agentsApp = new(mockHost.Object);

        // Act
        await agentsApp.StartAsync();

        // Assert
        mockHost.Verify(h => h.StartAsync(It.IsAny<CancellationToken>()), Times.Once);
    }

    [Fact]
    public async Task StartAsync_WhenAlreadyRunning_ShouldThrowInvalidOperationException()
    {
        // Arrange
        Mock<IHost> mockHost = new();
        AgentsApp agentsApp = new(mockHost.Object);

        // Act & Assert
        await agentsApp.StartAsync();
        await Assert.ThrowsAsync<InvalidOperationException>(() => agentsApp.StartAsync().AsTask());
    }

    [Fact]
    public async Task ShutdownAsync_ShouldStopHost()
    {
        // Arrange
        Mock<IHost> mockHost = new();
        mockHost.Setup(h => h.StopAsync(It.IsAny<CancellationToken>()))
            .Returns(Task.CompletedTask);

        AgentsApp agentsApp = new(mockHost.Object);
        await agentsApp.StartAsync(); // Start first so we can shut down

        // Act
        await agentsApp.ShutdownAsync();

        // Assert
        mockHost.Verify(h => h.StopAsync(It.IsAny<CancellationToken>()), Times.Once);
    }

    [Fact]
    public async Task ShutdownAsync_WhenNotRunning_ShouldThrowInvalidOperationException()
    {
        // Arrange
        Mock<IHost> mockHost = new();
        AgentsApp agentsApp = new(mockHost.Object);

        // Act & Assert
        await Assert.ThrowsAsync<InvalidOperationException>(() => agentsApp.ShutdownAsync().AsTask());
    }

    [Fact]
    public async Task PublishMessageAsync_WhenNotRunning_ShouldStartHostFirst()
    {
        // Arrange
        Mock<IAgentRuntime> mockAgentRuntime = new();
        ServiceProvider serviceProvider = new ServiceCollection()
            .AddSingleton(mockAgentRuntime.Object)
            .BuildServiceProvider();

        Mock<IHost> mockHost = new();
        mockHost.Setup(h => h.Services).Returns(serviceProvider);
        mockHost.Setup(h => h.StartAsync(It.IsAny<CancellationToken>()))
            .Returns(Task.CompletedTask);

        AgentsApp agentsApp = new(mockHost.Object);

        string message = "test message";
        TopicId topic = new("test-topic");

        // Act
        await agentsApp.PublishMessageAsync(message, topic);

        // Assert
        mockHost.Verify(h => h.StartAsync(It.IsAny<CancellationToken>()), Times.Once);
        mockAgentRuntime.Verify(
            r =>
            r.PublishMessageAsync(
                message,
                topic,
                It.IsAny<AgentId?>(),
                It.IsAny<string>(),
                It.IsAny<CancellationToken>()),
                Times.Once);
    }

    [Fact]
    public async Task PublishMessageAsync_WhenRunning_ShouldNotStartHostAgain()
    {
        // Arrange
        Mock<IAgentRuntime> mockAgentRuntime = new();
        ServiceProvider serviceProvider = new ServiceCollection()
            .AddSingleton(mockAgentRuntime.Object)
            .BuildServiceProvider();

        Mock<IHost> mockHost = new();
        mockHost.Setup(h => h.Services).Returns(serviceProvider);
        mockHost.Setup(h => h.StartAsync(It.IsAny<CancellationToken>()))
            .Returns(Task.CompletedTask);

        AgentsApp agentsApp = new(mockHost.Object);
        await agentsApp.StartAsync(); // Start first

        string message = "test message";
        TopicId topic = new("test-topic");

        // Act
        await agentsApp.PublishMessageAsync(message, topic);

        // Assert
        mockHost.Verify(h => h.StartAsync(It.IsAny<CancellationToken>()), Times.Once);
        mockAgentRuntime.Verify(
            r =>
                r.PublishMessageAsync(
                    message,
                    topic,
                    It.IsAny<AgentId?>(),
                    It.IsAny<string>(),
                    It.IsAny<CancellationToken>()),
                    Times.Once);
    }

    [Fact]
    public async Task PublishMessageAsync_ShouldPassAllParameters()
    {
        // Arrange
        Mock<IAgentRuntime> mockAgentRuntime = new();
        ServiceProvider serviceProvider = new ServiceCollection()
            .AddSingleton(mockAgentRuntime.Object)
            .BuildServiceProvider();

        Mock<IHost> mockHost = new();
        mockHost.Setup(h => h.Services).Returns(serviceProvider);

        AgentsApp agentsApp = new(mockHost.Object);
        await agentsApp.StartAsync();

        string message = "test message";
        TopicId topic = new("test-topic");
        string messageId = "test-message-id";

        // Act
        await agentsApp.PublishMessageAsync(message, topic, messageId, CancellationToken.None);

        // Assert
        mockAgentRuntime.Verify(
            r =>
                r.PublishMessageAsync(
                    message,
                    topic,
                    It.IsAny<AgentId?>(),
                    messageId,
                    CancellationToken.None),
                    Times.Once);
    }

    [Fact]
    public async Task WaitForShutdownAsync_ShouldBlock()
    {
        // Arrange
        IHost host = new HostApplicationBuilder().Build();

        AgentsApp agentsApp = new(host);
        await agentsApp.StartAsync();

        ValueTask shutdownTask = ValueTask.CompletedTask;
        try
        {
            // Assert - Verify initial state
            agentsApp.ApplicationLifetime.ApplicationStopped.IsCancellationRequested.Should().BeFalse();

            // Act
            shutdownTask = agentsApp.ShutdownAsync();
            await agentsApp.WaitForShutdownAsync();

            // Assert
            agentsApp.ApplicationLifetime.ApplicationStopped.IsCancellationRequested.Should().BeTrue();
        }
        finally
        {
            await shutdownTask; // Ensure shutdown completes
        }
    }
}


===== Runtime\Core.Tests\BaseAgentTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Linq;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using FluentAssertions;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.SemanticKernel.Agents.Runtime.InProcess;
using Moq;
using Xunit;

namespace Microsoft.SemanticKernel.Agents.Runtime.Core.Tests;

[Trait("Category", "Unit")]
public class BaseAgentTests
{
    [Fact]
    public void Constructor_InitializesActivitySource_Correctly()
    {
        BaseAgent.TraceSource.Name.Should().Be("Microsoft.SemanticKernel.Agents.Runtime");
    }

    [Fact]
    public void Constructor_InitializesProperties_Correctly()
    {
        // Arrange
        using ILoggerFactory loggerFactory = LoggerFactory.Create(_ => { });
        ILogger<TestAgentA> logger = loggerFactory.CreateLogger<TestAgentA>();
        AgentId agentId = new("TestType", "TestKey");
        const string description = "Test Description";
        Mock<IAgentRuntime> runtimeMock = new();

        // Act
        TestAgentA agent = new(agentId, runtimeMock.Object, description, logger);

        // Assert
        agent.Id.Should().Be(agentId);
        agent.Metadata.Type.Should().Be(agentId.Type);
        agent.Metadata.Key.Should().Be(agentId.Key);
        agent.Metadata.Description.Should().Be(description);
        agent.Logger.Should().Be(logger);
    }

    [Fact]
    public void Constructor_WithNoLogger_CreatesNullLogger()
    {
        // Arrange
        AgentId agentId = new("TestType", "TestKey");
        string description = "Test Description";
        Mock<IAgentRuntime> runtimeMock = new();

        // Act
        TestAgentA agent = new(agentId, runtimeMock.Object, description);

        // Assert
        agent.Logger.Should().Be(NullLogger.Instance);
    }

    [Fact]
    public async Task OnMessageAsync_WithoutMatchingHandler()
    {
        // Arrange
        Mock<IAgentRuntime> runtimeMock = new();
        AgentId agentId = new("TestType", "TestKey");
        TestAgentA agent = new(agentId, runtimeMock.Object, "Test Agent");
        MessageContext context = new(CancellationToken.None);

        // Act
        const string message = "This is a TestMessage";
        object? result = await agent.OnMessageAsync(message, context);

        // Assert
        result.Should().BeNull();
        agent.ReceivedMessages.Should().BeEmpty();
    }

    [Fact]
    public async Task OnMessageAsync_WithMatchingHandler_NoResult()
    {
        // Arrange
        Mock<IAgentRuntime> runtimeMock = new();
        AgentId agentId = new("TestType", "TestKey");
        TestAgentA agent = new(agentId, runtimeMock.Object, "Test Agent");

        // Act
        TestMessage message = new() { Content = "Hello World" };
        MessageContext context = new(CancellationToken.None);
        object? result = await agent.OnMessageAsync(message, context);

        // Assert
        result.Should().BeNull();
        agent.ReceivedMessages.Should().ContainSingle();
    }

    [Fact]
    public async Task OnMessageAsync_WithMatchingHandler_HasResult()
    {
        // Arrange
        Mock<IAgentRuntime> runtimeMock = new();
        AgentId agentId = new("TestType", "TestKey");
        TestAgentB agent = new(agentId, runtimeMock.Object);

        // Act
        TestMessage message = new() { Content = "Hello World" };
        MessageContext context = new(CancellationToken.None);
        object? result = await agent.OnMessageAsync(message, context);

        // Assert
        result.Should().Be(message.Content);
        agent.ReceivedMessages.Should().ContainSingle();
        agent.ReceivedMessages[0].Should().Contain(message.Content);
    }

    [Fact]
    public async Task CloseAsync_ReturnsCompletedTask()
    {
        // Arrange
        await using InProcessRuntime runtime = new();
        AgentId agentId = new("TestType", "TestKey");
        TestAgentA agent = new(agentId, runtime, "Test Agent");

        // Act
        await agent.CloseAsync();

        // Assert
        agent.IsClosed.Should().BeTrue();
    }

    [Fact]
    public async Task PublishMessageAsync_Received()
    {
        // Arrange
        ServiceProvider services = new ServiceCollection().BuildServiceProvider();
        await using InProcessRuntime runtime = new();
        TopicId topic = new("TestTopic");
        AgentType senderType = nameof(TestAgentC);
        AgentType receiverType = nameof(TestAgentB);
        await runtime.RegisterAgentTypeAsync<TestAgentB>(receiverType, services);
        await runtime.AddSubscriptionAsync(new TypeSubscription(topic.Type, receiverType));
        AgentId receiverId = await runtime.GetAgentAsync(receiverType, lazy: false);
        await runtime.RegisterAgentTypeAsync<TestAgentC>(senderType, services, [topic]);
        AgentId senderId = await runtime.GetAgentAsync(senderType, lazy: false);

        // Act
        await runtime.StartAsync();
        TestMessage message = new() { Content = "Hello World" };
        try
        {
            await runtime.SendMessageAsync(message, senderId);
        }
        finally
        {
            await runtime.RunUntilIdleAsync();
        }

        // Assert
        await VerifyMessageHandled(runtime, senderId, message.Content);
        await VerifyMessageHandled(runtime, receiverId, message.Content);
    }

    [Fact]
    public async Task SendMessageAsync_Received()
    {
        // Arrange
        ServiceProvider services = new ServiceCollection().BuildServiceProvider();
        await using InProcessRuntime runtime = new();
        AgentType senderType = nameof(TestAgentD);
        AgentType receiverType = nameof(TestAgentB);
        await runtime.RegisterAgentTypeAsync<TestAgentB>(receiverType, services);
        AgentId receiverId = await runtime.GetAgentAsync(receiverType, lazy: false);
        await runtime.RegisterAgentTypeAsync<TestAgentD>(senderType, services, [receiverId]);
        AgentId senderId = await runtime.GetAgentAsync(senderType, lazy: false);

        // Act
        await runtime.StartAsync();
        TestMessage message = new() { Content = "Hello World" };
        try
        {
            await runtime.SendMessageAsync(message, senderId);
        }
        finally
        {
            await runtime.RunUntilIdleAsync();
        }

        // Assert
        await VerifyMessageHandled(runtime, senderId, message.Content);
        await VerifyMessageHandled(runtime, receiverId, message.Content);
    }

    private static async Task VerifyMessageHandled(InProcessRuntime runtime, AgentId agentId, string expectedContent)
    {
        TestAgent agent = await runtime.TryGetUnderlyingAgentInstanceAsync<TestAgent>(agentId);
        agent.ReceivedMessages.Should().ContainSingle();
        agent.ReceivedMessages[0].Should().Be(expectedContent);
    }

    [Fact]
    public async Task SaveStateAsync_ReturnsEmptyJsonElement()
    {
        // Arrange
        await using InProcessRuntime runtime = new();
        AgentId agentId = new("TestType", "TestKey");
        TestAgentA agent = new(agentId, runtime, "Test Agent");

        // Act
        var state = await agent.SaveStateAsync();

        // Assert
        state.ValueKind.Should().Be(JsonValueKind.Object);
        state.EnumerateObject().Count().Should().Be(0);
    }

    [Fact]
    public async Task LoadStateAsync_WithValidState_HandlesStateCorrectly()
    {
        // Arrange
        await using InProcessRuntime runtime = new();
        AgentId agentId = new("TestType", "TestKey");
        TestAgentA agent = new(agentId, runtime, "Test Agent");

        JsonElement state = JsonDocument.Parse("{ }").RootElement;

        // Act
        await agent.LoadStateAsync(state);

        // Assert
        // BaseAgent's default implementation just accepts any state without error
        // This is primarily testing that the default method doesn't throw exceptions
    }

    [Fact]
    public async Task GetAgentAsync_WithValidType_ReturnsAgentId()
    {
        // Arrange
        ServiceProvider services = new ServiceCollection().BuildServiceProvider();
        await using InProcessRuntime runtime = new();
        AgentType agentType = nameof(TestAgentB);
        await runtime.RegisterAgentTypeAsync<TestAgentB>(agentType, services);

        AgentId callingAgentId = new("CallerType", "CallerKey");
        TestAgentB callingAgent = new(callingAgentId, runtime);

        // Act
        await runtime.StartAsync();
        AgentId? retrievedAgentId = await callingAgent.GetAgentAsync(agentType);

        // Assert
        retrievedAgentId.Should().NotBeNull();
        retrievedAgentId!.Value.Type.Should().Be(agentType.Name);
        retrievedAgentId!.Value.Key.Should().Be(AgentId.DefaultKey);

        // Act
        retrievedAgentId = await callingAgent.GetAgentAsync("badtype");

        // Assert
        retrievedAgentId.Should().BeNull();
    }

    // Custom test message
    private sealed class TestMessage
    {
        public string Content { get; set; } = string.Empty;
    }

    // TestAgent that collects the messages it receives
    protected abstract class TestAgent : BaseAgent
    {
        public List<string> ReceivedMessages { get; } = [];

        protected TestAgent(AgentId id, IAgentRuntime runtime, string description, ILogger? logger = null)
            : base(id, runtime, description, logger)
        {
        }
    }

    private sealed class TestAgentA : TestAgent, IHandle<TestMessage>
    {
        public bool IsClosed { get; private set; }

        public TestAgentA(AgentId id, IAgentRuntime runtime, string description, ILogger<TestAgentA>? logger = null)
            : base(id, runtime, description, logger)
        {
        }

        public ValueTask HandleAsync(TestMessage item, MessageContext messageContext)
        {
            this.ReceivedMessages.Add(item.Content);
            return ValueTask.CompletedTask;
        }

        public override ValueTask CloseAsync()
        {
            this.IsClosed = true;
            return base.CloseAsync();
        }
    }

    // TestAgent that implements handler for TestMessage that produces a result
    private sealed class TestAgentB : TestAgent, IHandle<TestMessage, string>
    {
        public TestAgentB(AgentId id, IAgentRuntime runtime)
            : base(id, runtime, "Test agent with handler result")
        {
        }

        public ValueTask<string> HandleAsync(TestMessage item, MessageContext messageContext)
        {
            this.ReceivedMessages.Add(item.Content);
            return ValueTask.FromResult(item.Content);
        }

        public new ValueTask<AgentId?> GetAgentAsync(AgentType agent, CancellationToken cancellationToken = default) => base.GetAgentAsync(agent, cancellationToken);
    }

    // TestAgent that implements handler for TestMessage that responds by publishing to a topic
    private sealed class TestAgentC : TestAgent, IHandle<TestMessage>
    {
        private readonly TopicId _broadcastTopic;

        public TestAgentC(AgentId id, IAgentRuntime runtime, TopicId broadcastTopic)
            : base(id, runtime, "Test agent that publishes")
        {
            this._broadcastTopic = broadcastTopic;
        }

        public async ValueTask HandleAsync(TestMessage item, MessageContext messageContext)
        {
            this.ReceivedMessages.Add(item.Content);
            await this.PublishMessageAsync(item, this._broadcastTopic, messageContext.MessageId, messageContext.CancellationToken);
        }
    }

    // TestAgent that implements handler for TestMessage that responds by messaging another agent
    private sealed class TestAgentD : TestAgent, IHandle<TestMessage>
    {
        private readonly AgentId _receiverId;

        public TestAgentD(AgentId id, IAgentRuntime runtime, AgentId receiverId)
            : base(id, runtime, "Test agent that sends")
        {
            this._receiverId = receiverId;
        }

        public async ValueTask HandleAsync(TestMessage item, MessageContext messageContext)
        {
            this.ReceivedMessages.Add(item.Content);
            await this.SendMessageAsync(item, this._receiverId, messageContext.MessageId, messageContext.CancellationToken);
        }
    }
}


===== Runtime\Core.Tests\TypePrefixSubscriptionAttributeTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using Xunit;

namespace Microsoft.SemanticKernel.Agents.Runtime.Core.Tests;

[Trait("Category", "Unit")]
public class TypePrefixSubscriptionAttributeTests
{
    [Fact]
    public void Constructor_SetsTopicCorrectly()
    {
        // Arrange & Act
        TypePrefixSubscriptionAttribute attribute = new("test-topic");

        // Assert
        Assert.Equal("test-topic", attribute.Topic);
    }

    [Fact]
    public void Bind_CreatesTypeSubscription()
    {
        // Arrange
        TypePrefixSubscriptionAttribute attribute = new("test");
        AgentType agentType = new("testagent");

        // Act
        ISubscriptionDefinition subscription = attribute.Bind(agentType);

        // Assert
        Assert.NotNull(subscription);
        TypePrefixSubscription typeSubscription = Assert.IsType<TypePrefixSubscription>(subscription);
        Assert.Equal("test", typeSubscription.TopicTypePrefix);
        Assert.Equal(agentType, typeSubscription.AgentType);
    }

    [Fact]
    public void AttributeUsage_AllowsOnlyClasses()
    {
        // Arrange
        Type attributeType = typeof(TypePrefixSubscriptionAttribute);

        // Act
        AttributeUsageAttribute usageAttribute =
            (AttributeUsageAttribute)Attribute.GetCustomAttribute(
                attributeType,
                typeof(AttributeUsageAttribute))!;

        // Assert
        Assert.NotNull(usageAttribute);
        Assert.Equal(AttributeTargets.Class, usageAttribute.ValidOn);
    }
}


===== Runtime\Core.Tests\TypePrefixSubscriptionTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using FluentAssertions;
using Xunit;

namespace Microsoft.SemanticKernel.Agents.Runtime.Core.Tests;

[Trait("Category", "Unit")]
public class TypePrefixSubscriptionTests
{
    [Fact]
    public void Constructor_WithProvidedId_ShouldSetProperties()
    {
        // Arrange
        string topicTypePrefix = "testPrefix";
        AgentType agentType = new("testAgent");
        string id = "custom-id";

        // Act
        TypePrefixSubscription subscription = new(topicTypePrefix, agentType, id);

        // Assert
        subscription.TopicTypePrefix.Should().Be(topicTypePrefix);
        subscription.AgentType.Should().Be(agentType);
        subscription.Id.Should().Be(id);
    }

    [Fact]
    public void Constructor_WithoutId_ShouldGenerateGuid()
    {
        // Arrange
        string topicTypePrefix = "testPrefix";
        AgentType agentType = new("testAgent");

        // Act
        TypePrefixSubscription subscription = new(topicTypePrefix, agentType);

        // Assert
        subscription.TopicTypePrefix.Should().Be(topicTypePrefix);
        subscription.AgentType.Should().Be(agentType);
        subscription.Id.Should().NotBeNullOrEmpty();
        Guid.TryParse(subscription.Id, out _).Should().BeTrue();
    }

    [Fact]
    public void Matches_TopicWithMatchingPrefix_ShouldReturnTrue()
    {
        // Arrange
        string topicTypePrefix = "testPrefix";
        TypePrefixSubscription subscription = new(topicTypePrefix, new AgentType("testAgent"));
        TopicId topic = new(topicTypePrefix, "source1");

        // Act
        bool result = subscription.Matches(topic);

        // Assert
        result.Should().BeTrue();
    }

    [Fact]
    public void Matches_TopicWithMatchingPrefixAndAdditionalSuffix_ShouldReturnTrue()
    {
        // Arrange
        string topicTypePrefix = "testPrefix";
        TypePrefixSubscription subscription = new(topicTypePrefix, new AgentType("testAgent"));
        TopicId topic = new($"{topicTypePrefix}Suffix", "source1");

        // Act
        bool result = subscription.Matches(topic);

        // Assert
        result.Should().BeTrue();
    }

    [Fact]
    public void Matches_TopicWithDifferentPrefix_ShouldReturnFalse()
    {
        // Arrange
        TypePrefixSubscription subscription = new("testPrefix", new AgentType("testAgent"));
        TopicId topic = new("differentPrefix", "source1");

        // Act
        bool result = subscription.Matches(topic);

        // Assert
        result.Should().BeFalse();
    }

    [Fact]
    public void MapToAgent_MatchingTopic_ShouldReturnCorrectAgentId()
    {
        // Arrange
        string topicTypePrefix = "testPrefix";
        string source = "source1";
        AgentType agentType = new("testAgent");
        TypePrefixSubscription subscription = new(topicTypePrefix, agentType);
        TopicId topic = new(topicTypePrefix, source);

        // Act
        var agentId = subscription.MapToAgent(topic);

        // Assert
        agentId.Type.Should().Be(agentType.Name);
        agentId.Key.Should().Be(source);
    }

    [Fact]
    public void MapToAgent_TopicWithMatchingPrefixAndSuffix_ShouldReturnCorrectAgentId()
    {
        // Arrange
        string topicTypePrefix = "testPrefix";
        string source = "source1";
        AgentType agentType = new("testAgent");
        TypePrefixSubscription subscription = new(topicTypePrefix, agentType);
        TopicId topic = new($"{topicTypePrefix}Suffix", source);

        // Act
        var agentId = subscription.MapToAgent(topic);

        // Assert
        agentId.Type.Should().Be(agentType.Name);
        agentId.Key.Should().Be(source);
    }

    [Fact]
    public void MapToAgent_NonMatchingTopic_ShouldThrowInvalidOperationException()
    {
        // Arrange
        TypePrefixSubscription subscription = new("testPrefix", new AgentType("testAgent"));
        TopicId topic = new("differentPrefix", "source1");

        // Act & Assert
        Action action = () => subscription.MapToAgent(topic);
        action.Should().Throw<InvalidOperationException>()
            .WithMessage("TopicId does not match the subscription.");
    }

    [Fact]
    public void Equals_SameId_ShouldReturnTrue()
    {
        // Arrange
        string id = "custom-id";
        TypePrefixSubscription subscription1 = new("prefix1", new AgentType("agent1"), id);
        TypePrefixSubscription subscription2 = new("prefix2", new AgentType("agent2"), id);

        // Act & Assert
        subscription1.Equals((object)subscription2).Should().BeTrue();
        subscription1.Equals(subscription2 as ISubscriptionDefinition).Should().BeTrue();
    }

    [Fact]
    public void Equals_SameTypeAndAgentType_ShouldReturnTrue()
    {
        // Arrange
        string topicTypePrefix = "prefix1";
        AgentType agentType = new("agent1");
        TypePrefixSubscription subscription1 = new(topicTypePrefix, agentType, "id1");
        TypePrefixSubscription subscription2 = new(topicTypePrefix, agentType, "id2");

        // Act & Assert
        subscription1.Equals((object)subscription2).Should().BeTrue();
    }

    [Fact]
    public void Equals_DifferentIdAndProperties_ShouldReturnFalse()
    {
        // Arrange
        TypePrefixSubscription subscription1 = new("prefix1", new AgentType("agent1"), "id1");
        TypePrefixSubscription subscription2 = new("prefix2", new AgentType("agent2"), "id2");

        // Act & Assert
        subscription1.Equals((object)subscription2).Should().BeFalse();
    }

    [Fact]
    public void Equals_ISubscriptionDefinition_WithDifferentId_ShouldReturnFalse()
    {
        // Arrange
        TypePrefixSubscription subscription1 = new("prefix1", new AgentType("agent1"), "id1");
        TypePrefixSubscription subscription2 = new("prefix1", new AgentType("agent1"), "id2");

        // Act & Assert
        subscription1.Equals(subscription2 as ISubscriptionDefinition).Should().BeFalse();
    }

    [Fact]
    public void Equals_WithNull_ShouldReturnFalse()
    {
        // Arrange
        TypePrefixSubscription subscription = new("prefix1", new AgentType("agent1"));

        // Act & Assert
        subscription.Equals(null as object).Should().BeFalse();
        subscription.Equals(null as ISubscriptionDefinition).Should().BeFalse();
    }

    [Fact]
    public void Equals_WithDifferentType_ShouldReturnFalse()
    {
        // Arrange
        TypePrefixSubscription subscription = new("prefix1", new AgentType("agent1"));
        object differentObject = new();

        // Act & Assert
        subscription.Equals(differentObject).Should().BeFalse();
    }

    [Fact]
    public void GetHashCode_SameValues_ShouldReturnSameHashCode()
    {
        // Arrange
        string id = "custom-id";
        string topicTypePrefix = "prefix1";
        AgentType agentType = new("agent1");
        TypePrefixSubscription subscription1 = new(topicTypePrefix, agentType, id);
        TypePrefixSubscription subscription2 = new(topicTypePrefix, agentType, id);

        // Act & Assert
        subscription1.GetHashCode().Should().Be(subscription2.GetHashCode());
    }

    [Fact]
    public void GetHashCode_DifferentValues_ShouldReturnDifferentHashCodes()
    {
        // Arrange
        TypePrefixSubscription subscription1 = new("prefix1", new AgentType("agent1"), "id1");
        TypePrefixSubscription subscription2 = new("prefix2", new AgentType("agent2"), "id2");

        // Act & Assert
        subscription1.GetHashCode().Should().NotBe(subscription2.GetHashCode());
    }
}


===== Runtime\Core.Tests\TypeSubscriptionAttributeTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using Xunit;

namespace Microsoft.SemanticKernel.Agents.Runtime.Core.Tests;

[Trait("Category", "Unit")]
public class TypeSubscriptionAttributeTests
{
    [Fact]
    public void Constructor_SetsTopicCorrectly()
    {
        // Arrange & Act
        TypeSubscriptionAttribute attribute = new("test-topic");

        // Assert
        Assert.Equal("test-topic", attribute.Topic);
    }

    [Fact]
    public void Bind_CreatesTypeSubscription()
    {
        // Arrange
        TypeSubscriptionAttribute attribute = new("test-topic");
        AgentType agentType = new("testagent");

        // Act
        ISubscriptionDefinition subscription = attribute.Bind(agentType);

        // Assert
        Assert.NotNull(subscription);
        TypeSubscription typeSubscription = Assert.IsType<TypeSubscription>(subscription);
        Assert.Equal("test-topic", typeSubscription.TopicType);
        Assert.Equal(agentType, typeSubscription.AgentType);
    }

    [Fact]
    public void AttributeUsage_AllowsOnlyClasses()
    {
        // Arrange
        Type attributeType = typeof(TypeSubscriptionAttribute);

        // Act
        AttributeUsageAttribute usageAttribute =
            (AttributeUsageAttribute)Attribute.GetCustomAttribute(
                attributeType,
                typeof(AttributeUsageAttribute))!;

        // Assert
        Assert.NotNull(usageAttribute);
        Assert.Equal(AttributeTargets.Class, usageAttribute.ValidOn);
    }
}


===== Runtime\Core.Tests\TypeSubscriptionTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using FluentAssertions;
using Xunit;

namespace Microsoft.SemanticKernel.Agents.Runtime.Core.Tests;

[Trait("Category", "Unit")]
public class TypeSubscriptionTests
{
    [Fact]
    public void Constructor_WithProvidedId_ShouldSetProperties()
    {
        // Arrange
        string topicType = "testTopic";
        AgentType agentType = new("testAgent");
        string id = "custom-id";

        // Act
        TypeSubscription subscription = new(topicType, agentType, id);

        // Assert
        subscription.TopicType.Should().Be(topicType);
        subscription.AgentType.Should().Be(agentType);
        subscription.Id.Should().Be(id);
    }

    [Fact]
    public void Constructor_WithoutId_ShouldGenerateGuid()
    {
        // Arrange
        string topicType = "testTopic";
        AgentType agentType = new("testAgent");

        // Act
        TypeSubscription subscription = new(topicType, agentType);

        // Assert
        subscription.TopicType.Should().Be(topicType);
        subscription.AgentType.Should().Be(agentType);
        subscription.Id.Should().NotBeNullOrEmpty();
        Guid.TryParse(subscription.Id, out _).Should().BeTrue();
    }

    [Fact]
    public void Matches_TopicWithMatchingType_ShouldReturnTrue()
    {
        // Arrange
        string topicType = "testTopic";
        TypeSubscription subscription = new(topicType, new AgentType("testAgent"));
        TopicId topic = new(topicType, "source1");

        // Act
        bool result = subscription.Matches(topic);

        // Assert
        result.Should().BeTrue();
    }

    [Fact]
    public void Matches_TopicWithDifferentType_ShouldReturnFalse()
    {
        // Arrange
        TypeSubscription subscription = new("testTopic", new AgentType("testAgent"));
        TopicId topic = new("differentTopic", "source1");

        // Act
        bool result = subscription.Matches(topic);

        // Assert
        result.Should().BeFalse();
    }

    [Fact]
    public void MapToAgent_MatchingTopic_ShouldReturnCorrectAgentId()
    {
        // Arrange
        string topicType = "testTopic";
        string source = "source1";
        AgentType agentType = new("testAgent");
        TypeSubscription subscription = new(topicType, agentType);
        TopicId topic = new(topicType, source);

        // Act
        var agentId = subscription.MapToAgent(topic);

        // Assert
        agentId.Type.Should().Be(agentType.Name);
        agentId.Key.Should().Be(source);
    }

    [Fact]
    public void MapToAgent_NonMatchingTopic_ShouldThrowInvalidOperationException()
    {
        // Arrange
        TypeSubscription subscription = new("testTopic", new AgentType("testAgent"));
        TopicId topic = new("differentTopic", "source1");

        // Act & Assert
        Action action = () => subscription.MapToAgent(topic);
        action.Should().Throw<InvalidOperationException>()
            .WithMessage("TopicId does not match the subscription.");
    }

    [Fact]
    public void Equals_SameId_ShouldReturnTrue()
    {
        // Arrange
        string id = "custom-id";
        TypeSubscription subscription1 = new("topic1", new AgentType("agent1"), id);
        TypeSubscription subscription2 = new("topic2", new AgentType("agent2"), id);

        // Act & Assert
        subscription1.Equals((object)subscription2).Should().BeTrue();
        subscription1.Equals(subscription2 as ISubscriptionDefinition).Should().BeTrue();
    }

    [Fact]
    public void Equals_SameTypeAndAgentType_ShouldReturnTrue()
    {
        // Arrange
        string topicType = "topic1";
        AgentType agentType = new("agent1");
        TypeSubscription subscription1 = new(topicType, agentType, "id1");
        TypeSubscription subscription2 = new(topicType, agentType, "id2");

        // Act & Assert
        subscription1.Equals((object)subscription2).Should().BeTrue();
    }

    [Fact]
    public void Equals_DifferentIdAndProperties_ShouldReturnFalse()
    {
        // Arrange
        TypeSubscription subscription1 = new("topic1", new AgentType("agent1"), "id1");
        TypeSubscription subscription2 = new("topic2", new AgentType("agent2"), "id2");

        // Act & Assert
        subscription1.Equals((object)subscription2).Should().BeFalse();
        subscription1.Equals(subscription2 as ISubscriptionDefinition).Should().BeFalse();
    }

    [Fact]
    public void Equals_WithNull_ShouldReturnFalse()
    {
        // Arrange
        TypeSubscription subscription = new("topic1", new AgentType("agent1"));

        // Act & Assert
        subscription.Equals(null as object).Should().BeFalse();
        subscription.Equals(null as ISubscriptionDefinition).Should().BeFalse();
    }

    [Fact]
    public void Equals_WithDifferentType_ShouldReturnFalse()
    {
        // Arrange
        TypeSubscription subscription = new("topic1", new AgentType("agent1"));
        object differentObject = new();

        // Act & Assert
        subscription.Equals(differentObject).Should().BeFalse();
    }

    [Fact]
    public void GetHashCode_SameValues_ShouldReturnSameHashCode()
    {
        // Arrange
        string id = "custom-id";
        string topicType = "topic1";
        AgentType agentType = new("agent1");
        TypeSubscription subscription1 = new(topicType, agentType, id);
        TypeSubscription subscription2 = new(topicType, agentType, id);

        // Act & Assert
        subscription1.GetHashCode().Should().Be(subscription2.GetHashCode());
    }

    [Fact]
    public void GetHashCode_DifferentValues_ShouldReturnDifferentHashCodes()
    {
        // Arrange
        TypeSubscription subscription1 = new("topic1", new AgentType("agent1"), "id1");
        TypeSubscription subscription2 = new("topic2", new AgentType("agent2"), "id2");

        // Act & Assert
        subscription1.GetHashCode().Should().NotBe(subscription2.GetHashCode());
    }
}


===== Runtime\Core\AgentRuntimeExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Threading.Tasks;
using Microsoft.Extensions.DependencyInjection;

namespace Microsoft.SemanticKernel.Agents.Runtime.Core;

/// <summary>
/// Provides extension methods for managing and registering agents within an <see cref="IAgentRuntime"/>.
/// </summary>
public static class AgentRuntimeExtensions
{
    internal const string DirectMessageTopicSuffix = ":";

    /// <summary>
    /// Registers an agent type with the runtime, providing a factory function to create instances of the agent.
    /// </summary>
    /// <typeparam name="TAgent">The type of agent being registered. Must implement <see cref="IHostableAgent"/>.</typeparam>
    /// <param name="runtime">The <see cref="IAgentRuntime"/> where the agent will be registered.</param>
    /// <param name="type">The <see cref="AgentType"/> representing the type of agent.</param>
    /// <param name="serviceProvider">The service provider used for dependency injection.</param>
    /// <param name="additionalArguments">Additional arguments to pass to the agent's constructor.</param>
    /// <returns>A <see cref="ValueTask{AgentType}"/> representing the asynchronous operation of registering the agent.</returns>
    public static ValueTask<AgentType> RegisterAgentTypeAsync<TAgent>(this IAgentRuntime runtime, AgentType type, IServiceProvider serviceProvider, params object[] additionalArguments)
        where TAgent : BaseAgent
        => RegisterAgentTypeAsync(runtime, type, typeof(TAgent), serviceProvider, additionalArguments);

    /// <summary>
    /// Registers an agent type with the runtime using the specified runtime type and additional constructor arguments.
    /// </summary>
    /// <param name="runtime">The agent runtime instance to register the agent with.</param>
    /// <param name="type">The agent type to register.</param>
    /// <param name="runtimeType">The .NET type of the agent to activate.</param>
    /// <param name="serviceProvider">The service provider for dependency injection.</param>
    /// <param name="additionalArguments">Additional arguments to pass to the agent's constructor.</param>
    /// <returns>A <see cref="ValueTask{AgentType}"/> representing the asynchronous registration operation containing the registered agent type.</returns>
    public static ValueTask<AgentType> RegisterAgentTypeAsync(this IAgentRuntime runtime, AgentType type, Type runtimeType, IServiceProvider serviceProvider, params object[] additionalArguments)
    {
        ValueTask<IHostableAgent> factory(AgentId id, IAgentRuntime runtime) => ActivateAgentAsync(serviceProvider, runtimeType, [id, runtime, .. additionalArguments]);

        return runtime.RegisterAgentFactoryAsync(type, factory);
    }

    /// <summary>
    /// Registers implicit subscriptions for an agent type based on the type's custom attributes.
    /// </summary>
    /// <typeparam name="TAgent">The type of the agent.</typeparam>
    /// <param name="runtime">The agent runtime instance.</param>
    /// <param name="type">The agent type to register subscriptions for.</param>
    /// <param name="skipClassSubscriptions">If true, class-level subscriptions are skipped.</param>
    /// <param name="skipDirectMessageSubscription">If true, the direct message subscription is skipped.</param>
    /// <returns>A <see cref="ValueTask"/> representing the asynchronous subscription registration operation.</returns>
    public static ValueTask RegisterImplicitAgentSubscriptionsAsync<TAgent>(this IAgentRuntime runtime, AgentType type, bool skipClassSubscriptions = false, bool skipDirectMessageSubscription = false)
        where TAgent : BaseAgent
        => RegisterImplicitAgentSubscriptionsAsync(runtime, type, typeof(TAgent), skipClassSubscriptions, skipDirectMessageSubscription);

    /// <summary>
    /// Registers implicit subscriptions for the specified agent type using runtime type information.
    /// </summary>
    /// <param name="runtime">The agent runtime instance.</param>
    /// <param name="type">The agent type for which to register subscriptions.</param>
    /// <param name="runtimeType">The .NET type of the agent.</param>
    /// <param name="skipClassSubscriptions">If true, class-level subscriptions are not registered.</param>
    /// <param name="skipDirectMessageSubscription">If true, the direct message subscription is not registered.</param>
    /// <returns>A <see cref="ValueTask"/> representing the asynchronous subscription registration operation.</returns>
    public static async ValueTask RegisterImplicitAgentSubscriptionsAsync(this IAgentRuntime runtime, AgentType type, Type runtimeType, bool skipClassSubscriptions = false, bool skipDirectMessageSubscription = false)
    {
        ISubscriptionDefinition[] subscriptions = BindSubscriptionsForAgentType(type, runtimeType, skipClassSubscriptions, skipDirectMessageSubscription);
        foreach (ISubscriptionDefinition subscription in subscriptions)
        {
            await runtime.AddSubscriptionAsync(subscription).ConfigureAwait(false);
        }
    }

    /// <summary>
    /// Binds subscription definitions for the given agent type based on the custom attributes applied to the runtime type.
    /// </summary>
    /// <param name="agentType">The agent type to bind subscriptions for.</param>
    /// <param name="runtimeType">The .NET type of the agent.</param>
    /// <param name="skipClassSubscriptions">If true, class-level subscriptions are skipped.</param>
    /// <param name="skipDirectMessageSubscription">If true, the direct message subscription is skipped.</param>
    /// <returns>An array of subscription definitions for the agent type.</returns>
    private static ISubscriptionDefinition[] BindSubscriptionsForAgentType(AgentType agentType, Type runtimeType, bool skipClassSubscriptions = false, bool skipDirectMessageSubscription = false)
    {
        List<ISubscriptionDefinition> subscriptions = [];

        if (!skipClassSubscriptions)
        {
            subscriptions.AddRange(runtimeType.GetCustomAttributes<TypeSubscriptionAttribute>().Select(t => t.Bind(agentType)));

            subscriptions.AddRange(runtimeType.GetCustomAttributes<TypePrefixSubscriptionAttribute>().Select(t => t.Bind(agentType)));
        }

        if (!skipDirectMessageSubscription)
        {
            // Direct message subscription using agent name as prefix.
            subscriptions.Add(new TypePrefixSubscription(agentType.Name + DirectMessageTopicSuffix, agentType));
        }

        return [.. subscriptions];
    }

    /// <summary>
    /// Instantiates and activates an agent asynchronously using dependency injection.
    /// </summary>
    /// <param name="serviceProvider">The service provider used for dependency injection.</param>
    /// <param name="runtimeType">The .NET type of the agent being activated.</param>
    /// <param name="additionalArguments">Additional arguments to pass to the agent's constructor.</param>
    /// <returns>A <see cref="ValueTask{T}"/> representing the asynchronous activation of the agent.</returns>
    private static ValueTask<IHostableAgent> ActivateAgentAsync(IServiceProvider serviceProvider, Type runtimeType, params object[] additionalArguments)
    {
        try
        {
            IHostableAgent agent = (BaseAgent)ActivatorUtilities.CreateInstance(serviceProvider, runtimeType, additionalArguments);

#if !NETCOREAPP
            return agent.AsValueTask();
#else
            return ValueTask.FromResult(agent);
#endif
        }
        catch (Exception e) when (!e.IsCriticalException())
        {
#if !NETCOREAPP
            return e.AsValueTask<IHostableAgent>();
#else
            return ValueTask.FromException<IHostableAgent>(e);
#endif
        }
    }
}


===== Runtime\Core\AgentsApp.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;

namespace Microsoft.SemanticKernel.Agents.Runtime.Core;

/// <summary>
/// Represents the core application hosting the agent runtime.
/// Manages the application lifecycle including startup, shutdown, and message publishing.
/// </summary>
public class AgentsApp
{
    private int _runningCount;

    /// <summary>
    /// Initializes a new instance of the <see cref="AgentsApp"/> class.
    /// </summary>
    /// <param name="host">The underlying application host.</param>
    internal AgentsApp(IHost host)
    {
        this.Host = host;
    }

    /// <summary>
    /// Gets the underlying host responsible for managing application lifetime.
    /// </summary>
    public IHost Host { get; }

    /// <summary>
    /// Gets the service provider for dependency resolution.
    /// </summary>
    public IServiceProvider Services => this.Host.Services;

    /// <summary>
    /// Gets the application lifetime object to manage startup and shutdown events.
    /// </summary>
    public IHostApplicationLifetime ApplicationLifetime => this.Services.GetRequiredService<IHostApplicationLifetime>();

    /// <summary>
    /// Gets the agent runtime responsible for handling agent messaging and operations.
    /// </summary>
    public IAgentRuntime AgentRuntime => this.Services.GetRequiredService<IAgentRuntime>();

    /// <summary>
    /// Starts the application by initiating the host.
    /// Throws an exception if the application is already running.
    /// </summary>
    public async ValueTask StartAsync()
    {
        if (Interlocked.Exchange(ref this._runningCount, 1) != 0)
        {
            throw new InvalidOperationException("Application is already running.");
        }

        await this.Host.StartAsync().ConfigureAwait(false);
    }

    /// <summary>
    /// Shuts down the application by stopping the host.
    /// Throws an exception if the application is not running.
    /// </summary>
    public async ValueTask ShutdownAsync()
    {
        if (Interlocked.Exchange(ref this._runningCount, 0) != 1)
        {
            throw new InvalidOperationException("Application is already stopped.");
        }

        await this.Host.StopAsync().ConfigureAwait(false);
    }

    /// <summary>
    /// Publishes a message to the specified topic.
    /// If the application is not running, it starts the host first.
    /// </summary>
    /// <typeparam name="TMessage">The type of the message being published.</typeparam>
    /// <param name="message">The message to publish.</param>
    /// <param name="topic">The topic to which the message will be published.</param>
    /// <param name="messageId">An optional unique identifier for the message.</param>
    /// <param name="cancellationToken">A token to cancel the operation if needed.</param>
    public async ValueTask PublishMessageAsync<TMessage>(TMessage message, TopicId topic, string? messageId = null, CancellationToken cancellationToken = default)
        where TMessage : notnull
    {
        if (Volatile.Read(ref this._runningCount) == 0)
        {
            await this.StartAsync().ConfigureAwait(false);
        }

        await this.AgentRuntime.PublishMessageAsync(message, topic, messageId: messageId, cancellationToken: cancellationToken).ConfigureAwait(false);
    }

    /// <summary>
    /// Waits for the host to complete its shutdown process.
    /// </summary>
    /// <param name="cancellationToken">A token to cancel the operation if needed.</param>
    public Task WaitForShutdownAsync(CancellationToken cancellationToken = default)
    {
        return this.Host.WaitForShutdownAsync(cancellationToken);
    }
}


===== Runtime\Core\AgentsAppBuilder.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Threading.Tasks;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;

namespace Microsoft.SemanticKernel.Agents.Runtime.Core;

/// <summary>
/// Provides a fluent API to configure and build an <see cref="AgentsApp"/> instance.
/// </summary>
public class AgentsAppBuilder
{
    private readonly HostApplicationBuilder _builder;
    private readonly List<Func<AgentsApp, ValueTask<AgentType>>> _agentTypeRegistrations;

    /// <summary>
    /// Initializes a new instance of the <see cref="AgentsAppBuilder"/> class using the specified <see cref="HostApplicationBuilder"/>.
    /// </summary>
    /// <param name="baseBuilder">An optional host application builder to use; if null, a new instance is created.</param>
    public AgentsAppBuilder(HostApplicationBuilder? baseBuilder = null)
    {
        this._builder = baseBuilder ?? new HostApplicationBuilder();
        this._agentTypeRegistrations = [];
    }

    /// <summary>
    /// Gets the dependency injection service collection.
    /// </summary>
    public IServiceCollection Services => this._builder.Services;

    /// <summary>
    /// Gets the application's configuration.
    /// </summary>
    public IConfiguration Configuration => this._builder.Configuration;

    /// <summary>
    /// Scans all assemblies loaded in the current application domain to register available agents.
    /// </summary>
    public void AddAgentsFromAssemblies()
    {
        this.AddAgentsFromAssemblies(AppDomain.CurrentDomain.GetAssemblies());
    }

    /// <summary>
    /// Configures the AgentsApp to use the specified agent runtime.
    /// </summary>
    /// <typeparam name="TRuntime">The type of the runtime.</typeparam>
    /// <param name="runtime">The runtime instance to use.</param>
    /// <returns>The modified instance of <see cref="AgentsAppBuilder"/>.</returns>
    public AgentsAppBuilder UseRuntime<TRuntime>(TRuntime runtime) where TRuntime : class, IAgentRuntime
    {
        this.Services.AddSingleton<IAgentRuntime>(_ => runtime);
        this.Services.AddHostedService(services => runtime);

        return this;
    }

    /// <summary>
    /// Registers agents from the provided assemblies.
    /// </summary>
    /// <param name="assemblies">An array of assemblies to scan for agents.</param>
    /// <returns>The modified instance of <see cref="AgentsAppBuilder"/>.</returns>
    public AgentsAppBuilder AddAgentsFromAssemblies(params Assembly[] assemblies)
    {
        IEnumerable<Type> agentTypes =
            assemblies.SelectMany(assembly => assembly.GetTypes())
                .Where(
                    type =>
                        typeof(BaseAgent).IsAssignableFrom(type) &&
                        !type.IsAbstract);

        foreach (Type agentType in agentTypes)
        {
            // TODO: Expose skipClassSubscriptions and skipDirectMessageSubscription as parameters?
            this.AddAgent(agentType.Name, agentType);
        }

        return this;
    }

    /// <summary>
    /// Registers an agent of type <typeparamref name="TAgent"/> with the associated agent type and subscription options.
    /// </summary>
    /// <typeparam name="TAgent">The .NET type of the agent.</typeparam>
    /// <param name="agentType">The agent type identifier.</param>
    /// <param name="skipClassSubscriptions">Option to skip class subscriptions.</param>
    /// <param name="skipDirectMessageSubscription">Option to skip direct message subscriptions.</param>
    /// <returns>The modified instance of <see cref="AgentsAppBuilder"/>.</returns>
    public AgentsAppBuilder AddAgent<TAgent>(AgentType agentType, bool skipClassSubscriptions = false, bool skipDirectMessageSubscription = false) where TAgent : IHostableAgent
        => this.AddAgent(agentType, typeof(TAgent), skipClassSubscriptions, skipDirectMessageSubscription);

    /// <summary>
    /// Builds the AgentsApp instance by constructing the host and registering all agent types.
    /// </summary>
    /// <returns>A task representing the asynchronous operation, returning the built <see cref="AgentsApp"/>.</returns>
    public async ValueTask<AgentsApp> BuildAsync()
    {
        IHost host = this._builder.Build();

        AgentsApp app = new(host);

        foreach (Func<AgentsApp, ValueTask<AgentType>> registration in this._agentTypeRegistrations)
        {
            await registration(app).ConfigureAwait(false);
        }

        return app;
    }

    /// <summary>
    /// Registers an agent with the runtime using the specified agent type and runtime type.
    /// </summary>
    /// <param name="agentType">The agent type identifier.</param>
    /// <param name="runtimeType">The .NET type representing the agent.</param>
    /// <param name="skipClassSubscriptions">Option to skip class subscriptions.</param>
    /// <param name="skipDirectMessageSubscription">Option to skip direct message subscriptions.</param>
    /// <returns>The modified instance of <see cref="AgentsAppBuilder"/>.</returns>
    private AgentsAppBuilder AddAgent(AgentType agentType, Type runtimeType, bool skipClassSubscriptions = false, bool skipDirectMessageSubscription = false)
    {
        this._agentTypeRegistrations.Add(
            async app =>
            {
                await app.AgentRuntime.RegisterAgentTypeAsync(agentType, runtimeType, app.Services).ConfigureAwait(false);

                await app.AgentRuntime.RegisterImplicitAgentSubscriptionsAsync(agentType, runtimeType, skipClassSubscriptions, skipDirectMessageSubscription).ConfigureAwait(false);

                return agentType;
            });

        return this;
    }
}


===== Runtime\Core\BaseAgent.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.SemanticKernel.Agents.Runtime.Core.Internal;

namespace Microsoft.SemanticKernel.Agents.Runtime.Core;

/// <summary>
/// Represents the base class for an agent in the AutoGen system.
/// </summary>
public abstract class BaseAgent : IHostableAgent, ISaveState
{
    /// <summary>
    /// The activity source for tracing.
    /// </summary>
    public static readonly ActivitySource TraceSource = new($"{typeof(IAgent).Namespace}");

    private readonly Dictionary<Type, HandlerInvoker> _handlerInvokers;
    private readonly IAgentRuntime _runtime;

    /// <summary>
    /// Provides logging capabilities used for diagnostic and operational information.
    /// </summary>
    protected internal ILogger Logger { get; }

    /// <summary>
    /// Gets the description of the agent.
    /// </summary>
    protected string Description { get; }

    /// <summary>
    /// Gets the unique identifier of the agent.
    /// </summary>
    public AgentId Id { get; }

    /// <summary>
    /// Gets the metadata of the agent.
    /// </summary>
    public AgentMetadata Metadata { get; }

    /// <summary>
    /// Initializes a new instance of the BaseAgent class with the specified identifier, runtime, description, and optional logger.
    /// </summary>
    /// <param name="id">The unique identifier of the agent.</param>
    /// <param name="runtime">The runtime environment in which the agent operates.</param>
    /// <param name="description">A brief description of the agent's purpose.</param>
    /// <param name="logger">An optional logger for recording diagnostic information.</param>
    protected BaseAgent(
        AgentId id,
        IAgentRuntime runtime,
        string description,
        ILogger? logger = null)
    {
        this.Logger = logger ?? NullLogger.Instance;

        this.Id = id;
        this.Description = description;
        this.Metadata = new AgentMetadata(this.Id.Type, this.Id.Key, this.Description);

        this._runtime = runtime;
        this._handlerInvokers = HandlerInvoker.ReflectAgentHandlers(this);
    }

    /// <summary>
    /// Handles an incoming message by determining its type and invoking the corresponding handler method if available.
    /// </summary>
    /// <param name="message">The message object to be handled.</param>
    /// <param name="messageContext">The context associated with the message.</param>
    /// <returns>A ValueTask that represents the asynchronous operation, containing the response object or null.</returns>
    public async ValueTask<object?> OnMessageAsync(object message, MessageContext messageContext)
    {
        // Determine type of message, then get handler method and invoke it
        Type messageType = message.GetType();
        if (this._handlerInvokers.TryGetValue(messageType, out HandlerInvoker? handlerInvoker))
        {
            return await handlerInvoker.InvokeAsync(message, messageContext).ConfigureAwait(false);
        }

        return null;
    }

    /// <inheritdoc/>
    public virtual ValueTask<JsonElement> SaveStateAsync()
    {
#if !NETCOREAPP
        return JsonDocument.Parse("{}").RootElement.AsValueTask();
#else
        return ValueTask.FromResult(JsonDocument.Parse("{}").RootElement);
#endif
    }

    /// <inheritdoc/>
    public virtual ValueTask LoadStateAsync(JsonElement state)
    {
#if !NETCOREAPP
        return Task.CompletedTask.AsValueTask();
#else
        return ValueTask.CompletedTask;
#endif
    }

    /// <summary>
    /// Closes this agent gracefully by releasing allocated resources and performing any necessary cleanup.
    /// </summary>
    public virtual ValueTask CloseAsync()
    {
#if !NETCOREAPP
        return Task.CompletedTask.AsValueTask();
#else
        return ValueTask.CompletedTask;
#endif
    }

    /// <summary>
    /// Sends a message to a specified recipient agent through the runtime.
    /// </summary>
    /// <param name="agent">The requested agent's type.</param>
    /// <param name="cancellationToken">A token used to cancel the operation if needed.</param>
    /// <returns>A ValueTask that represents the asynchronous operation, returning the response object or null.</returns>
    protected async ValueTask<AgentId?> GetAgentAsync(AgentType agent, CancellationToken cancellationToken = default)
    {
        try
        {
            return await this._runtime.GetAgentAsync(agent, lazy: false).ConfigureAwait(false);
        }
        catch (InvalidOperationException)
        {
            return null;
        }
    }

    /// <summary>
    /// Sends a message to a specified recipient agent through the runtime.
    /// </summary>
    /// <param name="message">The message object to send.</param>
    /// <param name="recipient">The recipient agent's identifier.</param>
    /// <param name="messageId">An optional identifier for the message.</param>
    /// <param name="cancellationToken">A token used to cancel the operation if needed.</param>
    /// <returns>A ValueTask that represents the asynchronous operation, returning the response object or null.</returns>
    protected ValueTask<object?> SendMessageAsync(object message, AgentId recipient, string? messageId = null, CancellationToken cancellationToken = default)
    {
        return this._runtime.SendMessageAsync(message, recipient, sender: this.Id, messageId, cancellationToken);
    }

    /// <summary>
    /// Publishes a message to all agents subscribed to a specific topic through the runtime.
    /// </summary>
    /// <param name="message">The message object to publish.</param>
    /// <param name="topic">The topic identifier to which the message is published.</param>
    /// <param name="messageId">An optional identifier for the message.</param>
    /// <param name="cancellationToken">A token used to cancel the operation if needed.</param>
    /// <returns>A ValueTask that represents the asynchronous publish operation.</returns>
    protected ValueTask PublishMessageAsync(object message, TopicId topic, string? messageId = null, CancellationToken cancellationToken = default)
    {
        return this._runtime.PublishMessageAsync(message, topic, sender: this.Id, messageId, cancellationToken);
    }
}


===== Runtime\Core\IHandle.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Threading.Tasks;

namespace Microsoft.SemanticKernel.Agents.Runtime.Core;

/// <summary>
/// Defines a handler interface for processing items of type <typeparamref name="T"/>.
/// </summary>
/// <typeparam name="T">The type of item to be handled.</typeparam>
public interface IHandle<in T>
{
    /// <summary>
    /// Handles the specified item asynchronously.
    /// </summary>
    /// <param name="item">The item to be handled.</param>
    /// <param name="messageContext">The context of the message being handled.</param>
    /// <returns>A task that represents the asynchronous operation.</returns>
    ValueTask HandleAsync(T item, MessageContext messageContext);
}

/// <summary>
/// Defines a handler interface for processing items of type <typeparamref name="TIn"/> and <typeparamref name="TOut"/>.
/// </summary>
/// <typeparam name="TIn">The input type</typeparam>
/// <typeparam name="TOut">The output type</typeparam>
public interface IHandle<in TIn, TOut>
{
    /// <summary>
    /// Handles the specified item asynchronously.
    /// </summary>
    /// <param name="item">The item to be handled.</param>
    /// <param name="messageContext">The context of the message being handled.</param>
    /// <returns>A task that represents the asynchronous operation.</returns>
    ValueTask<TOut> HandleAsync(TIn item, MessageContext messageContext);
}


===== Runtime\Core\Internal\HandlerInvoker.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Threading.Tasks;

namespace Microsoft.SemanticKernel.Agents.Runtime.Core.Internal;

/// <summary>
/// Invokes handler methods asynchronously using reflection.
/// The target methods must return either a ValueTask or a ValueTask{T}.
/// This class wraps the reflection call and provides a unified asynchronous invocation interface.
/// </summary>
internal sealed class HandlerInvoker
{
    /// <summary>
    /// Scans the provided agent for implemented handler interfaces (IHandle&lt;&gt; and IHandle&lt;,&gt;) via reflection,
    /// creates a corresponding <see cref="HandlerInvoker"/> for each handler method, and returns a dictionary that maps
    /// the message type (first generic argument of the interface) to its invoker.
    /// </summary>
    /// <param name="agent">The agent instance whose handler interfaces will be reflected.</param>
    /// <returns>A dictionary mapping message types to their corresponding <see cref="HandlerInvoker"/> instances.</returns>
    public static Dictionary<Type, HandlerInvoker> ReflectAgentHandlers(BaseAgent agent)
    {
        Type realType = agent.GetType();

        IEnumerable<Type> candidateInterfaces =
            realType.GetInterfaces()
                .Where(i => i.IsGenericType &&
                    (i.GetGenericTypeDefinition() == typeof(IHandle<>) ||
                    (i.GetGenericTypeDefinition() == typeof(IHandle<,>))));

        Dictionary<Type, HandlerInvoker> invokers = new();
        foreach (Type interface_ in candidateInterfaces)
        {
            MethodInfo handleAsync =
                interface_.GetMethod(nameof(IHandle<object>.HandleAsync), BindingFlags.Instance | BindingFlags.Public) ??
                throw new InvalidOperationException($"No handler method found for interface {interface_.FullName}");

            HandlerInvoker invoker = new(handleAsync, agent);
            invokers.Add(interface_.GetGenericArguments()[0], invoker);
        }

        return invokers;
    }

    /// <summary>
    /// Represents the asynchronous invocation function.
    /// </summary>
    private Func<object?, MessageContext, ValueTask<object?>> Invocation { get; }

    /// <summary>
    /// Initializes a new instance of the <see cref="HandlerInvoker"/> class with the specified method information and target object.
    /// </summary>
    /// <param name="methodInfo">The MethodInfo representing the handler method to be invoked.</param>
    /// <param name="target">The target instance of the agent.</param>
    /// <exception cref="InvalidOperationException">Thrown if the target is missing for a non-static method or if the method's return type is not supported.</exception>
    private HandlerInvoker(MethodInfo methodInfo, BaseAgent target)
    {
        object? invocation(object? message, MessageContext messageContext) => methodInfo.Invoke(target, [message, messageContext]);

        Func<object?, MessageContext, ValueTask<object?>> getResultAsync;
        // Check if the method returns a non-generic ValueTask
        if (methodInfo.ReturnType.IsAssignableFrom(typeof(ValueTask)))
        {
            getResultAsync = async (message, messageContext) =>
            {
                // Await the ValueTask and return null as there is no result value.
                await ((ValueTask)invocation(message, messageContext)!).ConfigureAwait(false);
                return null;
            };
        }
        // Check if the method returns a generic ValueTask<T>
        else if (methodInfo.ReturnType.IsGenericType && methodInfo.ReturnType.GetGenericTypeDefinition() == typeof(ValueTask<>))
        {
            // Obtain the generic type argument for ValueTask<T>
            MethodInfo typeEraseAwait = typeof(HandlerInvoker)
                    .GetMethod(nameof(TypeEraseAwaitAsync), BindingFlags.NonPublic | BindingFlags.Static)!
                    .MakeGenericMethod(methodInfo.ReturnType.GetGenericArguments()[0]);

            getResultAsync = async (message, messageContext) =>
            {
                // Execute the invocation and then type-erase the ValueTask<T> to ValueTask<object?>
                object valueTask = invocation(message, messageContext)!;
                object? typelessValueTask = typeEraseAwait.Invoke(null, [valueTask]);

                Debug.Assert(typelessValueTask is ValueTask<object?>, "Expected ValueTask<object?> after type erasure.");

                return await ((ValueTask<object?>)typelessValueTask).ConfigureAwait(false);
            };
        }
        else
        {
            throw new InvalidOperationException($"Method {methodInfo.Name} must return a ValueTask or ValueTask<T>");
        }

        this.Invocation = getResultAsync;
    }

    /// <summary>
    /// Invokes the handler method asynchronously with the provided message and context.
    /// </summary>
    /// <param name="obj">The message to be passed as the first argument to the handler.</param>
    /// <param name="messageContext">The contextual information associated with the message.</param>
    /// <returns>A ValueTask representing the asynchronous operation, which yields the handler's result.</returns>
    public async ValueTask<object?> InvokeAsync(object? obj, MessageContext messageContext)
    {
        try
        {
            return await this.Invocation.Invoke(obj, messageContext).ConfigureAwait(false);
        }
        catch (TargetInvocationException ex)
        {
            // Unwrap the exception to get the original exception thrown by the handler method.
            Exception? innerException = ex.InnerException;
            if (innerException != null)
            {
                throw innerException;
            }
            throw;
        }
    }

    /// <summary>
    /// Awaits a generic ValueTask and returns its result as an object.
    /// This method is used to convert a ValueTask{T} to ValueTask{object?}.
    /// </summary>
    /// <typeparam name="T">The type of the result contained in the ValueTask.</typeparam>
    /// <param name="vt">The ValueTask to be awaited.</param>
    /// <returns>A ValueTask containing the result as an object.</returns>
    private static async ValueTask<object?> TypeEraseAwaitAsync<T>(ValueTask<T> vt)
    {
        return await vt.ConfigureAwait(false);
    }
}


===== Runtime\Core\TypePrefixSubscription.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Diagnostics.CodeAnalysis;

namespace Microsoft.SemanticKernel.Agents.Runtime.Core;

/// <summary>
/// This subscription matches on topics based on a prefix of the type and maps to agents using the source of the topic as the agent key.
/// This subscription causes each source to have its own agent instance.
/// </summary>
/// <remarks>
/// Example:
/// <code>
/// var subscription = new TypePrefixSubscription("t1", "a1");
/// </code>
/// In this case:
/// - A <see cref="TopicId"/> with type `"t1"` and source `"s1"` will be handled by an agent of type `"a1"` with key `"s1"`.
/// - A <see cref="TopicId"/> with type `"t1"` and source `"s2"` will be handled by an agent of type `"a1"` with key `"s2"`.
/// - A <see cref="TopicId"/> with type `"t1SUFFIX"` and source `"s2"` will be handled by an agent of type `"a1"` with key `"s2"`.
/// </remarks>
public class TypePrefixSubscription : ISubscriptionDefinition
{
    /// <summary>
    /// Initializes a new instance of the <see cref="TypePrefixSubscription"/> class.
    /// </summary>
    /// <param name="topicTypePrefix">Topic type prefix to match against.</param>
    /// <param name="agentType">Agent type to handle this subscription.</param>
    /// <param name="id">Unique identifier for the subscription. If not provided, a new UUID will be generated.</param>
    public TypePrefixSubscription(string topicTypePrefix, AgentType agentType, string? id = null)
    {
        this.TopicTypePrefix = topicTypePrefix;
        this.AgentType = agentType;
        this.Id = id ?? Guid.NewGuid().ToString();
    }

    /// <summary>
    /// Gets the unique identifier of the subscription.
    /// </summary>
    public string Id { get; }

    /// <summary>
    /// Gets the topic type prefix used for matching.
    /// </summary>
    public string TopicTypePrefix { get; }

    /// <summary>
    /// Gets the agent type that handles this subscription.
    /// </summary>
    public AgentType AgentType { get; }

    /// <summary>
    /// Checks if a given <see cref="TopicId"/> matches the subscription based on its type prefix.
    /// </summary>
    /// <param name="topic">The topic to check.</param>
    /// <returns><c>true</c> if the topic's type starts with the subscription's prefix, <c>false</c> otherwise.</returns>
    public bool Matches(TopicId topic)
    {
        return topic.Type.StartsWith(this.TopicTypePrefix, StringComparison.Ordinal);
    }

    /// <summary>
    /// Maps a <see cref="TopicId"/> to an <see cref="AgentId"/>. Should only be called if <see cref="Matches"/> returns true.
    /// </summary>
    /// <param name="topic">The topic to map.</param>
    /// <returns>An <see cref="AgentId"/> representing the agent that should handle the topic.</returns>
    /// <exception cref="InvalidOperationException">Thrown if the topic does not match the subscription.</exception>
    public AgentId MapToAgent(TopicId topic)
    {
        if (!this.Matches(topic))
        {
            throw new InvalidOperationException("TopicId does not match the subscription.");
        }

        return new AgentId(this.AgentType, topic.Source); // No need for .Name, since AgentType implicitly converts to string
    }

    /// <summary>
    /// Determines whether the specified object is equal to the current subscription.
    /// </summary>
    /// <param name="obj">The object to compare with the current instance.</param>
    /// <returns><c>true</c> if the specified object is equal to this instance; otherwise, <c>false</c>.</returns>
    public override bool Equals([NotNullWhen(true)] object? obj)
    {
        return
            obj is TypePrefixSubscription other &&
                (this.Id == other.Id ||
                    (this.AgentType == other.AgentType &&
                     this.TopicTypePrefix == other.TopicTypePrefix));
    }

    /// <summary>
    /// Determines whether the specified subscription is equal to the current subscription.
    /// </summary>
    /// <param name="other">The subscription to compare.</param>
    /// <returns><c>true</c> if the subscriptions are equal; otherwise, <c>false</c>.</returns>
    public bool Equals(ISubscriptionDefinition? other) => this.Id == other?.Id;

    /// <summary>
    /// Returns a hash code for this instance.
    /// </summary>
    /// <returns>A hash code for this instance, suitable for use in hashing algorithms and data structures.</returns>
    public override int GetHashCode()
    {
        return HashCode.Combine(this.Id, this.AgentType, this.TopicTypePrefix);
    }
}


===== Runtime\Core\TypePrefixSubscriptionAttribute.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;

namespace Microsoft.SemanticKernel.Agents.Runtime.Core;

/// <summary>
/// Specifies that the attributed class subscribes to topics based on a type prefix.
/// </summary>
/// <param name="topic">The topic prefix used for matching incoming messages.</param>
[AttributeUsage(AttributeTargets.Class)]
public sealed class TypePrefixSubscriptionAttribute(string topic) : Attribute
{
    /// <summary>
    /// Gets the topic prefix that this subscription listens for.
    /// </summary>
    public string Topic => topic;

    /// <summary>
    /// Creates a subscription definition that binds the topic to the specified agent type.
    /// </summary>
    /// <param name="agentType">The agent type to bind to this topic.</param>
    /// <returns>An <see cref="ISubscriptionDefinition"/> representing the binding.</returns>
    internal ISubscriptionDefinition Bind(AgentType agentType)
    {
        return new TypePrefixSubscription(this.Topic, agentType);
    }
}


===== Runtime\Core\TypeSubscription.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Diagnostics.CodeAnalysis;

namespace Microsoft.SemanticKernel.Agents.Runtime.Core;

/// <summary>
/// This subscription matches on topics based on the exact type and maps to agents using the source of the topic as the agent key.
/// This subscription causes each source to have its own agent instance.
/// </summary>
/// <remarks>
/// Example:
/// <code>
/// var subscription = new TypeSubscription("t1", "a1");
/// </code>
/// In this case:
/// - A <see cref="TopicId"/> with type `"t1"` and source `"s1"` will be handled by an agent of type `"a1"` with key `"s1"`.
/// - A <see cref="TopicId"/> with type `"t1"` and source `"s2"` will be handled by an agent of type `"a1"` with key `"s2"`.
/// </remarks>
public class TypeSubscription : ISubscriptionDefinition
{
    /// <summary>
    /// Initializes a new instance of the <see cref="TypeSubscription"/> class.
    /// </summary>
    /// <param name="topicType">The exact topic type to match against.</param>
    /// <param name="agentType">Agent type to handle this subscription.</param>
    /// <param name="id">Unique identifier for the subscription. If not provided, a new UUID will be generated.</param>
    public TypeSubscription(string topicType, AgentType agentType, string? id = null)
    {
        this.TopicType = topicType;
        this.AgentType = agentType;
        this.Id = id ?? Guid.NewGuid().ToString();
    }

    /// <summary>
    /// Gets the unique identifier of the subscription.
    /// </summary>
    public string Id { get; }

    /// <summary>
    /// Gets the exact topic type used for matching.
    /// </summary>
    public string TopicType { get; }

    /// <summary>
    /// Gets the agent type that handles this subscription.
    /// </summary>
    public AgentType AgentType { get; }

    /// <summary>
    /// Checks if a given <see cref="TopicId"/> matches the subscription based on an exact type match.
    /// </summary>
    /// <param name="topic">The topic to check.</param>
    /// <returns><c>true</c> if the topic's type matches exactly, <c>false</c> otherwise.</returns>
    public bool Matches(TopicId topic)
    {
        return topic.Type == this.TopicType;
    }

    /// <summary>
    /// Maps a <see cref="TopicId"/> to an <see cref="AgentId"/>. Should only be called if <see cref="Matches"/> returns true.
    /// </summary>
    /// <param name="topic">The topic to map.</param>
    /// <returns>An <see cref="AgentId"/> representing the agent that should handle the topic.</returns>
    /// <exception cref="InvalidOperationException">Thrown if the topic does not match the subscription.</exception>
    public AgentId MapToAgent(TopicId topic)
    {
        if (!this.Matches(topic))
        {
            throw new InvalidOperationException("TopicId does not match the subscription.");
        }

        return new AgentId(this.AgentType, topic.Source);
    }

    /// <summary>
    /// Determines whether the specified object is equal to the current subscription.
    /// </summary>
    /// <param name="obj">The object to compare with the current instance.</param>
    /// <returns><c>true</c> if the specified object is equal to this instance; otherwise, <c>false</c>.</returns>
    public override bool Equals([NotNullWhen(true)] object? obj)
    {
        return
            obj is TypeSubscription other &&
                (this.Id == other.Id ||
                    (this.AgentType == other.AgentType &&
                        this.TopicType == other.TopicType));
    }

    /// <summary>
    /// Determines whether the specified subscription is equal to the current subscription.
    /// </summary>
    /// <param name="other">The subscription to compare.</param>
    /// <returns><c>true</c> if the subscriptions are equal; otherwise, <c>false</c>.</returns>
    public bool Equals(ISubscriptionDefinition? other) => this.Id == other?.Id;

    /// <summary>
    /// Returns a hash code for this instance.
    /// </summary>
    /// <returns>A hash code for this instance, suitable for use in hashing algorithms and data structures.</returns>
    public override int GetHashCode()
    {
        return HashCode.Combine(this.Id, this.AgentType, this.TopicType);
    }
}


===== Runtime\Core\TypeSubscriptionAttribute.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;

namespace Microsoft.SemanticKernel.Agents.Runtime.Core;

/// <summary>
/// Specifies that the attributed class subscribes to a particular topic for agent message handling.
/// </summary>
/// <param name="topic">The topic identifier that this class subscribes to.</param>
[AttributeUsage(AttributeTargets.Class)]
public sealed class TypeSubscriptionAttribute(string topic) : Attribute
{
    /// <summary>
    /// Gets the topic identifier associated with this subscription.
    /// </summary>
    public string Topic => topic;

    /// <summary>
    /// Creates a subscription definition that binds the topic to the specified agent type.
    /// </summary>
    /// <param name="agentType">The agent type to bind to this topic.</param>
    /// <returns>An <see cref="ISubscriptionDefinition"/> representing the binding.</returns>
    internal ISubscriptionDefinition Bind(AgentType agentType)
    {
        return new TypeSubscription(this.Topic, agentType);
    }
}


===== Runtime\InProcess.Tests\InProcessRuntimeTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.Json;
using System.Threading.Tasks;
using FluentAssertions;
using Xunit;

namespace Microsoft.SemanticKernel.Agents.Runtime.InProcess.Tests;

[Trait("Category", "Unit")]
public class InProcessRuntimeTests()
{
    [Fact]
    [Trait("Category", "Unit")]
    public async Task RuntimeStatusLifecycleTest()
    {
        // Arrange & Act
        await using InProcessRuntime runtime = new();

        // Assert
        Assert.False(runtime.DeliverToSelf);
        Assert.Equal(0, runtime.messageQueueCount);

        // Act
        await runtime.StopAsync(); // Already stopped
        await runtime.RunUntilIdleAsync(); // Never throws

        await runtime.StartAsync();

        // Assert
        // Invalid to start runtime that is already started
        await Assert.ThrowsAsync<InvalidOperationException>(() => runtime.StartAsync());
        Assert.Equal(0, runtime.messageQueueCount);

        // Act
        await runtime.StopAsync();

        // Assert
        Assert.Equal(0, runtime.messageQueueCount);
    }

    [Fact]
    [Trait("Category", "Unit")]
    public async Task SubscriptionRegistrationLifecycleTest()
    {
        // Arrange
        await using InProcessRuntime runtime = new();
        TestSubscription subscription = new("TestTopic", "MyAgent");

        // Act & Assert
        await Assert.ThrowsAsync<InvalidOperationException>(async () => await runtime.RemoveSubscriptionAsync(subscription.Id));

        // Arrange
        await runtime.AddSubscriptionAsync(subscription);

        // Act & Assert
        await Assert.ThrowsAsync<InvalidOperationException>(async () => await runtime.AddSubscriptionAsync(subscription));

        // Act
        await runtime.RemoveSubscriptionAsync(subscription.Id);
    }

    [Fact]
    [Trait("Category", "Unit")]
    public async Task AgentRegistrationLifecycleTest()
    {
        // Arrange
        const string agentType = "MyAgent";
        const string agentDescription = "A test agent";
        List<MockAgent> agents = [];
        await using InProcessRuntime runtime = new();

        // Act & Assert
        await Assert.ThrowsAsync<InvalidOperationException>(async () => await runtime.GetAgentAsync(agentType, lazy: false));

        // Arrange
        await runtime.RegisterAgentFactoryAsync(agentType, factoryFunc);

        // Act & Assert
        await Assert.ThrowsAsync<InvalidOperationException>(async () => await runtime.RegisterAgentFactoryAsync(agentType, factoryFunc));

        // Act: Lookup by type
        AgentId agentId = await runtime.GetAgentAsync(agentType, lazy: false);

        // Assert
        Assert.Single(agents);
        Assert.Single(runtime.agentInstances);

        // Act
        MockAgent agent = await runtime.TryGetUnderlyingAgentInstanceAsync<MockAgent>(agentId);

        // Assert
        Assert.Equal(agentId, agent.Id);

        // Act & Assert
        await Assert.ThrowsAsync<InvalidOperationException>(async () => await runtime.TryGetUnderlyingAgentInstanceAsync<WrongAgent>(agentId));

        // Act: Lookup by ID
        AgentId sameId = await runtime.GetAgentAsync(agentId, lazy: false);

        // Assert
        Assert.Equal(agentId, sameId);

        // Act: Lookup by Type
        sameId = await runtime.GetAgentAsync((AgentType)agent.Id.Type, lazy: false);

        // Assert
        Assert.Equal(agentId, sameId);

        // Act: Lookup metadata
        AgentMetadata metadata = await runtime.GetAgentMetadataAsync(agentId);

        // Assert
        Assert.Equal(agentId.Type, metadata.Type);
        Assert.Equal(agentDescription, metadata.Description);
        Assert.Equal(agentId.Key, metadata.Key);

        // Act: Access proxy
        AgentProxy proxy = await runtime.TryGetAgentProxyAsync(agentId);

        // Assert
        Assert.Equal(agentId, proxy.Id);
        Assert.Equal(metadata.Type, proxy.Metadata.Type);
        Assert.Equal(metadata.Description, proxy.Metadata.Description);
        Assert.Equal(metadata.Key, proxy.Metadata.Key);

        ValueTask<MockAgent> factoryFunc(AgentId id, IAgentRuntime runtime)
        {
            MockAgent agent = new(id, runtime, agentDescription);
            agents.Add(agent);
            return ValueTask.FromResult(agent);
        }
    }

    [Fact]
    [Trait("Category", "Unit")]
    public async Task AgentStateLifecycleTest()
    {
        // Arrange
        const string agentType = "MyAgent";
        const string testMessage = "test message";

        await using InProcessRuntime firstRuntime = new();
        await firstRuntime.RegisterAgentFactoryAsync(agentType, factoryFunc);

        // Act
        AgentId agentId = await firstRuntime.GetAgentAsync(agentType, lazy: false);

        // Assert
        Assert.Single(firstRuntime.agentInstances);

        // Arrange
        MockAgent agent = (MockAgent)firstRuntime.agentInstances[agentId];
        agent.ReceivedMessages.Add(testMessage);

        // Act
        JsonElement agentState = await firstRuntime.SaveAgentStateAsync(agentId);

        // Arrange
        await using InProcessRuntime secondRuntime = new();
        await secondRuntime.RegisterAgentFactoryAsync(agentType, factoryFunc);

        // Act
        await secondRuntime.LoadAgentStateAsync(agentId, agentState);

        // Assert
        Assert.Single(secondRuntime.agentInstances);
        MockAgent copy = (MockAgent)secondRuntime.agentInstances[agentId];
        Assert.Single(copy.ReceivedMessages);
        Assert.Equal(testMessage, copy.ReceivedMessages.Single().ToString());

        static ValueTask<MockAgent> factoryFunc(AgentId id, IAgentRuntime runtime)
        {
            MockAgent agent = new(id, runtime, "A test agent");
            return ValueTask.FromResult(agent);
        }
    }

    [Fact]
    [Trait("Category", "Unit")]
    public async Task RuntimeSendMessageTest()
    {
        // Arrange
        await using InProcessRuntime runtime = new();
        MockAgent? agent = null;
        await runtime.RegisterAgentFactoryAsync("MyAgent", (id, runtime) =>
        {
            agent = new MockAgent(id, runtime, "A test agent");
            return ValueTask.FromResult(agent);
        });

        // Act: Ensure the agent is actually created
        AgentId agentId = await runtime.GetAgentAsync("MyAgent", lazy: false);

        // Assert
        Assert.NotNull(agent);
        Assert.Empty(agent.ReceivedMessages);

        // Act: Send message
        await runtime.StartAsync();
        await runtime.SendMessageAsync("TestMessage", agent.Id);
        await runtime.RunUntilIdleAsync();

        // Assert
        Assert.Equal(0, runtime.messageQueueCount);
        Assert.Single(agent.ReceivedMessages);
    }

    // Agent will not deliver to self will success when runtime.DeliverToSelf is false (default)
    [Theory]
    [InlineData(false, 0)]
    [InlineData(true, 1)]
    [Trait("Category", "Unit")]
    public async Task RuntimeAgentPublishToSelfTest(bool selfPublish, int receiveCount)
    {
        // Arrange
        await using InProcessRuntime runtime = new()
        {
            DeliverToSelf = selfPublish
        };

        MockAgent? agent = null;
        await runtime.RegisterAgentFactoryAsync("MyAgent", (id, runtime) =>
        {
            agent = new MockAgent(id, runtime, "A test agent");
            return ValueTask.FromResult(agent);
        });

        // Assert
        runtime.agentInstances.Count.Should().Be(0, "No Agent should be registered in the runtime");

        // Act: Ensure the agent is actually created
        AgentId agentId = await runtime.GetAgentAsync("MyAgent", lazy: false);

        // Assert
        Assert.NotNull(agent);
        runtime.agentInstances.Count.Should().Be(1, "Agent should be registered in the runtime");

        const string TopicType = "TestTopic";

        // Arrange
        await runtime.AddSubscriptionAsync(new TestSubscription(TopicType, agentId.Type));

        // Act
        await runtime.StartAsync();
        await runtime.PublishMessageAsync("SelfMessage", new TopicId(TopicType), sender: agentId);
        await runtime.RunUntilIdleAsync();

        // Assert
        Assert.Equal(receiveCount, agent.ReceivedMessages.Count);
    }

    [Fact]
    [Trait("Category", "Unit")]
    public async Task RuntimeShouldSaveLoadStateCorrectlyTest()
    {
        // Arrange: Create a runtime and register an agent
        await using InProcessRuntime runtime = new();
        MockAgent? agent = null;
        await runtime.RegisterAgentFactoryAsync("MyAgent", (id, runtime) =>
        {
            agent = new MockAgent(id, runtime, "test agent");
            return ValueTask.FromResult(agent);
        });

        // Get agent ID and instantiate agent by publishing
        AgentId agentId = await runtime.GetAgentAsync("MyAgent", lazy: false);
        const string TopicType = "TestTopic";
        await runtime.AddSubscriptionAsync(new TestSubscription(TopicType, agentId.Type));

        await runtime.StartAsync();
        await runtime.PublishMessageAsync("test", new TopicId(TopicType));
        await runtime.RunUntilIdleAsync();

        // Act: Save the state
        JsonElement savedState = await runtime.SaveStateAsync();

        // Assert: Ensure the agent's state is stored as a valid JSON type
        Assert.NotNull(agent);
        savedState.TryGetProperty(agentId.ToString(), out JsonElement agentState).Should().BeTrue("Agent state should be saved");
        agentState.ValueKind.Should().Be(JsonValueKind.Array, "Agent state should be stored as a JSON array");
        agent.ReceivedMessages.Count.Should().Be(1, "Agent should be have state restored");

        // Arrange: Serialize and Deserialize the state to simulate persistence
        string json = JsonSerializer.Serialize(savedState);
        json.Should().NotBeNullOrEmpty("Serialized state should not be empty");
        IDictionary<string, JsonElement> deserializedState = JsonSerializer.Deserialize<IDictionary<string, JsonElement>>(json)
            ?? throw new InvalidOperationException("Deserialized state is unexpectedly null");
        deserializedState.Should().ContainKey(agentId.ToString());

        // Act: Start new runtime and restore the state
        agent = null;
        await using InProcessRuntime newRuntime = new();
        await newRuntime.StartAsync();
        await newRuntime.RegisterAgentFactoryAsync("MyAgent", (id, runtime) =>
        {
            agent = new MockAgent(id, runtime, "another agent");
            return ValueTask.FromResult(agent);
        });

        // Assert: Show that no agent instances exist in the new runtime
        newRuntime.agentInstances.Count.Should().Be(0, "Agent should be registered in the new runtime");

        // Act: Load the state into the new runtime and show that agent is now instantiated
        await newRuntime.LoadStateAsync(savedState);

        // Assert
        Assert.NotNull(agent);
        newRuntime.agentInstances.Count.Should().Be(1, "Agent should be registered in the new runtime");
        newRuntime.agentInstances.Should().ContainKey(agentId, "Agent should be loaded into the new runtime");
        agent.ReceivedMessages.Count.Should().Be(1, "Agent should be have state restored");
    }

    private sealed class TextMessage
    {
        public string Source { get; set; } = string.Empty;
        public string Content { get; set; } = string.Empty;
    }

    private sealed class WrongAgent : IAgent, IHostableAgent
    {
        public AgentId Id => throw new NotImplementedException();

        public AgentMetadata Metadata => throw new NotImplementedException();

        public ValueTask CloseAsync() => ValueTask.CompletedTask;

        public ValueTask LoadStateAsync(JsonElement state)
        {
            throw new NotImplementedException();
        }

        public ValueTask<object?> OnMessageAsync(object message, MessageContext messageContext)
        {
            throw new NotImplementedException();
        }

        public ValueTask<JsonElement> SaveStateAsync()
        {
            throw new NotImplementedException();
        }
    }
}


===== Runtime\InProcess.Tests\MessageDeliveryTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Threading;
using System.Threading.Tasks;
using Xunit;

namespace Microsoft.SemanticKernel.Agents.Runtime.InProcess.Tests;

[Trait("Category", "Unit")]
public class MessageDeliveryTests
{
    private static readonly Func<MessageEnvelope, CancellationToken, ValueTask> EmptyServicer = (_, _) => new ValueTask();

    [Fact]
    public void Constructor_InitializesProperties()
    {
        // Arrange
        MessageEnvelope message = new(new object());
        ResultSink<object?> resultSink = new();

        // Act
        MessageDelivery delivery = new(message, EmptyServicer, resultSink);

        // Assert
        Assert.Same(message, delivery.Message);
        Assert.Same(EmptyServicer, delivery.Servicer);
        Assert.Same(resultSink, delivery.ResultSink);
    }

    [Fact]
    public async Task Future_WithResultSink_ReturnsSinkFuture()
    {
        // Arrange
        MessageEnvelope message = new(new object());

        ResultSink<object?> resultSink = new();
        int expectedResult = 42;
        resultSink.SetResult(expectedResult);

        // Act
        MessageDelivery delivery = new(message, EmptyServicer, resultSink);
        object? result = await delivery.ResultSink.Future;

        // Assert
        Assert.Equal(expectedResult, result);
    }

    [Fact]
    public async Task InvokeAsync_CallsServicerWithCorrectParameters()
    {
        // Arrange
        MessageEnvelope message = new(new object());
        CancellationToken cancellationToken = new();

        bool servicerCalled = false;
        MessageEnvelope? passedMessage = null;
        CancellationToken? passedToken = null;

        ValueTask servicer(MessageEnvelope msg, CancellationToken token)
        {
            servicerCalled = true;
            passedMessage = msg;
            passedToken = token;
            return ValueTask.CompletedTask;
        }

        ResultSink<object?> sink = new();
        MessageDelivery delivery = new(message, servicer, sink);

        // Act
        await delivery.InvokeAsync(cancellationToken);

        // Assert
        Assert.True(servicerCalled);
        Assert.Same(message, passedMessage);
        Assert.Equal(cancellationToken, passedToken);
    }
}


===== Runtime\InProcess.Tests\MessageEnvelopeTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Threading;
using System.Threading.Tasks;
using Xunit;

namespace Microsoft.SemanticKernel.Agents.Runtime.InProcess.Tests;

[Trait("Category", "Unit")]
public class MessageEnvelopeTests
{
    [Fact]
    public void ConstructAllParametersTest()
    {
        // Arrange
        object message = new { Content = "Test message" };
        const string messageId = "testid";
        CancellationToken cancellation = new();

        // Act
        MessageEnvelope envelope = new(message, messageId, cancellation);

        // Assert
        Assert.Same(message, envelope.Message);
        Assert.Equal(messageId, envelope.MessageId);
        Assert.Equal(cancellation, envelope.Cancellation);
        Assert.Null(envelope.Sender);
        Assert.Null(envelope.Receiver);
        Assert.Null(envelope.Topic);
    }

    [Fact]
    public void ConstructOnlyRequiredParametersTest()
    {
        // Arrange & Act
        MessageEnvelope envelope = new("test");

        // Assert
        Assert.NotNull(envelope.MessageId);
        Assert.NotEmpty(envelope.MessageId);
        // Verify it's a valid GUID
        Assert.True(Guid.TryParse(envelope.MessageId, out _));
    }

    [Fact]
    public void WithSenderTest()
    {
        // Arrange
        MessageEnvelope envelope = new("test");
        AgentId sender = new("testtype", "testkey");

        // Act
        MessageEnvelope result = envelope.WithSender(sender);

        // Assert
        Assert.Same(envelope, result);
        Assert.Equal(sender, envelope.Sender);
    }

    [Fact]
    public async Task ForSendTest()
    {
        // Arrange
        MessageEnvelope envelope = new("test");
        AgentId receiver = new("receivertype", "receiverkey");
        object expectedResult = new { Response = "Success" };

        ValueTask<object?> servicer(MessageEnvelope env, CancellationToken ct) => ValueTask.FromResult<object?>(expectedResult);

        // Act
        MessageDelivery delivery = envelope.ForSend(receiver, servicer);

        // Assert
        Assert.NotNull(delivery);
        Assert.Same(envelope, delivery.Message);
        Assert.Equal(receiver, envelope.Receiver);

        // Invoke the servicer to verify result sink works
        await delivery.InvokeAsync(CancellationToken.None);
        Assert.True(delivery.ResultSink.Future.IsCompleted);
        object? result = await delivery.ResultSink.Future;
        Assert.Same(expectedResult, result);
    }

    [Fact]
    public void ForPublishTest()
    {
        // Arrange
        MessageEnvelope envelope = new("test");
        TopicId topic = new("testtopic");

        static ValueTask servicer(MessageEnvelope env, CancellationToken ct) => ValueTask.CompletedTask;

        // Act
        MessageDelivery delivery = envelope.ForPublish(topic, servicer);

        // Assert
        Assert.NotNull(delivery);
        Assert.Same(envelope, delivery.Message);
        Assert.Equal(topic, envelope.Topic);
    }
}


===== Runtime\InProcess.Tests\MessagingTestFixture.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.SemanticKernel.Agents.Runtime.Core;

namespace Microsoft.SemanticKernel.Agents.Runtime.InProcess.Tests;

public sealed class BasicMessage
{
    public string Content { get; set; } = string.Empty;
}

#pragma warning disable RCS1194 // Implement exception constructors
public sealed class TestException : Exception { }
#pragma warning restore RCS1194 // Implement exception constructors

public sealed class PublisherAgent : TestAgent, IHandle<BasicMessage>
{
    private readonly IList<TopicId> targetTopics;

    public PublisherAgent(AgentId id, IAgentRuntime runtime, string description, IList<TopicId> targetTopics)
        : base(id, runtime, description)
    {
        this.targetTopics = targetTopics;
    }

    public async ValueTask HandleAsync(BasicMessage item, MessageContext messageContext)
    {
        this.ReceivedMessages.Add(item);
        foreach (TopicId targetTopic in this.targetTopics)
        {
            await this.PublishMessageAsync(
                new BasicMessage { Content = $"@{targetTopic}: {item.Content}" },
                targetTopic);
        }
    }
}

public sealed class SendOnAgent : TestAgent, IHandle<BasicMessage>
{
    private readonly IList<Guid> targetKeys;

    public SendOnAgent(AgentId id, IAgentRuntime runtime, string description, IList<Guid> targetKeys)
        : base(id, runtime, description)
    {
        this.targetKeys = targetKeys;
    }

    public async ValueTask HandleAsync(BasicMessage item, MessageContext messageContext)
    {
        foreach (Guid targetKey in this.targetKeys)
        {
            AgentId targetId = new(nameof(ReceiverAgent), targetKey.ToString());
            BasicMessage response = new() { Content = $"@{targetKey}: {item.Content}" };
            await this.SendMessageAsync(response, targetId);
        }
    }
}

public sealed class ReceiverAgent : TestAgent, IHandle<BasicMessage>
{
    public List<BasicMessage> Messages { get; } = [];

    public ReceiverAgent(AgentId id, IAgentRuntime runtime, string description)
        : base(id, runtime, description)
    {
    }

    public ValueTask HandleAsync(BasicMessage item, MessageContext messageContext)
    {
        this.Messages.Add(item);
        return ValueTask.CompletedTask;
    }
}

public sealed class ProcessorAgent : TestAgent, IHandle<BasicMessage, BasicMessage>
{
    private Func<string, string> ProcessFunc { get; }

    public ProcessorAgent(AgentId id, IAgentRuntime runtime, Func<string, string> processFunc, string description)
        : base(id, runtime, description)
    {
        this.ProcessFunc = processFunc;
    }

    public ValueTask<BasicMessage> HandleAsync(BasicMessage item, MessageContext messageContext)
    {
        BasicMessage result = new() { Content = this.ProcessFunc.Invoke(((BasicMessage)item).Content) };

        return ValueTask.FromResult(result);
    }
}

public sealed class CancelAgent : TestAgent, IHandle<BasicMessage>
{
    public CancelAgent(AgentId id, IAgentRuntime runtime, string description)
        : base(id, runtime, description)
    {
    }

    public ValueTask HandleAsync(BasicMessage item, MessageContext messageContext)
    {
        CancellationToken cancelledToken = new(canceled: true);
        cancelledToken.ThrowIfCancellationRequested();

        return ValueTask.CompletedTask;
    }
}

public sealed class ErrorAgent : TestAgent, IHandle<BasicMessage>
{
    public ErrorAgent(AgentId id, IAgentRuntime runtime, string description)
        : base(id, runtime, description)
    {
    }

    public bool DidThrow { get; private set; }

    public ValueTask HandleAsync(BasicMessage item, MessageContext messageContext)
    {
        this.DidThrow = true;

        throw new TestException();
    }
}

public sealed class MessagingTestFixture
{
    private Dictionary<Type, object> AgentsTypeMap { get; } = [];
    public InProcessRuntime Runtime { get; } = new();

    public ValueTask<AgentType> RegisterFactoryMapInstances<TAgent>(AgentType type, Func<AgentId, IAgentRuntime, ValueTask<TAgent>> factory)
        where TAgent : IHostableAgent
    {
        async ValueTask<TAgent> WrappedFactory(AgentId id, IAgentRuntime runtime)
        {
            TAgent agent = await factory(id, runtime);
            this.GetAgentInstances<TAgent>()[id] = agent;
            return agent;
        }

        return this.Runtime.RegisterAgentFactoryAsync(type, WrappedFactory);
    }

    public Dictionary<AgentId, TAgent> GetAgentInstances<TAgent>() where TAgent : IHostableAgent
    {
        if (!this.AgentsTypeMap.TryGetValue(typeof(TAgent), out object? maybeAgentMap) ||
            maybeAgentMap is not Dictionary<AgentId, TAgent> result)
        {
            this.AgentsTypeMap[typeof(TAgent)] = result = [];
        }

        return result;
    }
    public async ValueTask RegisterReceiverAgent(string? agentNameSuffix = null, params string[] topicTypes)
    {
        await this.RegisterFactoryMapInstances(
            $"{nameof(ReceiverAgent)}{agentNameSuffix ?? string.Empty}",
            (id, runtime) => ValueTask.FromResult(new ReceiverAgent(id, runtime, string.Empty)));

        foreach (string topicType in topicTypes)
        {
            await this.Runtime.AddSubscriptionAsync(new TestSubscription(topicType, $"{nameof(ReceiverAgent)}{agentNameSuffix ?? string.Empty}"));
        }
    }

    public async ValueTask RegisterErrorAgent(string? agentNameSuffix = null, params string[] topicTypes)
    {
        await this.RegisterFactoryMapInstances(
            $"{nameof(ErrorAgent)}{agentNameSuffix ?? string.Empty}",
            (id, runtime) => ValueTask.FromResult(new ErrorAgent(id, runtime, string.Empty)));

        foreach (string topicType in topicTypes)
        {
            await this.Runtime.AddSubscriptionAsync(new TestSubscription(topicType, $"{nameof(ErrorAgent)}{agentNameSuffix ?? string.Empty}"));
        }
    }

    public async ValueTask RunPublishTestAsync(TopicId sendTarget, object message, string? messageId = null)
    {
        messageId ??= Guid.NewGuid().ToString();

        await this.Runtime.StartAsync();
        await this.Runtime.PublishMessageAsync(message, sendTarget, messageId: messageId);
        await this.Runtime.RunUntilIdleAsync();
    }

    public async ValueTask<object?> RunSendTestAsync(AgentId sendTarget, object message, string? messageId = null)
    {
        messageId ??= Guid.NewGuid().ToString();

        await this.Runtime.StartAsync();

        object? result = await this.Runtime.SendMessageAsync(message, sendTarget, messageId: messageId);

        await this.Runtime.RunUntilIdleAsync();

        return result;
    }
}


===== Runtime\InProcess.Tests\PublishMessageTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Threading.Tasks;
using FluentAssertions;
using Xunit;

namespace Microsoft.SemanticKernel.Agents.Runtime.InProcess.Tests;

[Trait("Category", "Unit")]
public class PublishMessageTests
{
    [Fact]
    public async Task Test_PublishMessage_Success()
    {
        MessagingTestFixture fixture = new();

        await fixture.RegisterReceiverAgent(topicTypes: "TestTopic");
        await fixture.RegisterReceiverAgent("2", topicTypes: "TestTopic");

        await fixture.RunPublishTestAsync(new TopicId("TestTopic"), new BasicMessage { Content = "1" });

        fixture.GetAgentInstances<ReceiverAgent>().Values
            .Should().HaveCount(2, "Two agents should have been created")
                 .And.AllSatisfy(receiverAgent => receiverAgent.Messages
                                                               .Should().NotBeNull()
                                                                    .And.HaveCount(1)
                                                                    .And.ContainSingle(m => m.Content == "1"));
    }

    [Fact]
    public async Task Test_PublishMessage_SingleFailure()
    {
        MessagingTestFixture fixture = new();

        await fixture.RegisterErrorAgent(topicTypes: "TestTopic");

        Func<Task> publishTask = async () => await fixture.RunPublishTestAsync(new TopicId("TestTopic"), new BasicMessage { Content = "1" });

        // Publish is fire and forget, so we expect no exception to be thrown
        await publishTask.Should().NotThrowAsync();

        fixture.GetAgentInstances<ErrorAgent>().Values.Should().ContainSingle()
                                                .Which.DidThrow.Should().BeTrue("Agent should have thrown an exception");
    }

    [Fact]
    public async Task Test_PublishMessage_MultipleFailures()
    {
        MessagingTestFixture fixture = new();

        await fixture.RegisterErrorAgent(topicTypes: "TestTopic");
        await fixture.RegisterErrorAgent("2", topicTypes: "TestTopic");

        Func<Task> publishTask = async () => await fixture.RunPublishTestAsync(new TopicId("TestTopic"), new BasicMessage { Content = "1" });

        // Publish is fire and forget, so we expect no exception to be thrown
        await publishTask.Should().NotThrowAsync();

        fixture.GetAgentInstances<ErrorAgent>().Values
            .Should().HaveCount(2)
                 .And.AllSatisfy(
                    agent => agent.DidThrow.Should().BeTrue("Agent should have thrown an exception"));
    }

    [Fact]
    public async Task Test_PublishMessage_MixedSuccessFailure()
    {
        MessagingTestFixture fixture = new();

        await fixture.RegisterReceiverAgent(topicTypes: "TestTopic");
        await fixture.RegisterReceiverAgent("2", topicTypes: "TestTopic");

        await fixture.RegisterErrorAgent(topicTypes: "TestTopic");
        await fixture.RegisterErrorAgent("2", topicTypes: "TestTopic");

        Func<Task> publicTask = async () => await fixture.RunPublishTestAsync(new TopicId("TestTopic"), new BasicMessage { Content = "1" });

        // Publish is fire and forget, so we expect no exception to be thrown
        await publicTask.Should().NotThrowAsync();

        fixture.GetAgentInstances<ReceiverAgent>().Values
            .Should().HaveCount(2, "Two ReceiverAgents should have been created")
                 .And.AllSatisfy(receiverAgent => receiverAgent.Messages
                                                               .Should().NotBeNull()
                                                                    .And.HaveCount(1)
                                                                    .And.ContainSingle(m => m.Content == "1"),
                                 "ReceiverAgents should get published message regardless of ErrorAgents throwing exception.");

        fixture.GetAgentInstances<ErrorAgent>().Values
            .Should().HaveCount(2, "Two ErrorAgents should have been created")
                 .And.AllSatisfy(agent => agent.DidThrow.Should().BeTrue("ErrorAgent should have thrown an exception"));
    }

    [Fact]
    public async Task Test_PublishMessage_RecurrentPublishSucceeds()
    {
        MessagingTestFixture fixture = new();

        await fixture.RegisterFactoryMapInstances(
            nameof(PublisherAgent),
            (id, runtime) => ValueTask.FromResult(new PublisherAgent(id, runtime, string.Empty, [new TopicId("TestTopic")])));

        await fixture.Runtime.AddSubscriptionAsync(new TestSubscription("RunTest", nameof(PublisherAgent)));

        await fixture.RegisterReceiverAgent(topicTypes: "TestTopic");
        await fixture.RegisterReceiverAgent("2", topicTypes: "TestTopic");

        await fixture.RunPublishTestAsync(new TopicId("RunTest"), new BasicMessage { Content = "1" });

        TopicId testTopicId = new("TestTopic");
        fixture.GetAgentInstances<ReceiverAgent>().Values
            .Should().HaveCount(2, "Two ReceiverAgents should have been created")
                 .And.AllSatisfy(receiverAgent => receiverAgent.Messages
                                                               .Should().NotBeNull()
                                                                    .And.HaveCount(1)
                                                                    .And.ContainSingle(m => m.Content == $"@{testTopicId}: 1"));
    }
}


===== Runtime\InProcess.Tests\ResultSinkTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Threading.Tasks;
using System.Threading.Tasks.Sources;
using Xunit;

namespace Microsoft.SemanticKernel.Agents.Runtime.InProcess.Tests;

[Trait("Category", "Unit")]
public class ResultSinkTests
{
    [Fact]
    public void GetResultTest()
    {
        // Arrange
        ResultSink<int> sink = new();
        const int expectedResult = 42;

        // Act
        sink.SetResult(expectedResult);
        int result = sink.GetResult(0);

        // Assert
        Assert.Equal(expectedResult, result);
        Assert.Equal(ValueTaskSourceStatus.Succeeded, sink.GetStatus(0));
    }

    [Fact]
    public async Task FutureResultTest()
    {
        // Arrange
        ResultSink<string> sink = new();
        const string expectedResult = "test";

        // Act
        sink.SetResult(expectedResult);
        string result = await sink.Future;

        // Assert
        Assert.Equal(expectedResult, result);
        Assert.Equal(ValueTaskSourceStatus.Succeeded, sink.GetStatus(0));
    }

    [Fact]
    public async Task SetExceptionTest()
    {
        // Arrange
        ResultSink<int> sink = new();
        InvalidOperationException expectedException = new("Test exception");

        // Act
        sink.SetException(expectedException);

        // Assert
        Exception exception = await Assert.ThrowsAsync<InvalidOperationException>(async () => await sink.Future);
        Assert.Equal(expectedException.Message, exception.Message);
        exception = Assert.Throws<InvalidOperationException>(() => sink.GetResult(0));
        Assert.Equal(expectedException.Message, exception.Message);
        Assert.Equal(ValueTaskSourceStatus.Faulted, sink.GetStatus(0));
    }

    [Fact]
    public async Task SetCancelledTest()
    {
        // Arrange
        ResultSink<int> sink = new();

        // Act
        sink.SetCancelled();

        // Assert
        Assert.True(sink.IsCancelled);
        Assert.Throws<OperationCanceledException>(() => sink.GetResult(0));
        await Assert.ThrowsAsync<OperationCanceledException>(async () => await sink.Future);
        Assert.Equal(ValueTaskSourceStatus.Canceled, sink.GetStatus(0));
    }

    [Fact]
    public void OnCompletedTest()
    {
        // Arrange
        ResultSink<int> sink = new();
        bool continuationCalled = false;
        const int expectedResult = 42;

        // Register the continuation
        sink.OnCompleted(
            state => continuationCalled = true,
            state: null,
            token: 0,
            ValueTaskSourceOnCompletedFlags.None);

        // Assert
        Assert.False(continuationCalled, "Continuation should have been called");

        // Act
        sink.SetResult(expectedResult);

        // Assert
        Assert.Equal(expectedResult, sink.GetResult(0));
        Assert.Equal(ValueTaskSourceStatus.Succeeded, sink.GetStatus(0));
        Assert.True(continuationCalled, "Continuation should have been called");
    }
}


===== Runtime\InProcess.Tests\SendMessageTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Threading.Tasks;
using FluentAssertions;
using Xunit;

namespace Microsoft.SemanticKernel.Agents.Runtime.InProcess.Tests;

[Trait("Category", "Unit")]
public class SendMessageTests
{
    [Fact]
    public async Task Test_SendMessage_ReturnsValue()
    {
        static string ProcessFunc(string s) => $"Processed({s})";

        MessagingTestFixture fixture = new();

        await fixture.RegisterFactoryMapInstances(nameof(ProcessorAgent),
            (id, runtime) => ValueTask.FromResult(new ProcessorAgent(id, runtime, ProcessFunc, string.Empty)));

        AgentId targetAgent = new(nameof(ProcessorAgent), Guid.NewGuid().ToString());
        object? maybeResult = await fixture.RunSendTestAsync(targetAgent, new BasicMessage { Content = "1" });

        maybeResult.Should().NotBeNull()
            .And.BeOfType<BasicMessage>()
            .And.Match<BasicMessage>(m => m.Content == "Processed(1)");
    }

    [Fact]
    public async Task Test_SendMessage_Cancellation()
    {
        MessagingTestFixture fixture = new();

        await fixture.RegisterFactoryMapInstances(nameof(CancelAgent),
            (id, runtime) => ValueTask.FromResult(new CancelAgent(id, runtime, string.Empty)));

        AgentId targetAgent = new(nameof(CancelAgent), Guid.NewGuid().ToString());
        Func<Task> testAction = () => fixture.RunSendTestAsync(targetAgent, new BasicMessage { Content = "1" }).AsTask();

        await testAction.Should().ThrowAsync<OperationCanceledException>();
    }

    [Fact]
    public async Task Test_SendMessage_Error()
    {
        MessagingTestFixture fixture = new();

        await fixture.RegisterFactoryMapInstances(nameof(ErrorAgent),
            (id, runtime) => ValueTask.FromResult(new ErrorAgent(id, runtime, string.Empty)));

        AgentId targetAgent = new(nameof(ErrorAgent), Guid.NewGuid().ToString());
        Func<Task> testAction = () => fixture.RunSendTestAsync(targetAgent, new BasicMessage { Content = "1" }).AsTask();

        await testAction.Should().ThrowAsync<TestException>();
    }

    [Fact]
    public async Task Test_SendMessage_FromSendMessageHandler()
    {
        Guid[] targetGuids = [Guid.NewGuid(), Guid.NewGuid()];

        MessagingTestFixture fixture = new();

        Dictionary<AgentId, SendOnAgent> sendAgents = fixture.GetAgentInstances<SendOnAgent>();
        Dictionary<AgentId, ReceiverAgent> receiverAgents = fixture.GetAgentInstances<ReceiverAgent>();

        await fixture.RegisterFactoryMapInstances(nameof(SendOnAgent),
            (id, runtime) => ValueTask.FromResult(new SendOnAgent(id, runtime, string.Empty, targetGuids)));

        await fixture.RegisterFactoryMapInstances(nameof(ReceiverAgent),
            (id, runtime) => ValueTask.FromResult(new ReceiverAgent(id, runtime, string.Empty)));

        AgentId targetAgent = new(nameof(SendOnAgent), Guid.NewGuid().ToString());
        BasicMessage input = new() { Content = "Hello" };
        Task testTask = fixture.RunSendTestAsync(targetAgent, input).AsTask();

        // We do not actually expect to wait the timeout here, but it is still better than waiting the 10 min
        // timeout that the tests default to. A failure will fail regardless of what timeout value we set.
        TimeSpan timeout = Debugger.IsAttached ? TimeSpan.FromSeconds(120) : TimeSpan.FromSeconds(10);
        Task timeoutTask = Task.Delay(timeout);

        Task completedTask = await Task.WhenAny([testTask, timeoutTask]);
        completedTask.Should().Be(testTask, "SendOnAgent should complete before timeout");

        // Check that each of the target agents received the message
        foreach (Guid targetKey in targetGuids)
        {
            AgentId targetId = new(nameof(ReceiverAgent), targetKey.ToString());
            receiverAgents[targetId].Messages.Should().ContainSingle(m => m.Content == $"@{targetKey}: {input.Content}");
        }
    }
}


===== Runtime\InProcess.Tests\TestAgents.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Threading.Tasks;
using Microsoft.SemanticKernel.Agents.Runtime.Core;

namespace Microsoft.SemanticKernel.Agents.Runtime.InProcess.Tests;

public abstract class TestAgent : BaseAgent
{
    internal List<object> ReceivedMessages = [];

    protected TestAgent(AgentId id, IAgentRuntime runtime, string description)
        : base(id, runtime, description)
    {
    }
}

/// <summary>
/// A test agent that captures the messages it receives and
/// is able to save and load its state.
/// </summary>
public sealed class MockAgent : TestAgent, IHandle<string>
{
    public MockAgent(AgentId id, IAgentRuntime runtime, string description)
        : base(id, runtime, description) { }

    public ValueTask HandleAsync(string item, MessageContext messageContext)
    {
        this.ReceivedMessages.Add(item);
        return ValueTask.CompletedTask;
    }

    public override ValueTask<JsonElement> SaveStateAsync()
    {
        JsonElement json = JsonSerializer.SerializeToElement(this.ReceivedMessages);
        return ValueTask.FromResult(json);
    }

    public override ValueTask LoadStateAsync(JsonElement state)
    {
        this.ReceivedMessages = JsonSerializer.Deserialize<List<object>>(state) ?? throw new InvalidOperationException("Failed to deserialize state");
        return ValueTask.CompletedTask;
    }
}


===== Runtime\InProcess.Tests\TestSubscription.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Diagnostics.CodeAnalysis;

namespace Microsoft.SemanticKernel.Agents.Runtime.InProcess.Tests;

public class TestSubscription(string topicType, string agentType, string? id = null) : ISubscriptionDefinition
{
    public string Id { get; } = id ?? Guid.NewGuid().ToString();

    public string TopicType { get; } = topicType;

    public AgentId MapToAgent(TopicId topic)
    {
        if (!this.Matches(topic))
        {
            throw new InvalidOperationException("TopicId does not match the subscription.");
        }

        return new AgentId(agentType, topic.Source);
    }

    public bool Equals(ISubscriptionDefinition? other) => this.Id == other?.Id;

    public override bool Equals([NotNullWhen(true)] object? obj) => obj is TestSubscription other && other.Equals(this);

    public override int GetHashCode() => this.Id.GetHashCode();

    public bool Matches(TopicId topic)
    {
        return topic.Type == this.TopicType;
    }
}


===== Runtime\InProcess\InProcessRuntime.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;

namespace Microsoft.SemanticKernel.Agents.Runtime.InProcess;

/// <summary>
/// Provides an in-process/in-memory implementation of the agent runtime.
/// </summary>
public sealed class InProcessRuntime : IAgentRuntime, IAsyncDisposable
{
    private readonly Dictionary<AgentType, Func<AgentId, IAgentRuntime, ValueTask<IHostableAgent>>> _agentFactories = [];
    private readonly Dictionary<string, ISubscriptionDefinition> _subscriptions = [];
    private readonly ConcurrentQueue<MessageDelivery> _messageDeliveryQueue = new();

    private CancellationTokenSource? _shutdownSource;
    private CancellationTokenSource? _finishSource;
    private Task _messageDeliveryTask = Task.CompletedTask;
    private Func<bool> _shouldContinue = () => true;

    // Exposed for testing purposes.
    internal int messageQueueCount;
    internal readonly Dictionary<AgentId, IHostableAgent> agentInstances = [];

    /// <summary>
    /// Gets or sets a value indicating whether agents should receive messages they send themselves.
    /// </summary>
    public bool DeliverToSelf { get; set; } //= false;

    /// <inheritdoc/>
    public async ValueTask DisposeAsync()
    {
        await this.RunUntilIdleAsync().ConfigureAwait(false);
        this._shutdownSource?.Dispose();
        this._finishSource?.Dispose();
    }

    /// <summary>
    /// Starts the runtime service.
    /// </summary>
    /// <param name="cancellationToken">Token to monitor for shutdown requests.</param>
    /// <returns>A task representing the asynchronous operation.</returns>
    /// <exception cref="InvalidOperationException">Thrown if the runtime is already started.</exception>
    public Task StartAsync(CancellationToken cancellationToken = default)
    {
        if (this._shutdownSource != null)
        {
            throw new InvalidOperationException("Runtime is already running.");
        }

        this._shutdownSource = new CancellationTokenSource();
        this._messageDeliveryTask = Task.Run(() => this.RunAsync(this._shutdownSource.Token), cancellationToken);

        return Task.CompletedTask;
    }

    /// <summary>
    /// Stops the runtime service.
    /// </summary>
    /// <param name="cancellationToken">Token to propagate when stopping the runtime.</param>
    /// <returns>A task representing the asynchronous operation.</returns>
    /// <exception cref="InvalidOperationException">Thrown if the runtime is in the process of stopping.</exception>
    public Task StopAsync(CancellationToken cancellationToken = default)
    {
        if (this._shutdownSource != null)
        {
            if (this._finishSource != null)
            {
                throw new InvalidOperationException("Runtime is already stopping.");
            }

            this._finishSource = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);

            this._shutdownSource.Cancel();
        }

        return Task.CompletedTask;
    }

    /// <summary>
    /// This will run until the message queue is empty and then stop the runtime.
    /// </summary>
    public async Task RunUntilIdleAsync()
    {
        Func<bool> oldShouldContinue = this._shouldContinue;
        this._shouldContinue = () => !this._messageDeliveryQueue.IsEmpty;

        // TODO: Do we want detach semantics?
        await this._messageDeliveryTask.ConfigureAwait(false);

        this._shouldContinue = oldShouldContinue;
    }

    /// <inheritdoc/>
    public ValueTask PublishMessageAsync(object message, TopicId topic, AgentId? sender = null, string? messageId = null, CancellationToken cancellationToken = default)
    {
        return this.ExecuteTracedAsync(() =>
        {
            MessageDelivery delivery =
                new MessageEnvelope(message, messageId, cancellationToken)
                    .WithSender(sender)
                    .ForPublish(topic, this.PublishMessageServicerAsync);

            this._messageDeliveryQueue.Enqueue(delivery);
            Interlocked.Increment(ref this.messageQueueCount);

#if !NETCOREAPP
            return Task.CompletedTask.AsValueTask();
#else
            return ValueTask.CompletedTask;
#endif
        });
    }

    /// <inheritdoc/>
    public async ValueTask<object?> SendMessageAsync(object message, AgentId recipient, AgentId? sender = null, string? messageId = null, CancellationToken cancellationToken = default)
    {
        return await this.ExecuteTracedAsync(async () =>
        {
            MessageDelivery delivery =
                new MessageEnvelope(message, messageId, cancellationToken)
                    .WithSender(sender)
                    .ForSend(recipient, this.SendMessageServicerAsync);

            this._messageDeliveryQueue.Enqueue(delivery);
            Interlocked.Increment(ref this.messageQueueCount);

            try
            {
                return await delivery.ResultSink.Future.ConfigureAwait(false);
            }
            catch (TargetInvocationException ex) when (ex.InnerException is OperationCanceledException innerOCEx)
            {
                throw new OperationCanceledException($"Delivery of message {messageId} was cancelled.", innerOCEx);
            }
        }).ConfigureAwait(false);
    }

    /// <inheritdoc/>
    public async ValueTask<AgentId> GetAgentAsync(AgentId agentId, bool lazy = true)
    {
        if (!lazy)
        {
            await this.EnsureAgentAsync(agentId).ConfigureAwait(false);
        }

        return agentId;
    }

    /// <inheritdoc/>
    public ValueTask<AgentId> GetAgentAsync(AgentType agentType, string key = AgentId.DefaultKey, bool lazy = true)
        => this.GetAgentAsync(new AgentId(agentType, key), lazy);

    /// <inheritdoc/>
    public ValueTask<AgentId> GetAgentAsync(string agent, string key = AgentId.DefaultKey, bool lazy = true)
        => this.GetAgentAsync(new AgentId(agent, key), lazy);

    /// <inheritdoc/>
    public async ValueTask<AgentMetadata> GetAgentMetadataAsync(AgentId agentId)
    {
        IHostableAgent agent = await this.EnsureAgentAsync(agentId).ConfigureAwait(false);
        return agent.Metadata;
    }

    /// <inheritdoc/>
    public async ValueTask<TAgent> TryGetUnderlyingAgentInstanceAsync<TAgent>(AgentId agentId) where TAgent : IHostableAgent
    {
        IHostableAgent agent = await this.EnsureAgentAsync(agentId).ConfigureAwait(false);

        if (agent is not TAgent concreteAgent)
        {
            throw new InvalidOperationException($"Agent with name {agentId.Type} is not of type {typeof(TAgent).Name}.");
        }

        return concreteAgent;
    }

    /// <inheritdoc/>
    public async ValueTask LoadAgentStateAsync(AgentId agentId, JsonElement state)
    {
        IHostableAgent agent = await this.EnsureAgentAsync(agentId).ConfigureAwait(false);
        await agent.LoadStateAsync(state).ConfigureAwait(false);
    }

    /// <inheritdoc/>
    public async ValueTask<JsonElement> SaveAgentStateAsync(AgentId agentId)
    {
        IHostableAgent agent = await this.EnsureAgentAsync(agentId).ConfigureAwait(false);
        return await agent.SaveStateAsync().ConfigureAwait(false);
    }

    /// <inheritdoc/>
    public ValueTask AddSubscriptionAsync(ISubscriptionDefinition subscription)
    {
        if (this._subscriptions.ContainsKey(subscription.Id))
        {
            throw new InvalidOperationException($"Subscription with id {subscription.Id} already exists.");
        }

        this._subscriptions.Add(subscription.Id, subscription);

#if !NETCOREAPP
        return Task.CompletedTask.AsValueTask();
#else
        return ValueTask.CompletedTask;
#endif
    }

    /// <inheritdoc/>
    public ValueTask RemoveSubscriptionAsync(string subscriptionId)
    {
        if (!this._subscriptions.ContainsKey(subscriptionId))
        {
            throw new InvalidOperationException($"Subscription with id {subscriptionId} does not exist.");
        }

        this._subscriptions.Remove(subscriptionId);

#if !NETCOREAPP
        return Task.CompletedTask.AsValueTask();
#else
        return ValueTask.CompletedTask;
#endif
    }

    /// <inheritdoc/>
    public async ValueTask LoadStateAsync(JsonElement state)
    {
        foreach (JsonProperty agentIdStr in state.EnumerateObject())
        {
            AgentId agentId = AgentId.FromStr(agentIdStr.Name);

            if (this._agentFactories.ContainsKey(agentId.Type))
            {
                IHostableAgent agent = await this.EnsureAgentAsync(agentId).ConfigureAwait(false);
                await agent.LoadStateAsync(agentIdStr.Value).ConfigureAwait(false);
            }
        }
    }

    /// <inheritdoc/>
    public async ValueTask<JsonElement> SaveStateAsync()
    {
        Dictionary<string, JsonElement> state = [];
        foreach (AgentId agentId in this.agentInstances.Keys)
        {
            JsonElement agentState = await this.agentInstances[agentId].SaveStateAsync().ConfigureAwait(false);
            state[agentId.ToString()] = agentState;
        }
        return JsonSerializer.SerializeToElement(state);
    }

    /// <summary>
    /// Registers an agent factory with the runtime, associating it with a specific agent type.
    /// </summary>
    /// <typeparam name="TAgent">The type of agent created by the factory.</typeparam>
    /// <param name="type">The agent type to associate with the factory.</param>
    /// <param name="factoryFunc">A function that asynchronously creates the agent instance.</param>
    /// <returns>A task representing the asynchronous operation, returning the registered agent type.</returns>
    public ValueTask<AgentType> RegisterAgentFactoryAsync<TAgent>(AgentType type, Func<AgentId, IAgentRuntime, ValueTask<TAgent>> factoryFunc) where TAgent : IHostableAgent
        // Declare the lambda return type explicitly, as otherwise the compiler will infer 'ValueTask<TAgent>'
        // and recurse into the same call, causing a stack overflow.
        => this.RegisterAgentFactoryAsync(type, async ValueTask<IHostableAgent> (agentId, runtime) => await factoryFunc(agentId, runtime).ConfigureAwait(false));

    /// <inheritdoc/>
    public ValueTask<AgentType> RegisterAgentFactoryAsync(AgentType type, Func<AgentId, IAgentRuntime, ValueTask<IHostableAgent>> factoryFunc)
    {
        if (this._agentFactories.ContainsKey(type))
        {
            throw new InvalidOperationException($"Agent with type {type} already exists.");
        }

        this._agentFactories.Add(type, factoryFunc);

#if !NETCOREAPP
        return type.AsValueTask();
#else
        return ValueTask.FromResult(type);
#endif
    }

    /// <inheritdoc/>
    public ValueTask<AgentProxy> TryGetAgentProxyAsync(AgentId agentId)
    {
        AgentProxy proxy = new(agentId, this);

#if !NETCOREAPP
        return proxy.AsValueTask();
#else
        return ValueTask.FromResult(proxy);
#endif
    }

    private ValueTask ProcessNextMessageAsync(CancellationToken cancellation = default)
    {
        if (this._messageDeliveryQueue.TryDequeue(out MessageDelivery? delivery))
        {
            Interlocked.Decrement(ref this.messageQueueCount);
            Debug.WriteLine($"Processing message {delivery.Message.MessageId}...");
            return delivery.InvokeAsync(cancellation);
        }

#if !NETCOREAPP
        return Task.CompletedTask.AsValueTask();
#else
        return ValueTask.CompletedTask;
#endif
    }

    private async Task RunAsync(CancellationToken cancellation)
    {
        Dictionary<Guid, Task> pendingTasks = [];
        while (!cancellation.IsCancellationRequested && this._shouldContinue())
        {
            // Get a unique task id
            Guid taskId;
            do
            {
                taskId = Guid.NewGuid();
            } while (pendingTasks.ContainsKey(taskId));

            // There is potentially a race condition here, but even if we leak a Task, we will
            // still catch it on the Finish() pass.
            ValueTask processTask = this.ProcessNextMessageAsync(cancellation);
            await Task.Yield();

            // Check if the task is already completed
            if (processTask.IsCompleted)
            {
                continue;
            }

            Task actualTask = processTask.AsTask();
            pendingTasks.Add(taskId, actualTask.ContinueWith(t => pendingTasks.Remove(taskId), TaskScheduler.Current));
        }

        // The pending task dictionary may contain null values when a race condition is experienced during
        // the prior "ContinueWith" call.  This could be solved with a ConcurrentDictionary, but locking
        // is entirely undesirable in this context.
        await Task.WhenAll([.. pendingTasks.Values.Where(task => task is not null)]).ConfigureAwait(false);
        await this.FinishAsync(this._finishSource?.Token ?? CancellationToken.None).ConfigureAwait(false);
    }

    private async ValueTask PublishMessageServicerAsync(MessageEnvelope envelope, CancellationToken deliveryToken)
    {
        if (!envelope.Topic.HasValue)
        {
            throw new InvalidOperationException("Message must have a topic to be published.");
        }

        List<Task>? tasks = null;
        TopicId topic = envelope.Topic.Value;
        foreach (ISubscriptionDefinition subscription in this._subscriptions.Values.Where(subscription => subscription.Matches(topic)))
        {
            (tasks ??= []).Add(ProcessSubscriptionAsync(envelope, topic, subscription, deliveryToken));
        }

        if (tasks is not null)
        {
            await Task.WhenAll(tasks).ConfigureAwait(false);
        }

        async Task ProcessSubscriptionAsync(MessageEnvelope envelope, TopicId topic, ISubscriptionDefinition subscription, CancellationToken deliveryToken)
        {
            deliveryToken.ThrowIfCancellationRequested();

            AgentId? sender = envelope.Sender;

            using CancellationTokenSource combinedSource = CancellationTokenSource.CreateLinkedTokenSource(envelope.Cancellation, deliveryToken);
            MessageContext messageContext = new(envelope.MessageId, combinedSource.Token)
            {
                Sender = sender,
                Topic = topic,
                IsRpc = false
            };

            AgentId agentId = subscription.MapToAgent(topic);
            if (!this.DeliverToSelf && sender.HasValue && sender == agentId)
            {
                return;
            }

            IHostableAgent agent = await this.EnsureAgentAsync(agentId).ConfigureAwait(false);

            await agent.OnMessageAsync(envelope.Message, messageContext).ConfigureAwait(false);
        }
    }

    private async ValueTask<object?> SendMessageServicerAsync(MessageEnvelope envelope, CancellationToken deliveryToken)
    {
        if (!envelope.Receiver.HasValue)
        {
            throw new InvalidOperationException("Message must have a receiver to be sent.");
        }

        using CancellationTokenSource combinedSource = CancellationTokenSource.CreateLinkedTokenSource(envelope.Cancellation, deliveryToken);
        MessageContext messageContext = new(envelope.MessageId, combinedSource.Token)
        {
            Sender = envelope.Sender,
            IsRpc = false
        };

        AgentId receiver = envelope.Receiver.Value;
        IHostableAgent agent = await this.EnsureAgentAsync(receiver).ConfigureAwait(false);

        return await agent.OnMessageAsync(envelope.Message, messageContext).ConfigureAwait(false);
    }

    private async ValueTask<IHostableAgent> EnsureAgentAsync(AgentId agentId)
    {
        if (!this.agentInstances.TryGetValue(agentId, out IHostableAgent? agent))
        {
            if (!this._agentFactories.TryGetValue(agentId.Type, out Func<AgentId, IAgentRuntime, ValueTask<IHostableAgent>>? factoryFunc))
            {
                throw new InvalidOperationException($"Agent with name {agentId.Type} not found.");
            }

            agent = await factoryFunc(agentId, this).ConfigureAwait(false);
            this.agentInstances.Add(agentId, agent);
        }

        return this.agentInstances[agentId];
    }

    private async Task FinishAsync(CancellationToken token)
    {
        foreach (IHostableAgent agent in this.agentInstances.Values)
        {
            if (!token.IsCancellationRequested)
            {
                await agent.CloseAsync().ConfigureAwait(false);
            }
        }

        this._shutdownSource?.Dispose();
        this._finishSource?.Dispose();
        this._finishSource = null;
        this._shutdownSource = null;
    }

#pragma warning disable CA1822 // Mark members as static
    private ValueTask<T> ExecuteTracedAsync<T>(Func<ValueTask<T>> func)
#pragma warning restore CA1822 // Mark members as static
    {
        // TODO: Bind tracing
        return func();
    }

#pragma warning disable CA1822 // Mark members as static
    private ValueTask ExecuteTracedAsync(Func<ValueTask> func)
#pragma warning restore CA1822 // Mark members as static
    {
        // TODO: Bind tracing
        return func();
    }
}


===== Runtime\InProcess\MessageDelivery.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Threading;
using System.Threading.Tasks;

namespace Microsoft.SemanticKernel.Agents.Runtime.InProcess;

internal sealed class MessageDelivery(MessageEnvelope message, Func<MessageEnvelope, CancellationToken, ValueTask> servicer, IResultSink<object?> resultSink)
{
    public MessageEnvelope Message { get; } = message;
    public Func<MessageEnvelope, CancellationToken, ValueTask> Servicer { get; } = servicer;
    public IResultSink<object?> ResultSink { get; } = resultSink;

    public ValueTask InvokeAsync(CancellationToken cancellation)
    {
        return this.Servicer(this.Message, cancellation);
    }
}


===== Runtime\InProcess\MessageEnvelope.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Threading;
using System.Threading.Tasks;

namespace Microsoft.SemanticKernel.Agents.Runtime.InProcess;

internal sealed class MessageEnvelope
{
    public object Message { get; }
    public string MessageId { get; }
    public TopicId? Topic { get; private set; }
    public AgentId? Sender { get; private set; }
    public AgentId? Receiver { get; private set; }
    public CancellationToken Cancellation { get; }

    public MessageEnvelope(object message, string? messageId = null, CancellationToken cancellation = default)
    {
        this.Message = message;
        this.MessageId = messageId ?? Guid.NewGuid().ToString();
        this.Cancellation = cancellation;
    }

    public MessageEnvelope WithSender(AgentId? sender)
    {
        this.Sender = sender;
        return this;
    }

    public MessageDelivery ForSend(AgentId receiver, Func<MessageEnvelope, CancellationToken, ValueTask<object?>> servicer)
    {
        this.Receiver = receiver;

        ResultSink<object?> resultSink = new();

        return new MessageDelivery(this, BoundServicer, resultSink);

        async ValueTask BoundServicer(MessageEnvelope envelope, CancellationToken cancellation)
        {
            try
            {
                object? result = await servicer(envelope, cancellation).ConfigureAwait(false);
                resultSink.SetResult(result);
            }
            catch (OperationCanceledException exception)
            {
                resultSink.SetCancelled(exception);
            }
            catch (Exception exception) when (!exception.IsCriticalException())
            {
                resultSink.SetException(exception);
            }
        }
    }

    public MessageDelivery ForPublish(TopicId topic, Func<MessageEnvelope, CancellationToken, ValueTask> servicer)
    {
        this.Topic = topic;

        ResultSink<object?> waitForPublish = new();

        async ValueTask BoundServicer(MessageEnvelope envelope, CancellationToken cancellation)
        {
            try
            {
                await servicer(envelope, cancellation).ConfigureAwait(false);
                waitForPublish.SetResult(null);
            }
            catch (Exception ex) when (!ex.IsCriticalException())
            {
                waitForPublish.SetException(ex);
            }
        }

        return new MessageDelivery(this, BoundServicer, waitForPublish);
    }
}


===== Runtime\InProcess\ResultSink.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Threading.Tasks;
using System.Threading.Tasks.Sources;

namespace Microsoft.SemanticKernel.Agents.Runtime.InProcess;

internal interface IResultSink<TResult> : IValueTaskSource<TResult>
{
    void SetResult(TResult result);
    void SetException(Exception exception);
    void SetCancelled(OperationCanceledException? exception = null);

    ValueTask<TResult> Future { get; }
}

internal sealed class ResultSink<TResult> : IResultSink<TResult>
{
    private ManualResetValueTaskSourceCore<TResult> _core;

    public bool IsCancelled { get; private set; }

    public TResult GetResult(short token)
    {
        return this._core.GetResult(token);
    }

    public ValueTaskSourceStatus GetStatus(short token)
    {
        return this._core.GetStatus(token);
    }

    public void OnCompleted(Action<object?> continuation, object? state, short token, ValueTaskSourceOnCompletedFlags flags)
    {
        this._core.OnCompleted(continuation, state, token, flags);
    }

    public void SetCancelled(OperationCanceledException? exception = null)
    {
        this.IsCancelled = true;
        this._core.SetException(exception ?? new OperationCanceledException());
    }

    public void SetException(Exception exception)
    {
        this._core.SetException(exception);
    }

    public void SetResult(TResult result)
    {
        this._core.SetResult(result);
    }

    public ValueTask<TResult> Future => new(this, this._core.Version);
}


===== UnitTests\A2A\A2AAgentExtensionsTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Net.Http;
using System.Text.Json;
using A2A;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.Agents.A2A;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.A2A;

public sealed class A2AAgentExtensionsTests
{
    [Fact]
    public void AsAIAgent_WithValidA2AAgent_ReturnsSemanticKernelAIAgent()
    {
        // Arrange
        using var httpClient = new HttpClient();
        var a2aClient = new A2AClient(new Uri("http://testservice", UriKind.Absolute), httpClient);
        var agentCard = new AgentCard();
        var a2aAgent = new A2AAgent(a2aClient, agentCard);

        // Act
        var result = a2aAgent.AsAIAgent();

        // Assert
        Assert.NotNull(result);
        Assert.IsType<SemanticKernelAIAgent>(result);
    }

    [Fact]
    public void AsAIAgent_WithNullA2AAgent_ThrowsArgumentNullException()
    {
        // Arrange
        A2AAgent nullAgent = null!;

        // Act & Assert
        Assert.Throws<ArgumentNullException>(() => nullAgent.AsAIAgent());
    }

    [Fact]
    public void AsAIAgent_CreatesWorkingThreadFactory()
    {
        // Arrange
        using var httpClient = new HttpClient();
        var a2aClient = new A2AClient(new Uri("http://testservice", UriKind.Absolute), httpClient);
        var agentCard = new AgentCard();
        var a2aAgent = new A2AAgent(a2aClient, agentCard);

        // Act
        var result = a2aAgent.AsAIAgent();
        var thread = result.GetNewThread();

        // Assert
        Assert.NotNull(thread);
        Assert.IsType<SemanticKernelAIAgentThread>(thread);
        var threadAdapter = (SemanticKernelAIAgentThread)thread;
        Assert.IsType<A2AAgentThread>(threadAdapter.InnerThread);
    }

    [Fact]
    public void AsAIAgent_ThreadDeserializationFactory_WithNullAgentId_CreatesNewThread()
    {
        // Arrange
        using var httpClient = new HttpClient();
        var a2aClient = new A2AClient(new Uri("http://testservice", UriKind.Absolute), httpClient);
        var agentCard = new AgentCard();
        var a2aAgent = new A2AAgent(a2aClient, agentCard);
        var jsonElement = JsonSerializer.SerializeToElement((string?)null);

        // Act
        var result = a2aAgent.AsAIAgent();
        var thread = result.DeserializeThread(jsonElement);

        // Assert
        Assert.NotNull(thread);
        Assert.IsType<SemanticKernelAIAgentThread>(thread);
        var threadAdapter = (SemanticKernelAIAgentThread)thread;
        Assert.IsType<A2AAgentThread>(threadAdapter.InnerThread);
    }

    [Fact]
    public void AsAIAgent_ThreadDeserializationFactory_WithValidAgentId_CreatesThreadWithId()
    {
        // Arrange
        using var httpClient = new HttpClient();
        var a2aClient = new A2AClient(new Uri("http://testservice", UriKind.Absolute), httpClient);
        var agentCard = new AgentCard();
        var a2aAgent = new A2AAgent(a2aClient, agentCard);
        var threadId = "test-agent-id";
        var jsonElement = JsonSerializer.SerializeToElement(threadId);

        // Act
        var result = a2aAgent.AsAIAgent();
        var thread = result.DeserializeThread(jsonElement);

        // Assert
        Assert.NotNull(thread);
        Assert.IsType<SemanticKernelAIAgentThread>(thread);
        var threadAdapter = (SemanticKernelAIAgentThread)thread;
        Assert.IsType<A2AAgentThread>(threadAdapter.InnerThread);
        Assert.Equal(threadId, threadAdapter.InnerThread.Id);
    }

    [Fact]
    public void AsAIAgent_ThreadSerializer_SerializesThreadId()
    {
        // Arrange
        using var httpClient = new HttpClient();
        var a2aClient = new A2AClient(new Uri("http://testservice", UriKind.Absolute), httpClient);
        var agentCard = new AgentCard();
        var a2aAgent = new A2AAgent(a2aClient, agentCard);
        var expectedThreadId = "test-thread-id";
        var a2aThread = new A2AAgentThread(a2aClient, expectedThreadId);
        var jsonElement = JsonSerializer.SerializeToElement(expectedThreadId);

        var result = a2aAgent.AsAIAgent();
        var thread = result.DeserializeThread(jsonElement);

        // Act
        var serializedElement = thread.Serialize();

        // Assert
        Assert.Equal(JsonValueKind.String, serializedElement.ValueKind);
        Assert.Equal(expectedThreadId, serializedElement.GetString());
    }
}


===== UnitTests\A2A\A2AAgentTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Linq;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.Agents.A2A;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.A2A;

/// <summary>
/// Tests for the <see cref="A2AAgent"/> class.
/// </summary>
public sealed class A2AAgentTests : BaseA2AClientTest
{
    /// <summary>
    /// Tests that the constructor verifies parameters and throws <see cref="ArgumentNullException"/> when necessary.
    /// </summary>
    [Fact]
    public void ConstructorShouldVerifyParams()
    {
        using var httpClient = new HttpClient();

        // Arrange & Act & Assert
        Assert.Throws<ArgumentNullException>(() => new A2AAgent(null!, new()));
        Assert.Throws<ArgumentNullException>(() => new A2AAgent(this.Client, null!));
    }

    [Fact]
    public async Task VerifyConstructor()
    {
        // Arrange & Act
        var agent = new A2AAgent(this.Client, await this.CreateAgentCardAsync());

        // Assert
        Assert.NotNull(agent);
        Assert.Equal("InvoiceAgent", agent.Name);
        Assert.Equal("Handles requests relating to invoices.", agent.Description);
    }

    [Fact]
    public async Task VerifyInvokeAsync()
    {
        // Arrange
        this.MessageHandlerStub.ResponsesToReturn.Add(
            new HttpResponseMessage(System.Net.HttpStatusCode.OK) { Content = new StringContent(InvokeResponse, Encoding.UTF8, "application/json") }
        );
        var agent = new A2AAgent(this.Client, await this.CreateAgentCardAsync());

        // Act
        var responseItems = agent.InvokeAsync("List the latest invoices for Contoso?");

        // Assert
        Assert.NotNull(responseItems);
        var items = await responseItems!.ToListAsync<AgentResponseItem<ChatMessageContent>>();
        Assert.Single(items);
        Assert.StartsWith("Here are the latest invoices for Contoso:", items[0].Message.Content);
    }

    [Fact]
    public async Task VerifyInvokeStreamingAsync()
    {
        // Arrange
        this.MessageHandlerStub.ResponsesToReturn.Add(
            new HttpResponseMessage(System.Net.HttpStatusCode.OK) { Content = new StringContent(InvokeResponse, Encoding.UTF8, "application/json") }
        );
        var agent = new A2AAgent(this.Client, await this.CreateAgentCardAsync());

        // Act
        var responseItems = agent.InvokeStreamingAsync("List the latest invoices for Contoso?");

        // Assert
        Assert.NotNull(responseItems);
        var items = await responseItems!.ToListAsync<AgentResponseItem<StreamingChatMessageContent>>();
        Assert.Single(items);
        Assert.StartsWith("Here are the latest invoices for Contoso:", items[0].Message.Content);
    }

    #region private
    private const string InvokeResponse =
        """
        {
            "jsonrpc": "2.0",
            "id": "ce7a5ef6-1078-4b6e-ad35-a8bfa6743c5d",
            "result": {
                "kind": "task",
                "id": "8d328159-ca63-4ce8-b416-4bcf69f9e119",
                "contextId": "496a4a95-392b-4c04-a517-9a043b3f7565",
                "status": {
                    "state": "completed",
                    "timestamp": "2025-06-20T09:42:49.4013958Z"
                },
                "artifacts": [
                    {
                        "artifactId": "",
                        "parts": [
                            {
                                "kind": "text",
                                "text": "Here are the latest invoices for Contoso:\n\n1. Invoice ID: INV789, Date: 2025-06-18\n   Products: T-Shirts (150 units at $10.00), Hats (200 units at $15.00), Glasses (300 units at $5.00)\n\n2. Invoice ID: INV666, Date: 2025-06-15\n   Products: T-Shirts (2500 units at $8.00), Hats (1200 units at $10.00), Glasses (1000 units at $6.00)\n\n3. Invoice ID: INV999, Date: 2025-05-17\n   Products: T-Shirts (1400 units at $10.50), Hats (1100 units at $9.00), Glasses (950 units at $12.00)\n\n4. Invoice ID: INV333, Date: 2025-05-13\n   Products: T-Shirts (400 units at $11.00), Hats (600 units at $15.00), Glasses (700 units at $5.00)\n\nIf you need more details on any specific invoice, please let me know!"
                            }
                        ]
                    }
                ],
                "history": [
                    {
                        "kind": "message",
                        "role": "user",
                        "parts": [
                            {
                                "kind": "text",
                                "text": "List the latest invoices for Contoso?"
                            }
                        ],
                        "messageId": "80a26c0f-2262-4d0f-8e7d-51ac4046173b"
                    }
                ]
            }
        }
        """;
    #endregion
}


===== UnitTests\A2A\A2AHostAgentTests.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using A2A;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.Agents.A2A;
using Microsoft.SemanticKernel.ChatCompletion;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.A2A;

/// <summary>
/// Tests for the <see cref="A2AHostAgent"/> class.
/// </summary>
public sealed class A2AHostAgentTests : BaseA2AClientTest
{
    /// <summary>
    /// Tests that the constructor verifies parameters and throws <see cref="ArgumentNullException"/> when necessary.
    /// </summary>
    [Fact]
    public async Task ConstructorShouldVerifyParams()
    {
        // Arrange & Act & Assert
        var agentCard = await this.CreateAgentCardAsync();
        Assert.Throws<ArgumentNullException>(() => new A2AHostAgent(null!, agentCard));
        Assert.Throws<ArgumentNullException>(() => new A2AHostAgent(new MockAgent(), null!));
    }

    [Fact]
    public async Task VerifyExecuteAgentTaskAsync()
    {
        // Arrange
        var agentCard = await this.CreateAgentCardAsync();
        var agent = new MockAgent();
        var taskManager = new TaskManager();
        var hostAgent = new A2AHostAgent(agent, agentCard, taskManager);

        // Act
        var agentTask = await taskManager.CreateTaskAsync();
        agentTask.History = this.CreateUserMessages(["Hello"]);
        await hostAgent.ExecuteAgentTaskAsync(agentTask);

        // Assert
        Assert.NotNull(agentTask);
        Assert.NotNull(agentTask.Artifacts);
        Assert.Single(agentTask.Artifacts);
        Assert.NotNull(agentTask.Artifacts[0].Parts);
        Assert.Single(agentTask.Artifacts[0].Parts);
        Assert.Equal("Mock Response", agentTask.Artifacts[0].Parts[0].AsTextPart().Text);
    }

    #region private
    private List<AgentMessage> CreateUserMessages(string[] userMessages)
    {
        var messages = new List<AgentMessage>();

        foreach (var userMessage in userMessages)
        {
            messages.Add(new AgentMessage()
            {
                Role = MessageRole.User,
                Parts = [new TextPart() { Text = userMessage }],
            });
        }

        return messages;
    }
    #endregion
}

internal sealed class MockAgent : Agent
{
    public override async IAsyncEnumerable<AgentResponseItem<ChatMessageContent>> InvokeAsync(ICollection<ChatMessageContent> messages, AgentThread? thread = null, AgentInvokeOptions? options = null, [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        await Task.Delay(100, cancellationToken);

        yield return new AgentResponseItem<ChatMessageContent>(new ChatMessageContent(AuthorRole.Assistant, "Mock Response"), thread ?? new MockAgentThread());
    }

    public override async IAsyncEnumerable<AgentResponseItem<StreamingChatMessageContent>> InvokeStreamingAsync(ICollection<ChatMessageContent> messages, AgentThread? thread = null, AgentInvokeOptions? options = null, [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        await Task.Delay(100, cancellationToken);

        yield return new AgentResponseItem<StreamingChatMessageContent>(new StreamingChatMessageContent(AuthorRole.Assistant, "Mock Streaming Response"), thread ?? new MockAgentThread());
    }

    protected internal override Task<AgentChannel> CreateChannelAsync(CancellationToken cancellationToken)
    {
        throw new NotImplementedException();
    }

    protected internal override IEnumerable<string> GetChannelKeys()
    {
        throw new NotImplementedException();
    }

    protected internal override Task<AgentChannel> RestoreChannelAsync(string channelState, CancellationToken cancellationToken)
    {
        throw new NotImplementedException();
    }
}

internal sealed class MockAgentThread : AgentThread
{
    protected override Task<string?> CreateInternalAsync(CancellationToken cancellationToken)
    {
        throw new NotImplementedException();
    }

    protected override Task DeleteInternalAsync(CancellationToken cancellationToken)
    {
        throw new NotImplementedException();
    }

    protected override Task OnNewMessageInternalAsync(ChatMessageContent newMessage, CancellationToken cancellationToken = default)
    {
        throw new NotImplementedException();
    }
}


===== UnitTests\A2A\BaseA2AClientTest.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Net.Http;
using System.Threading.Tasks;
using A2A;

namespace SemanticKernel.Agents.UnitTests.A2A;
public class BaseA2AClientTest : IDisposable
{
    internal MultipleHttpMessageHandlerStub MessageHandlerStub { get; }
    internal HttpClient HttpClient { get; }
    internal A2AClient Client { get; }

    internal BaseA2AClientTest()
    {
        this.MessageHandlerStub = new MultipleHttpMessageHandlerStub();
        this.HttpClient = new HttpClient(this.MessageHandlerStub, disposeHandler: false);
        this.Client = new A2AClient(new Uri("http://127.0.0.1/"), this.HttpClient);
    }

    /// <inheritdoc />
    public void Dispose()
    {
        this.MessageHandlerStub.Dispose();
        this.HttpClient.Dispose();

        GC.SuppressFinalize(this);
    }

    protected async Task<AgentCard> CreateAgentCardAsync()
    {
        var capabilities = new AgentCapabilities()
        {
            Streaming = false,
            PushNotifications = false,
        };

        var invoiceQuery = new AgentSkill()
        {
            Id = "id_invoice_agent",
            Name = "InvoiceQuery",
            Description = "Handles requests relating to invoices.",
            Tags = ["invoice", "semantic-kernel"],
            Examples =
            [
                "List the latest invoices for Contoso.",
            ],
        };

        return new AgentCard()
        {
            Name = "InvoiceAgent",
            Description = "Handles requests relating to invoices.",
            Url = "http://127.0.0.1/5000",
            Version = "1.0.0",
            DefaultInputModes = ["text"],
            DefaultOutputModes = ["text"],
            Capabilities = capabilities,
            Skills = [invoiceQuery],
        };
    }
}


===== UnitTests\AgentChannelTests.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Linq;
using System.Threading.Tasks;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents;
using Moq;
using Xunit;

namespace SemanticKernel.Agents.UnitTests;

/// <summary>
/// Unit testing of <see cref="AgentChannel"/>.
/// </summary>
public class AgentChannelTests
{
    /// <summary>
    /// Verify a <see cref="AgentChannel{TAgent}"/> throws if passed
    /// an agent type that does not match declared agent type (TAgent).
    /// </summary>
    [Fact]
    public async Task VerifyAgentChannelUpcastAsync()
    {
        // Arrange
        MockChannel channel = new();
        // Assert
        Assert.Equal(0, channel.InvokeCount);

        // Act
        var messages = await channel.InvokeAgentAsync(new MockAgent()).ToArrayAsync();
        // Assert
        Assert.Equal(1, channel.InvokeCount);

        // Act
        Mock<Agent> mockAgent = new();
        await Assert.ThrowsAsync<KernelException>(() => channel.InvokeAgentAsync(mockAgent.Object).ToArrayAsync().AsTask());
        // Assert
        Assert.Equal(1, channel.InvokeCount);
    }
}


===== UnitTests\AgentChatSerializerTests.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.Agents.Serialization;
using Microsoft.SemanticKernel.ChatCompletion;
using Xunit;

namespace SemanticKernel.Agents.UnitTests;

/// <summary>
/// Unit testing of <see cref="AgentChat"/>.
/// </summary>
public class AgentChatSerializerTests
{
    /// <summary>
    /// Verify serialization cycle for an empty <see cref="AgentChat"/>.
    /// </summary>
    [Fact]
    public async Task VerifySerializedChatEmptyAsync()
    {
        // Create chat
        TestChat chat = new();

        // Serialize and deserialize chat
        AgentChatState chatState = chat.Serialize();
        string jsonState = await this.SerializeChatAsync(chat);
        AgentChatState? restoredState = JsonSerializer.Deserialize<AgentChatState>(jsonState);

        // Validate state
        Assert.Empty(chatState.Participants);
        ChatHistory? chatHistory = JsonSerializer.Deserialize<ChatHistory>(chatState.History);
        Assert.NotNull(chatHistory);
        Assert.Empty(chatHistory);
        Assert.Empty(chatState.Channels);

        Assert.NotNull(restoredState);
        Assert.Empty(restoredState.Participants);
        ChatHistory? restoredHistory = JsonSerializer.Deserialize<ChatHistory>(restoredState.History);
        Assert.NotNull(restoredHistory);
        Assert.Empty(restoredHistory);
        Assert.Empty(restoredState.Channels);
    }

    /// <summary>
    /// Verify serialization cycle for a <see cref="AgentChat"/> with only user message (no channels).
    /// </summary>
    [Fact]
    public async Task VerifySerializedChatWithoutAgentsAsync()
    {
        // Create chat
        TestChat chat = new();
        chat.AddChatMessage(new ChatMessageContent(AuthorRole.User, "test"));

        // Serialize and deserialize chat
        AgentChatState chatState = chat.Serialize();
        string jsonState = await this.SerializeChatAsync(chat);
        AgentChatState? restoredState = JsonSerializer.Deserialize<AgentChatState>(jsonState);

        // Validate state
        Assert.Empty(chatState.Participants);
        ChatHistory? chatHistory = JsonSerializer.Deserialize<ChatHistory>(chatState.History);
        Assert.NotNull(chatHistory);
        Assert.Single(chatHistory);
        Assert.Empty(chatState.Channels);

        Assert.NotNull(restoredState);
        Assert.Empty(restoredState.Participants);
        ChatHistory? restoredHistory = JsonSerializer.Deserialize<ChatHistory>(restoredState.History);
        Assert.NotNull(restoredHistory);
        Assert.Single(restoredHistory);
        Assert.Empty(restoredState.Channels);
    }

    /// <summary>
    /// Verify serialization cycle for a <see cref="AgentChat"/> with history and channels.
    /// </summary>
    [Fact]
    public async Task VerifySerializedChatWithAgentsAsync()
    {
        // Create chat
        TestChat chat = new(CreateMockAgent(), CreateMockAgent());
        chat.AddChatMessage(new ChatMessageContent(AuthorRole.User, "test"));
        ChatMessageContent[] messages = await chat.InvokeAsync().ToArrayAsync();

        // Serialize and deserialize chat
        AgentChatState chatState = chat.Serialize();
        string jsonState = await this.SerializeChatAsync(chat);
        AgentChatState? restoredState = JsonSerializer.Deserialize<AgentChatState>(jsonState);

        // Validate state
        Assert.Equal(2, chatState.Participants.Count());
        ChatHistory? chatHistory = JsonSerializer.Deserialize<ChatHistory>(chatState.History);
        Assert.NotNull(chatHistory);
        Assert.Equal(2, chatHistory.Count);
        Assert.Single(chatState.Channels);

        Assert.NotNull(restoredState);
        Assert.Equal(2, restoredState.Participants.Count());
        ChatHistory? restoredHistory = JsonSerializer.Deserialize<ChatHistory>(restoredState.History);
        Assert.NotNull(restoredHistory);
        Assert.Equal(2, restoredHistory.Count);
        Assert.Single(restoredState.Channels);
    }

    /// <summary>
    /// Verify serialization cycle for a <see cref="AgentChat"/> with a <see cref="AggregatorAgent"/>.
    /// </summary>
    [Fact]
    public async Task VerifySerializedChatWithAggregatorAsync()
    {
        // Create chat
        TestChat chat = new(new AggregatorAgent(() => new TestChat(CreateMockAgent())));
        chat.AddChatMessage(new ChatMessageContent(AuthorRole.User, "test"));
        ChatMessageContent[] messages = await chat.InvokeAsync().ToArrayAsync();

        // Serialize and deserialize chat
        AgentChatState chatState = chat.Serialize();
        string jsonState = await this.SerializeChatAsync(chat);
        AgentChatState? restoredState = JsonSerializer.Deserialize<AgentChatState>(jsonState);

        // Validate state
        Assert.Single(chatState.Participants);
        ChatHistory? chatHistory = JsonSerializer.Deserialize<ChatHistory>(chatState.History);
        Assert.NotNull(chatHistory);
        Assert.Equal(2, chatHistory.Count);
        Assert.Single(chatState.Channels);

        Assert.NotNull(restoredState);
        Assert.Single(restoredState.Participants);
        ChatHistory? restoredHistory = JsonSerializer.Deserialize<ChatHistory>(restoredState.History);
        Assert.NotNull(restoredHistory);
        Assert.Equal(2, restoredHistory.Count);
        Assert.Single(restoredState.Channels);
    }

    /// <summary>
    /// Verify Deserialization cycle for a <see cref="AgentChat"/> with history and channels.
    /// </summary>
    [Fact]
    public async Task VerifyDeserializedChatWithAgentsAsync()
    {
        // Create chat
        TestChat chat = new(CreateMockAgent(), CreateMockAgent());
        chat.AddChatMessage(new ChatMessageContent(AuthorRole.User, "test"));
        ChatMessageContent[] messages = await chat.InvokeAsync().ToArrayAsync();

        // Serialize and deserialize chat
        AgentChatSerializer serializer = await this.CreateSerializerAsync(chat);
        Assert.Equal(2, serializer.Participants.Count());

        TestChat copy = new(CreateMockAgent(), CreateMockAgent());

        await serializer.DeserializeAsync(copy);

        // Validate chat state
        ChatMessageContent[] history = await copy.GetChatMessagesAsync().ToArrayAsync();
        Assert.Equal(2, history.Length);

        await copy.InvokeAsync().ToArrayAsync();
        history = await copy.GetChatMessagesAsync().ToArrayAsync();
        Assert.Equal(3, history.Length);
    }

    /// <summary>
    /// Verify deserialization cycle for a <see cref="AgentChat"/> with <see cref="AggregatorAgent"/>.
    /// </summary>
    [Fact]
    public async Task VerifyDeserializedChatWithAggregatorAsync()
    {
        // Create chat
        TestChat chat = new(new AggregatorAgent(() => new TestChat(CreateMockAgent())) { Name = "Group" });
        chat.AddChatMessage(new ChatMessageContent(AuthorRole.User, "test"));
        ChatMessageContent[] messages = await chat.InvokeAsync().ToArrayAsync();

        // Serialize and deserialize chat
        AgentChatSerializer serializer = await this.CreateSerializerAsync(chat);
        Assert.Single(serializer.Participants);

        TestChat copy = new(new AggregatorAgent(() => new TestChat(CreateMockAgent())) { Name = "Group" });

        await serializer.DeserializeAsync(copy);

        // Validate chat state
        ChatMessageContent[] history = await copy.GetChatMessagesAsync().ToArrayAsync();
        Assert.Equal(2, history.Length);

        await copy.InvokeAsync().ToArrayAsync();
        history = await copy.GetChatMessagesAsync().ToArrayAsync();
        Assert.Equal(3, history.Length);
    }

    /// <summary>
    /// Verify deserialization into a <see cref="AgentChat"/> that already has history and channels.
    /// </summary>
    [Fact]
    public async Task VerifyDeserializedChatWithActivityAsync()
    {
        // Create chat
        TestChat chat = new(CreateMockAgent());

        // Serialize and deserialize chat
        AgentChatSerializer serializer = await this.CreateSerializerAsync(chat);

        TestChat copy = new(CreateMockAgent());
        ChatMessageContent[] messages = await copy.InvokeAsync().ToArrayAsync();

        // Verify exception
        await Assert.ThrowsAsync<KernelException>(() => serializer.DeserializeAsync(copy));
    }

    /// <summary>
    /// Verify deserialization into a <see cref="AgentChat"/> with only user message (no channels).
    /// </summary>
    [Fact]
    public async Task VerifyDeserializedChatWithUserMessageAsync()
    {
        // Create chat
        TestChat chat = new(CreateMockAgent());

        // Serialize and deserialize chat
        AgentChatSerializer serializer = await this.CreateSerializerAsync(chat);

        TestChat copy = new(CreateMockAgent());
        copy.AddChatMessage(new ChatMessageContent(AuthorRole.User, "test"));

        // Verify exception
        await Assert.ThrowsAsync<KernelException>(() => serializer.DeserializeAsync(copy));
    }

    private async Task<AgentChatSerializer> CreateSerializerAsync(TestChat chat)
    {
        string jsonState = await this.SerializeChatAsync(chat);
        await using MemoryStream stream = new();
        await using StreamWriter writer = new(stream);
        writer.Write(jsonState);
        writer.Flush();
        stream.Position = 0;

        return await AgentChatSerializer.DeserializeAsync(stream);
    }

    private async Task<string> SerializeChatAsync(TestChat chat)
    {
        await using MemoryStream stream = new();
        await AgentChatSerializer.SerializeAsync(chat, stream);

        stream.Position = 0;
        using StreamReader reader = new(stream);
        return reader.ReadToEnd();
    }

    private static MockAgent CreateMockAgent() => new() { Response = [new(AuthorRole.Assistant, "sup")] };

    private sealed class TestChat(params Agent[] agents) : AgentChat
    {
        public override IReadOnlyList<Agent> Agents => agents;

        public override IAsyncEnumerable<ChatMessageContent> InvokeAsync(
            CancellationToken cancellationToken = default) =>
                this.InvokeAgentAsync(this.Agents[0], cancellationToken);

        public override IAsyncEnumerable<StreamingChatMessageContent> InvokeStreamingAsync(CancellationToken cancellationToken = default)
        {
            throw new System.NotImplementedException();
        }
    }
}


===== UnitTests\AgentChatTests.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.ChatCompletion;
using Moq;
using Xunit;

namespace SemanticKernel.Agents.UnitTests;

/// <summary>
/// Unit testing of <see cref="AgentChat"/>.
/// </summary>
public class AgentChatTests
{
    /// <summary>
    /// Verify behavior of <see cref="AgentChat"/> over the course of agent interactions.
    /// </summary>
    [Fact]
    public async Task VerifyAgentChatLifecycleAsync()
    {
        // Arrange: Create chat
        TestChat chat = new();

        // Assert: Verify initial state
        Assert.False(chat.IsActive);
        await this.VerifyHistoryAsync(expectedCount: 0, chat.GetChatMessagesAsync()); // Primary history
        await this.VerifyHistoryAsync(expectedCount: 0, chat.GetChatMessagesAsync(chat.Agent)); // Agent history

        // Act: Inject history
        chat.AddChatMessages([new ChatMessageContent(AuthorRole.User, "More")]);
        chat.AddChatMessages([new ChatMessageContent(AuthorRole.User, "And then some")]);

        // Assert: Verify updated history
        await this.VerifyHistoryAsync(expectedCount: 2, chat.GetChatMessagesAsync()); // Primary history
        await this.VerifyHistoryAsync(expectedCount: 0, chat.GetChatMessagesAsync(chat.Agent)); // Agent hasn't joined

        // Act: Invoke with input & verify (agent joins chat)
        chat.AddChatMessage(new ChatMessageContent(AuthorRole.User, "hi"));
        await chat.InvokeAsync().ToArrayAsync();

        // Assert: Verify updated history
        Assert.Equal(1, chat.Agent.InvokeCount);
        await this.VerifyHistoryAsync(expectedCount: 4, chat.GetChatMessagesAsync()); // Primary history
        await this.VerifyHistoryAsync(expectedCount: 4, chat.GetChatMessagesAsync(chat.Agent)); // Agent history

        // Act: Invoke without input
        await chat.InvokeAsync().ToArrayAsync();

        // Assert: Verify final history
        Assert.Equal(2, chat.Agent.InvokeCount);
        await this.VerifyHistoryAsync(expectedCount: 5, chat.GetChatMessagesAsync()); // Primary history
        await this.VerifyHistoryAsync(expectedCount: 5, chat.GetChatMessagesAsync(chat.Agent)); // Agent history

        // Reset verify
        await chat.ResetAsync();
        Assert.Equal(2, chat.Agent.InvokeCount);

        // Verify final history
        await this.VerifyHistoryAsync(expectedCount: 0, chat.GetChatMessagesAsync()); // Primary history
        await this.VerifyHistoryAsync(expectedCount: 0, chat.GetChatMessagesAsync(chat.Agent)); // Agent history
    }

    /// <summary>
    /// Verify <see cref="AgentChat"/> throw exception for system message.
    /// </summary>
    [Fact]
    public void VerifyAgentChatRejectsSystemMessage()
    {
        // Arrange: Create chat
        TestChat chat = new() { LoggerFactory = new Mock<ILoggerFactory>().Object };

        // Assert and Act: Verify system message not accepted
        Assert.Throws<KernelException>(() => chat.AddChatMessage(new ChatMessageContent(AuthorRole.System, "hi")));
    }

    /// <summary>
    /// Verify <see cref="AgentChat"/> throw exception for if invoked when active.
    /// </summary>
    [Fact]
    public async Task VerifyAgentChatThrowsWhenActiveAsync()
    {
        // Arrange: Create chat
        TestChat chat = new();

        // Assert and Act: Verify system message not accepted
        await Assert.ThrowsAsync<KernelException>(() => chat.InvalidInvokeAsync().ToArrayAsync().AsTask());
    }

    /// <summary>
    /// Verify the management of <see cref="Agent"/> instances as they join <see cref="AgentChat"/>.
    /// </summary>
    [Fact(Skip = "Not 100% reliable for github workflows, but useful for dev testing.")]
    public async Task VerifyGroupAgentChatConcurrencyAsync()
    {
        // Arrange
        TestChat chat = new();

        Task[] tasks;

        int isActive = 0;

        // Act: Queue concurrent tasks
        object syncObject = new();
        lock (syncObject)
        {
            tasks =
                [
                    Task.Run(() => SynchronizedInvokeAsync()),
                    Task.Run(() => SynchronizedInvokeAsync()),
                    Task.Run(() => SynchronizedInvokeAsync()),
                    Task.Run(() => SynchronizedInvokeAsync()),
                    Task.Run(() => SynchronizedInvokeAsync()),
                    Task.Run(() => SynchronizedInvokeAsync()),
                    Task.Run(() => SynchronizedInvokeAsync()),
                    Task.Run(() => SynchronizedInvokeAsync()),
                ];
        }

        // Signal tasks to execute
        Interlocked.CompareExchange(ref isActive, 1, 0);

        await Task.Yield();

        // Assert: Verify failure
        await Assert.ThrowsAsync<KernelException>(() => Task.WhenAll(tasks));

        async Task SynchronizedInvokeAsync()
        {
            // Loop until signaled
            int isReady;
            do
            {
                isReady = Interlocked.CompareExchange(ref isActive, 1, 1);
            }
            while (isReady == 0);

            // Rush invocation
            await chat.InvokeAsync().ToArrayAsync().AsTask();
        }
    }

    private async Task VerifyHistoryAsync(int expectedCount, IAsyncEnumerable<ChatMessageContent> history)
    {
        Assert.Equal(expectedCount, await history.CountAsync());
    }

    private sealed class TestChat : AgentChat
    {
        public MockAgent Agent { get; } = new() { Response = [new(AuthorRole.Assistant, "sup")] };

        public override IReadOnlyList<Agent> Agents => [this.Agent];

        public override IAsyncEnumerable<ChatMessageContent> InvokeAsync(
            CancellationToken cancellationToken = default) =>
                this.InvokeAgentAsync(this.Agent, cancellationToken);

        public IAsyncEnumerable<ChatMessageContent> InvalidInvokeAsync(
            CancellationToken cancellationToken = default)
        {
            this.SetActivityOrThrow();
            return this.InvokeAgentAsync(this.Agent, cancellationToken);
        }

        public override IAsyncEnumerable<StreamingChatMessageContent> InvokeStreamingAsync(CancellationToken cancellationToken = default)
        {
            StreamingChatMessageContent[] messages = [new StreamingChatMessageContent(AuthorRole.Assistant, "sup")];
            return messages.ToAsyncEnumerable();
        }
    }
}


===== UnitTests\AgentExtensionsTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Text.Json;
using Microsoft.SemanticKernel.Agents;
using Moq;
using Xunit;

namespace SemanticKernel.Agents.UnitTests;

public sealed class AgentExtensionsTests
{
    [Fact]
    public void AsAIAgent_WithValidParameters_ReturnsSemanticKernelAIAgent()
    {
        // Arrange
        var agentMock = new Mock<Agent>();
        AgentThread ThreadFactory() => Mock.Of<AgentThread>();
        AgentThread ThreadDeserializationFactory(JsonElement e, JsonSerializerOptions? o) => Mock.Of<AgentThread>();
        JsonElement ThreadSerializer(AgentThread t, JsonSerializerOptions? o) => default;

        // Act
        var result = agentMock.Object.AsAIAgent(ThreadFactory, ThreadDeserializationFactory, ThreadSerializer);

        // Assert
        Assert.NotNull(result);
        Assert.IsType<SemanticKernelAIAgent>(result);
    }

    [Fact]
    public void AsAIAgent_WithNullSemanticKernelAgent_ThrowsArgumentNullException()
    {
        // Arrange
        Agent nullAgent = null!;
        AgentThread ThreadFactory() => Mock.Of<AgentThread>();
        AgentThread ThreadDeserializationFactory(JsonElement e, JsonSerializerOptions? o) => Mock.Of<AgentThread>();
        JsonElement ThreadSerializer(AgentThread t, JsonSerializerOptions? o) => default;

        // Act & Assert
        Assert.Throws<ArgumentNullException>(() => nullAgent.AsAIAgent(ThreadFactory, ThreadDeserializationFactory, ThreadSerializer));
    }

    [Fact]
    public void AsAIAgent_WithNullThreadFactory_ThrowsArgumentNullException()
    {
        // Arrange
        var agentMock = new Mock<Agent>();
        AgentThread ThreadDeserializationFactory(JsonElement e, JsonSerializerOptions? o) => Mock.Of<AgentThread>();
        JsonElement ThreadSerializer(AgentThread t, JsonSerializerOptions? o) => default;

        // Act & Assert
        Assert.Throws<ArgumentNullException>(() => agentMock.Object.AsAIAgent(null!, ThreadDeserializationFactory, ThreadSerializer));
    }

    [Fact]
    public void AsAIAgent_WithNullThreadDeserializationFactory_ThrowsArgumentNullException()
    {
        // Arrange
        var agentMock = new Mock<Agent>();
        AgentThread ThreadFactory() => Mock.Of<AgentThread>();
        JsonElement ThreadSerializer(AgentThread t, JsonSerializerOptions? o) => default;

        // Act & Assert
        Assert.Throws<ArgumentNullException>(() => agentMock.Object.AsAIAgent(ThreadFactory, null!, ThreadSerializer));
    }

    [Fact]
    public void AsAIAgent_WithNullThreadSerializer_ThrowsArgumentNullException()
    {
        // Arrange
        var agentMock = new Mock<Agent>();
        AgentThread ThreadFactory() => Mock.Of<AgentThread>();
        AgentThread ThreadDeserializationFactory(JsonElement e, JsonSerializerOptions? o) => Mock.Of<AgentThread>();

        // Act & Assert
        Assert.Throws<ArgumentNullException>(() => agentMock.Object.AsAIAgent(ThreadFactory, ThreadDeserializationFactory, null!));
    }

    [Fact]
    public void AsAIAgent_WithValidFactories_CreatesWorkingAdapter()
    {
        // Arrange
        var agentMock = new Mock<Agent>();
        var expectedThread = Mock.Of<AgentThread>();
        var factoryCallCount = 0;

        AgentThread ThreadFactory()
        {
            factoryCallCount++;
            return expectedThread;
        }

        AgentThread ThreadDeserializationFactory(JsonElement e, JsonSerializerOptions? o) => expectedThread;
        JsonElement ThreadSerializer(AgentThread t, JsonSerializerOptions? o) => default;

        // Act
        var result = agentMock.Object.AsAIAgent(ThreadFactory, ThreadDeserializationFactory, ThreadSerializer);
        var thread = result.GetNewThread();

        // Assert
        Assert.NotNull(thread);
        Assert.Equal(1, factoryCallCount);
        Assert.IsType<SemanticKernelAIAgentThread>(thread);
        Assert.Same(expectedThread, ((SemanticKernelAIAgentThread)thread).InnerThread);
    }

    [Fact]
    public void AsAIAgent_WithDeserializationFactory_CreatesWorkingAdapter()
    {
        // Arrange
        var agentMock = new Mock<Agent>();
        var expectedThread = Mock.Of<AgentThread>();
        var deserializationCallCount = 0;

        AgentThread ThreadFactory() => Mock.Of<AgentThread>();

        AgentThread ThreadDeserializationFactory(JsonElement e, JsonSerializerOptions? o)
        {
            deserializationCallCount++;
            return expectedThread;
        }

        JsonElement ThreadSerializer(AgentThread t, JsonSerializerOptions? o) => default;

        // Act
        var result = agentMock.Object.AsAIAgent(ThreadFactory, ThreadDeserializationFactory, ThreadSerializer);
        var json = JsonDocument.Parse("{}").RootElement;
        var thread = result.DeserializeThread(json);

        // Assert
        Assert.NotNull(thread);
        Assert.Equal(1, deserializationCallCount);
        Assert.IsType<SemanticKernelAIAgentThread>(thread);
        Assert.Same(expectedThread, ((SemanticKernelAIAgentThread)thread).InnerThread);
    }
}


===== UnitTests\AgentTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.Arguments.Extensions;
using Microsoft.SemanticKernel.ChatCompletion;
using Moq;
using Xunit;

namespace SemanticKernel.Agents.UnitTests;

/// <summary>
/// Unit tests for the <see cref="Agent"/> class.
/// </summary>
public class AgentTests
{
    private readonly Mock<Agent> _agentMock;
    private readonly Mock<AgentThread> _agentThreadMock;
    private readonly List<AgentResponseItem<ChatMessageContent>> _invokeResponses = new();
    private readonly List<AgentResponseItem<StreamingChatMessageContent>> _invokeStreamingResponses = new();

    /// <summary>
    /// Initializes a new instance of the <see cref="AgentTests"/> class.
    /// </summary>
    public AgentTests()
    {
        this._agentThreadMock = new Mock<AgentThread>(MockBehavior.Strict);

        this._invokeResponses.Add(new AgentResponseItem<ChatMessageContent>(new ChatMessageContent(AuthorRole.Assistant, "Hi"), this._agentThreadMock.Object));
        this._invokeStreamingResponses.Add(new AgentResponseItem<StreamingChatMessageContent>(new StreamingChatMessageContent(AuthorRole.Assistant, "Hi"), this._agentThreadMock.Object));

        this._agentMock = new Mock<Agent>() { CallBase = true };
        this._agentMock
            .Setup(x => x.InvokeAsync(
                It.IsAny<ICollection<ChatMessageContent>>(),
                this._agentThreadMock.Object,
                It.IsAny<AgentInvokeOptions?>(),
                It.IsAny<CancellationToken>()))
            .Returns(this._invokeResponses.ToAsyncEnumerable());
        this._agentMock
            .Setup(x => x.InvokeStreamingAsync(
                It.IsAny<ICollection<ChatMessageContent>>(),
                this._agentThreadMock.Object,
                It.IsAny<AgentInvokeOptions?>(),
                It.IsAny<CancellationToken>()))
            .Returns(this._invokeStreamingResponses.ToAsyncEnumerable());
    }

    /// <summary>
    /// Tests that invoking without a message calls the mocked invoke method with an empty array.
    /// </summary>
    /// <returns>A task that represents the asynchronous operation.</returns>
    [Fact]
    public async Task InvokeWithoutMessageCallsMockedInvokeWithEmptyArrayAsync()
    {
        // Arrange
        var options = new AgentInvokeOptions();
        var cancellationToken = new CancellationToken();

        // Act
        await foreach (var response in this._agentMock.Object.InvokeAsync(this._agentThreadMock.Object, options, cancellationToken))
        {
            // Assert
            Assert.Contains(response, this._invokeResponses);
        }

        // Verify that the mocked method was called with the expected parameters
        this._agentMock.Verify(
            x => x.InvokeAsync(
                It.Is<ICollection<ChatMessageContent>>(messages => messages.Count == 0),
                this._agentThreadMock.Object,
                options,
                cancellationToken),
            Times.Once);
    }

    /// <summary>
    /// Tests that invoking with a string message calls the mocked invoke method with the message in the ICollection of messages.
    /// </summary>
    /// <returns>A task that represents the asynchronous operation.</returns>
    [Fact]
    public async Task InvokeWithStringMessageCallsMockedInvokeWithMessageInCollectionAsync()
    {
        // Arrange
        var message = "Hello, Agent!";
        var options = new AgentInvokeOptions();
        var cancellationToken = new CancellationToken();

        // Act
        await foreach (var response in this._agentMock.Object.InvokeAsync(message, this._agentThreadMock.Object, options, cancellationToken))
        {
            // Assert
            Assert.Contains(response, this._invokeResponses);
        }

        // Verify that the mocked method was called with the expected parameters
        this._agentMock.Verify(
            x => x.InvokeAsync(
                It.Is<ICollection<ChatMessageContent>>(messages => messages.Count == 1 && messages.First().Content == message),
                this._agentThreadMock.Object,
                options,
                cancellationToken),
            Times.Once);
    }

    /// <summary>
    /// Tests that invoking with a single message calls the mocked invoke method with the message in the ICollection of messages.
    /// </summary>
    /// <returns>A task that represents the asynchronous operation.</returns>
    [Fact]
    public async Task InvokeWithSingleMessageCallsMockedInvokeWithMessageInCollectionAsync()
    {
        // Arrange
        var message = new ChatMessageContent(AuthorRole.User, "Hello, Agent!");
        var options = new AgentInvokeOptions();
        var cancellationToken = new CancellationToken();

        // Act
        await foreach (var response in this._agentMock.Object.InvokeAsync(message, this._agentThreadMock.Object, options, cancellationToken))
        {
            // Assert
            Assert.Contains(response, this._invokeResponses);
        }

        // Verify that the mocked method was called with the expected parameters
        this._agentMock.Verify(
            x => x.InvokeAsync(
                It.Is<ICollection<ChatMessageContent>>(messages => messages.Count == 1 && messages.First() == message),
                this._agentThreadMock.Object,
                options,
                cancellationToken),
            Times.Once);
    }

    /// <summary>
    /// Tests that invoking streaming without a message calls the mocked invoke method with an empty array.
    /// </summary>
    /// <returns>A task that represents the asynchronous operation.</returns>
    [Fact]
    public async Task InvokeStreamingWithoutMessageCallsMockedInvokeWithEmptyArrayAsync()
    {
        // Arrange
        var options = new AgentInvokeOptions();
        var cancellationToken = new CancellationToken();

        // Act
        await foreach (var response in this._agentMock.Object.InvokeStreamingAsync(this._agentThreadMock.Object, options, cancellationToken))
        {
            // Assert
            Assert.Contains(response, this._invokeStreamingResponses);
        }

        // Verify that the mocked method was called with the expected parameters
        this._agentMock.Verify(
            x => x.InvokeStreamingAsync(
                It.Is<ICollection<ChatMessageContent>>(messages => messages.Count == 0),
                this._agentThreadMock.Object,
                options,
                cancellationToken),
            Times.Once);
    }

    /// <summary>
    /// Tests that invoking streaming with a string message calls the mocked invoke method with the message in the ICollection of messages.
    /// </summary>
    /// <returns>A task that represents the asynchronous operation.</returns>
    [Fact]
    public async Task InvokeStreamingWithStringMessageCallsMockedInvokeWithMessageInCollectionAsync()
    {
        // Arrange
        var message = "Hello, Agent!";
        var options = new AgentInvokeOptions();
        var cancellationToken = new CancellationToken();

        // Act
        await foreach (var response in this._agentMock.Object.InvokeStreamingAsync(message, this._agentThreadMock.Object, options, cancellationToken))
        {
            // Assert
            Assert.Contains(response, this._invokeStreamingResponses);
        }

        // Verify that the mocked method was called with the expected parameters
        this._agentMock.Verify(
            x => x.InvokeStreamingAsync(
                It.Is<ICollection<ChatMessageContent>>(messages => messages.Count == 1 && messages.First().Content == message),
                this._agentThreadMock.Object,
                options,
                cancellationToken),
            Times.Once);
    }

    /// <summary>
    /// Tests that invoking streaming with a single message calls the mocked invoke method with the message in the ICollection of messages.
    /// </summary>
    /// <returns>A task that represents the asynchronous operation.</returns>
    [Fact]
    public async Task InvokeStreamingWithSingleMessageCallsMockedInvokeWithMessageInCollectionAsync()
    {
        // Arrange
        var message = new ChatMessageContent(AuthorRole.User, "Hello, Agent!");
        var options = new AgentInvokeOptions();
        var cancellationToken = new CancellationToken();

        // Act
        await foreach (var response in this._agentMock.Object.InvokeStreamingAsync(message, this._agentThreadMock.Object, options, cancellationToken))
        {
            // Assert
            Assert.Contains(response, this._invokeStreamingResponses);
        }

        // Verify that the mocked method was called with the expected parameters
        this._agentMock.Verify(
            x => x.InvokeStreamingAsync(
                It.Is<ICollection<ChatMessageContent>>(messages => messages.Count == 1 && messages.First() == message),
                this._agentThreadMock.Object,
                options,
                cancellationToken),
            Times.Once);
    }

    /// <summary>
    /// Verify ability to merge null <see cref="KernelArguments"/>.
    /// </summary>
    [Fact]
    public void VerifyNullArgumentMergeWhenRenderingPrompt()
    {
        // Arrange
        KernelArguments? primaryArguments = null;
        // Act
        KernelArguments arguments = primaryArguments.Merge(null);
        // Assert
        Assert.Empty(arguments);

        // Arrange
        KernelArguments overrideArguments = new() { { "test", 1 } };
        // Act
        arguments = primaryArguments.Merge(overrideArguments);
        // Assert
        Assert.StrictEqual(1, arguments.Count);
    }

    /// <summary>
    /// Verify ability to merge <see cref="KernelArguments"/> parameters.
    /// </summary>
    [Fact]
    public void VerifyArgumentParameterMerge()
    {
        // Arrange
        KernelArguments? primaryArguments = new() { { "a", 1 } };
        KernelArguments overrideArguments = new() { { "b", 2 } };

        // Act
        KernelArguments? arguments = primaryArguments.Merge(overrideArguments);

        // Assert
        Assert.NotNull(arguments);
        Assert.Equal(2, arguments.Count);
        Assert.Equal(1, arguments["a"]);
        Assert.Equal(2, arguments["b"]);

        // Arrange
        overrideArguments["a"] = 11;
        overrideArguments["c"] = 3;

        // Act
        arguments = primaryArguments.Merge(overrideArguments);

        // Assert
        Assert.NotNull(arguments);
        Assert.Equal(3, arguments.Count);
        Assert.Equal(11, arguments["a"]);
        Assert.Equal(2, arguments["b"]);
        Assert.Equal(3, arguments["c"]);
    }

    /// <summary>
    /// Verify ability to merge <see cref="KernelArguments.ExecutionSettings"/>.
    /// </summary>
    [Fact]
    public void VerifyArgumentSettingsMerge()
    {
        // Arrange
        FunctionChoiceBehavior autoInvoke = FunctionChoiceBehavior.Auto();
        PromptExecutionSettings promptExecutionSettings = new() { FunctionChoiceBehavior = autoInvoke };
        KernelArguments primaryArgument = new() { ExecutionSettings = new Dictionary<string, PromptExecutionSettings>() { { PromptExecutionSettings.DefaultServiceId, promptExecutionSettings } } };
        KernelArguments overrideArgumentsNoSettings = [];

        // Act
        KernelArguments? arguments = primaryArgument.Merge(overrideArgumentsNoSettings);

        // Assert
        Assert.NotNull(arguments);
        Assert.NotNull(arguments.ExecutionSettings);
        Assert.Single(arguments.ExecutionSettings);
        Assert.StrictEqual(autoInvoke, arguments.ExecutionSettings.First().Value.FunctionChoiceBehavior);

        // Arrange
        FunctionChoiceBehavior noInvoke = FunctionChoiceBehavior.None();
        KernelArguments overrideArgumentsWithSettings = new(new PromptExecutionSettings() { FunctionChoiceBehavior = noInvoke });

        // Act
        arguments = primaryArgument.Merge(overrideArgumentsWithSettings);

        // Assert
        Assert.NotNull(arguments);
        Assert.NotNull(arguments.ExecutionSettings);
        Assert.Single(arguments.ExecutionSettings);
        Assert.StrictEqual(noInvoke, arguments.ExecutionSettings.First().Value.FunctionChoiceBehavior);
    }
}


===== UnitTests\AggregatorAgentTests.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.Agents.Chat;
using Microsoft.SemanticKernel.ChatCompletion;
using Xunit;

namespace SemanticKernel.Agents.UnitTests;

/// <summary>
/// Unit testing of <see cref="AggregatorAgent"/>.
/// </summary>
public class AggregatorAgentTests
{
    /// <summary>
    /// Verify usage of <see cref="AggregatorAgent"/> through various states.
    /// </summary>
    [Theory]
    [InlineData(AggregatorMode.Nested, 0)]
    [InlineData(AggregatorMode.Flat, 2)]
    public async Task VerifyAggregatorAgentUsageAsync(AggregatorMode mode, int modeOffset)
    {
        // Arrange
        Agent agent1 = CreateMockAgent("First");
        Agent agent2 = CreateMockAgent("Second");
        Agent agent3 = CreateMockAgent("Third");

        AgentGroupChat groupChat =
            new(agent1, agent2, agent3)
            {
                ExecutionSettings =
                    new()
                    {
                        TerminationStrategy =
                        {
                            MaximumIterations = 3
                        }
                    }
            };

        AggregatorAgent uberAgent = new(() => groupChat) { Mode = mode };
        AgentGroupChat uberChat = new();

        // Add message to outer chat (no agent has joined)
        uberChat.AddChatMessage(new ChatMessageContent(AuthorRole.User, "test uber"));

        // Act
        var messages = await uberChat.GetChatMessagesAsync().ToArrayAsync();
        // Assert
        Assert.Single(messages);

        // Act
        messages = await uberChat.GetChatMessagesAsync(uberAgent).ToArrayAsync();
        // Assert
        Assert.Empty(messages); // Agent hasn't joined chat, no broadcast

        // Act
        messages = await groupChat.GetChatMessagesAsync().ToArrayAsync();
        // Assert
        Assert.Empty(messages); // Agent hasn't joined chat, no broadcast

        // Arrange: Add message to inner chat (not visible to parent)
        groupChat.AddChatMessage(new ChatMessageContent(AuthorRole.User, "test inner"));

        // Act
        messages = await uberChat.GetChatMessagesAsync().ToArrayAsync();
        // Assert
        Assert.Single(messages);

        // Act
        messages = await uberChat.GetChatMessagesAsync(uberAgent).ToArrayAsync();
        // Assert
        Assert.Empty(messages); // Agent still hasn't joined chat

        // Act
        messages = await groupChat.GetChatMessagesAsync().ToArrayAsync();
        // Assert
        Assert.Single(messages);

        // Act: Invoke outer chat (outer chat captures final inner message)
        messages = await uberChat.InvokeAsync(uberAgent).ToArrayAsync();
        // Assert
        Assert.Equal(1 + modeOffset, messages.Length); // New messages generated from inner chat

        // Act
        messages = await uberChat.GetChatMessagesAsync().ToArrayAsync();
        // Assert
        Assert.Equal(2 + modeOffset, messages.Length); // Total messages on uber chat

        // Act
        messages = await groupChat.GetChatMessagesAsync().ToArrayAsync();
        // Assert
        Assert.Equal(5, messages.Length); // Total messages on inner chat once synchronized

        // Act
        messages = await uberChat.GetChatMessagesAsync(uberAgent).ToArrayAsync();
        // Assert
        Assert.Equal(5, messages.Length); // Total messages on inner chat once synchronized (agent equivalent)
    }

    /// <summary>
    /// Ensure multiple <see cref="AggregatorAgent"/> instances do not share a channel.
    /// </summary>
    [Fact]
    public async Task VerifyMultipleAggregatorAgentAsync()
    {
        const string UserInput = "User Input";

        // Arrange
        Agent agent1Exec = CreateMockAgent("agent1 exec");
        Agent agent1Review = CreateMockAgent("agent1 [OK]");
        Agent agent2Exec = CreateMockAgent("agent2 exec");
        Agent agent2Review = CreateMockAgent("agent2 [OK]");

        AgentGroupChat agent1Chat =
            new(agent1Exec, agent1Review)
            {
                ExecutionSettings =
                    new()
                    {
                        TerminationStrategy = new ApprovalTerminationStrategy()
                        {
                            Agents = [agent1Review],
                            MaximumIterations = 3,
                            AutomaticReset = true,
                        }
                    }
            };
        AgentGroupChat agent2Chat =
            new(agent2Exec, agent2Review)
            {
                ExecutionSettings =
                    new()
                    {
                        TerminationStrategy = new ApprovalTerminationStrategy()
                        {
                            Agents = [agent2Review],
                            MaximumIterations = 4,
                            AutomaticReset = false,
                        }
                    }
            };

        AggregatorAgent agent1 = new(() => agent1Chat) { Mode = AggregatorMode.Flat, Name = "agent1" };
        AggregatorAgent agent2 = new(() => agent2Chat) { Mode = AggregatorMode.Flat, Name = "agent2" };
        AgentGroupChat userChat = new(agent1, agent2)
        {
            ExecutionSettings =
                new()
                {
                    TerminationStrategy = new AgentTerminationStrategy(agent2)
                    {
                        MaximumIterations = 8,
                        AutomaticReset = true
                    }
                }
        };

        userChat.AddChatMessage(new ChatMessageContent(AuthorRole.User, UserInput));

        // Act
        ChatMessageContent[] messages = await userChat.InvokeAsync().ToArrayAsync();

        // Assert
        Assert.Equal(4, messages.Length);
        Assert.Equal(agent1Exec.Name, messages[0].AuthorName);
        Assert.Equal(agent1Review.Name, messages[1].AuthorName);
        Assert.Equal(agent2Exec.Name, messages[2].AuthorName);
        Assert.Equal(agent2Review.Name, messages[3].AuthorName);
    }

    private static MockAgent CreateMockAgent(string agentName) => new() { Name = agentName, Response = [new(AuthorRole.Assistant, $"{agentName} -> test") { AuthorName = agentName }] };

    private sealed class ApprovalTerminationStrategy : TerminationStrategy
    {
        protected override Task<bool> ShouldAgentTerminateAsync(Agent agent, IReadOnlyList<ChatMessageContent> history, CancellationToken cancellationToken)
            => Task.FromResult(history[history.Count - 1].Content?.Contains("[OK]", StringComparison.OrdinalIgnoreCase) ?? false);
    }

    private sealed class AgentTerminationStrategy(Agent lastAgent) : TerminationStrategy
    {
        protected override Task<bool> ShouldAgentTerminateAsync(Agent agent, IReadOnlyList<ChatMessageContent> history, CancellationToken cancellationToken = default)
        {
            return Task.FromResult(agent == lastAgent);
        }
    }
}


===== UnitTests\AIAgent\SemanticKernelAIAgentTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.ChatCompletion;
using Moq;
using Xunit;
using MAAI = Microsoft.Agents.AI;
using MEAI = Microsoft.Extensions.AI;

namespace SemanticKernel.Agents.UnitTests.AIAgent;

public sealed class SemanticKernelAIAgentTests
{
    [Fact]
    public void Constructor_Succeeds()
    {
        // Arrange
        var agentMock = new Mock<Agent>();
        AgentThread ThreadFactory() => Mock.Of<AgentThread>();
        AgentThread ThreadDeserializationFactory(JsonElement e, JsonSerializerOptions? o) => Mock.Of<AgentThread>();
        JsonElement ThreadSerializer(AgentThread t, JsonSerializerOptions? o) => default;

        // Act
        var adapter = new SemanticKernelAIAgent(agentMock.Object, ThreadFactory, ThreadDeserializationFactory, ThreadSerializer);

        // Assert
        Assert.IsType<SemanticKernelAIAgent>(adapter);
    }

    [Fact]
    public void Constructor_WithNullSemanticKernelAgent_ThrowsArgumentNullException()
    {
        // Arrange
        AgentThread ThreadFactory() => Mock.Of<AgentThread>();
        AgentThread ThreadDeserializationFactory(JsonElement e, JsonSerializerOptions? o) => Mock.Of<AgentThread>();
        JsonElement ThreadSerializer(AgentThread t, JsonSerializerOptions? o) => default;

        // Act & Assert
        Assert.Throws<ArgumentNullException>(() => new SemanticKernelAIAgent(null!, ThreadFactory, ThreadDeserializationFactory, ThreadSerializer));
    }

    [Fact]
    public void Constructor_WithNullThreadFactory_ThrowsArgumentNullException()
    {
        // Arrange
        var agentMock = new Mock<Agent>();
        AgentThread ThreadDeserializationFactory(JsonElement e, JsonSerializerOptions? o) => Mock.Of<AgentThread>();
        JsonElement ThreadSerializer(AgentThread t, JsonSerializerOptions? o) => default;

        // Act & Assert
        Assert.Throws<ArgumentNullException>(() => new SemanticKernelAIAgent(agentMock.Object, null!, ThreadDeserializationFactory, ThreadSerializer));
    }

    [Fact]
    public void Constructor_WithNullThreadDeserializationFactory_ThrowsArgumentNullException()
    {
        // Arrange
        var agentMock = new Mock<Agent>();
        AgentThread ThreadFactory() => Mock.Of<AgentThread>();
        JsonElement ThreadSerializer(AgentThread t, JsonSerializerOptions? o) => default;

        // Act & Assert
        Assert.Throws<ArgumentNullException>(() => new SemanticKernelAIAgent(agentMock.Object, ThreadFactory, null!, ThreadSerializer));
    }

    [Fact]
    public void Constructor_WithNullThreadSerializer_ThrowsArgumentNullException()
    {
        // Arrange
        var agentMock = new Mock<Agent>();
        AgentThread ThreadFactory() => Mock.Of<AgentThread>();
        AgentThread ThreadDeserializationFactory(JsonElement e, JsonSerializerOptions? o) => Mock.Of<AgentThread>();

        // Act & Assert
        Assert.Throws<ArgumentNullException>(() => new SemanticKernelAIAgent(agentMock.Object, ThreadFactory, ThreadDeserializationFactory, null!));
    }

    [Fact]
    public void DeserializeThread_ReturnsSemanticKernelAIAgentThread()
    {
        // Arrange
        var agentMock = new Mock<Agent>();
        var expectedThread = Mock.Of<AgentThread>();
        JsonElement ThreadSerializer(AgentThread t, JsonSerializerOptions? o) => default;
        AgentThread ThreadDeserializationFactory(JsonElement e, JsonSerializerOptions? o) => expectedThread;
        var adapter = new SemanticKernelAIAgent(agentMock.Object, () => expectedThread, ThreadDeserializationFactory, ThreadSerializer);
        var json = JsonDocument.Parse("{}").RootElement;

        // Act
        var result = adapter.DeserializeThread(json);

        // Assert
        Assert.IsType<SemanticKernelAIAgentThread>(result);
    }

    [Fact]
    public void GetNewThread_ReturnsSemanticKernelAIAgentThread()
    {
        // Arrange
        var agentMock = new Mock<Agent>();
        var expectedThread = Mock.Of<AgentThread>();
        JsonElement ThreadSerializer(AgentThread t, JsonSerializerOptions? o) => default;
        var adapter = new SemanticKernelAIAgent(agentMock.Object, () => expectedThread, (e, o) => expectedThread, ThreadSerializer);

        // Act
        var result = adapter.GetNewThread();

        // Assert
        Assert.IsType<SemanticKernelAIAgentThread>(result);
        Assert.Equal(expectedThread, ((SemanticKernelAIAgentThread)result).InnerThread);
    }

    [Fact]
    public void DeserializeThread_CallsDeserializationFactory()
    {
        // Arrange
        var agentMock = new Mock<Agent>();
        var expectedThread = Mock.Of<AgentThread>();
        var factoryCallCount = 0;

        AgentThread DeserializationFactory(JsonElement e, JsonSerializerOptions? o)
        {
            factoryCallCount++;
            return expectedThread;
        }

        var adapter = new SemanticKernelAIAgent(agentMock.Object, () => expectedThread, DeserializationFactory, (t, o) => default);
        var json = JsonDocument.Parse("{}").RootElement;

        // Act
        var result = adapter.DeserializeThread(json);

        // Assert
        Assert.Equal(1, factoryCallCount);
        Assert.IsType<SemanticKernelAIAgentThread>(result);
    }

    [Fact]
    public void GetNewThread_CallsThreadFactory()
    {
        // Arrange
        var agentMock = new Mock<Agent>();
        var expectedThread = Mock.Of<AgentThread>();
        var factoryCallCount = 0;

        AgentThread ThreadFactory()
        {
            factoryCallCount++;
            return expectedThread;
        }

        var adapter = new SemanticKernelAIAgent(agentMock.Object, ThreadFactory, (e, o) => expectedThread, (t, o) => default);

        // Act
        var result = adapter.GetNewThread();

        // Assert
        Assert.Equal(1, factoryCallCount);
        Assert.IsType<SemanticKernelAIAgentThread>(result);
    }

    [Fact]
    public void Properties_ReflectInnerAgentProperties()
    {
        // Arrange
        var concreteAgent = new TestAgent
        {
            Id = "test-agent-id",
            Name = "Test Agent Name",
            Description = "Test Agent Description"
        };

        var adapter = new SemanticKernelAIAgent(concreteAgent, () => Mock.Of<AgentThread>(), (e, o) => Mock.Of<AgentThread>(), (t, o) => default);

        // Act & Assert
        Assert.Equal("test-agent-id", adapter.Id);
        Assert.Equal("Test Agent Name", adapter.Name);
        Assert.Equal("Test Agent Description", adapter.Description);
    }

    [Fact]
    public async Task Run_CallsInnerAgentAsync()
    {
        // Arrange
        var threadMock = new Mock<AgentThread>();
        var innerThread = threadMock.Object;
        var agentMock = new Mock<Agent>();
        agentMock.Setup(a => a.InvokeAsync(
            It.IsAny<List<ChatMessageContent>>(),
            It.IsAny<AgentThread>(),
            It.IsAny<AgentInvokeOptions>(),
            It.IsAny<CancellationToken>()))
            .Returns(MockInvokeAsync);
        var adapter = new SemanticKernelAIAgent(agentMock.Object, () => Mock.Of<AgentThread>(), (e, o) => Mock.Of<AgentThread>(), (t, o) => default);

        async IAsyncEnumerable<AgentResponseItem<ChatMessageContent>> MockInvokeAsync(ICollection<ChatMessageContent> messages,
            AgentThread? thread = null,
            AgentInvokeOptions? options = null,
            [EnumeratorCancellation] CancellationToken cancellationToken = default)
        {
            var message = new ChatMessageContent(AuthorRole.Assistant, "Final response");
            await options!.OnIntermediateMessage!.Invoke(message);
            yield return new AgentResponseItem<ChatMessageContent>(message, innerThread);
        }

        var thread = new SemanticKernelAIAgentThread(innerThread, (t, o) => default);

        // Act
        var result = await adapter.RunAsync("Input text", thread);

        // Assert
        Assert.IsType<MAAI.AgentRunResponse>(result);
        Assert.Equal("Final response", result.Text);
        agentMock.Verify(a => a.InvokeAsync(
            It.Is<List<ChatMessageContent>>(x => x.First().Content == "Input text"),
            innerThread,
            It.IsAny<AgentInvokeOptions>(),
            It.IsAny<CancellationToken>()), Times.Once);
    }

    [Fact]
    public async Task RunStreaming_CallsInnerAgentAsync()
    {
        // Arrange
        var threadMock = new Mock<AgentThread>();
        var innerThread = threadMock.Object;
        var agentMock = new Mock<Agent>();
        agentMock.Setup(a => a.InvokeStreamingAsync(
            It.IsAny<List<ChatMessageContent>>(),
            It.IsAny<AgentThread>(),
            It.IsAny<AgentInvokeOptions>(),
            It.IsAny<CancellationToken>()))
            .Returns(GetAsyncEnumerable());
        var adapter = new SemanticKernelAIAgent(agentMock.Object, () => Mock.Of<AgentThread>(), (e, o) => Mock.Of<AgentThread>(), (t, o) => default);

        async IAsyncEnumerable<AgentResponseItem<StreamingChatMessageContent>> GetAsyncEnumerable()
        {
            yield return new AgentResponseItem<StreamingChatMessageContent>(new StreamingChatMessageContent(AuthorRole.Assistant, "Final response"), innerThread);
        }

        var thread = new SemanticKernelAIAgentThread(innerThread, (t, o) => default);

        // Act
        var results = await adapter.RunStreamingAsync("Input text", thread).ToListAsync();

        // Assert
        Assert.IsType<MAAI.AgentRunResponseUpdate>(results.First());
        Assert.Equal("Final response", results.First().Text);
        agentMock.Verify(a => a.InvokeStreamingAsync(
            It.Is<List<ChatMessageContent>>(x => x.First().Content == "Input text"),
            innerThread,
            It.IsAny<AgentInvokeOptions>(),
            It.IsAny<CancellationToken>()), Times.Once);
    }

    [Fact]
    public async Task RunAsync_RemovesDuplicateTextContentInToolMessage()
    {
        // Arrange
        var innerThread = Mock.Of<AgentThread>();
        var agentMock = new Mock<Agent>();
        var adapter = new SemanticKernelAIAgent(agentMock.Object, () => innerThread, (e, o) => innerThread, (t, o) => default);

        agentMock.Setup(a => a.InvokeAsync(
            It.IsAny<List<ChatMessageContent>>(),
            It.IsAny<AgentThread>(),
            It.IsAny<AgentInvokeOptions>(),
            It.IsAny<CancellationToken>()))
            .Returns((List<ChatMessageContent> msgs, AgentThread thread, AgentInvokeOptions opts, CancellationToken ct) => GetEnumerableWithDuplicateToolMessage(thread, opts));

        async IAsyncEnumerable<AgentResponseItem<ChatMessageContent>> GetEnumerableWithDuplicateToolMessage(AgentThread thread, AgentInvokeOptions opts)
        {
            // Tool message with duplicate text + function result
            var toolMessage = new ChatMessageContent(AuthorRole.Tool, "RESULT");
            toolMessage.Items.Add(new FunctionResultContent(functionName: "Fn", result: "RESULT"));
            await opts.OnIntermediateMessage!.Invoke(toolMessage);

            // Final assistant message
            var final = new ChatMessageContent(AuthorRole.Assistant, "done");
            yield return new AgentResponseItem<ChatMessageContent>(final, thread);
        }

        var threadWrapper = new SemanticKernelAIAgentThread(innerThread, (t, o) => default);

        // Act
        var response = await adapter.RunAsync("input", threadWrapper);

        // Assert
        // Use reflection to inspect Messages collection inside AgentRunResponse
        var messages = response.Messages;
        var contents = messages.First().Contents;
        Assert.Single(contents); // Duplicate text content should have been removed
        Assert.IsType<MEAI.FunctionResultContent>(contents.First());
    }

    [Fact]
    public async Task RunAsync_DoesNotRemoveTextContentWhenDifferent()
    {
        // Arrange
        var innerThread = Mock.Of<AgentThread>();
        var agentMock = new Mock<Agent>();
        var adapter = new SemanticKernelAIAgent(agentMock.Object, () => innerThread, (e, o) => innerThread, (t, o) => default);

        agentMock.Setup(a => a.InvokeAsync(
            It.IsAny<List<ChatMessageContent>>(),
            It.IsAny<AgentThread>(),
            It.IsAny<AgentInvokeOptions>(),
            It.IsAny<CancellationToken>()))
            .Returns((List<ChatMessageContent> msgs, AgentThread thread, AgentInvokeOptions opts, CancellationToken ct) => GetEnumerableWithNonDuplicateToolMessage(thread, opts));

        async IAsyncEnumerable<AgentResponseItem<ChatMessageContent>> GetEnumerableWithNonDuplicateToolMessage(AgentThread thread, AgentInvokeOptions opts)
        {
            // Tool message with text + function result differing
            var toolMessage = new ChatMessageContent(AuthorRole.Tool, "TEXT");
            toolMessage.Items.Add(new FunctionResultContent(functionName: "Fn", result: "DIFFERENT"));
            await opts.OnIntermediateMessage!.Invoke(toolMessage);

            var final = new ChatMessageContent(AuthorRole.Assistant, "done");
            yield return new AgentResponseItem<ChatMessageContent>(final, thread);
        }

        var threadWrapper = new SemanticKernelAIAgentThread(innerThread, (t, o) => default);

        // Act
        var response = await adapter.RunAsync("input", threadWrapper);

        // Assert
        var messages = response.Messages;
        var contents = messages.First().Contents;
        Assert.Equal(2, contents.Count); // Both contents should remain
        Assert.IsType<MEAI.TextContent>(contents.First());
        Assert.IsType<MEAI.FunctionResultContent>(contents.Last());
    }

    [Fact]
    public void GetService_WithKernelType_ReturnsKernel()
    {
        // Arrange
        var kernel = new Kernel();
        var fakeAgent = new TestAgent() { Kernel = kernel };

        var adapter = new SemanticKernelAIAgent(fakeAgent, () => Mock.Of<AgentThread>(), (e, o) => Mock.Of<AgentThread>(), (t, o) => default);

        // Act
        var result = adapter.GetService(typeof(Kernel));

        // Assert
        Assert.Same(kernel, result);
    }

    [Fact]
    public void GetService_WithKernelTypeAndServiceKey_ReturnsNull()
    {
        // Arrange
        var kernel = new Kernel();
        var fakeAgent = new TestAgent() { Kernel = kernel };
        var adapter = new SemanticKernelAIAgent(fakeAgent, () => Mock.Of<AgentThread>(), (e, o) => Mock.Of<AgentThread>(), (t, o) => default);
        var serviceKey = new object();

        // Act
        var result = adapter.GetService(typeof(Kernel), serviceKey);

        // Assert
        Assert.Null(result);
    }

    [Fact]
    public void GetService_WithAgentType_ReturnsInnerAgent()
    {
        // Arrange
        var agentMock = new Mock<Agent>();
        var adapter = new SemanticKernelAIAgent(agentMock.Object, () => Mock.Of<AgentThread>(), (e, o) => Mock.Of<AgentThread>(), (t, o) => default);

        // Act
        var result = adapter.GetService(typeof(Agent));

        // Assert
        Assert.Same(agentMock.Object, result);
    }

    [Fact]
    public void GetService_WithAgentTypeAndServiceKey_ReturnsNull()
    {
        // Arrange
        var agentMock = new Mock<Agent>();
        var adapter = new SemanticKernelAIAgent(agentMock.Object, () => Mock.Of<AgentThread>(), (e, o) => Mock.Of<AgentThread>(), (t, o) => default);
        var serviceKey = new object();

        // Act
        var result = adapter.GetService(typeof(Agent), serviceKey);

        // Assert
        Assert.Null(result);
    }

    [Fact]
    public void GetService_WithNonAgentType_ReturnsNull()
    {
        // Arrange
        var agentMock = new Mock<Agent>();
        var adapter = new SemanticKernelAIAgent(agentMock.Object, () => Mock.Of<AgentThread>(), (e, o) => Mock.Of<AgentThread>(), (t, o) => default);

        // Act
        var result = adapter.GetService(typeof(string));

        // Assert
        Assert.Null(result);
    }

    [Fact]
    public void GetService_WithNullType_ThrowsArgumentNullException()
    {
        // Arrange
        var agentMock = new Mock<Agent>();
        var adapter = new SemanticKernelAIAgent(agentMock.Object, () => Mock.Of<AgentThread>(), (e, o) => Mock.Of<AgentThread>(), (t, o) => default);

        // Act & Assert
        Assert.Throws<ArgumentNullException>(() => adapter.GetService(null!));
    }

    [Fact]
    public void GetService_WithBaseClassType_ReturnsInnerAgent()
    {
        // Arrange
        var concreteAgent = new TestAgent();
        var adapter = new SemanticKernelAIAgent(concreteAgent, () => Mock.Of<AgentThread>(), (e, o) => Mock.Of<AgentThread>(), (t, o) => default);

        // Act
        var result = adapter.GetService(typeof(Agent));

        // Assert
        Assert.Same(concreteAgent, result);
    }

    [Fact]
    public void GetService_WithDerivedType_ReturnsInnerAgentWhenMatches()
    {
        // Arrange
        var concreteAgent = new TestAgent();
        var adapter = new SemanticKernelAIAgent(concreteAgent, () => Mock.Of<AgentThread>(), (e, o) => Mock.Of<AgentThread>(), (t, o) => default);

        // Act
        var result = adapter.GetService(typeof(TestAgent));

        // Assert
        Assert.Same(concreteAgent, result);
    }

    [Fact]
    public void GetService_WithIncompatibleDerivedType_ReturnsNull()
    {
        // Arrange
        var agentMock = new Mock<Agent>();
        var adapter = new SemanticKernelAIAgent(agentMock.Object, () => Mock.Of<AgentThread>(), (e, o) => Mock.Of<AgentThread>(), (t, o) => default);

        // Act
        var result = adapter.GetService(typeof(TestAgent));

        // Assert
        Assert.Null(result);
    }

    private sealed class TestAgent : Agent
    {
        public override IAsyncEnumerable<AgentResponseItem<ChatMessageContent>> InvokeAsync(ICollection<ChatMessageContent> messages, AgentThread? thread = null, AgentInvokeOptions? options = null, CancellationToken cancellationToken = default)
        {
            throw new NotImplementedException();
        }

        public override IAsyncEnumerable<AgentResponseItem<StreamingChatMessageContent>> InvokeStreamingAsync(ICollection<ChatMessageContent> messages, AgentThread? thread = null, AgentInvokeOptions? options = null, CancellationToken cancellationToken = default)
        {
            throw new NotImplementedException();
        }

        protected internal override Task<AgentChannel> CreateChannelAsync(CancellationToken cancellationToken)
        {
            throw new NotImplementedException();
        }

        protected internal override IEnumerable<string> GetChannelKeys()
        {
            throw new NotImplementedException();
        }

        protected internal override Task<AgentChannel> RestoreChannelAsync(string channelState, CancellationToken cancellationToken)
        {
            throw new NotImplementedException();
        }
    }
}


===== UnitTests\AIAgent\SemanticKernelAIAgentThreadTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents;
using Moq;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.AIAgent;

public sealed class SemanticKernelAIAgentThreadTests
{
    [Fact]
    public void Constructor_InitializesProperties()
    {
        // Arrange
        var threadMock = new Mock<AgentThread>();
        JsonElement ThreadSerializer(AgentThread t, JsonSerializerOptions? o) => default;

        // Act
        var adapter = new SemanticKernelAIAgentThread(threadMock.Object, ThreadSerializer);

        // Assert
        Assert.Equal(threadMock.Object, adapter.InnerThread);
    }

    [Fact]
    public void Serialize_CallsThreadSerializer()
    {
        // Arrange
        var threadMock = new Mock<AgentThread>();
        var serializerCallCount = 0;
        var expectedJsonElement = JsonDocument.Parse("{\"test\": \"value\"}").RootElement;

        JsonElement ThreadSerializer(AgentThread t, JsonSerializerOptions? o)
        {
            serializerCallCount++;
            Assert.Same(threadMock.Object, t);
            return expectedJsonElement;
        }

        var adapter = new SemanticKernelAIAgentThread(threadMock.Object, ThreadSerializer);

        // Act
        var result = adapter.Serialize();

        // Assert
        Assert.Equal(1, serializerCallCount);
        Assert.Equal(expectedJsonElement.ToString(), result.ToString());
    }

    [Fact]
    public void Serialize_WithJsonSerializerOptions_PassesOptionsToSerializer()
    {
        // Arrange
        var threadMock = new Mock<AgentThread>();
        var expectedOptions = new JsonSerializerOptions();
        JsonSerializerOptions? capturedOptions = null;

        JsonElement ThreadSerializer(AgentThread t, JsonSerializerOptions? o)
        {
            capturedOptions = o;
            return default;
        }

        var adapter = new SemanticKernelAIAgentThread(threadMock.Object, ThreadSerializer);

        // Act
        adapter.Serialize(expectedOptions);

        // Assert
        Assert.Same(expectedOptions, capturedOptions);
    }

    [Fact]
    public void GetService_WithAgentThreadType_ReturnsInnerThread()
    {
        // Arrange
        var threadMock = new Mock<AgentThread>();
        var adapter = new SemanticKernelAIAgentThread(threadMock.Object, (t, o) => default);

        // Act
        var result = adapter.GetService(typeof(AgentThread));

        // Assert
        Assert.Same(threadMock.Object, result);
    }

    [Fact]
    public void GetService_WithAgentThreadTypeAndServiceKey_ReturnsNull()
    {
        // Arrange
        var threadMock = new Mock<AgentThread>();
        var adapter = new SemanticKernelAIAgentThread(threadMock.Object, (t, o) => default);
        var serviceKey = new object();

        // Act
        var result = adapter.GetService(typeof(AgentThread), serviceKey);

        // Assert
        Assert.Null(result);
    }

    [Fact]
    public void GetService_WithNonAgentThreadType_ReturnsNull()
    {
        // Arrange
        var threadMock = new Mock<AgentThread>();
        var adapter = new SemanticKernelAIAgentThread(threadMock.Object, (t, o) => default);

        // Act
        var result = adapter.GetService(typeof(string));

        // Assert
        Assert.Null(result);
    }

    [Fact]
    public void GetService_WithNullType_ThrowsArgumentNullException()
    {
        // Arrange
        var threadMock = new Mock<AgentThread>();
        var adapter = new SemanticKernelAIAgentThread(threadMock.Object, (t, o) => default);

        // Act & Assert
        Assert.Throws<ArgumentNullException>(() => adapter.GetService(null!));
    }

    [Fact]
    public void Serialize_WithNullOptions_CallsSerializerWithNull()
    {
        // Arrange
        var threadMock = new Mock<AgentThread>();
        JsonSerializerOptions? capturedOptions = new();

        JsonElement ThreadSerializer(AgentThread t, JsonSerializerOptions? o)
        {
            capturedOptions = o;
            return default;
        }

        var adapter = new SemanticKernelAIAgentThread(threadMock.Object, ThreadSerializer);

        // Act
        adapter.Serialize(null);

        // Assert
        Assert.Null(capturedOptions);
    }

    [Fact]
    public void Constructor_WithNullThread_ThrowsArgumentNullException()
    {
        // Arrange & Act
        JsonElement ThreadSerializer(AgentThread t, JsonSerializerOptions? o) => default;
        Assert.Throws<ArgumentNullException>(() => new SemanticKernelAIAgentThread(null!, ThreadSerializer));
    }

    [Fact]
    public void Constructor_WithNullSerializer_ThrowsArgumentNullException()
    {
        // Arrange & Act
        var threadMock = new Mock<AgentThread>();
        Assert.Throws<ArgumentNullException>(() => new SemanticKernelAIAgentThread(threadMock.Object, null!));
    }

    [Fact]
    public void GetService_WithBaseClassType_ReturnsInnerThread()
    {
        // Arrange
        var concreteThread = new TestAgentThread();
        var adapter = new SemanticKernelAIAgentThread(concreteThread, (t, o) => default);

        // Act
        var result = adapter.GetService(typeof(AgentThread));

        // Assert
        Assert.Same(concreteThread, result);
    }

    [Fact]
    public void GetService_WithDerivedType_ReturnsInnerThreadWhenMatches()
    {
        // Arrange
        var concreteThread = new TestAgentThread();
        var adapter = new SemanticKernelAIAgentThread(concreteThread, (t, o) => default);

        // Act
        var result = adapter.GetService(typeof(TestAgentThread));

        // Assert
        Assert.Same(concreteThread, result);
    }

    [Fact]
    public void GetService_WithIncompatibleDerivedType_ReturnsNull()
    {
        // Arrange
        var threadMock = new Mock<AgentThread>();
        var adapter = new SemanticKernelAIAgentThread(threadMock.Object, (t, o) => default);

        // Act
        var result = adapter.GetService(typeof(TestAgentThread));

        // Assert
        Assert.Null(result);
    }

    [Fact]
    public void GetService_WithInterfaceType_ReturnsNull()
    {
        // Arrange
        var threadMock = new Mock<AgentThread>();
        var adapter = new SemanticKernelAIAgentThread(threadMock.Object, (t, o) => default);

        // Act
        var result = adapter.GetService(typeof(IServiceProvider));

        // Assert
        Assert.Null(result);
    }

    private sealed class TestAgentThread : AgentThread
    {
        protected override Task<string?> CreateInternalAsync(CancellationToken cancellationToken)
        {
            return Task.FromResult<string?>("test-thread-id");
        }

        protected override Task DeleteInternalAsync(CancellationToken cancellationToken)
        {
            return Task.CompletedTask;
        }

        protected override Task OnNewMessageInternalAsync(ChatMessageContent newMessage, CancellationToken cancellationToken = default)
        {
            return Task.CompletedTask;
        }
    }
}


===== UnitTests\AzureAI\AzureAIAgentExtensionsTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.ClientModel.Primitives;
using System.Text.Json;
using Azure.AI.Agents.Persistent;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.Agents.AzureAI;
using Moq;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.AzureAI;

public sealed class AzureAIAgentExtensionsTests
{
    private static readonly JsonSerializerOptions s_jsonModelConvererOptions = new() { Converters = { new JsonModelConverter() } };
    private static readonly PersistentAgent s_agentMetadata = JsonSerializer.Deserialize<PersistentAgent>(
    """
    {
        "id": "1",
        "description": "A test agent",
        "name": "TestAgent"
    }
    """, s_jsonModelConvererOptions)!;

    [Fact]
    public void AsAIAgent_WithValidAzureAIAgent_ReturnsSemanticKernelAIAgent()
    {
        // Arrange
        var clientMock = new Mock<Azure.AI.Agents.Persistent.PersistentAgentsClient>();
        var azureAIAgent = new AzureAIAgent(s_agentMetadata, clientMock.Object);

        // Act
        var result = azureAIAgent.AsAIAgent();

        // Assert
        Assert.NotNull(result);
        Assert.IsType<SemanticKernelAIAgent>(result);
    }

    [Fact]
    public void AsAIAgent_WithNullAzureAIAgent_ThrowsArgumentNullException()
    {
        // Arrange
        AzureAIAgent nullAgent = null!;

        // Act & Assert
        Assert.Throws<ArgumentNullException>(() => nullAgent.AsAIAgent());
    }

    [Fact]
    public void AsAIAgent_CreatesWorkingThreadFactory()
    {
        var clientMock = new Mock<Azure.AI.Agents.Persistent.PersistentAgentsClient>();
        var azureAIAgent = new AzureAIAgent(s_agentMetadata, clientMock.Object);

        // Act
        var result = azureAIAgent.AsAIAgent();
        var thread = result.GetNewThread();

        // Assert
        Assert.NotNull(thread);
        Assert.IsType<SemanticKernelAIAgentThread>(thread);
        var threadAdapter = (SemanticKernelAIAgentThread)thread;
        Assert.IsType<AzureAIAgentThread>(threadAdapter.InnerThread);
    }

    [Fact]
    public void AsAIAgent_ThreadDeserializationFactory_WithNullAgentId_CreatesNewThread()
    {
        // Arrange
        var clientMock = new Mock<Azure.AI.Agents.Persistent.PersistentAgentsClient>();
        var azureAIAgent = new AzureAIAgent(s_agentMetadata, clientMock.Object);
        var jsonElement = JsonSerializer.SerializeToElement((string?)null);

        // Act
        var result = azureAIAgent.AsAIAgent();
        var thread = result.DeserializeThread(jsonElement);

        // Assert
        Assert.NotNull(thread);
        Assert.IsType<SemanticKernelAIAgentThread>(thread);
        var threadAdapter = (SemanticKernelAIAgentThread)thread;
        Assert.IsType<AzureAIAgentThread>(threadAdapter.InnerThread);
    }

    [Fact]
    public void AsAIAgent_ThreadDeserializationFactory_WithValidAgentId_CreatesThreadWithId()
    {
        // Arrange
        var clientMock = new Mock<Azure.AI.Agents.Persistent.PersistentAgentsClient>();
        var azureAIAgent = new AzureAIAgent(s_agentMetadata, clientMock.Object);

        var threadId = "test-thread-id";
        var jsonElement = JsonSerializer.SerializeToElement(threadId);

        // Act
        var result = azureAIAgent.AsAIAgent();
        var thread = result.DeserializeThread(jsonElement);

        // Assert
        Assert.NotNull(thread);
        Assert.IsType<SemanticKernelAIAgentThread>(thread);
        var threadAdapter = (SemanticKernelAIAgentThread)thread;
        Assert.IsType<AzureAIAgentThread>(threadAdapter.InnerThread);
        Assert.Equal(threadId, threadAdapter.InnerThread.Id);
    }

    [Fact]
    public void AsAIAgent_ThreadSerializer_SerializesThreadId()
    {
        // Arrange
        var clientMock = new Mock<Azure.AI.Agents.Persistent.PersistentAgentsClient>();
        var azureAIAgent = new AzureAIAgent(s_agentMetadata, clientMock.Object);

        var expectedThreadId = "test-thread-id";
        var azureAIThread = new AzureAIAgentThread(clientMock.Object, expectedThreadId);
        var jsonElement = JsonSerializer.SerializeToElement(expectedThreadId);

        var result = azureAIAgent.AsAIAgent();
        var thread = result.DeserializeThread(jsonElement);

        // Act
        var serializedElement = thread.Serialize();

        // Assert
        Assert.Equal(JsonValueKind.String, serializedElement.ValueKind);
        Assert.Equal(expectedThreadId, serializedElement.GetString());
    }
}


===== UnitTests\AzureAI\AzureAIAgentInvokeOptionsTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.Agents.AzureAI;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.AzureAI;

/// <summary>
/// Tests for <see cref="AzureAIAgentInvokeOptions"/>.
/// </summary>
public class AzureAIAgentInvokeOptionsTests
{
    /// <summary>
    /// Tests the constructor of <see cref="AzureAIAgentInvokeOptions"/> to ensure it correctly clones properties from the base class.
    /// </summary>
    [Fact]
    public void ConstructorShouldClonePropertiesCorrectly()
    {
        // Arrange
        var originalOptions = new AzureAIAgentInvokeOptions
        {
            ModelName = "TestModel",
            AdditionalMessages = new List<ChatMessageContent>(),
            EnableCodeInterpreter = true,
            EnableFileSearch = true,
            EnableJsonResponse = true,
            MaxCompletionTokens = 100,
            MaxPromptTokens = 50,
            ParallelToolCallsEnabled = true,
            TruncationMessageCount = 10,
            Temperature = 0.5f,
            TopP = 0.9f,
            Metadata = new Dictionary<string, string> { { "key", "value" } }
        };

        // Act
        var clonedOptions = new AzureAIAgentInvokeOptions(originalOptions);

        // Assert
        Assert.Equal(originalOptions.ModelName, clonedOptions.ModelName);
        Assert.Equal(originalOptions.AdditionalMessages, clonedOptions.AdditionalMessages);
        Assert.Equal(originalOptions.EnableCodeInterpreter, clonedOptions.EnableCodeInterpreter);
        Assert.Equal(originalOptions.EnableFileSearch, clonedOptions.EnableFileSearch);
        Assert.Equal(originalOptions.EnableJsonResponse, clonedOptions.EnableJsonResponse);
        Assert.Equal(originalOptions.MaxCompletionTokens, clonedOptions.MaxCompletionTokens);
        Assert.Equal(originalOptions.MaxPromptTokens, clonedOptions.MaxPromptTokens);
        Assert.Equal(originalOptions.ParallelToolCallsEnabled, clonedOptions.ParallelToolCallsEnabled);
        Assert.Equal(originalOptions.TruncationMessageCount, clonedOptions.TruncationMessageCount);
        Assert.Equal(originalOptions.Temperature, clonedOptions.Temperature);
        Assert.Equal(originalOptions.TopP, clonedOptions.TopP);
        Assert.Equal(originalOptions.Metadata, clonedOptions.Metadata);
    }

    /// <summary>
    /// Tests the constructor of <see cref="AzureAIAgentInvokeOptions"/> to ensure it correctly clones properties from an instance of <see cref="AgentInvokeOptions"/>.
    /// </summary>
    [Fact]
    public void ConstructorShouldCloneAgentInvokeOptionsPropertiesCorrectly()
    {
        // Arrange
        var originalOptions = new AgentInvokeOptions
        {
            AdditionalInstructions = "Test instructions"
        };

        // Act
        var clonedOptions = new AzureAIAgentInvokeOptions(originalOptions);

        // Assert
        Assert.Equal(originalOptions.AdditionalInstructions, clonedOptions.AdditionalInstructions);
    }
}


===== UnitTests\AzureAI\AzureAIAssistantInvocationOptionsTests.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Collections.Generic;
using System.Text.Json;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents.AzureAI;
using Microsoft.SemanticKernel.ChatCompletion;
using SemanticKernel.Agents.UnitTests.Test;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.AzureAI;

/// <summary>
/// Unit testing of <see cref="AzureAIInvocationOptions"/>.
/// </summary>
public class AzureAIAssistantInvocationOptionsTests
{
    /// <summary>
    /// Verify initial state.
    /// </summary>
    [Fact]
    public void OpenAIAssistantInvocationOptionsInitialState()
    {
        // Arrange
        AzureAIInvocationOptions options = new();

        // Assert
        Assert.Null(options.ModelName);
        Assert.Null(options.AdditionalInstructions);
        Assert.Null(options.AdditionalMessages);
        Assert.Null(options.Metadata);
        Assert.Null(options.Temperature);
        Assert.Null(options.TopP);
        Assert.Null(options.ParallelToolCallsEnabled);
        Assert.Null(options.MaxCompletionTokens);
        Assert.Null(options.MaxPromptTokens);
        Assert.Null(options.TruncationMessageCount);
        Assert.Null(options.EnableJsonResponse);
        Assert.False(options.EnableCodeInterpreter);
        Assert.False(options.EnableFileSearch);

        // Act and Assert
        ValidateSerialization(options);
    }

    /// <summary>
    /// Verify initialization.
    /// </summary>
    [Fact]
    public void OpenAIAssistantInvocationOptionsAssignment()
    {
        // Arrange
        AzureAIInvocationOptions options =
            new()
            {
                ModelName = "testmodel",
                AdditionalInstructions = "test instructions",
                AdditionalMessages = [
                    new ChatMessageContent(AuthorRole.User, "test message")
                ],
                Metadata = new Dictionary<string, string>() { { "a", "1" } },
                MaxCompletionTokens = 1000,
                MaxPromptTokens = 1000,
                ParallelToolCallsEnabled = false,
                TruncationMessageCount = 12,
                Temperature = 2,
                TopP = 0,
                EnableCodeInterpreter = true,
                EnableJsonResponse = true,
                EnableFileSearch = true,
            };

        // Assert
        Assert.Equal("testmodel", options.ModelName);
        Assert.Equal("test instructions", options.AdditionalInstructions);
        Assert.Single(options.AdditionalMessages);
        Assert.Equal(2, options.Temperature);
        Assert.Equal(0, options.TopP);
        Assert.Equal(1000, options.MaxCompletionTokens);
        Assert.Equal(1000, options.MaxPromptTokens);
        Assert.Equal(12, options.TruncationMessageCount);
        Assert.False(options.ParallelToolCallsEnabled);
        Assert.Single(options.Metadata);
        Assert.True(options.EnableCodeInterpreter);
        Assert.True(options.EnableJsonResponse);
        Assert.True(options.EnableFileSearch);

        // Act and Assert
        ValidateSerialization(options);
    }

    private static void ValidateSerialization(AzureAIInvocationOptions source)
    {
        // Act
        string json = JsonSerializer.Serialize(source);

        AzureAIInvocationOptions? target = JsonSerializer.Deserialize<AzureAIInvocationOptions>(json);

        // Assert
        Assert.NotNull(target);
        Assert.Equal(source.AdditionalInstructions, target.AdditionalInstructions);
        Assert.Equivalent(source.AdditionalMessages, target.AdditionalMessages);
        Assert.Equal(source.ModelName, target.ModelName);
        Assert.Equal(source.Temperature, target.Temperature);
        Assert.Equal(source.TopP, target.TopP);
        Assert.Equal(source.MaxCompletionTokens, target.MaxCompletionTokens);
        Assert.Equal(source.MaxPromptTokens, target.MaxPromptTokens);
        Assert.Equal(source.TruncationMessageCount, target.TruncationMessageCount);
        Assert.Equal(source.EnableCodeInterpreter, target.EnableCodeInterpreter);
        Assert.Equal(source.EnableJsonResponse, target.EnableJsonResponse);
        Assert.Equal(source.EnableFileSearch, target.EnableFileSearch);
        AssertCollection.Equal(source.Metadata, target.Metadata);
    }
}


===== UnitTests\AzureAI\Definition\AzureAIAgentFactoryTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Net;
using System.Net.Http;
using System.Threading.Tasks;
using Azure.AI.Agents.Persistent;
using Azure.AI.Projects;
using Azure.Core.Pipeline;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.Agents.AzureAI;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.AzureAI.Definition;

/// <summary>
/// Unit tests for <see cref="AzureAIAgentFactory"/>.
/// </summary>
public class AzureAIAgentFactoryTests : IDisposable
{
    private readonly HttpMessageHandlerStub _messageHandlerStub;
    private readonly HttpClient _httpClient;
    private readonly Kernel _kernel;

    /// <summary>
    /// Initializes a new instance of the <see cref="AzureAIAgentFactoryTests"/> class.
    /// </summary>
    public AzureAIAgentFactoryTests()
    {
        this._messageHandlerStub = new HttpMessageHandlerStub();
        this._httpClient = new HttpClient(this._messageHandlerStub, disposeHandler: false);

        var builder = Kernel.CreateBuilder();
        var client = new PersistentAgentsClient(
            "https://test",
            new FakeTokenCredential(),
            new PersistentAgentsAdministrationClientOptions
            {
                Transport = new HttpClientTransport(this._httpClient)
            });
        builder.Services.AddSingleton(client);
        var projectClient = new AIProjectClient(
            new Uri("https://test"),
            new FakeTokenCredential());
        builder.Services.AddSingleton(projectClient);
        this._kernel = builder.Build();
    }

    /// <inheritdoc/>
    public void Dispose()
    {
        GC.SuppressFinalize(this);
        this._messageHandlerStub.Dispose();
        this._httpClient.Dispose();
    }

    /// <summary>
    /// Verify can create an instance of <see cref="Microsoft.SemanticKernel.Agents.Agent"/> using <see cref="AzureAIAgentFactory"/>
    /// </summary>
    [Fact]
    public async Task VerifyCanCreateAzureAIAgentAsync()
    {
        // Arrange
        AgentDefinition agentDefinition = new()
        {
            Type = AzureAIAgentFactory.AzureAIAgentType,
            Name = "AzureAIAgent",
            Description = "AzureAIAgent Description",
            Instructions = "AzureAIAgent Instructions",
            Model = new()
            {
                Id = "gpt-4o-mini"
            },
            Tools = [
                new Microsoft.SemanticKernel.Agents.AgentToolDefinition()
                {
                    Id = "tool1",
                    Type = "code_interpreter",
                },
            ]
        };
        AzureAIAgentFactory factory = new();
        using var responseMessage = this.SetupResponse(HttpStatusCode.OK, AzureAIAgentCreateResponse);

        // Act
        var agent = await factory.CreateAsync(this._kernel, agentDefinition);

        // Assert
        Assert.NotNull(agent);
        Assert.Equal("asst_thdyqg4yVC9ffeILVdEWLONT", agent.Id);
        Assert.Equal(agentDefinition.Name, agent.Name);
        Assert.Equal(agentDefinition.Description, agent.Description);
        Assert.Equal(agentDefinition.Instructions, agent.Instructions);
        Assert.Equal(this._kernel, agent.Kernel);
    }

    /// <summary>
    /// Verify can create an instance of <see cref="Microsoft.SemanticKernel.Agents.Agent"/> using <see cref="AzureAIAgentFactory"/>
    /// </summary>
    [Fact]
    public async Task VerifyCanGetAzureAIAgentAsync()
    {
        // Arrange
        AgentDefinition agentDefinition = new()
        {
            Id = "asst_oKtAcmYQCtTj95BxpvL1RQBP",
            Type = AzureAIAgentFactory.AzureAIAgentType,
        };
        AzureAIAgentFactory factory = new();
        using var responseMessage = this.SetupResponse(HttpStatusCode.OK, AzureAIAgentGetResponse);

        // Act
        var agent = await factory.CreateAsync(this._kernel, agentDefinition);

        // Assert
        Assert.NotNull(agent);
        Assert.Equal("asst_oKtAcmYQCtTj95BxpvL1RQBP", agent.Id);
        Assert.Equal("HelpfulAssistant", agent.Name);
        Assert.Equal("Helpful Assistant", agent.Description);
        Assert.Equal("You are a helpful assistant.", agent.Instructions);
        Assert.Equal(this._kernel, agent.Kernel);
    }

    /// <summary>
    /// Azure AI Agent create response.
    /// </summary>
    public const string AzureAIAgentCreateResponse =
        """
        {
          "id": "asst_thdyqg4yVC9ffeILVdEWLONT",
          "object": "assistant",
          "created_at": 1739991984,
          "name": "AzureAIAgent",
          "description": "AzureAIAgent Description",
          "model": "gpt-4o",
          "instructions": "AzureAIAgent Instructions",
          "tools": [],
          "top_p": 1.0,
          "temperature": 1.0,
          "tool_resources": {},
          "metadata": {},
          "response_format": "auto"
        }
        """;

    /// <summary>
    /// Azure AI Agent create response.
    /// </summary>
    public const string ProjectBingGroundingConnectionResponse =
        """
        {
          "value": [
            {
              "name": "test_connection",
              "id": "unique-id",
              "type": "AzureOpenAI",
              "target": "bbzo",
              "isDefault": true,
              "credentials": {
                "type": "BaseCredentials"
              },
              "metadata": {}
            }
          ]
        }
        """;

    /// <summary>
    /// Azure AI Agent get response.
    /// </summary>
    public const string AzureAIAgentGetResponse =
        """
        {
          "id": "asst_oKtAcmYQCtTj95BxpvL1RQBP",
          "object": "assistant",
          "created_at": 1744215200,
          "name": "HelpfulAssistant",
          "description": "Helpful Assistant",
          "model": "gpt-4o-mini",
          "instructions": "You are a helpful assistant.",
          "tools": [],
          "top_p": 1.0,
          "temperature": 1.0,
          "tool_resources": {},
          "metadata": {},
          "response_format": "auto"
        }
        """;

    #region private
    private HttpResponseMessage SetupResponse(HttpStatusCode statusCode, string response)
    {
        var responseMessage = new HttpResponseMessage(statusCode)
        {
            Content = new StringContent(response)
        };

        this._messageHandlerStub.ResponseQueue.Enqueue(responseMessage);

        return responseMessage;
    }
    #endregion
}


===== UnitTests\AzureAI\Extensions\AgentDefinitionExtensionsTests.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Linq;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.Agents.AzureAI;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.AzureAI.Extensions;

/// <summary>
/// Unit tests for YamlAgentDefinitionExtensions
/// </summary>
public class AgentDefinitionExtensionsTests
{
    /// <summary>
    /// Verify GetAzureToolDefinitions
    /// </summary>
    [Fact]
    public void VerifyGetAzureToolDefinitions()
    {
        // Arrange
        AgentDefinition agentDefinition = new()
        {
            Tools = [
                new AgentToolDefinition()
                {
                    Id = "tool1",
                    Type = "code_interpreter",
                },
                new AgentToolDefinition()
                {
                    Id = "tool2",
                    Type = "file_search",
                },
            ]
        };

        // Act
        var toolDefinitions = agentDefinition.GetAzureToolDefinitions(new Kernel());

        // Assert
        Assert.NotNull(toolDefinitions);
        Assert.Equal(2, toolDefinitions.Count());
    }

    /// <summary>
    /// Verify GetMetadata
    /// </summary>
    [Fact]
    public void VerifyGetMetadata()
    {
        // Arrange
        AgentDefinition agentDefinition = new()
        {
        };

        // Act
        var metadata = agentDefinition.GetMetadata();

        // Assert
        Assert.Null(metadata);
    }
}


===== UnitTests\AzureAI\Extensions\KernelFunctionExtensionsTests.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.ComponentModel;
using Azure.AI.Agents.Persistent;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents.AzureAI;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.OpeAzureAInAI.Extensions;

/// <summary>
/// Unit testing of <see cref="Microsoft.SemanticKernel.Agents.AzureAI.KernelFunctionExtensions"/>.
/// </summary>
public class KernelFunctionExtensionsTests
{
    /// <summary>
    /// Verify conversion from <see cref="KernelFunction"/> to <see cref="FunctionToolDefinition"/>.
    /// </summary>
    [Fact]
    public void VerifyKernelFunctionToFunctionTool()
    {
        // Arrange
        KernelPlugin plugin = KernelPluginFactory.CreateFromType<TestPlugin>();

        // Assert
        Assert.Equal(2, plugin.FunctionCount);

        // Arrange
        KernelFunction f1 = plugin[nameof(TestPlugin.TestFunction1)];
        KernelFunction f2 = plugin[nameof(TestPlugin.TestFunction2)];

        // Act
        FunctionToolDefinition definition1 = f1.ToToolDefinition("testplugin");

        // Assert
        Assert.StartsWith($"testplugin-{nameof(TestPlugin.TestFunction1)}", definition1.Name, StringComparison.Ordinal);
        Assert.Equal("test description", definition1.Description);

        // Act
        FunctionToolDefinition definition2 = f2.ToToolDefinition("testplugin");

        // Assert
        Assert.StartsWith($"testplugin-{nameof(TestPlugin.TestFunction2)}", definition2.Name, StringComparison.Ordinal);
        Assert.Equal("test description", definition2.Description);
    }

    /// <summary>
    /// Exists only for parsing.
    /// </summary>
#pragma warning disable CA1812 // Avoid uninstantiated internal classes
    private sealed class TestPlugin()
#pragma warning restore CA1812 // Avoid uninstantiated internal classes
    {
        [KernelFunction]
        [Description("test description")]
        public void TestFunction1() { }

        [KernelFunction]
        [Description("test description")]
#pragma warning disable IDE0060 // Unused parameter for mock kernel function
        public void TestFunction2(string p1, bool p2, int p3, string[] p4, ConsoleColor p5, DateTime p6) { }
#pragma warning restore IDE0060 // Unused parameter
    }
}


===== UnitTests\AzureAI\Internal\AgentMessageFactoryTests.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using Azure.AI.Agents.Persistent;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents.AzureAI;
using Microsoft.SemanticKernel.Agents.AzureAI.Internal;
using Microsoft.SemanticKernel.ChatCompletion;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.AzureAI.Internal;

/// <summary>
/// Unit testing of <see cref="AgentMessageFactory"/>.
/// </summary>
public class AgentMessageFactoryTests
{
    /// <summary>
    /// Verify options creation.
    /// </summary>
    [Fact]
    public void VerifyAssistantMessageAdapterGetMessageContentsWithText()
    {
        // Arrange
        ChatMessageContent message = new(AuthorRole.User, items: [new TextContent("test")]);

        // Act
        ThreadMessageOptions[] contents = [.. AgentMessageFactory.GetThreadMessages([message])];

        // Assert
        Assert.NotNull(contents);
        Assert.Single(contents);
        Assert.NotNull(contents[0].Content);
    }

    /// <summary>
    /// Verify options creation.
    /// </summary>
    [Fact]
    public void VerifyAssistantMessageAdapterGetMessageWithImageUrl()
    {
        // Arrange
        ChatMessageContent message = new(AuthorRole.User, items: [new ImageContent(new Uri("https://localhost/myimage.png"))]);

        // Act
        ThreadMessageOptions[] contents = [.. AgentMessageFactory.GetThreadMessages([message])];

        // Assert
        Assert.NotNull(contents);
        Assert.Empty(contents);
    }

    /// <summary>
    /// Verify options creation.
    /// </summary>
    [Fact]
    public void VerifyAssistantMessageAdapterGetMessageWithImageData()
    {
        // Arrange
        ChatMessageContent message = new(AuthorRole.User, items: [new ImageContent(new byte[] { 1, 2, 3 }, "image/png") { DataUri = "data:image/png;base64,MTIz" }]);

        // Act
        ThreadMessageOptions[] contents = [.. AgentMessageFactory.GetThreadMessages([message])];

        // Assert
        Assert.NotNull(contents);
        Assert.Empty(contents);
    }

    /// <summary>
    /// Verify options creation.
    /// </summary>
    [Fact]
    public void VerifyAssistantMessageAdapterGetMessageWithImageFile()
    {
        // Arrange
        ChatMessageContent message = new(AuthorRole.User, items: [new FileReferenceContent("file-id")]);

        // Act
        ThreadMessageOptions[] contents = [.. AgentMessageFactory.GetThreadMessages([message])];

        // Assert
        Assert.NotNull(contents);
        Assert.Empty(contents);
    }

    /// <summary>
    /// Verify options creation.
    /// </summary>
    [Fact]
    public void VerifyAssistantMessageAdapterGetMessageWithAll()
    {
        // Arrange
        ChatMessageContent message =
            new(
                AuthorRole.User,
                items:
                [
                    new TextContent("test"),
                    new ImageContent(new Uri("https://localhost/myimage.png")),
                    new FileReferenceContent("file-id1"),
                    new FileReferenceContent("file-id2") { Tools = [AzureAIAgent.Tools.CodeInterpreter] }
                ]);

        // Act
        ThreadMessageOptions[] contents = [.. AgentMessageFactory.GetThreadMessages([message])];

        // Assert
        Assert.NotNull(contents);
        Assert.Single(contents);
        Assert.NotNull(contents[0].Content);
        Assert.Single(contents[0].Attachments);
    }
}


===== UnitTests\AzureAI\RunPollingOptionsTests.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using Microsoft.SemanticKernel.Agents.AzureAI;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.AzureAI;

/// <summary>
/// Unit testing of <see cref="RunPollingOptions"/>.
/// </summary>
public class RunPollingOptionsTests
{
    /// <summary>
    /// Verify initial state.
    /// </summary>
    [Fact]
    public void RunPollingOptionsInitialStateTest()
    {
        // Arrange
        RunPollingOptions options = new();

        // Assert
        Assert.Equal(RunPollingOptions.DefaultPollingInterval, options.RunPollingInterval);
        Assert.Equal(RunPollingOptions.DefaultPollingBackoff, options.RunPollingBackoff);
        Assert.Equal(RunPollingOptions.DefaultMessageSynchronizationDelay, options.MessageSynchronizationDelay);
        Assert.Equal(RunPollingOptions.DefaultPollingBackoffThreshold, options.RunPollingBackoffThreshold);
    }

    /// <summary>s
    /// Verify initialization.
    /// </summary>
    [Fact]
    public void RunPollingOptionsAssignmentTest()
    {
        // Arrange
        RunPollingOptions options =
            new()
            {
                RunPollingInterval = TimeSpan.FromSeconds(3),
                RunPollingBackoff = TimeSpan.FromSeconds(4),
                RunPollingBackoffThreshold = 8,
                MessageSynchronizationDelay = TimeSpan.FromSeconds(5),
            };

        // Assert
        Assert.Equal(3, options.RunPollingInterval.TotalSeconds);
        Assert.Equal(4, options.RunPollingBackoff.TotalSeconds);
        Assert.Equal(5, options.MessageSynchronizationDelay.TotalSeconds);
        Assert.Equal(8, options.RunPollingBackoffThreshold);
    }

    /// <summary>s
    /// Verify initialization.
    /// </summary>
    [Fact]
    public void RunPollingOptionsGetIntervalTest()
    {
        // Arrange
        RunPollingOptions options =
            new()
            {
                RunPollingInterval = TimeSpan.FromSeconds(3),
                RunPollingBackoff = TimeSpan.FromSeconds(4),
                RunPollingBackoffThreshold = 8,
            };

        // Assert
        Assert.Equal(options.RunPollingInterval, options.GetPollingInterval(8));
        Assert.Equal(options.RunPollingBackoff, options.GetPollingInterval(9));
    }
}


===== UnitTests\Bedrock\BedrockAgentChannelTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Amazon.BedrockAgent;
using Amazon.BedrockAgentRuntime;
using Amazon.BedrockAgentRuntime.Model;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents.Bedrock;
using Microsoft.SemanticKernel.ChatCompletion;
using Moq;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.Bedrock;

/// <summary>
/// Unit testing of <see cref="BedrockAgentChannel"/>.
/// </summary>
public class BedrockAgentChannelTests
{
    private readonly Amazon.BedrockAgent.Model.Agent _agentModel = new()
    {
        AgentId = "1234567890",
        AgentName = "testName",
        Description = "test description",
        Instruction = "Instruction must have at least 40 characters",
    };

    /// <summary>
    /// Verify the simple scenario of receiving messages in a <see cref="BedrockAgentChannel"/>.
    /// </summary>
    [Fact]
    public async Task VerifyReceiveAsync()
    {
        // Arrange
        BedrockAgentChannel channel = new();
        List<ChatMessageContent> history = this.CreateNormalHistory();

        // Act
        await channel.ReceiveAsync(history);

        // Assert
        Assert.Equal(2, await channel.GetHistoryAsync().CountAsync());
    }

    /// <summary>
    /// Verify the <see cref="BedrockAgentChannel"/> skips messages with empty content.
    /// </summary>
    [Fact]
    public async Task VerifyReceiveWithEmptyContentAsync()
    {
        // Arrange
        BedrockAgentChannel channel = new();
        List<ChatMessageContent> history = [
            new ChatMessageContent()
            {
                Role = AuthorRole.User,
            },
        ];

        // Act
        await channel.ReceiveAsync(history);

        // Assert
        Assert.Empty(await channel.GetHistoryAsync().ToArrayAsync());
    }

    /// <summary>
    /// Verify the channel inserts placeholders when the message sequence is incorrect.
    /// </summary>
    [Fact]
    public async Task VerifyReceiveWithIncorrectSequenceAsync()
    {
        // Arrange
        BedrockAgentChannel channel = new();
        List<ChatMessageContent> history = this.CreateIncorrectSequenceHistory();

        // Act
        await channel.ReceiveAsync(history);

        // Assert that a user message is inserted between the two agent messages.
        // Note that `GetHistoryAsync` returns the history in a reversed order.
        Assert.Equal(6, await channel.GetHistoryAsync().CountAsync());
        Assert.Equal(AuthorRole.User, (await channel.GetHistoryAsync().ToArrayAsync())[3].Role);
    }

    /// <summary>
    /// Verify the channel empties the history when reset.
    /// </summary>
    [Fact]
    public async Task VerifyResetAsync()
    {
        // Arrange
        BedrockAgentChannel channel = new();
        List<ChatMessageContent> history = this.CreateNormalHistory();

        // Act
        await channel.ReceiveAsync(history);

        // Assert
        Assert.NotEmpty(await channel.GetHistoryAsync().ToArrayAsync());

        // Act
        await channel.ResetAsync();

        // Assert
        Assert.Empty(await channel.GetHistoryAsync().ToArrayAsync());
    }

    /// <summary>
    /// Verify the channel correctly prepares the history for invocation.
    /// </summary>
    [Fact]
    public async Task VerifyInvokeAsync()
    {
        // Arrange
        var (mockClient, mockRuntimeClient) = this.CreateMockClients();
        BedrockAgent agent = new(this._agentModel, mockClient.Object, mockRuntimeClient.Object);

        BedrockAgentChannel channel = new();
        List<ChatMessageContent> history = this.CreateIncorrectSequenceHistory();

        // Act
        async Task InvokeAgent()
        {
            await channel.ReceiveAsync(history);
            await foreach (var _ in channel.InvokeAsync(agent))
            {
                continue;
            }
        }

        // Assert
        await Assert.ThrowsAsync<HttpOperationException>(() => InvokeAgent());
        mockRuntimeClient.Verify(x => x.InvokeAgentAsync(
            It.Is<InvokeAgentRequest>(r =>
                r.AgentAliasId == BedrockAgent.WorkingDraftAgentAlias
                && r.AgentId == this._agentModel.AgentId
                && r.InputText == "[SILENCE]"   // Inserted by `EnsureLastMessageIsUser`.
                && r.SessionState.ConversationHistory.Messages.Count == 6   // There is also a user message inserted between the two agent messages.
            ),
            It.IsAny<CancellationToken>()
        ), Times.Once);
    }

    /// <summary>
    /// Verify the channel returns an empty stream when invoking with an empty history.
    /// </summary>
    [Fact]
    public async Task VerifyInvokeWithEmptyHistoryAsync()
    {
        // Arrange
        var (mockClient, mockRuntimeClient) = this.CreateMockClients();
        BedrockAgent agent = new(this._agentModel, mockClient.Object, mockRuntimeClient.Object);

        BedrockAgentChannel channel = new();

        // Act
        List<ChatMessageContent> history = [];
        await foreach ((bool _, ChatMessageContent Message) in channel.InvokeAsync(agent))
        {
            history.Add(Message);
        }

        // Assert
        Assert.Empty(history);
    }

    /// <summary>
    /// Verify the channel correctly prepares the history for streaming invocation.
    /// </summary>
    [Fact]
    public async Task VerifyInvokeStreamAsync()
    {
        // Arrange
        var (mockClient, mockRuntimeClient) = this.CreateMockClients();
        BedrockAgent agent = new(this._agentModel, mockClient.Object, mockRuntimeClient.Object);

        BedrockAgentChannel channel = new();
        List<ChatMessageContent> history = this.CreateIncorrectSequenceHistory();

        // Act
        async Task InvokeAgent()
        {
            await channel.ReceiveAsync(history);
            await foreach (var _ in channel.InvokeStreamingAsync(agent, []))
            {
                continue;
            }
        }

        // Assert
        await Assert.ThrowsAsync<HttpOperationException>(() => InvokeAgent());
        mockRuntimeClient.Verify(x => x.InvokeAgentAsync(
            It.Is<InvokeAgentRequest>(r =>
                r.AgentAliasId == BedrockAgent.WorkingDraftAgentAlias
                && r.AgentId == this._agentModel.AgentId
                && r.InputText == "[SILENCE]"   // Inserted by `EnsureLastMessageIsUser`.
                && r.SessionState.ConversationHistory.Messages.Count == 6   // There is also a user message inserted between the two agent messages.
            ),
            It.IsAny<CancellationToken>()
        ), Times.Once);
    }

    /// <summary>
    /// Verify the channel returns an empty stream when invoking with an empty history.
    /// </summary>
    [Fact]
    public async Task VerifyInvokeStreamingWithEmptyHistoryAsync()
    {
        // Arrange
        var (mockClient, mockRuntimeClient) = this.CreateMockClients();
        BedrockAgent agent = new(this._agentModel, mockClient.Object, mockRuntimeClient.Object);

        BedrockAgentChannel channel = new();

        // Act
        List<StreamingChatMessageContent> history = [];
        await foreach (var message in channel.InvokeStreamingAsync(agent, []))
        {
            history.Add(message);
        }

        // Assert
        Assert.Empty(history);
    }

    private List<ChatMessageContent> CreateNormalHistory()
    {
        return
        [
            new ChatMessageContent(AuthorRole.User, "Hi!"),
            new ChatMessageContent(AuthorRole.Assistant, "Hi, how can I help you?"),
        ];
    }

    private List<ChatMessageContent> CreateIncorrectSequenceHistory()
    {
        return
        [
            new ChatMessageContent(AuthorRole.User, "What is a word that starts with 'x'?"),
            new ChatMessageContent(AuthorRole.Assistant, "Xylophone.")
            {
                AuthorName = "Agent 1"
            },
            new ChatMessageContent(AuthorRole.Assistant, "Xenon.")
            {
                AuthorName = "Agent 2"
            },
            new ChatMessageContent(AuthorRole.User, "Thanks!"),
            new ChatMessageContent(AuthorRole.Assistant, "Is there anything else you need?")
            {
                AuthorName = "Agent 1"
            },
        ];
    }

    private (Mock<IAmazonBedrockAgent>, Mock<IAmazonBedrockAgentRuntime>) CreateMockClients()
    {
        Mock<IAmazonBedrockAgent> mockClient = new();
        Mock<IAmazonBedrockAgentRuntime> mockRuntimeClient = new();
#pragma warning disable CA2000 // Dispose objects before losing scope
        mockRuntimeClient.Setup(x => x.InvokeAgentAsync(
            It.IsAny<InvokeAgentRequest>(),
            It.IsAny<CancellationToken>())
        ).ReturnsAsync(new InvokeAgentResponse()
        {
            // It's not important what the response is for this test.
            // And it's difficult to mock the response stream.
            // Tests should expect an exception to be thrown.
            HttpStatusCode = System.Net.HttpStatusCode.NotFound,
        });
#pragma warning restore CA2000 // Dispose objects before losing scope

        return (mockClient, mockRuntimeClient);
    }
}


===== UnitTests\Bedrock\BedrockAgentTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.ComponentModel;
using System.Threading;
using System.Threading.Tasks;
using Amazon.BedrockAgent;
using Amazon.BedrockAgent.Model;
using Amazon.BedrockAgentRuntime;
using Amazon.BedrockAgentRuntime.Model;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.Agents.Bedrock;
using Microsoft.SemanticKernel.ChatCompletion;
using Moq;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.Bedrock;

/// <summary>
/// Unit testing of <see cref="BedrockAgent"/>.
/// </summary>
public class BedrockAgentTests
{
    private readonly Amazon.BedrockAgent.Model.Agent _agentModel = new()
    {
        AgentId = "1234567890",
        AgentName = "testName",
        Description = "test description",
        Instruction = "Instruction must have at least 40 characters",
    };

    private readonly CreateAgentRequest _createAgentRequest = new()
    {
        AgentName = "testName",
        Description = "test description",
        Instruction = "Instruction must have at least 40 characters",
    };

    /// <summary>
    /// Verify the initialization of <see cref="BedrockAgent"/>.
    /// </summary>
    [Fact]
    public void VerifyBedrockAgentDefinition()
    {
        // Arrange
        var (mockClient, mockRuntimeClient) = this.CreateMockClients();
        BedrockAgent agent = new(this._agentModel, mockClient.Object, mockRuntimeClient.Object);

        // Assert
        this.VerifyAgent(agent);
    }

    /// <summary>
    /// Verify the creation of <see cref="BedrockAgent"/> without specialized settings.
    /// </summary>
    [Fact]
    public async Task VerifyBedrockAgentCreateAsync()
    {
        // Arrange
        var (mockClient, mockRuntimeClient) = this.CreateMockClients();
        var agentModel = await mockClient.Object.CreateAndPrepareAgentAsync(this._createAgentRequest);

        // Act
        var bedrockAgent = new BedrockAgent(agentModel, mockClient.Object, mockRuntimeClient.Object);

        // Assert
        this.VerifyAgent(bedrockAgent);
    }

    /// <summary>
    /// Verify the creation of <see cref="BedrockAgent"/> with action groups.
    /// </summary>
    [Fact]
    public async Task VerifyBedrockAgentCreateWithActionGroupsAsync()
    {
        // Arrange
        var (mockClient, mockRuntimeClient) = this.CreateMockClients();
        // Mock the creation of an agent action group.
        mockClient.Setup(x => x.CreateAgentActionGroupAsync(
            It.IsAny<CreateAgentActionGroupRequest>(),
            default)
        ).ReturnsAsync(new CreateAgentActionGroupResponse());
        // Override the sequence of calls to GetAgentAsync to return the agent status
        // because creating an agent action group will require the agent to be prepared again.
        mockClient.SetupSequence(x => x.GetAgentAsync(
            It.IsAny<GetAgentRequest>(),
            default)
        ).ReturnsAsync(new GetAgentResponse
        {
            Agent = new Amazon.BedrockAgent.Model.Agent()
            {
                AgentId = this._agentModel.AgentId,
                AgentName = this._agentModel.AgentName,
                Description = this._agentModel.Description,
                Instruction = this._agentModel.Instruction,
                AgentStatus = AgentStatus.NOT_PREPARED,
            }
        }).ReturnsAsync(new GetAgentResponse
        {
            Agent = new Amazon.BedrockAgent.Model.Agent()
            {
                AgentId = this._agentModel.AgentId,
                AgentName = this._agentModel.AgentName,
                Description = this._agentModel.Description,
                Instruction = this._agentModel.Instruction,
                AgentStatus = AgentStatus.PREPARING,
            }
        }).ReturnsAsync(new GetAgentResponse
        {
            Agent = new Amazon.BedrockAgent.Model.Agent()
            {
                AgentId = this._agentModel.AgentId,
                AgentName = this._agentModel.AgentName,
                Description = this._agentModel.Description,
                Instruction = this._agentModel.Instruction,
                AgentStatus = AgentStatus.PREPARED,
            }
        }).ReturnsAsync(new GetAgentResponse
        {
            Agent = new Amazon.BedrockAgent.Model.Agent()
            {
                AgentId = this._agentModel.AgentId,
                AgentName = this._agentModel.AgentName,
                Description = this._agentModel.Description,
                Instruction = this._agentModel.Instruction,
                AgentStatus = AgentStatus.PREPARING,
            }
        }).ReturnsAsync(new GetAgentResponse
        {
            Agent = new Amazon.BedrockAgent.Model.Agent()
            {
                AgentId = this._agentModel.AgentId,
                AgentName = this._agentModel.AgentName,
                Description = this._agentModel.Description,
                Instruction = this._agentModel.Instruction,
                AgentStatus = AgentStatus.PREPARED,
            }
        });
        var agentModel = await mockClient.Object.CreateAndPrepareAgentAsync(this._createAgentRequest);

        // Act
        var bedrockAgent = new BedrockAgent(agentModel, mockClient.Object, mockRuntimeClient.Object);
        await bedrockAgent.CreateCodeInterpreterActionGroupAsync();

        // Assert
        this.VerifyAgent(bedrockAgent);
        mockClient.Verify(x => x.CreateAgentActionGroupAsync(
            It.IsAny<CreateAgentActionGroupRequest>(),
            default), Times.Exactly(1));
    }

    /// <summary>
    /// Verify the creation of <see cref="BedrockAgent"/> with a kernel.
    /// </summary>
    [Fact]
    public async Task VerifyBedrockAgentCreateWithKernelAsync()
    {
        // Arrange
        var (mockClient, mockRuntimeClient) = this.CreateMockClients();
        var agentModel = await mockClient.Object.CreateAndPrepareAgentAsync(this._createAgentRequest);

        // Act
        Kernel kernel = new();
        var bedrockAgent = new BedrockAgent(agentModel, mockClient.Object, mockRuntimeClient.Object);
        bedrockAgent.Kernel.Plugins.Add(KernelPluginFactory.CreateFromType<WeatherPlugin>());

        // Assert
        this.VerifyAgent(bedrockAgent);
        Assert.Single(bedrockAgent.Kernel.Plugins);
    }

    /// <summary>
    /// Verify the creation of <see cref="BedrockAgent"/> with kernel arguments.
    /// </summary>
    [Fact]
    public async Task VerifyBedrockAgentCreateWithKernelArgumentsAsync()
    {
        // Arrange
        var (mockClient, mockRuntimeClient) = this.CreateMockClients();
        var agentModel = await mockClient.Object.CreateAndPrepareAgentAsync(this._createAgentRequest);

        // Act
        KernelArguments arguments = new() { { "key", "value" } };
        var bedrockAgent = new BedrockAgent(agentModel, mockClient.Object, mockRuntimeClient.Object)
        {
            Arguments = arguments,
        };

        // Assert
        this.VerifyAgent(bedrockAgent);
        Assert.Single(bedrockAgent.Arguments);
    }

    /// <summary>
    /// Verify the bedrock agent returns the expected channel key.
    /// </summary>
    [Fact]
    public async Task VerifyBedrockAgentChannelKeyAsync()
    {
        // Arrange
        var (mockClient, mockRuntimeClient) = this.CreateMockClients();
        var agentModel = await mockClient.Object.CreateAndPrepareAgentAsync(this._createAgentRequest);

        // Act
        var bedrockAgent = new BedrockAgent(agentModel, mockClient.Object, mockRuntimeClient.Object);

        // Assert
        Assert.Single(bedrockAgent.GetChannelKeys());
    }

    /// <summary>
    /// Verify the InvokeAsync method throws when an incorrect thread type is provided.
    /// </summary>
    /// <returns></returns>
    [Fact]
    public async Task VerifyInvokeWithWrongThreadTypeThrowsAsync()
    {
        var (mockClient, mockRuntimeClient) = this.CreateMockClients();
        var bedrockAgent = new BedrockAgent(this._agentModel, mockClient.Object, mockRuntimeClient.Object);
        var messages = new List<ChatMessageContent>
        {
            new (AuthorRole.User, "Hello, how are you?")
        };
        var agentThread = new Mock<AgentThread>();

        // Act
        await Assert.ThrowsAsync<KernelException>(async () =>
        {
            await foreach (var response in bedrockAgent.InvokeAsync(messages, agentThread.Object, null, default))
            {
            }
        });
    }

    private (Mock<IAmazonBedrockAgent>, Mock<IAmazonBedrockAgentRuntime>) CreateMockClients()
    {
        Mock<IAmazonBedrockAgent> mockClient = new();
        Mock<IAmazonBedrockAgentRuntime> mockRuntimeClient = new();

        mockClient.Setup(x => x.CreateAgentAsync(
            It.IsAny<CreateAgentRequest>(),
            default)
        ).ReturnsAsync(new CreateAgentResponse { Agent = this._agentModel });

        // After a new agent is created, its status will first be CREATING then NOT_PREPARED.
        // Internally, we will prepare the agent for use. During preparation, the agent status
        // will be PREPARING, then finally PREPARED.
        mockClient.SetupSequence(x => x.GetAgentAsync(
            It.IsAny<GetAgentRequest>(),
            default)
        ).ReturnsAsync(new GetAgentResponse
        {
            Agent = new Amazon.BedrockAgent.Model.Agent()
            {
                AgentId = this._agentModel.AgentId,
                AgentName = this._agentModel.AgentName,
                Description = this._agentModel.Description,
                Instruction = this._agentModel.Instruction,
                AgentStatus = AgentStatus.NOT_PREPARED,
            }
        }).ReturnsAsync(new GetAgentResponse
        {
            Agent = new Amazon.BedrockAgent.Model.Agent()
            {
                AgentId = this._agentModel.AgentId,
                AgentName = this._agentModel.AgentName,
                Description = this._agentModel.Description,
                Instruction = this._agentModel.Instruction,
                AgentStatus = AgentStatus.PREPARING,
            }
        }).ReturnsAsync(new GetAgentResponse
        {
            Agent = new Amazon.BedrockAgent.Model.Agent()
            {
                AgentId = this._agentModel.AgentId,
                AgentName = this._agentModel.AgentName,
                Description = this._agentModel.Description,
                Instruction = this._agentModel.Instruction,
                AgentStatus = AgentStatus.PREPARED,
            }
        });

#pragma warning disable CA2000 // Dispose objects before losing scope
        mockRuntimeClient.Setup(x => x.InvokeAgentAsync(
            It.IsAny<InvokeAgentRequest>(),
            It.IsAny<CancellationToken>()))
            .ReturnsAsync(new InvokeAgentResponse() { HttpStatusCode = System.Net.HttpStatusCode.OK });
#pragma warning restore CA2000 // Dispose objects before losing scope

        return (mockClient, mockRuntimeClient);
    }

    private void VerifyAgent(BedrockAgent bedrockAgent)
    {
        Assert.Equal(bedrockAgent.Id, this._agentModel.AgentId);
        Assert.Equal(bedrockAgent.Name, this._agentModel.AgentName);
        Assert.Equal(bedrockAgent.Description, this._agentModel.Description);
        Assert.Equal(bedrockAgent.Instructions, this._agentModel.Instruction);
    }

    private sealed class WeatherPlugin
    {
        [KernelFunction, Description("Provides realtime weather information.")]
        public string Current([Description("The location to get the weather for.")] string location)
        {
            return $"The current weather in {location} is 72 degrees.";
        }
    }
}


===== UnitTests\Bedrock\Extensions.cs\BedrockAgentExtensionsTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Text.Json;
using System.Threading.Tasks;
using Amazon.BedrockAgent;
using Amazon.BedrockAgent.Model;
using Amazon.BedrockAgentRuntime;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.Agents.Bedrock;
using Moq;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.Bedrock.Extensions;

/// <summary>
/// Unit testing of <see cref="BedrockAgentExtensions"/>.
/// </summary>
public class BedrockAgentExtensionsTests
{
    private readonly Amazon.BedrockAgent.Model.Agent _agentModel = new()
    {
        AgentId = "1234567890",
        AgentName = "testName",
        Description = "test description",
        Instruction = "Instruction must have at least 40 characters",
    };

    private readonly CreateAgentRequest _createAgentRequest = new()
    {
        AgentName = "testName",
        Description = "test description",
        Instruction = "Instruction must have at least 40 characters",
    };

    [Fact]
    public void AsAIAgent_WithValidBedrockAgent_ReturnsSemanticKernelAIAgent()
    {
        // Arrange
        var (mockClient, mockRuntimeClient) = this.CreateMockClients();
        var bedrockAgent = new BedrockAgent(this._agentModel, mockClient.Object, mockRuntimeClient.Object);

        // Act
        var result = bedrockAgent.AsAIAgent();

        // Assert
        Assert.NotNull(result);
        Assert.IsType<SemanticKernelAIAgent>(result);
    }

    [Fact]
    public void AsAIAgent_WithNullBedrockAgent_ThrowsArgumentNullException()
    {
        // Arrange
        BedrockAgent nullAgent = null!;

        // Act & Assert
        Assert.Throws<ArgumentNullException>(() => nullAgent.AsAIAgent());
    }

    [Fact]
    public void AsAIAgent_CreatesWorkingThreadFactory()
    {
        // Arrange
        var (mockClient, mockRuntimeClient) = this.CreateMockClients();
        var bedrockAgent = new BedrockAgent(this._agentModel, mockClient.Object, mockRuntimeClient.Object);

        // Act
        var result = bedrockAgent.AsAIAgent();
        var thread = result.GetNewThread();

        // Assert
        Assert.NotNull(thread);
        Assert.IsType<SemanticKernelAIAgentThread>(thread);
        var threadAdapter = (SemanticKernelAIAgentThread)thread;
        Assert.IsType<BedrockAgentThread>(threadAdapter.InnerThread);
    }

    [Fact]
    public void AsAIAgent_ThreadDeserializationFactory_WithNullAgentId_CreatesNewThread()
    {
        // Arrange
        var (mockClient, mockRuntimeClient) = this.CreateMockClients();
        var bedrockAgent = new BedrockAgent(this._agentModel, mockClient.Object, mockRuntimeClient.Object);
        var jsonElement = JsonSerializer.SerializeToElement((string?)null);

        // Act
        var result = bedrockAgent.AsAIAgent();
        var thread = result.DeserializeThread(jsonElement);

        // Assert
        Assert.NotNull(thread);
        Assert.IsType<SemanticKernelAIAgentThread>(thread);
        var threadAdapter = (SemanticKernelAIAgentThread)thread;
        Assert.IsType<BedrockAgentThread>(threadAdapter.InnerThread);
    }

    [Fact]
    public void AsAIAgent_ThreadDeserializationFactory_WithValidAgentId_CreatesThreadWithId()
    {
        // Arrange
        var (mockClient, mockRuntimeClient) = this.CreateMockClients();
        var bedrockAgent = new BedrockAgent(this._agentModel, mockClient.Object, mockRuntimeClient.Object);
        var agentId = "test-agent-id";
        var jsonElement = JsonSerializer.SerializeToElement(agentId);

        // Act
        var result = bedrockAgent.AsAIAgent();
        var thread = result.DeserializeThread(jsonElement);

        // Assert
        Assert.NotNull(thread);
        Assert.IsType<SemanticKernelAIAgentThread>(thread);
        var threadAdapter = (SemanticKernelAIAgentThread)thread;
        Assert.IsType<BedrockAgentThread>(threadAdapter.InnerThread);
    }

    [Fact]
    public void AsAIAgent_ThreadSerializer_SerializesThreadId()
    {
        // Arrange
        var (mockClient, mockRuntimeClient) = this.CreateMockClients();
        var bedrockAgent = new BedrockAgent(this._agentModel, mockClient.Object, mockRuntimeClient.Object);
        var expectedThreadId = "test-thread-id";
        var bedrockThread = new BedrockAgentThread(mockRuntimeClient.Object, expectedThreadId);
        var jsonElement = JsonSerializer.SerializeToElement(expectedThreadId);

        var result = bedrockAgent.AsAIAgent();
        var thread = result.DeserializeThread(jsonElement);

        // Act
        var serializedElement = thread.Serialize();

        // Assert
        Assert.Equal(JsonValueKind.String, serializedElement.ValueKind);
        Assert.Equal(expectedThreadId, serializedElement.GetString());
    }

    /// <summary>
    /// Verify the creation of the agent and the preparation of the agent.
    /// The status of the agent should be checked 3 times based on the setup.
    /// 1: Waiting for the agent to go from CREATING to NOT_PREPARED.
    /// 2: Waiting for the agent to go from NOT_PREPARED to PREPARING.
    /// 3: Waiting for the agent to go from PREPARING to PREPARED.
    /// </summary>
    [Fact]
    public async Task VerifyCreateAndPrepareAgentAsync()
    {
        // Arrange
        var (mockClient, mockRuntimeClient) = this.CreateMockClients();

        // Act
        var agentModel = await mockClient.Object.CreateAndPrepareAgentAsync(this._createAgentRequest);

        // Assert
        mockClient.Verify(x => x.GetAgentAsync(
            It.IsAny<GetAgentRequest>(),
            default), Times.Exactly(3));
    }

    /// <summary>
    /// Verify the modification and preparation of the agent is correctly performed.
    /// The status of the agent should be go through the following states:
    /// PREPARED -> PREPARING -> PREPARED.
    /// </summary>
    [Fact]
    public async Task VerifyAssociateAgentKnowledgeBaseAsync()
    {
        // Arrange
        var (mockClient, mockRuntimeClient) = this.CreateMockClients();
        this.ModifyMockClientGetAgentResponseSequence(mockClient);

        mockClient.Setup(x => x.AssociateAgentKnowledgeBaseAsync(
            It.IsAny<AssociateAgentKnowledgeBaseRequest>(),
            default)
        ).ReturnsAsync(new AssociateAgentKnowledgeBaseResponse());

        // Act
        var agentModel = await mockClient.Object.CreateAndPrepareAgentAsync(this._createAgentRequest);
        var bedrockAgent = new BedrockAgent(agentModel, mockClient.Object, mockRuntimeClient.Object);
        await bedrockAgent.AssociateAgentKnowledgeBaseAsync("testKnowledgeBaseId", "testKnowledgeBaseDescription");

        // Assert
        mockClient.Verify(x => x.GetAgentAsync(
            It.IsAny<GetAgentRequest>(),
            default), Times.Exactly(5));
    }

    /// <summary>
    /// Verify the modification and preparation of the agent is correctly performed.
    /// The status of the agent should be go through the following states:
    /// PREPARED -> PREPARING -> PREPARED.
    /// </summary>
    [Fact]
    public async Task VerifyDisassociateAgentKnowledgeBaseAsync()
    {
        // Arrange
        var (mockClient, mockRuntimeClient) = this.CreateMockClients();
        this.ModifyMockClientGetAgentResponseSequence(mockClient);

        mockClient.Setup(x => x.DisassociateAgentKnowledgeBaseAsync(
            It.IsAny<DisassociateAgentKnowledgeBaseRequest>(),
            default)
        ).ReturnsAsync(new DisassociateAgentKnowledgeBaseResponse());

        // Act
        var agentModel = await mockClient.Object.CreateAndPrepareAgentAsync(this._createAgentRequest);
        var bedrockAgent = new BedrockAgent(agentModel, mockClient.Object, mockRuntimeClient.Object);
        await bedrockAgent.DisassociateAgentKnowledgeBaseAsync("testKnowledgeBaseId");

        // Assert
        mockClient.Verify(x => x.GetAgentAsync(
            It.IsAny<GetAgentRequest>(),
            default), Times.Exactly(5));
    }

    /// <summary>
    /// Verify the modification and preparation of the agent is correctly performed.
    /// The status of the agent should be go through the following states:
    /// PREPARED -> PREPARING -> PREPARED.
    /// </summary>
    [Fact]
    public async Task VerifyCreateCodeInterpreterActionGroupAsync()
    {
        // Arrange
        var (mockClient, mockRuntimeClient) = this.CreateMockClients();
        this.ModifyMockClientGetAgentResponseSequence(mockClient);

        mockClient.Setup(x => x.CreateAgentActionGroupAsync(
            It.IsAny<CreateAgentActionGroupRequest>(),
            default)
        ).ReturnsAsync(new CreateAgentActionGroupResponse());

        // Act
        var agentModel = await mockClient.Object.CreateAndPrepareAgentAsync(this._createAgentRequest);
        var bedrockAgent = new BedrockAgent(agentModel, mockClient.Object, mockRuntimeClient.Object);
        await bedrockAgent.CreateCodeInterpreterActionGroupAsync();

        // Assert
        mockClient.Verify(x => x.GetAgentAsync(
            It.IsAny<GetAgentRequest>(),
            default), Times.Exactly(5));
    }

    /// <summary>
    /// Verify the modification and preparation of the agent is correctly performed.
    /// The status of the agent should be go through the following states:
    /// PREPARED -> PREPARING -> PREPARED.
    /// </summary>
    [Fact]
    public async Task VerifyCreateKernelFunctionActionGroupAsync()
    {
        // Arrange
        var (mockClient, mockRuntimeClient) = this.CreateMockClients();
        this.ModifyMockClientGetAgentResponseSequence(mockClient);

        mockClient.Setup(x => x.CreateAgentActionGroupAsync(
            It.IsAny<CreateAgentActionGroupRequest>(),
            default)
        ).ReturnsAsync(new CreateAgentActionGroupResponse());

        // Act
        var agentModel = await mockClient.Object.CreateAndPrepareAgentAsync(this._createAgentRequest);
        var bedrockAgent = new BedrockAgent(agentModel, mockClient.Object, mockRuntimeClient.Object);
        await bedrockAgent.CreateKernelFunctionActionGroupAsync();

        // Assert
        mockClient.Verify(x => x.GetAgentAsync(
            It.IsAny<GetAgentRequest>(),
            default), Times.Exactly(5));
    }

    /// <summary>
    /// Verify the modification and preparation of the agent is correctly performed.
    /// The status of the agent should be go through the following states:
    /// PREPARED -> PREPARING -> PREPARED.
    /// </summary>
    [Fact]
    public async Task VerifyEnableUserInputActionGroupAsync()
    {
        // Arrange
        var (mockClient, mockRuntimeClient) = this.CreateMockClients();
        this.ModifyMockClientGetAgentResponseSequence(mockClient);

        mockClient.Setup(x => x.CreateAgentActionGroupAsync(
            It.IsAny<CreateAgentActionGroupRequest>(),
            default)
        ).ReturnsAsync(new CreateAgentActionGroupResponse());

        // Act
        var agentModel = await mockClient.Object.CreateAndPrepareAgentAsync(this._createAgentRequest);
        var bedrockAgent = new BedrockAgent(agentModel, mockClient.Object, mockRuntimeClient.Object);
        await bedrockAgent.EnableUserInputActionGroupAsync();

        // Assert
        mockClient.Verify(x => x.GetAgentAsync(
            It.IsAny<GetAgentRequest>(),
            default), Times.Exactly(5));
    }

    private (Mock<IAmazonBedrockAgent>, Mock<IAmazonBedrockAgentRuntime>) CreateMockClients()
    {
        Mock<IAmazonBedrockAgent> mockClient = new();
        Mock<IAmazonBedrockAgentRuntime> mockRuntimeClient = new();

        mockClient.Setup(x => x.CreateAgentAsync(
            It.IsAny<CreateAgentRequest>(),
            default)
        ).ReturnsAsync(new CreateAgentResponse { Agent = this._agentModel });

        // After a new agent is created, its status will first be CREATING then NOT_PREPARED.
        // Internally, we will prepare the agent for use. During preparation, the agent status
        // will be PREPARING, then finally PREPARED.
        mockClient.SetupSequence(x => x.GetAgentAsync(
            It.IsAny<GetAgentRequest>(),
            default)
        ).ReturnsAsync(new GetAgentResponse
        {
            Agent = new Amazon.BedrockAgent.Model.Agent()
            {
                AgentId = this._agentModel.AgentId,
                AgentName = this._agentModel.AgentName,
                Description = this._agentModel.Description,
                Instruction = this._agentModel.Instruction,
                AgentStatus = AgentStatus.NOT_PREPARED,
            }
        }).ReturnsAsync(new GetAgentResponse
        {
            Agent = new Amazon.BedrockAgent.Model.Agent()
            {
                AgentId = this._agentModel.AgentId,
                AgentName = this._agentModel.AgentName,
                Description = this._agentModel.Description,
                Instruction = this._agentModel.Instruction,
                AgentStatus = AgentStatus.PREPARING,
            }
        }).ReturnsAsync(new GetAgentResponse
        {
            Agent = new Amazon.BedrockAgent.Model.Agent()
            {
                AgentId = this._agentModel.AgentId,
                AgentName = this._agentModel.AgentName,
                Description = this._agentModel.Description,
                Instruction = this._agentModel.Instruction,
                AgentStatus = AgentStatus.PREPARED,
            }
        });

        mockClient.Setup(x => x.PrepareAgentAsync(
            It.IsAny<PrepareAgentRequest>(),
            default)
        ).ReturnsAsync(new PrepareAgentResponse { AgentId = this._agentModel.AgentId, AgentStatus = AgentStatus.PREPARING });

        return (mockClient, mockRuntimeClient);
    }

    /// <summary>
    /// Modify the mock client to return a new sequence of responses for the GetAgentAsync method
    /// that reflect the correct sequence of status change when modifying the agent.
    /// </summary>
    private void ModifyMockClientGetAgentResponseSequence(Mock<IAmazonBedrockAgent> mockClient)
    {
        mockClient.SetupSequence(x => x.GetAgentAsync(
            It.IsAny<GetAgentRequest>(),
            default)
        ).ReturnsAsync(new GetAgentResponse
        {
            Agent = new Amazon.BedrockAgent.Model.Agent()
            {
                AgentId = this._agentModel.AgentId,
                AgentName = this._agentModel.AgentName,
                Description = this._agentModel.Description,
                Instruction = this._agentModel.Instruction,
                AgentStatus = AgentStatus.NOT_PREPARED,
            }
        }).ReturnsAsync(new GetAgentResponse
        {
            Agent = new Amazon.BedrockAgent.Model.Agent()
            {
                AgentId = this._agentModel.AgentId,
                AgentName = this._agentModel.AgentName,
                Description = this._agentModel.Description,
                Instruction = this._agentModel.Instruction,
                AgentStatus = AgentStatus.PREPARING,
            }
        }).ReturnsAsync(new GetAgentResponse
        {
            Agent = new Amazon.BedrockAgent.Model.Agent()
            {
                AgentId = this._agentModel.AgentId,
                AgentName = this._agentModel.AgentName,
                Description = this._agentModel.Description,
                Instruction = this._agentModel.Instruction,
                AgentStatus = AgentStatus.PREPARED,
            }
        }).ReturnsAsync(new GetAgentResponse
        {
            Agent = new Amazon.BedrockAgent.Model.Agent()
            {
                AgentId = this._agentModel.AgentId,
                AgentName = this._agentModel.AgentName,
                Description = this._agentModel.Description,
                Instruction = this._agentModel.Instruction,
                AgentStatus = AgentStatus.PREPARING,
            }
        }).ReturnsAsync(new GetAgentResponse
        {
            Agent = new Amazon.BedrockAgent.Model.Agent()
            {
                AgentId = this._agentModel.AgentId,
                AgentName = this._agentModel.AgentName,
                Description = this._agentModel.Description,
                Instruction = this._agentModel.Instruction,
                AgentStatus = AgentStatus.PREPARED,
            }
        });
    }
}


===== UnitTests\Bedrock\Extensions.cs\BedrockFunctionSchemaExtensionsTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.ComponentModel;
using Amazon.BedrockAgentRuntime.Model;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents.Bedrock;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.Bedrock.Extensions;

/// <summary>
/// Unit testing of <see cref="BedrockFunctionSchemaExtensions"/>.
/// </summary>
public class BedrockFunctionSchemaExtensionsTests
{
    /// <summary>
    /// Verify the conversion of a <see cref="FunctionParameter"/> to a <see cref="KernelArguments"/>.
    /// </summary>
    [Fact]
    public void VerifyFromFunctionParameters()
    {
        // Arrange
        List<FunctionParameter> parameters =
        [
            new FunctionParameter()
            {
                Name = "TestParameter",
                Type = Amazon.BedrockAgent.Type.String,
            },
        ];

        // Act
        KernelArguments arguments = parameters.FromFunctionParameters(null);

        // Assert
        Assert.Single(arguments);
        Assert.True(arguments.ContainsName("TestParameter"));
    }

    /// <summary>
    /// Verify the conversion of a <see cref="FunctionParameter"/> to a <see cref="KernelArguments"/> with existing arguments.
    /// </summary>
    [Fact]
    public void VerifyFromFunctionParametersWithArguments()
    {
        // Arrange
        List<FunctionParameter> parameters =
        [
            new FunctionParameter()
            {
                Name = "TestParameter",
                Type = Amazon.BedrockAgent.Type.String,
            },
        ];

        KernelArguments arguments = new()
        {
            { "ExistingParameter", "ExistingValue" }
        };

        // Act
        KernelArguments updatedArguments = parameters.FromFunctionParameters(arguments);

        // Assert
        Assert.Equal(2, updatedArguments.Count);
        Assert.True(updatedArguments.ContainsName("TestParameter"));
        Assert.True(updatedArguments.ContainsName("ExistingParameter"));
    }

    /// <summary>
    /// Verify the conversion of a <see cref="Kernel"/> plugin to a <see cref="Amazon.BedrockAgent.Model.FunctionSchema"/>.
    /// </summary>
    [Fact]
    public void VerifyToFunctionSchema()
    {
        // Arrange
        (Kernel kernel, KernelFunction function, KernelParameterMetadata parameter) = this.CreateKernelPlugin();

        // Act
        Amazon.BedrockAgent.Model.FunctionSchema schema = kernel.ToFunctionSchema();

        // Assert
        Assert.Single(schema.Functions);
        Assert.Equal(function.Name, schema.Functions[0].Name);
        Assert.Equal(function.Description, schema.Functions[0].Description);
        Assert.True(schema.Functions[0].Parameters.ContainsKey(parameter.Name));
        Assert.Equal(parameter.Description, schema.Functions[0].Parameters[parameter.Name].Description);
        Assert.True(schema.Functions[0].Parameters[parameter.Name].Required);
        Assert.Equal(Amazon.BedrockAgent.Type.String, schema.Functions[0].Parameters[parameter.Name].Type);
        Assert.Equal(Amazon.BedrockAgent.RequireConfirmation.DISABLED, schema.Functions[0].RequireConfirmation);
    }

    private (Kernel, KernelFunction, KernelParameterMetadata) CreateKernelPlugin()
    {
        Kernel kernel = new();
        kernel.Plugins.Add(KernelPluginFactory.CreateFromType<WeatherPlugin>());
        var function = kernel.Plugins["WeatherPlugin"]["Current"];
        var parameter = function.Metadata.Parameters[0];
        return (kernel, function, parameter);
    }

    private sealed class WeatherPlugin
    {
        [KernelFunction, Description("Provides realtime weather information.")]
        public string Current([Description("The location to get the weather for.")] string location)
        {
            return $"The current weather in {location} is 72 degrees.";
        }
    }
}


===== UnitTests\Copilot\CopilotStudioAgentExtensionsTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Text.Json;
using Microsoft.Agents.CopilotStudio.Client;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.Agents.Copilot;
using Moq;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.Copilot;

public sealed class CopilotStudioAgentExtensionsTests
{
    [Fact]
    public void AsAIAgent_WithValidCopilotStudioAgent_ReturnsSemanticKernelAIAgent()
    {
        // Arrange
        var clientMock = new Mock<CopilotClient>(null, null, null, null);
        var copilotStudioAgent = new CopilotStudioAgent(clientMock.Object);

        // Act
        var result = copilotStudioAgent.AsAIAgent();

        // Assert
        Assert.NotNull(result);
        Assert.IsType<SemanticKernelAIAgent>(result);
    }

    [Fact]
    public void AsAIAgent_WithNullCopilotStudioAgent_ThrowsArgumentNullException()
    {
        // Arrange
        CopilotStudioAgent nullAgent = null!;

        // Act & Assert
        Assert.Throws<ArgumentNullException>(() => nullAgent.AsAIAgent());
    }

    [Fact]
    public void AsAIAgent_CreatesWorkingThreadFactory()
    {
        // Arrange
        var clientMock = new Mock<CopilotClient>(null, null, null, null);
        var copilotStudioAgent = new CopilotStudioAgent(clientMock.Object);

        // Act
        var result = copilotStudioAgent.AsAIAgent();
        var thread = result.GetNewThread();

        // Assert
        Assert.NotNull(thread);
        Assert.IsType<SemanticKernelAIAgentThread>(thread);
        var threadAdapter = (SemanticKernelAIAgentThread)thread;
        Assert.IsType<CopilotStudioAgentThread>(threadAdapter.InnerThread);
    }

    [Fact]
    public void AsAIAgent_ThreadDeserializationFactory_WithNullAgentId_CreatesNewThread()
    {
        // Arrange
        var clientMock = new Mock<CopilotClient>(null, null, null, null);
        var copilotStudioAgent = new CopilotStudioAgent(clientMock.Object);
        var jsonElement = JsonSerializer.SerializeToElement((string?)null);

        // Act
        var result = copilotStudioAgent.AsAIAgent();
        var thread = result.DeserializeThread(jsonElement);

        // Assert
        Assert.NotNull(thread);
        Assert.IsType<SemanticKernelAIAgentThread>(thread);
        var threadAdapter = (SemanticKernelAIAgentThread)thread;
        Assert.IsType<CopilotStudioAgentThread>(threadAdapter.InnerThread);
    }

    [Fact]
    public void AsAIAgent_ThreadDeserializationFactory_WithValidAgentId_CreatesThreadWithId()
    {
        // Arrange
        var clientMock = new Mock<CopilotClient>(null, null, null, null);
        var copilotStudioAgent = new CopilotStudioAgent(clientMock.Object);
        var agentId = "test-agent-id";
        var jsonElement = JsonSerializer.SerializeToElement(agentId);

        // Act
        var result = copilotStudioAgent.AsAIAgent();
        var thread = result.DeserializeThread(jsonElement);

        // Assert
        Assert.NotNull(thread);
        Assert.IsType<SemanticKernelAIAgentThread>(thread);
        var threadAdapter = (SemanticKernelAIAgentThread)thread;
        Assert.IsType<CopilotStudioAgentThread>(threadAdapter.InnerThread);
    }

    [Fact]
    public void AsAIAgent_ThreadSerializer_SerializesThreadId()
    {
        // Arrange
        var clientMock = new Mock<CopilotClient>(null, null, null, null);
        var copilotStudioAgent = new CopilotStudioAgent(clientMock.Object);
        var expectedThreadId = "test-thread-id";
        var copilotStudioThread = new CopilotStudioAgentThread(clientMock.Object, expectedThreadId);
        var jsonElement = JsonSerializer.SerializeToElement(expectedThreadId);

        var result = copilotStudioAgent.AsAIAgent();
        var thread = result.DeserializeThread(jsonElement);

        // Act
        var serializedElement = thread.Serialize();

        // Assert
        Assert.Equal(JsonValueKind.String, serializedElement.ValueKind);
        Assert.Equal(expectedThreadId, serializedElement.GetString());
    }
}


===== UnitTests\CopilotStudio\ActivityProcessorTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.Agents.Core.Models;
using Microsoft.Extensions.Logging;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents.CopilotStudio.Internal;
using Microsoft.SemanticKernel.ChatCompletion;
using Moq;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.CopilotStudio;

/// <summary>
/// Unit tests for the ActivityProcessor class.
/// </summary>
public class ActivityProcessorTests
{
    /// <summary>
    /// Tests that a message activity is processed and returns a ChatMessageContent with assistant role and correct content.
    /// </summary>
    [Fact]
    public async Task ProcessActivity_WithMessageActivity_ReturnsAssistantChatMessageContent()
    {
        // Arrange
        Activity messageActivity = new()
        {
            Type = "message",
            Text = "Hello, I'm Copilot!"
        };

        IAsyncEnumerable<IActivity> activities = CreateAsyncEnumerable(new[] { messageActivity });
        Mock<ILogger> loggerMock = new();

        // Act
        ChatMessageContent[] results = await ActivityProcessor.ProcessActivity(activities, loggerMock.Object)
            .ToArrayAsync();

        // Assert
        Assert.Single(results);
        ChatMessageContent chatMessage = results[0];
        Assert.Equal(AuthorRole.Assistant, chatMessage.Role);
        Assert.Equal("Hello, I'm Copilot!", chatMessage.Content);
        Assert.Same(messageActivity, chatMessage.InnerContent);
    }

    /// <summary>
    /// Tests that a typing activity is processed and returns a ChatMessageContent with assistant role and ReasoningContent item.
    /// </summary>
    [Fact]
    public async Task ProcessActivity_WithTypingActivity_ReturnsAssistantReasoningContent()
    {
        // Arrange
        Activity typingActivity = new()
        {
            Type = "typing"
        };

        IAsyncEnumerable<IActivity> activities = CreateAsyncEnumerable(new[] { typingActivity });
        Mock<ILogger> loggerMock = new(MockBehavior.Strict);

        // Act
        ChatMessageContent[] results = await ActivityProcessor.ProcessActivity(activities, loggerMock.Object).ToArrayAsync();

        // Assert
        Assert.Single(results);
        ChatMessageContent chatMessage = results[0];
        Assert.Equal(AuthorRole.Assistant, chatMessage.Role);
        Assert.Single(chatMessage.Items);
        Assert.IsType<ReasoningContent>(chatMessage.Items[0]);
        Assert.Same(typingActivity, chatMessage.InnerContent);
    }

    /// <summary>
    /// Tests that an event activity is processed and returns no ChatMessageContent.
    /// </summary>
    [Fact]
    public async Task ProcessActivity_WithEventActivity_ReturnsNoMessages()
    {
        // Arrange
        Activity eventActivity = new()
        {
            Type = "event"
        };

        IAsyncEnumerable<IActivity> activities = CreateAsyncEnumerable(new[] { eventActivity });
        Mock<ILogger> loggerMock = new(MockBehavior.Strict);

        // Act
        ChatMessageContent[] results = await ActivityProcessor.ProcessActivity(activities, loggerMock.Object).ToArrayAsync();

        // Assert
        Assert.Empty(results);
    }

    /// <summary>
    /// Tests that an unknown activity type is processed and logs a warning.
    /// </summary>
    [Fact]
    public async Task ProcessActivity_WithUnknownActivity_LogsWarning()
    {
        // Arrange
        Activity unknownActivity = new()
        {
            Type = "unknown_type"
        };

        IAsyncEnumerable<IActivity> activities = CreateAsyncEnumerable(new[] { unknownActivity });
        Mock<ILogger> loggerMock = new();

        // Act
        ChatMessageContent[] results = await ActivityProcessor.ProcessActivity(activities, loggerMock.Object).ToArrayAsync();

        // Assert
        Assert.Empty(results);
        loggerMock.Verify(
            x => x.Log(
                LogLevel.Warning,
                It.IsAny<EventId>(),
                It.Is<It.IsAnyType>((v, t) => true),
                It.IsAny<Exception>(),
                It.Is<Func<It.IsAnyType, Exception?, string>>((v, t) => true)),
            Times.Once);
    }

    /// <summary>
    /// Tests that a message activity with suggested actions returns a ChatMessageContent with action items.
    /// </summary>
    [Fact]
    public async Task ProcessActivity_WithSuggestedActions_ReturnsMessageWithActions()
    {
        // Arrange
        Activity messageActivity = new()
        {
            Type = "message",
            Text = "Select an option:",
            SuggestedActions = new SuggestedActions
            {
                Actions = new[]
                {
                    new CardAction { Title = "Option 1" },
                    new CardAction { Title = "Option 2" }
                }
            }
        };

        IAsyncEnumerable<IActivity> activities = CreateAsyncEnumerable(new[] { messageActivity });
        Mock<ILogger> loggerMock = new(MockBehavior.Strict);

        // Act
        ChatMessageContent[] results = await ActivityProcessor.ProcessActivity(activities, loggerMock.Object).ToArrayAsync();

        // Assert
        Assert.Single(results);
        ChatMessageContent chatMessage = results[0];
        Assert.Equal(AuthorRole.Assistant, chatMessage.Role);
        Assert.Equal("Select an option:", chatMessage.Content);
        Assert.Equal(3, chatMessage.Items.Count); // Text content + 2 action contents
        Assert.IsType<TextContent>(chatMessage.Items[0]);
        Assert.IsType<ActionContent>(chatMessage.Items[1]);
        Assert.IsType<ActionContent>(chatMessage.Items[2]);
        Assert.Equal("Option 1", ((ActionContent)chatMessage.Items[1]).Text);
        Assert.Equal("Option 2", ((ActionContent)chatMessage.Items[2]).Text);
    }

    /// <summary>
    /// Tests that multiple activities are processed and all valid activities are returned as ChatMessageContent.
    /// </summary>
    [Fact]
    public async Task ProcessActivity_WithMultipleActivities_ProcessesAllActivities()
    {
        // Arrange
        Activity messageActivity = new()
        {
            Type = "message",
            Text = "Hello"
        };

        Activity typingActivity = new()
        {
            Type = "typing"
        };

        Activity eventActivity = new()
        {
            Type = "event"
        };

        IAsyncEnumerable<IActivity> activities = CreateAsyncEnumerable(
            [messageActivity, typingActivity, eventActivity]);
        Mock<ILogger> loggerMock = new(MockBehavior.Strict);

        // Act
        ChatMessageContent[] results = await ActivityProcessor.ProcessActivity(activities, loggerMock.Object).ToArrayAsync();

        // Assert
        Assert.Equal(2, results.Length);
        Assert.Equal("Hello", results[0].Content);
        Assert.IsType<ReasoningContent>(results[1].Items[0]);
    }

    /// <summary>
    /// Helper method to create an IAsyncEnumerable from a collection of IActivity.
    /// </summary>
    /// <param name="activities">The activities to yield.</param>
    /// <returns>An async enumerable of IActivity.</returns>
    private static IAsyncEnumerable<IActivity> CreateAsyncEnumerable(IEnumerable<IActivity> activities) => activities.ToAsyncEnumerable();
}


===== UnitTests\CopilotStudio\ContentProcessorTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents.CopilotStudio.Internal;
using Microsoft.SemanticKernel.ChatCompletion;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.CopilotStudio;

public class ContentProcessorTests
{
    [Fact]
    public void ConvertToStreaming_EmptyCollection_ReturnsEmptyEnumerable()
    {
        // Arrange
        ChatMessageContentItemCollection collection = [];

        // Act
        IEnumerable<StreamingKernelContent> result = ContentProcessor.ConvertToStreaming(collection, NullLogger.Instance);

        // Assert
        Assert.Empty(result);
    }

    [Fact]
    public void ConvertToStreaming_TextContent_ReturnsStreamingTextContent()
    {
        // Arrange
        ChatMessageContentItemCollection collection = [];
        TextContent textContent = new("Display text");
        collection.Add(textContent);

        // Act
        IEnumerable<StreamingKernelContent> result = ContentProcessor.ConvertToStreaming(collection, NullLogger.Instance);

        // Assert
        StreamingKernelContent streamingContent = Assert.Single(result);
        Assert.IsType<StreamingTextContent>(streamingContent);
    }

    [Fact]
    public void ConvertToStreaming_ReasoningContent_ReturnsStreamingReasoningContent()
    {
        // Arrange
        ChatMessageContentItemCollection collection = [];
        ReasoningContent reasoningContent = new("Reasoning text");
        collection.Add(reasoningContent);

        // Act
        IEnumerable<StreamingKernelContent> result = ContentProcessor.ConvertToStreaming(collection, NullLogger.Instance);

        // Assert
        StreamingKernelContent streamingContent = Assert.Single(result);
        Assert.IsType<StreamingReasoningContent>(streamingContent);
    }

    [Fact]
    public void ConvertToStreaming_ActionContent_ReturnsStreamingActionContent()
    {
        // Arrange
        ChatMessageContentItemCollection collection = [];
        ActionContent actionContent = new("Action text");
        collection.Add(actionContent);

        // Act
        IEnumerable<StreamingKernelContent> result = ContentProcessor.ConvertToStreaming(collection, NullLogger.Instance);

        // Assert
        StreamingKernelContent streamingContent = Assert.Single(result);
        Assert.IsType<StreamingActionContent>(streamingContent);
    }

    [Fact]
    public void ConvertToStreaming_MixedContentTypes_ReturnsCorrespondingStreamingTypes()
    {
        // Arrange
        ChatMessageContentItemCollection collection = [];
        TextContent textContent = new("Text content");
        ReasoningContent reasoningContent = new("Reasoning content");
        ActionContent actionContent = new("Action content");
        collection.Add(textContent);
        collection.Add(reasoningContent);
        collection.Add(actionContent);

        // Act
        List<StreamingKernelContent> result = [.. ContentProcessor.ConvertToStreaming(collection, NullLogger.Instance)];

        // Assert
        Assert.Equal(3, result.Count);
        Assert.IsType<StreamingTextContent>(result[0]);
        Assert.IsType<StreamingReasoningContent>(result[1]);
        Assert.IsType<StreamingActionContent>(result[2]);
    }

    [Fact]
    public void ConvertToStreaming_UnknownContentType_LogsWarningAndSkipsContent()
    {
        // Arrange
        ChatMessageContentItemCollection collection = [];
        KernelContent unknownContent = new TestUnknownContent();
        collection.Add(unknownContent);

        // Create test logger to capture logs
        TestLogger testLogger = new();

        // Act
        IEnumerable<StreamingKernelContent> result = ContentProcessor.ConvertToStreaming(collection, testLogger);

        // Assert
        Assert.Empty(result);
        Assert.Single(testLogger.LoggedWarnings);
        Assert.Contains("Unknown content type 'TestUnknownContent' received.", testLogger.LoggedWarnings[0]);
    }

    // Test helper classes
    private sealed class TestUnknownContent : KernelContent;

    private sealed class TestLogger : ILogger
    {
        public List<string> LoggedWarnings { get; } = [];

        public bool IsEnabled(LogLevel logLevel) => true;

        public void Log<TState>(LogLevel logLevel, EventId eventId, TState state, Exception? exception, Func<TState, Exception?, string> formatter)
        {
            if (logLevel == LogLevel.Warning)
            {
                this.LoggedWarnings.Add(formatter(state, exception));
            }
        }

        IDisposable? ILogger.BeginScope<TState>(TState state) => null;
    }
}


===== UnitTests\CopilotStudio\CopilotStudioAgentTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using Microsoft.Agents.CopilotStudio.Client;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.SemanticKernel.Agents.Copilot;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.CopilotStudio;

public class CopilotStudioAgentTests
{
    [Fact]
    public void CreateClient_WithValidSettings_ReturnsConfiguredClient()
    {
        // Arrange
        CopilotStudioConnectionSettings settings = new("test-tenant-id", "test-app-client-id", "test-app-client-secret");
        ILogger logger = NullLogger.Instance;

        // Act
        CopilotClient client = CopilotStudioAgent.CreateClient(settings, logger);

        // Assert
        Assert.NotNull(client);
        Assert.IsType<CopilotClient>(client);
    }

    [Fact]
    public void CreateClient_WithNullLogger_UsesNullLogger()
    {
        // Arrange
        CopilotStudioConnectionSettings settings = new("test-tenant-id", "test-app-client-id", "test-app-client-secret");

        // Act
        CopilotClient client = CopilotStudioAgent.CreateClient(settings);

        // Assert
        Assert.NotNull(client);
        Assert.IsType<CopilotClient>(client);
    }
}


===== UnitTests\CopilotStudio\CopilotStudioConnectionSettingsTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using Microsoft.Agents.CopilotStudio.Client.Discovery;
using Microsoft.Extensions.Configuration;
using Microsoft.SemanticKernel.Agents.Copilot;
using Moq;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.CopilotStudio;

/// <summary>
/// Unit tests for the <see cref="CopilotStudioConnectionSettings"/> class.
/// </summary>
public class CopilotStudioConnectionSettingsTests
{
    /// <summary>
    /// Verifies that the constructor with all parameters sets properties correctly.
    /// </summary>
    [Fact]
    public void Constructor_WithAllParameters_SetsPropertiesCorrectly()
    {
        // Arrange
        string tenantId = "testTenantId";
        string appClientId = "testAppClientId";
        string appClientSecret = "testAppClientSecret";

        // Act
        CopilotStudioConnectionSettings settings = new(tenantId, appClientId, appClientSecret);

        // Assert
        Assert.Equal(tenantId, settings.TenantId);
        Assert.Equal(appClientId, settings.AppClientId);
        Assert.Equal(appClientSecret, settings.AppClientSecret);
        Assert.Equal(PowerPlatformCloud.Prod, settings.Cloud);
        Assert.Equal(AgentType.Published, settings.CopilotAgentType);
        Assert.True(settings.UseInteractiveAuthentication);
    }

    /// <summary>
    /// Verifies that the constructor with required parameters sets properties correctly.
    /// </summary>
    [Fact]
    public void Constructor_WithRequiredParameters_SetsPropertiesCorrectly()
    {
        // Arrange
        string tenantId = "testTenantId";
        string appClientId = "testAppClientId";

        // Act
        CopilotStudioConnectionSettings settings = new(tenantId, appClientId);

        // Assert
        Assert.Equal(tenantId, settings.TenantId);
        Assert.Equal(appClientId, settings.AppClientId);
        Assert.Null(settings.AppClientSecret);
        Assert.Equal(PowerPlatformCloud.Prod, settings.Cloud);
        Assert.Equal(AgentType.Published, settings.CopilotAgentType);
        Assert.True(settings.UseInteractiveAuthentication);
    }

    /// <summary>
    /// Verifies that the constructor with configuration sets properties correctly.
    /// </summary>
    [Fact]
    public void Constructor_WithConfiguration_SetsPropertiesCorrectly()
    {
        // Arrange
        string tenantId = "testTenantId";
        string appClientId = "testAppClientId";
        string appClientSecret = "testAppClientSecret";

        Mock<IConfigurationSection> mockConfig = new();
        mockConfig.Setup(c => c[nameof(CopilotStudioConnectionSettings.TenantId)]).Returns(tenantId);
        mockConfig.Setup(c => c[nameof(CopilotStudioConnectionSettings.AppClientId)]).Returns(appClientId);
        mockConfig.Setup(c => c[nameof(CopilotStudioConnectionSettings.AppClientSecret)]).Returns(appClientSecret);

        // Act
        CopilotStudioConnectionSettings settings = new(mockConfig.Object);

        // Assert
        Assert.Equal(tenantId, settings.TenantId);
        Assert.Equal(appClientId, settings.AppClientId);
        Assert.Equal(appClientSecret, settings.AppClientSecret);
        Assert.True(settings.UseInteractiveAuthentication);
    }

    /// <summary>
    /// Verifies that the constructor throws an exception when AppClientId is missing in configuration.
    /// </summary>
    [Fact]
    public void Constructor_WithConfigurationMissingAppClientId_ThrowsArgumentException()
    {
        // Arrange
        string tenantId = "testTenantId";

        Mock<IConfigurationSection> mockConfig = new();
        mockConfig.Setup(c => c[nameof(CopilotStudioConnectionSettings.TenantId)]).Returns(tenantId);
        mockConfig.Setup(c => c[nameof(CopilotStudioConnectionSettings.AppClientId)]).Returns((string)null!);

        // Act & Assert
        ArgumentException exception = Assert.Throws<ArgumentException>(() =>
            new CopilotStudioConnectionSettings(mockConfig.Object));
        Assert.Contains("AppClientId", exception.Message);
    }

    /// <summary>
    /// Verifies that the constructor throws an exception when TenantId is missing in configuration.
    /// </summary>
    [Fact]
    public void Constructor_WithConfigurationMissingTenantId_ThrowsArgumentException()
    {
        // Arrange
        string appClientId = "testAppClientId";

        Mock<IConfigurationSection> mockConfig = new();
        mockConfig.Setup(c => c[nameof(CopilotStudioConnectionSettings.TenantId)]).Returns((string)null!);
        mockConfig.Setup(c => c[nameof(CopilotStudioConnectionSettings.AppClientId)]).Returns(appClientId);

        // Act & Assert
        ArgumentException exception = Assert.Throws<ArgumentException>(() =>
            new CopilotStudioConnectionSettings(mockConfig.Object));
        Assert.Contains("TenantId", exception.Message);
    }

    /// <summary>
    /// Verifies that the constructor does not throw when AppClientSecret is missing in configuration.
    /// </summary>
    [Fact]
    public void Constructor_WithConfigurationMissingAppClientSecret_DoesNotThrow()
    {
        // Arrange
        string tenantId = "testTenantId";
        string appClientId = "testAppClientId";

        Mock<IConfigurationSection> mockConfig = new();
        mockConfig.Setup(c => c[nameof(CopilotStudioConnectionSettings.TenantId)]).Returns(tenantId);
        mockConfig.Setup(c => c[nameof(CopilotStudioConnectionSettings.AppClientId)]).Returns(appClientId);
        mockConfig.Setup(c => c[nameof(CopilotStudioConnectionSettings.AppClientSecret)]).Returns((string)null!);

        // Act & Assert - Should not throw
        CopilotStudioConnectionSettings settings = new(mockConfig.Object);

        // Additional verification
        Assert.Equal(tenantId, settings.TenantId);
        Assert.Equal(appClientId, settings.AppClientId);
        Assert.Null(settings.AppClientSecret);
    }

    /// <summary>
    /// Verifies that the default value of UseInteractiveAuthentication is true.
    /// </summary>
    [Fact]
    public void UseInteractiveAuthentication_DefaultValue_IsTrue()
    {
        // Arrange & Act
        CopilotStudioConnectionSettings settings = new("testTenantId", "testAppClientId");

        // Assert
        Assert.True(settings.UseInteractiveAuthentication);
    }

    /// <summary>
    /// Verifies that UseInteractiveAuthentication property can be modified.
    /// </summary>
    [Fact]
    public void UseInteractiveAuthentication_CanBeModified()
    {
        // Arrange
        CopilotStudioConnectionSettings settings = new("testTenantId", "testAppClientId")
        {
            UseInteractiveAuthentication = false
        };

        // Assert
        Assert.False(settings.UseInteractiveAuthentication);
    }

    /// <summary>
    /// Verifies that the default value of Cloud property is Prod.
    /// </summary>
    [Fact]
    public void DefaultCloud_IsProd()
    {
        // Arrange & Act
        CopilotStudioConnectionSettings settings = new("testTenantId", "testAppClientId");

        // Assert
        Assert.Equal(PowerPlatformCloud.Prod, settings.Cloud);
    }

    /// <summary>
    /// Verifies that the default value of CopilotAgentType property is Published.
    /// </summary>
    [Fact]
    public void DefaultCopilotAgentType_IsPublished()
    {
        // Arrange & Act
        CopilotStudioConnectionSettings settings = new("testTenantId", "testAppClientId");

        // Assert
        Assert.Equal(AgentType.Published, settings.CopilotAgentType);
    }
}


===== UnitTests\Core\AgentGroupChatTests.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.Agents.Chat;
using Microsoft.SemanticKernel.ChatCompletion;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.Core;

/// <summary>
/// Unit testing of <see cref="AgentChat"/>.
/// </summary>
public class AgentGroupChatTests
{
    /// <summary>
    /// Verify the default state of <see cref="AgentChat"/>.
    /// </summary>
    [Fact]
    public void VerifyGroupAgentChatDefaultState()
    {
        // Arrange
        AgentGroupChat chat = new();

        // Assert
        Assert.Empty(chat.Agents);
        Assert.NotNull(chat.ExecutionSettings);
        Assert.False(chat.IsComplete);

        // Act
        chat.IsComplete = true;

        // Assert
        Assert.True(chat.IsComplete);
    }

    /// <summary>
    /// Verify the management of <see cref="Agent"/> instances as they join <see cref="AgentChat"/>.
    /// </summary>
    [Fact]
    public async Task VerifyGroupAgentChatAgentMembershipAsync()
    {
        // Arrange
        Agent agent1 = CreateMockAgent();
        Agent agent2 = CreateMockAgent();
        Agent agent3 = CreateMockAgent();
        Agent agent4 = CreateMockAgent();

        AgentGroupChat chat = new(agent1, agent2);

        // Assert
        Assert.Equal(2, chat.Agents.Count);

        // Act
        chat.AddAgent(agent3);
        // Assert
        Assert.Equal(3, chat.Agents.Count);

        // Act
        ChatMessageContent[] messages = await chat.InvokeAsync(agent4).ToArrayAsync();
        // Assert
        Assert.Equal(4, chat.Agents.Count);
    }

    /// <summary>
    /// Verify the management of <see cref="Agent"/> instances as they join <see cref="AgentChat"/>.
    /// </summary>
    [Fact]
    public async Task VerifyGroupAgentChatMultiTurnAsync()
    {
        // Arrange
        Agent agent1 = CreateMockAgent();
        Agent agent2 = CreateMockAgent();
        Agent agent3 = CreateMockAgent();

        AgentGroupChat chat =
            new(agent1, agent2, agent3)
            {
                ExecutionSettings =
                    new()
                    {
                        TerminationStrategy =
                        {
                            // This test is designed to take 9 turns.
                            MaximumIterations = 9,
                        }
                    },
                IsComplete = true
            };

        // Act and Assert
        await Assert.ThrowsAsync<KernelException>(() => chat.InvokeAsync(CancellationToken.None).ToArrayAsync().AsTask());

        // Act
        chat.ExecutionSettings.TerminationStrategy.AutomaticReset = true;
        var messages = await chat.InvokeAsync(CancellationToken.None).ToArrayAsync();

        // Assert
        Assert.Equal(9, messages.Length);
        Assert.False(chat.IsComplete);

        for (int index = 0; index < messages.Length; ++index) // Clean-up
        {
            switch (index % 3)
            {
                case 0:
                    Assert.Equal(agent1.Name, messages[index].AuthorName);
                    break;
                case 1:
                    Assert.Equal(agent2.Name, messages[index].AuthorName);
                    break;
                case 2:
                    Assert.Equal(agent3.Name, messages[index].AuthorName);
                    break;
            }
        }
    }

    /// <summary>
    /// Verify the management of <see cref="Agent"/> instances as they join <see cref="AgentChat"/>.
    /// </summary>
    [Fact]
    public async Task VerifyGroupAgentChatFailedSelectionAsync()
    {
        // Arrange
        AgentGroupChat chat = Create3AgentChat();

        chat.ExecutionSettings =
            new()
            {
                // Strategy that will not select an agent.
                SelectionStrategy = new FailedSelectionStrategy(),
                TerminationStrategy =
                {
                    // Remove max-limit in order to isolate the target behavior.
                    MaximumIterations = int.MaxValue
                }
            };

        // Remove max-limit in order to isolate the target behavior.
        chat.ExecutionSettings.TerminationStrategy.MaximumIterations = int.MaxValue;

        // Act and Assert
        await Assert.ThrowsAsync<InvalidOperationException>(() => chat.InvokeAsync().ToArrayAsync().AsTask());
    }

    /// <summary>
    /// Verify the management of <see cref="Agent"/> instances as they join <see cref="AgentChat"/>.
    /// </summary>
    [Fact]
    public async Task VerifyGroupAgentChatMultiTurnTerminationAsync()
    {
        // Arrange
        AgentGroupChat chat = Create3AgentChat();

        chat.ExecutionSettings =
            new()
            {
                TerminationStrategy =
                    new TestTerminationStrategy(shouldTerminate: true)
                    {
                        // Remove max-limit in order to isolate the target behavior.
                        MaximumIterations = int.MaxValue
                    }
            };

        // Act
        var messages = await chat.InvokeAsync(CancellationToken.None).ToArrayAsync();

        // Assert
        Assert.Single(messages);
        Assert.True(chat.IsComplete);
    }

    /// <summary>
    /// Verify the management of <see cref="Agent"/> instances as they join <see cref="AgentChat"/>.
    /// </summary>
    [Fact]
    public async Task VerifyGroupAgentChatDiscreteTerminationAsync()
    {
        // Arrange
        Agent agent1 = CreateMockAgent();

        AgentGroupChat chat =
            new()
            {
                ExecutionSettings =
                    new()
                    {
                        TerminationStrategy =
                            new TestTerminationStrategy(shouldTerminate: true)
                            {
                                // Remove max-limit in order to isolate the target behavior.
                                MaximumIterations = int.MaxValue
                            }
                    }
            };

        // Act
        var messages = await chat.InvokeAsync(agent1).ToArrayAsync();

        // Assert
        Assert.Single(messages);
        Assert.True(chat.IsComplete);
    }

    private static AgentGroupChat Create3AgentChat()
    {
        Agent agent1 = CreateMockAgent();
        Agent agent2 = CreateMockAgent();
        Agent agent3 = CreateMockAgent();

        return new(agent1, agent2, agent3);
    }

    private static MockAgent CreateMockAgent() => new() { Response = [new(AuthorRole.Assistant, "test")] };

    private sealed class TestTerminationStrategy(bool shouldTerminate) : TerminationStrategy
    {
        protected override Task<bool> ShouldAgentTerminateAsync(Agent agent, IReadOnlyList<ChatMessageContent> history, CancellationToken cancellationToken)
        {
            return Task.FromResult(shouldTerminate);
        }
    }

    private sealed class FailedSelectionStrategy : SelectionStrategy
    {
        protected override Task<Agent> SelectAgentAsync(IReadOnlyList<Agent> agents, IReadOnlyList<ChatMessageContent> history, CancellationToken cancellationToken = default)
        {
            throw new InvalidOperationException();
        }
    }
}


===== UnitTests\Core\AgentThreadTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.AI;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.ChatCompletion;
using Moq;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.Core;

/// <summary>
/// Contains tests for the <see cref="AgentThread"/> class.
/// </summary>
public class AgentThreadTests
{
    /// <summary>
    /// Tests that the CreateAsync method sets the Id and invokes CreateInternalAsync once.
    /// </summary>
    [Fact]
    public async Task CreateShouldSetIdAndInvokeCreateInternalOnceAsync()
    {
        // Arrange
        var thread = new TestAgentThread();

        // Act
        await thread.CreateAsync();
        await thread.CreateAsync();

        // Assert
        Assert.Equal("test-thread-id", thread.Id);
        Assert.Equal(1, thread.CreateInternalAsyncCount);
    }

    /// <summary>
    /// Tests that the CreateAsync method throws an InvalidOperationException if the thread is deleted.
    /// </summary>
    [Fact]
    public async Task CreateShouldThrowIfThreadDeletedAsync()
    {
        // Arrange
        var thread = new TestAgentThread();
        await thread.CreateAsync();
        await thread.DeleteAsync();

        // Act & Assert
        await Assert.ThrowsAsync<InvalidOperationException>(() => thread.CreateAsync());
        Assert.Equal(1, thread.CreateInternalAsyncCount);
        Assert.Equal(1, thread.DeleteInternalAsyncCount);
    }

    /// <summary>
    /// Tests that the DeleteAsync method sets IsDeleted and invokes DeleteInternalAsync.
    /// </summary>
    [Fact]
    public async Task DeleteShouldSetIsDeletedAndInvokeDeleteInternalAsync()
    {
        // Arrange
        var thread = new TestAgentThread();
        await thread.CreateAsync();

        // Act
        await thread.DeleteAsync();

        // Assert
        Assert.True(thread.IsDeleted);
        Assert.Equal(1, thread.CreateInternalAsyncCount);
        Assert.Equal(1, thread.DeleteInternalAsyncCount);
    }

    /// <summary>
    /// Tests that the DeleteAsync method does not invoke DeleteInternalAsync if the thread is already deleted.
    /// </summary>
    [Fact]
    public async Task DeleteShouldNotInvokeDeleteInternalIfAlreadyDeletedAsync()
    {
        // Arrange
        var thread = new TestAgentThread();
        await thread.CreateAsync();
        await thread.DeleteAsync();

        // Act
        await thread.DeleteAsync();

        // Assert
        Assert.True(thread.IsDeleted);
        Assert.Equal(1, thread.CreateInternalAsyncCount);
        Assert.Equal(1, thread.DeleteInternalAsyncCount);
    }

    /// <summary>
    /// Tests that the DeleteAsync method throws an InvalidOperationException if the thread was never created.
    /// </summary>
    [Fact]
    public async Task DeleteShouldThrowIfNeverCreatedAsync()
    {
        // Arrange
        var thread = new TestAgentThread();

        // Act & Assert
        await Assert.ThrowsAsync<InvalidOperationException>(() => thread.DeleteAsync());
        Assert.Equal(0, thread.CreateInternalAsyncCount);
        Assert.Equal(0, thread.DeleteInternalAsyncCount);
    }

    /// <summary>
    /// Tests that the OnNewMessageAsync method creates the thread if it is not already created.
    /// </summary>
    [Fact]
    public async Task OnNewMessageShouldCreateThreadIfNotCreatedAsync()
    {
        // Arrange
        var thread = new TestAgentThread();
        var message = new ChatMessageContent();

        // Act
        await thread.OnNewMessageAsync(message);

        // Assert
        Assert.Equal("test-thread-id", thread.Id);
        Assert.Equal(1, thread.CreateInternalAsyncCount);
        Assert.Equal(1, thread.OnNewMessageInternalAsyncCount);
    }

    /// <summary>
    /// Tests that the OnNewMessageAsync method throws an InvalidOperationException if the thread is deleted.
    /// </summary>
    [Fact]
    public async Task OnNewMessageShouldThrowIfThreadDeletedAsync()
    {
        // Arrange
        var thread = new TestAgentThread();
        await thread.CreateAsync();
        await thread.DeleteAsync();
        var message = new ChatMessageContent();

        // Act & Assert
        await Assert.ThrowsAsync<InvalidOperationException>(() => thread.OnNewMessageAsync(message));
        Assert.Equal(1, thread.CreateInternalAsyncCount);
        Assert.Equal(1, thread.DeleteInternalAsyncCount);
        Assert.Equal(0, thread.OnNewMessageInternalAsyncCount);
    }

    /// <summary>
    /// Tests that the <see cref="AgentThread.OnResumeAsync(CancellationToken)"/> method throws an InvalidOperationException if the thread is not yet created.
    /// </summary>
    [Fact]
    public async Task OnResumeShouldThrowIfThreadNotCreatedAsync()
    {
        // Arrange
        var thread = new TestAgentThread();

        // Act & Assert
        await Assert.ThrowsAsync<InvalidOperationException>(() => thread.OnResumeAsync());
    }

    /// <summary>
    /// Tests that the <see cref="AgentThread.OnResumeAsync(CancellationToken)"/> method throws an InvalidOperationException if the thread is deleted.
    /// </summary>
    [Fact]
    public async Task OnResumeShouldThrowIfThreadDeletedAsync()
    {
        // Arrange
        var thread = new TestAgentThread();
        await thread.CreateAsync();
        await thread.DeleteAsync();

        // Act & Assert
        await Assert.ThrowsAsync<InvalidOperationException>(() => thread.OnResumeAsync());
    }

    /// <summary>
    /// Tests that the <see cref="AgentThread.OnSuspendAsync(CancellationToken)"/> method
    /// calls each registered state part in turn.
    /// </summary>
    [Fact]
    public async Task OnSuspendShouldCallOnSuspendOnRegisteredPartsAsync()
    {
        // Arrange.
        var thread = new TestAgentThread();
        var mockProvider = new Mock<AIContextProvider>();
        thread.AIContextProviders.Add(mockProvider.Object);
        await thread.CreateAsync();

        // Act.
        await thread.OnSuspendAsync();

        // Assert.
        mockProvider.Verify(x => x.SuspendingAsync("test-thread-id", It.IsAny<CancellationToken>()), Times.Once);
    }

    /// <summary>
    /// Tests that the <see cref="AgentThread.OnResumeAsync(CancellationToken)"/> method
    /// calls each registered state part in turn.
    /// </summary>
    [Fact]
    public async Task OnResumeShouldCallOnResumeOnRegisteredPartsAsync()
    {
        // Arrange.
        var thread = new TestAgentThread();
        var mockProvider = new Mock<AIContextProvider>();
        thread.AIContextProviders.Add(mockProvider.Object);
        await thread.CreateAsync();

        // Act.
        await thread.OnResumeAsync();

        // Assert.
        mockProvider.Verify(x => x.ResumingAsync("test-thread-id", It.IsAny<CancellationToken>()), Times.Once);
    }

    /// <summary>
    /// Tests that the <see cref="AgentThread.CreateAsync(CancellationToken)"/> method
    /// calls each registered state parts in turn.
    /// </summary>
    [Fact]
    public async Task CreateShouldCallOnThreadCreatedOnRegisteredPartsAsync()
    {
        // Arrange.
        var thread = new TestAgentThread();
        var mockProvider = new Mock<AIContextProvider>();
        thread.AIContextProviders.Add(mockProvider.Object);

        // Act.
        await thread.CreateAsync();

        // Assert.
        mockProvider.Verify(x => x.ConversationCreatedAsync("test-thread-id", It.IsAny<CancellationToken>()), Times.Once);
    }

    /// <summary>
    /// Tests that the <see cref="AgentThread.DeleteAsync(CancellationToken)"/> method
    /// calls each registered state parts in turn.
    /// </summary>
    [Fact]
    public async Task DeleteShouldCallOnThreadDeleteOnRegisteredPartsAsync()
    {
        // Arrange.
        var thread = new TestAgentThread();
        var mockProvider = new Mock<AIContextProvider>();
        thread.AIContextProviders.Add(mockProvider.Object);
        await thread.CreateAsync();

        // Act.
        await thread.DeleteAsync();

        // Assert.
        mockProvider.Verify(x => x.ConversationDeletingAsync("test-thread-id", It.IsAny<CancellationToken>()), Times.Once);
    }

    /// <summary>
    /// Tests that the <see cref="AgentThread.OnNewMessageAsync(ChatMessageContent, CancellationToken)"/> method
    /// calls each registered state part in turn.
    /// </summary>
    [Fact]
    public async Task OnNewMessageShouldCallOnNewMessageOnRegisteredPartsAsync()
    {
        // Arrange.
        var thread = new TestAgentThread();
        var mockProvider = new Mock<AIContextProvider>();
        thread.AIContextProviders.Add(mockProvider.Object);
        var message = new ChatMessageContent(AuthorRole.User, "Test Message.");

        await thread.CreateAsync();

        // Act.
        await thread.OnNewMessageAsync(message);

        // Assert.
        mockProvider.Verify(x => x.MessageAddingAsync("test-thread-id", It.Is<ChatMessage>(x => x.Text == "Test Message." && x.Role == ChatRole.User), It.IsAny<CancellationToken>()), Times.Once);
    }

    private sealed class TestAgentThread : AgentThread
    {
        public int CreateInternalAsyncCount { get; private set; }
        public int DeleteInternalAsyncCount { get; private set; }
        public int OnNewMessageInternalAsyncCount { get; private set; }

        public new Task CreateAsync(CancellationToken cancellationToken = default)
        {
            return base.CreateAsync(cancellationToken);
        }

        protected override Task<string?> CreateInternalAsync(CancellationToken cancellationToken)
        {
            this.CreateInternalAsyncCount++;
            return Task.FromResult<string?>("test-thread-id");
        }

        protected override Task DeleteInternalAsync(CancellationToken cancellationToken)
        {
            this.DeleteInternalAsyncCount++;
            return Task.CompletedTask;
        }

        protected override Task OnNewMessageInternalAsync(ChatMessageContent newMessage, CancellationToken cancellationToken = default)
        {
            this.OnNewMessageInternalAsyncCount++;
            return Task.CompletedTask;
        }
    }
}


===== UnitTests\Core\Chat\AgentGroupChatSettingsTests.cs =====

// Copyright (c) Microsoft. All rights reserved.
using Microsoft.SemanticKernel.Agents.Chat;
using Moq;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.Core.Chat;

/// <summary>
/// Unit testing of <see cref="AgentGroupChatSettings"/>.
/// </summary>
public class AgentGroupChatSettingsTests
{
    /// <summary>
    /// Verify default state.
    /// </summary>
    [Fact]
    public void VerifyChatExecutionSettingsDefault()
    {
        // Arrange
        AgentGroupChatSettings settings = new();

        // Assert
        Assert.IsType<AgentGroupChatSettings.DefaultTerminationStrategy>(settings.TerminationStrategy);
        Assert.Equal(1, settings.TerminationStrategy.MaximumIterations);
        Assert.IsType<SequentialSelectionStrategy>(settings.SelectionStrategy);
    }

    /// <summary>
    /// Verify accepts <see cref="TerminationStrategy"/> for <see cref="AgentGroupChatSettings.TerminationStrategy"/>.
    /// </summary>
    [Fact]
    public void VerifyChatExecutionContinuationStrategyDefault()
    {
        // Arrange
        Mock<TerminationStrategy> strategyMock = new();
        AgentGroupChatSettings settings =
            new()
            {
                TerminationStrategy = strategyMock.Object
            };

        // Assert
        Assert.Equal(strategyMock.Object, settings.TerminationStrategy);
    }

    /// <summary>
    /// Verify accepts <see cref="SelectionStrategy"/> for <see cref="AgentGroupChatSettings.SelectionStrategy"/>.
    /// </summary>
    [Fact]
    public void VerifyChatExecutionSelectionStrategyDefault()
    {
        // Arrange
        Mock<SelectionStrategy> strategyMock = new();
        AgentGroupChatSettings settings =
            new()
            {
                SelectionStrategy = strategyMock.Object
            };

        // Assert
        Assert.NotNull(settings.SelectionStrategy);
        Assert.Equal(strategyMock.Object, settings.SelectionStrategy);
    }
}


===== UnitTests\Core\Chat\AggregatorTerminationStrategyTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.Agents.Chat;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.Core.Chat;

/// <summary>
/// Unit testing of <see cref="AggregatorTerminationStrategy"/>.
/// </summary>
public class AggregatorTerminationStrategyTests
{
    /// <summary>
    /// Verify initial state.
    /// </summary>
    [Fact]
    public void VerifyAggregateTerminationStrategyInitialState()
    {
        // Arrange
        AggregatorTerminationStrategy strategy = new();

        // Assert
        Assert.Equal(AggregateTerminationCondition.All, strategy.Condition);
    }

    /// <summary>
    /// Verify evaluation of AggregateTerminationCondition.Any.
    /// </summary>
    [Fact]
    public async Task VerifyAggregateTerminationStrategyAnyAsync()
    {
        // Arrange
        TerminationStrategy strategyMockTrue = new MockTerminationStrategy(terminationResult: true);
        TerminationStrategy strategyMockFalse = new MockTerminationStrategy(terminationResult: false);

        MockAgent agentMock = new();

        // Act and Assert
        await VerifyResultAsync(
            expectedResult: true,
            agentMock,
            new(strategyMockTrue, strategyMockFalse)
            {
                Condition = AggregateTerminationCondition.Any,
            });

        await VerifyResultAsync(
            expectedResult: false,
            agentMock,
            new(strategyMockFalse, strategyMockFalse)
            {
                Condition = AggregateTerminationCondition.Any,
            });

        await VerifyResultAsync(
            expectedResult: true,
            agentMock,
            new(strategyMockTrue, strategyMockTrue)
            {
                Condition = AggregateTerminationCondition.Any,
            });
    }

    /// <summary>
    /// Verify evaluation of AggregateTerminationCondition.All.
    /// </summary>
    [Fact]
    public async Task VerifyAggregateTerminationStrategyAllAsync()
    {
        // Arrange
        TerminationStrategy strategyMockTrue = new MockTerminationStrategy(terminationResult: true);
        TerminationStrategy strategyMockFalse = new MockTerminationStrategy(terminationResult: false);

        MockAgent agentMock = new();

        // Act and Assert
        await VerifyResultAsync(
            expectedResult: false,
            agentMock,
            new(strategyMockTrue, strategyMockFalse)
            {
                Condition = AggregateTerminationCondition.All,
            });

        await VerifyResultAsync(
            expectedResult: false,
            agentMock,
            new(strategyMockFalse, strategyMockFalse)
            {
                Condition = AggregateTerminationCondition.All,
            });

        await VerifyResultAsync(
            expectedResult: true,
            agentMock,
            new(strategyMockTrue, strategyMockTrue)
            {
                Condition = AggregateTerminationCondition.All,
            });
    }

    /// <summary>
    /// Verify evaluation of agent scope evaluation.
    /// </summary>
    [Fact]
    public async Task VerifyAggregateTerminationStrategyAgentAsync()
    {
        // Arrange
        TerminationStrategy strategyMockTrue = new MockTerminationStrategy(terminationResult: true);
        TerminationStrategy strategyMockFalse = new MockTerminationStrategy(terminationResult: false);

        MockAgent agentMockA = new();
        MockAgent agentMockB = new();

        // Act and Assert
        await VerifyResultAsync(
            expectedResult: false,
            agentMockB,
            new(strategyMockTrue, strategyMockTrue)
            {
                Agents = [agentMockA],
                Condition = AggregateTerminationCondition.All,
            });

        await VerifyResultAsync(
            expectedResult: true,
            agentMockB,
            new(strategyMockTrue, strategyMockTrue)
            {
                Agents = [agentMockB],
                Condition = AggregateTerminationCondition.All,
            });
    }

    private static async Task VerifyResultAsync(bool expectedResult, Agent agent, AggregatorTerminationStrategy strategyRoot)
    {
        // Act
        var result = await strategyRoot.ShouldTerminateAsync(agent, []);

        // Assert
        Assert.Equal(expectedResult, result);
    }

    /// <summary>
    /// Less side-effects when mocking protected method.
    /// </summary>
    private sealed class MockTerminationStrategy(bool terminationResult) : TerminationStrategy
    {
        protected override Task<bool> ShouldAgentTerminateAsync(Agent agent, IReadOnlyList<ChatMessageContent> history, CancellationToken cancellationToken)
            => Task.FromResult(terminationResult);
    }
}


===== UnitTests\Core\Chat\KernelFunctionSelectionStrategyTests.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Linq;
using System.Threading.Tasks;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.Agents.Chat;
using Microsoft.SemanticKernel.Connectors.OpenAI;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.Core.Chat;

/// <summary>
/// Unit testing of <see cref="KernelFunctionSelectionStrategy"/>.
/// </summary>
public class KernelFunctionSelectionStrategyTests
{
    /// <summary>
    /// Verify default state and behavior
    /// </summary>
    [Fact]
    public async Task VerifyKernelFunctionSelectionStrategyDefaultsAsync()
    {
        // Arrange
        MockAgent mockAgent = new();
        KernelPlugin plugin = KernelPluginFactory.CreateFromObject(new TestPlugin(mockAgent.Id));

        KernelFunctionSelectionStrategy strategy =
            new(plugin.Single(), new())
            {
                AgentsVariableName = "_a_",
                HistoryVariableName = "_h_",
                ResultParser = (result) => result.GetValue<string>() ?? string.Empty,
            };

        // Assert
        Assert.Null(strategy.Arguments);
        Assert.NotNull(strategy.Kernel);
        Assert.NotNull(strategy.ResultParser);
        Assert.Equal("_a_", strategy.AgentsVariableName);
        Assert.Equal("_h_", strategy.HistoryVariableName);

        // Act
        Agent nextAgent = await strategy.NextAsync([mockAgent], []);

        // Assert
        Assert.NotNull(nextAgent);
        Assert.Equal(mockAgent, nextAgent);
    }

    /// <summary>
    /// Verify strategy mismatch.
    /// </summary>
    [Fact]
    public async Task VerifyKernelFunctionSelectionStrategyThrowsOnNullResultAsync()
    {
        // Arrange
        MockAgent mockAgent = new();
        KernelPlugin plugin = KernelPluginFactory.CreateFromObject(new TestPlugin(mockAgent.Id));

        KernelFunctionSelectionStrategy strategy =
            new(plugin.Single(), new())
            {
                Arguments = new(new OpenAIPromptExecutionSettings()) { { "key", mockAgent.Name } },
                ResultParser = (result) => "larry",
            };

        // Act and Assert
        await Assert.ThrowsAsync<KernelException>(() => strategy.NextAsync([mockAgent], []));
    }
    /// <summary>
    /// Verify default state and behavior
    /// </summary>
    [Fact]
    public async Task VerifyKernelFunctionSelectionStrategyInitialAgentAsync()
    {
        MockAgent mockAgent1 = new();
        MockAgent mockAgent2 = new();
        KernelPlugin plugin = KernelPluginFactory.CreateFromObject(new TestPlugin(mockAgent2.Id));

        KernelFunctionSelectionStrategy strategy =
            new(plugin.Single(), new())
            {
                InitialAgent = mockAgent1,
                ResultParser = (result) => result.GetValue<string>() ?? string.Empty,
            };

        Agent nextAgent = await strategy.NextAsync([mockAgent2], []);

        Assert.NotNull(nextAgent);
        Assert.Equal(mockAgent1, nextAgent);
    }

    /// <summary>
    /// Verify strategy mismatch.
    /// </summary>
    [Fact]
    public async Task VerifyKernelFunctionSelectionStrategyNullAgentAsync()
    {
        MockAgent mockAgent = new();
        KernelPlugin plugin = KernelPluginFactory.CreateFromObject(new TestPlugin(null));

        KernelFunctionSelectionStrategy strategy =
            new(plugin.Single(), new())
            {
                Arguments = new(new OpenAIPromptExecutionSettings()) { { "key", mockAgent.Name } },
            };

        await Assert.ThrowsAsync<KernelException>(() => strategy.NextAsync([mockAgent], []));

        strategy =
            new(plugin.Single(), new())
            {
                Arguments = new(new OpenAIPromptExecutionSettings()) { { "key", mockAgent.Name } },
                UseInitialAgentAsFallback = true
            };

        await Assert.ThrowsAsync<KernelException>(() => strategy.NextAsync([mockAgent], []));
    }

    /// <summary>
    /// Verify strategy mismatch.
    /// </summary>
    [Fact]
    public async Task VerifyKernelFunctionSelectionStrategyBadAgentFallbackWithNoInitialAgentAsync()
    {
        // Arrange
        MockAgent mockAgent = new();
        KernelPlugin plugin = KernelPluginFactory.CreateFromObject(new TestPlugin("bad"));

        KernelFunctionSelectionStrategy strategy =
            new(plugin.Single(), new())
            {
                Arguments = new(new OpenAIPromptExecutionSettings()) { { "key", mockAgent.Name } },
            };

        await Assert.ThrowsAsync<KernelException>(() => strategy.NextAsync([mockAgent], []));

        strategy =
            new(plugin.Single(), new())
            {
                Arguments = new(new OpenAIPromptExecutionSettings()) { { "key", mockAgent.Name } },
                UseInitialAgentAsFallback = true
            };

        // Act and Assert
        await Assert.ThrowsAsync<KernelException>(() => strategy.NextAsync([mockAgent], []));
    }

    /// <summary>
    /// Verify strategy mismatch.
    /// </summary>
    [Fact]
    public async Task VerifyKernelFunctionSelectionStrategyBadAgentFallbackAsync()
    {
        MockAgent mockAgent = new();
        KernelPlugin plugin = KernelPluginFactory.CreateFromObject(new TestPlugin("bad"));

        KernelFunctionSelectionStrategy strategy =
            new(plugin.Single(), new())
            {
                Arguments = new(new OpenAIPromptExecutionSettings()) { { "key", mockAgent.Name } },
                InitialAgent = mockAgent,
                UseInitialAgentAsFallback = true
            };

        Agent nextAgent = await strategy.NextAsync([mockAgent], []);

        Assert.NotNull(nextAgent);
        Assert.Equal(mockAgent, nextAgent);
    }

    private sealed class TestPlugin(string? agentName)
    {
        [KernelFunction]
        public string? GetValue() => agentName;
    }
}


===== UnitTests\Core\Chat\KernelFunctionTerminationStrategyTests.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents.Chat;
using Microsoft.SemanticKernel.Connectors.OpenAI;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.Core.Chat;

/// <summary>
/// Unit testing of <see cref="KernelFunctionTerminationStrategy"/>.
/// </summary>
public class KernelFunctionTerminationStrategyTests
{
    /// <summary>
    /// Verify default state and behavior
    /// </summary>
    [Fact]
    public async Task VerifyKernelFunctionTerminationStrategyDefaultsAsync()
    {
        // Arrange
        KernelPlugin plugin = KernelPluginFactory.CreateFromObject(new TestPlugin());

        KernelFunctionTerminationStrategy strategy =
            new(plugin.Single(), new())
            {
                AgentVariableName = "agent",
                HistoryVariableName = "history",
            };

        // Assert
        Assert.Null(strategy.Arguments);
        Assert.NotNull(strategy.Kernel);
        Assert.NotNull(strategy.ResultParser);
        Assert.NotEqual("agent", KernelFunctionTerminationStrategy.DefaultAgentVariableName);
        Assert.NotEqual("history", KernelFunctionTerminationStrategy.DefaultHistoryVariableName);

        // Act
        MockAgent mockAgent = new();
        bool isTerminating = await strategy.ShouldTerminateAsync(mockAgent, []);

        Assert.True(isTerminating);
    }

    /// <summary>
    /// Verify strategy with result parser.
    /// </summary>
    [Fact]
    public async Task VerifyKernelFunctionTerminationStrategyParsingAsync()
    {
        KernelPlugin plugin = KernelPluginFactory.CreateFromObject(new TestPlugin());

        KernelFunctionTerminationStrategy strategy =
            new(plugin.Single(), new())
            {
                Arguments = new(new OpenAIPromptExecutionSettings()) { { "key", "test" } },
                ResultParser = (result) => string.Equals("test", result.GetValue<string>(), StringComparison.OrdinalIgnoreCase)
            };

        MockAgent mockAgent = new();

        bool isTerminating = await strategy.ShouldTerminateAsync(mockAgent, []);

        Assert.True(isTerminating);
    }

    private sealed class TestPlugin()
    {
        [KernelFunction]
        public string GetValue(KernelArguments? arguments)
        {
            string? argument = arguments?.First().Value?.ToString();
            return argument ?? string.Empty;
        }
    }
}


===== UnitTests\Core\Chat\RegExTerminationStrategyTests.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents.Chat;
using Microsoft.SemanticKernel.ChatCompletion;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.Core.Chat;

/// <summary>
/// Unit testing of <see cref="RegexTerminationStrategy"/>.
/// </summary>
public partial class RegexTerminationStrategyTests
{
    /// <summary>
    /// Verify abililty of strategy to match expression.
    /// </summary>
    [Fact]
    public async Task VerifyExpressionTerminationStrategyAsync()
    {
        // Arrange
        RegexTerminationStrategy strategy = new("test");

        Regex r = MyRegex();

        // Act and Assert
        await VerifyResultAsync(
            expectedResult: false,
            new(r),
            content: "fred");

        await VerifyResultAsync(
            expectedResult: true,
            new(r),
            content: "this is a test");
    }

    private static async Task VerifyResultAsync(bool expectedResult, RegexTerminationStrategy strategyRoot, string content)
    {
        // Arrange
        ChatMessageContent message = new(AuthorRole.Assistant, content);
        MockAgent agent = new();

        // Act
        var result = await strategyRoot.ShouldTerminateAsync(agent, [message]);

        // Assert
        Assert.Equal(expectedResult, result);
    }

    [GeneratedRegex("(?:^|\\W)test(?:$|\\W)")]
    private static partial Regex MyRegex();
}


===== UnitTests\Core\Chat\SequentialSelectionStrategyTests.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Threading.Tasks;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.Agents.Chat;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.Core.Chat;

/// <summary>
/// Unit testing of <see cref="SequentialSelectionStrategy"/>.
/// </summary>
public class SequentialSelectionStrategyTests
{
    /// <summary>
    /// Verify <see cref="SequentialSelectionStrategy"/> provides agents in expected order.
    /// </summary>
    [Fact]
    public async Task VerifySequentialSelectionStrategyTurnsAsync()
    {
        // Arrange
        MockAgent agent1 = new();
        MockAgent agent2 = new();

        Agent[] agents = [agent1, agent2];
        SequentialSelectionStrategy strategy = new();

        // Act and Assert
        await VerifyNextAgentAsync(agent1, agents, strategy);
        await VerifyNextAgentAsync(agent2, agents, strategy);
        await VerifyNextAgentAsync(agent1, agents, strategy);
        await VerifyNextAgentAsync(agent2, agents, strategy);
        await VerifyNextAgentAsync(agent1, agents, strategy);

        // Arrange
        strategy.Reset();
        await VerifyNextAgentAsync(agent1, agents, strategy);

        // Verify index does not exceed current bounds.
        agents = [agent1];
        await VerifyNextAgentAsync(agent1, agents, strategy);
    }

    /// <summary>
    /// Verify <see cref="SequentialSelectionStrategy"/> provides agents in expected order.
    /// </summary>
    [Fact]
    public async Task VerifySequentialSelectionStrategyInitialLastAgentAsync()
    {
        MockAgent agent1 = new();
        MockAgent agent2 = new();

        Agent[] agents = [agent1, agent2];
        SequentialSelectionStrategy strategy =
            new()
            {
                InitialAgent = agent2
            };

        await VerifyNextAgentAsync(agent2, agents, strategy);
        await VerifyNextAgentAsync(agent1, agents, strategy);
        await VerifyNextAgentAsync(agent2, agents, strategy);
        await VerifyNextAgentAsync(agent1, agents, strategy);
    }

    /// <summary>
    /// Verify <see cref="SequentialSelectionStrategy"/> provides agents in expected order.
    /// </summary>
    [Fact]
    public async Task VerifySequentialSelectionStrategyInitialFirstAgentAsync()
    {
        MockAgent agent1 = new();
        MockAgent agent2 = new();

        Agent[] agents = [agent1, agent2];
        SequentialSelectionStrategy strategy =
            new()
            {
                InitialAgent = agent1
            };

        await VerifyNextAgentAsync(agent1, agents, strategy);
        await VerifyNextAgentAsync(agent2, agents, strategy);
        await VerifyNextAgentAsync(agent1, agents, strategy);
        await VerifyNextAgentAsync(agent2, agents, strategy);
    }

    /// <summary>
    /// Verify <see cref="SequentialSelectionStrategy"/> behavior with no agents.
    /// </summary>
    [Fact]
    public async Task VerifySequentialSelectionStrategyEmptyAsync()
    {
        // Arrange
        SequentialSelectionStrategy strategy = new();

        // Act and Assert
        await Assert.ThrowsAsync<KernelException>(() => strategy.NextAsync([], []));
    }

    private static async Task VerifyNextAgentAsync(Agent expectedAgent, Agent[] agents, SequentialSelectionStrategy strategy)
    {
        // Act
        Agent? nextAgent = await strategy.NextAsync(agents, []);
        // Assert
        Assert.NotNull(nextAgent);
        Assert.Equal(expectedAgent.Id, nextAgent.Id);
    }
}


===== UnitTests\Core\ChatCompletionAgentExtensionsTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Text.Json;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.ChatCompletion;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.Core;

public sealed class ChatCompletionAgentExtensionsTests
{
    [Fact]
    public void AsAIAgent_WithValidChatCompletionAgent_ReturnsSemanticKernelAIAgent()
    {
        // Arrange
        var chatCompletionAgent = new ChatCompletionAgent()
        {
            Name = "TestAgent",
            Instructions = "Test instructions"
        };

        // Act
        var result = chatCompletionAgent.AsAIAgent();

        // Assert
        Assert.NotNull(result);
        Assert.IsType<SemanticKernelAIAgent>(result);
    }

    [Fact]
    public void AsAIAgent_WithNullChatCompletionAgent_ThrowsArgumentNullException()
    {
        // Arrange
        ChatCompletionAgent nullAgent = null!;

        // Act & Assert
        Assert.Throws<ArgumentNullException>(() => nullAgent.AsAIAgent());
    }

    [Fact]
    public void AsAIAgent_CreatesWorkingThreadFactory()
    {
        // Arrange
        var chatCompletionAgent = new ChatCompletionAgent()
        {
            Name = "TestAgent",
            Instructions = "Test instructions"
        };

        // Act
        var result = chatCompletionAgent.AsAIAgent();
        var thread = result.GetNewThread();

        // Assert
        Assert.NotNull(thread);
        Assert.IsType<SemanticKernelAIAgentThread>(thread);
        var threadAdapter = (SemanticKernelAIAgentThread)thread;
        Assert.IsType<ChatHistoryAgentThread>(threadAdapter.InnerThread);
    }

    [Fact]
    public void AsAIAgent_ThreadDeserializationFactory_WithNullChatHistory_CreatesNewThread()
    {
        // Arrange
        var chatCompletionAgent = new ChatCompletionAgent()
        {
            Name = "TestAgent",
            Instructions = "Test instructions"
        };
        var jsonElement = JsonSerializer.SerializeToElement((ChatHistory?)null);

        // Act
        var result = chatCompletionAgent.AsAIAgent();
        var thread = result.DeserializeThread(jsonElement);

        // Assert
        Assert.NotNull(thread);
        Assert.IsType<SemanticKernelAIAgentThread>(thread);
        var threadAdapter = (SemanticKernelAIAgentThread)thread;
        Assert.IsType<ChatHistoryAgentThread>(threadAdapter.InnerThread);
    }

    [Fact]
    public void AsAIAgent_ThreadDeserializationFactory_WithValidChatHistory_CreatesThreadWithHistory()
    {
        // Arrange
        var chatCompletionAgent = new ChatCompletionAgent()
        {
            Name = "TestAgent",
            Instructions = "Test instructions"
        };

        var chatHistory = new ChatHistory();
        chatHistory.AddSystemMessage("System message");
        chatHistory.AddUserMessage("User message");
        var jsonElement = JsonSerializer.SerializeToElement(chatHistory);

        // Act
        var result = chatCompletionAgent.AsAIAgent();
        var thread = result.DeserializeThread(jsonElement);

        // Assert
        Assert.NotNull(thread);
        Assert.IsType<SemanticKernelAIAgentThread>(thread);
        var threadAdapter = (SemanticKernelAIAgentThread)thread;
        Assert.IsType<ChatHistoryAgentThread>(threadAdapter.InnerThread);
        var chatHistoryThread = (ChatHistoryAgentThread)threadAdapter.InnerThread;
        Assert.Equal(2, chatHistoryThread.ChatHistory.Count);
    }

    [Fact]
    public void AsAIAgent_ThreadSerializer_SerializesChatHistory()
    {
        // Arrange
        var chatCompletionAgent = new ChatCompletionAgent()
        {
            Name = "TestAgent",
            Instructions = "Test instructions"
        };

        var chatHistory = new ChatHistory();
        chatHistory.AddSystemMessage("System message");
        chatHistory.AddUserMessage("User message");
        var chatHistoryThread = new ChatHistoryAgentThread(chatHistory);
        var jsonElement = JsonSerializer.SerializeToElement(chatHistory);

        var result = chatCompletionAgent.AsAIAgent();
        var thread = result.DeserializeThread(jsonElement);

        // Act
        var serializedElement = thread.Serialize();

        // Assert
        Assert.Equal(JsonValueKind.Array, serializedElement.ValueKind);
        var deserializedChatHistory = JsonSerializer.Deserialize<ChatHistory>(serializedElement.GetRawText());
        Assert.NotNull(deserializedChatHistory);
        Assert.Equal(2, deserializedChatHistory.Count);
    }
}


===== UnitTests\Core\ChatCompletionAgentTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.AI;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.ChatCompletion;
using Moq;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.Core;

/// <summary>
/// Unit testing of <see cref="ChatCompletionAgent"/>.
/// </summary>
public class ChatCompletionAgentTests
{
    /// <summary>
    /// Verify the invocation and response of <see cref="ChatCompletionAgent"/>.
    /// </summary>
    [Fact]
    public void VerifyChatCompletionAgentDefinition()
    {
        // Arrange
        ChatCompletionAgent agent =
            new()
            {
                Description = "test description",
                Instructions = "test instructions",
                Name = "test name",
            };

        // Assert
        Assert.NotNull(agent.Id);
        Assert.Equal("test instructions", agent.Instructions);
        Assert.Equal("test description", agent.Description);
        Assert.Equal("test name", agent.Name);
        Assert.Null(agent.Arguments);
    }

    /// <summary>
    /// Verify the invocation and response of <see cref="ChatCompletionAgent"/>.
    /// </summary>
    [Fact]
    public void VerifyChatCompletionAgentDefinitionWithArguments()
    {
        // Arrange
        KernelArguments arguments = new() { { "prop1", "val1" } };

        ChatCompletionAgent agent =
            new()
            {
                Description = "test description",
                Instructions = "test instructions",
                Name = "test name",
                Arguments = arguments
            };

        // Assert
        Assert.NotNull(agent.Id);
        Assert.Equal("test instructions", agent.Instructions);
        Assert.Equal("test description", agent.Description);
        Assert.Equal("test name", agent.Name);
        Assert.NotNull(agent.Arguments);
        Assert.Equal(arguments, agent.Arguments);
    }

    /// <summary>
    /// Verify the invocation and response of <see cref="ChatCompletionAgent"/>.
    /// </summary>
    [Fact]
    public void VerifyChatCompletionAgentTemplate()
    {
        PromptTemplateConfig promptConfig =
            new()
            {
                Name = "TestName",
                Description = "TestDescription",
                Template = "TestInstructions",
                ExecutionSettings =
                {
                    {
                        PromptExecutionSettings.DefaultServiceId,
                        new PromptExecutionSettings()
                        {
                            FunctionChoiceBehavior = FunctionChoiceBehavior.Auto(),
                            ModelId = "gpt-new",
                        }
                    },
                    {
                        "manual",
                        new PromptExecutionSettings()
                        {
                            ServiceId = "manual",
                            FunctionChoiceBehavior = FunctionChoiceBehavior.Required(),
                            ModelId = "gpt-old",
                        }
                    },
                }
            };
        KernelPromptTemplateFactory templateFactory = new();

        // Arrange
        ChatCompletionAgent agent = new(promptConfig, templateFactory);

        // Assert
        Assert.NotNull(agent.Id);
        Assert.Equal(promptConfig.Template, agent.Instructions);
        Assert.Equal(promptConfig.Description, agent.Description);
        Assert.Equal(promptConfig.Name, agent.Name);
        Assert.Equal(promptConfig.ExecutionSettings, agent.Arguments?.ExecutionSettings);
    }

    /// <summary>
    /// Verify throws <see cref="KernelException"/> when invalid <see cref="IPromptTemplateFactory"/> is provided.
    /// </summary>
    [Fact]
    public void VerifyThrowsForInvalidTemplateFactory()
    {
        // Arrange
        PromptTemplateConfig promptConfig =
            new()
            {
                Name = "TestName",
                Description = "TestDescription",
                Template = "TestInstructions",
                TemplateFormat = "handlebars",
            };
        KernelPromptTemplateFactory templateFactory = new();

        // Act and Assert
        Assert.Throws<KernelException>(() => new ChatCompletionAgent(promptConfig, templateFactory));
    }

    /// <summary>
    /// Verify the invocation and response of <see cref="ChatCompletionAgent"/>.
    /// </summary>
    [Fact]
    public async Task VerifyChatCompletionAgentInvocationAsync()
    {
        // Arrange
        Mock<IChatCompletionService> mockService = new();
        mockService.Setup(
            s => s.GetChatMessageContentsAsync(
                It.IsAny<ChatHistory>(),
                It.IsAny<PromptExecutionSettings>(),
                It.IsAny<Kernel>(),
                It.IsAny<CancellationToken>())).ReturnsAsync([new(AuthorRole.Assistant, "what?")]);

        ChatCompletionAgent agent =
            new()
            {
                Instructions = "test instructions",
                Kernel = CreateKernel(mockService.Object),
                Arguments = [],
            };

        // Act
        AgentResponseItem<ChatMessageContent>[] result = await agent.InvokeAsync(Array.Empty<ChatMessageContent>() as ICollection<ChatMessageContent>).ToArrayAsync();

        // Assert
        Assert.Single(result);

        mockService.Verify(
            x =>
                x.GetChatMessageContentsAsync(
                    It.IsAny<ChatHistory>(),
                    It.IsAny<PromptExecutionSettings>(),
                    It.IsAny<Kernel>(),
                    It.IsAny<CancellationToken>()),
            Times.Once);
    }

    /// <summary>
    /// Verify the invocation and response of <see cref="ChatCompletionAgent"/>.
    /// </summary>
    [Fact]
    public async Task VerifyChatCompletionAgentInvocationsCanMutateProvidedKernelAsync()
    {
        // Arrange
        Mock<IChatCompletionService> mockService = new();
        mockService.Setup(
            s => s.GetChatMessageContentsAsync(
                It.IsAny<ChatHistory>(),
                It.IsAny<PromptExecutionSettings>(),
                It.IsAny<Kernel>(),
                It.IsAny<CancellationToken>())).ReturnsAsync([new(AuthorRole.Assistant, "what?")]);

        var kernel = CreateKernel(mockService.Object);
        ChatCompletionAgent agent =
            new()
            {
                Instructions = "test instructions",
                Kernel = kernel,
                Arguments = [],
            };

        // Act
        AgentResponseItem<ChatMessageContent>[] result = await agent.InvokeAsync(Array.Empty<ChatMessageContent>() as ICollection<ChatMessageContent>).ToArrayAsync();

        // Assert
        Assert.Single(result);

        mockService.Verify(
            x =>
                x.GetChatMessageContentsAsync(
                    It.IsAny<ChatHistory>(),
                    It.IsAny<PromptExecutionSettings>(),
                    kernel, // Use the same kernel instance
                    It.IsAny<CancellationToken>()),
            Times.Once);
    }

    /// <summary>
    /// Verify the invocation and response of <see cref="ChatCompletionAgent"/> using <see cref="IChatClient"/>.
    /// </summary>
    [Fact]
    public async Task VerifyChatClientAgentInvocationAsync()
    {
        // Arrange
        Mock<IChatClient> mockService = new();
        mockService.Setup(
            s => s.GetResponseAsync(
                It.IsAny<IEnumerable<ChatMessage>>(),
                It.IsAny<ChatOptions>(),
                It.IsAny<CancellationToken>())).ReturnsAsync(new ChatResponse([new(ChatRole.Assistant, "what?")]));

        ChatCompletionAgent agent =
            new()
            {
                Instructions = "test instructions",
                Kernel = CreateKernel(mockService.Object),
                Arguments = new(new PromptExecutionSettings() { FunctionChoiceBehavior = FunctionChoiceBehavior.Auto() }),
            };

        // Act
        AgentResponseItem<ChatMessageContent>[] result = await agent.InvokeAsync(Array.Empty<ChatMessageContent>() as ICollection<ChatMessageContent>).ToArrayAsync();

        // Assert
        Assert.Single(result);

        mockService.Verify(
            x =>
                x.GetResponseAsync(
                    It.IsAny<IEnumerable<ChatMessage>>(),
                    It.Is<ChatOptions>(o => GetKernelFromChatOptions(o) == agent.Kernel),
                    It.IsAny<CancellationToken>()),
            Times.Once);
    }

    /// <summary>
    /// Verify the streaming invocation and response of <see cref="ChatCompletionAgent"/>.
    /// </summary>
    [Fact]
    public async Task VerifyChatCompletionAgentStreamingAsync()
    {
        // Arrange
        StreamingChatMessageContent[] returnContent =
            [
                new(AuthorRole.Assistant, "wh"),
                new(AuthorRole.Assistant, "at?"),
            ];

        Mock<IChatCompletionService> mockService = new();
        mockService.Setup(
            s => s.GetStreamingChatMessageContentsAsync(
                It.IsAny<ChatHistory>(),
                It.IsAny<PromptExecutionSettings>(),
                It.IsAny<Kernel>(),
                It.IsAny<CancellationToken>())).Returns(returnContent.ToAsyncEnumerable());

        ChatCompletionAgent agent =
            new()
            {
                Instructions = "test instructions",
                Kernel = CreateKernel(mockService.Object),
                Arguments = [],
            };

        // Act
        AgentResponseItem<StreamingChatMessageContent>[] result = await agent.InvokeStreamingAsync(Array.Empty<ChatMessageContent>() as ICollection<ChatMessageContent>).ToArrayAsync();

        // Assert
        Assert.Equal(2, result.Length);

        mockService.Verify(
            x =>
                x.GetStreamingChatMessageContentsAsync(
                    It.IsAny<ChatHistory>(),
                    It.IsAny<PromptExecutionSettings>(),
                    It.IsAny<Kernel>(),
                    It.IsAny<CancellationToken>()),
            Times.Once);
    }

    /// <summary>
    /// Verify the streaming invocation and response of <see cref="ChatCompletionAgent"/>.
    /// </summary>
    [Fact]
    public async Task VerifyChatCompletionAgentStreamingCanMutateProvidedKernelAsync()
    {
        // Arrange
        StreamingChatMessageContent[] returnContent =
            [
                new(AuthorRole.Assistant, "wh"),
                new(AuthorRole.Assistant, "at?"),
            ];

        Mock<IChatCompletionService> mockService = new();
        mockService.Setup(
            s => s.GetStreamingChatMessageContentsAsync(
                It.IsAny<ChatHistory>(),
                It.IsAny<PromptExecutionSettings>(),
                It.IsAny<Kernel>(),
                It.IsAny<CancellationToken>())).Returns(returnContent.ToAsyncEnumerable());

        var kernel = CreateKernel(mockService.Object);
        ChatCompletionAgent agent =
            new()
            {
                Instructions = "test instructions",
                Kernel = kernel,
                Arguments = [],
            };

        // Act
        AgentResponseItem<StreamingChatMessageContent>[] result = await agent.InvokeStreamingAsync(Array.Empty<ChatMessageContent>() as ICollection<ChatMessageContent>).ToArrayAsync();

        // Assert
        Assert.Equal(2, result.Length);

        mockService.Verify(
            x =>
                x.GetStreamingChatMessageContentsAsync(
                    It.IsAny<ChatHistory>(),
                    It.IsAny<PromptExecutionSettings>(),
                    kernel, // Use the same kernel instance
                    It.IsAny<CancellationToken>()),
            Times.Once);
    }

    /// <summary>
    /// Verify the streaming invocation and response of <see cref="ChatCompletionAgent"/> using <see cref="IChatClient"/>.
    /// </summary>
    [Fact]
    public async Task VerifyChatClientAgentStreamingAsync()
    {
        // Arrange
        ChatResponseUpdate[] returnUpdates =
        [
            new ChatResponseUpdate(role: ChatRole.Assistant, content: "wh"),
            new ChatResponseUpdate(role: null, content: "at?"),
        ];

        Mock<IChatClient> mockService = new();
        mockService.Setup(
            s => s.GetStreamingResponseAsync(
                It.IsAny<IEnumerable<ChatMessage>>(),
                It.IsAny<ChatOptions>(),
                It.IsAny<CancellationToken>())).Returns(returnUpdates.ToAsyncEnumerable());

        ChatCompletionAgent agent =
            new()
            {
                Instructions = "test instructions",
                Kernel = CreateKernel(mockService.Object),
                Arguments = new(new PromptExecutionSettings() { FunctionChoiceBehavior = FunctionChoiceBehavior.Auto() }),
            };

        // Act
        AgentResponseItem<StreamingChatMessageContent>[] result = await agent.InvokeStreamingAsync(Array.Empty<ChatMessageContent>() as ICollection<ChatMessageContent>).ToArrayAsync();

        // Assert
        Assert.Equal(2, result.Length);

        mockService.Verify(
            x =>
                x.GetStreamingResponseAsync(
                    It.IsAny<IEnumerable<ChatMessage>>(),
                    It.Is<ChatOptions>(o => GetKernelFromChatOptions(o) == agent.Kernel),
                    It.IsAny<CancellationToken>()),
            Times.Once);
    }

    /// <summary>
    /// Verify the invocation and response of <see cref="ChatCompletionAgent.GetChatCompletionService"/>.
    /// </summary>
    [Fact]
    public void VerifyChatCompletionServiceSelection()
    {
        // Arrange
        Mock<IChatCompletionService> mockService = new();
        Kernel kernel = CreateKernel(mockService.Object);

        // Act
        (IChatCompletionService service, PromptExecutionSettings? settings) = ChatCompletionAgent.GetChatCompletionService(kernel, null);
        // Assert
        Assert.Equal(mockService.Object, service);
        Assert.Null(settings);

        // Act
        (service, settings) = ChatCompletionAgent.GetChatCompletionService(kernel, []);
        // Assert
        Assert.Equal(mockService.Object, service);
        Assert.Null(settings);

        // Act and Assert
        Assert.Throws<KernelException>(() => ChatCompletionAgent.GetChatCompletionService(kernel, new KernelArguments(new PromptExecutionSettings() { ServiceId = "anything" })));
    }

    /// <summary>
    /// Verify the invocation and response of <see cref="ChatCompletionAgent.GetChatCompletionService"/> using <see cref="IChatClient"/>.
    /// </summary>
    [Fact]
    public void VerifyChatClientSelection()
    {
        // Arrange
        Mock<IChatClient> mockClient = new();
        Kernel kernel = CreateKernel(mockClient.Object);

        // Act
        (IChatCompletionService client, PromptExecutionSettings? settings) = ChatCompletionAgent.GetChatCompletionService(kernel, null);
        // Assert
        Assert.Equal("ChatClientChatCompletionService", client.GetType().Name);
        Assert.Null(settings);

        // Act
        (client, settings) = ChatCompletionAgent.GetChatCompletionService(kernel, []);
        // Assert
        Assert.Equal("ChatClientChatCompletionService", client.GetType().Name);
        Assert.Null(settings);

        // Act and Assert
        Assert.Throws<KernelException>(() => ChatCompletionAgent.GetChatCompletionService(kernel, new KernelArguments(new PromptExecutionSettings() { ServiceId = "anything" })));
    }

    /// <summary>
    /// Verify the invocation and response of <see cref="ChatCompletionAgent.GetChatCompletionService"/>.
    /// </summary>
    [Fact]
    public void VerifyChatCompletionChannelKeys()
    {
        // Arrange
        ChatCompletionAgent agent1 = new();
        ChatCompletionAgent agent2 = new();
        ChatCompletionAgent agent3 = new() { HistoryReducer = new ChatHistoryTruncationReducer(50) };
        ChatCompletionAgent agent4 = new() { HistoryReducer = new ChatHistoryTruncationReducer(50) };
        ChatCompletionAgent agent5 = new() { HistoryReducer = new ChatHistoryTruncationReducer(100) };

        // Act ans Assert
        Assert.Equal(agent1.GetChannelKeys(), agent2.GetChannelKeys());
        Assert.Equal(agent3.GetChannelKeys(), agent4.GetChannelKeys());
        Assert.NotEqual(agent1.GetChannelKeys(), agent3.GetChannelKeys());
        Assert.NotEqual(agent3.GetChannelKeys(), agent5.GetChannelKeys());
    }

    /// <summary>
    /// Verify that InvalidOperationException is thrown when UseImmutableKernel is false and AIFunctions exist.
    /// </summary>
    [Fact]
    public async Task VerifyChatCompletionAgentThrowsWhenUseImmutableKernelFalseWithAIFunctionsAsync()
    {
        // Arrange
        Mock<IChatCompletionService> mockService = new();
        mockService.Setup(
            s => s.GetChatMessageContentsAsync(
                It.IsAny<ChatHistory>(),
                It.IsAny<PromptExecutionSettings>(),
                It.IsAny<Kernel>(),
                It.IsAny<CancellationToken>())).ReturnsAsync([new(AuthorRole.Assistant, "what?")]);

        var mockAIContextProvider = new Mock<AIContextProvider>();
        var aiContext = new AIContext
        {
            AIFunctions = [new TestAIFunction("TestFunction", "Test function description")]
        };
        mockAIContextProvider.Setup(p => p.ModelInvokingAsync(It.IsAny<ICollection<ChatMessage>>(), It.IsAny<CancellationToken>()))
                           .ReturnsAsync(aiContext);

        ChatCompletionAgent agent =
            new()
            {
                Instructions = "test instructions",
                Kernel = CreateKernel(mockService.Object),
                Arguments = [],
                UseImmutableKernel = false // Explicitly set to false
            };

        var thread = new ChatHistoryAgentThread();
        thread.AIContextProviders.Add(mockAIContextProvider.Object);

        // Act & Assert
        var exception = await Assert.ThrowsAsync<InvalidOperationException>(
            async () => await agent.InvokeAsync(Array.Empty<ChatMessageContent>() as ICollection<ChatMessageContent>, thread: thread).ToArrayAsync());

        Assert.NotNull(exception);
    }

    /// <summary>
    /// Verify that InvalidOperationException is thrown when UseImmutableKernel is default (false) and AIFunctions exist.
    /// </summary>
    [Fact]
    public async Task VerifyChatCompletionAgentThrowsWhenUseImmutableKernelDefaultWithAIFunctionsAsync()
    {
        // Arrange
        Mock<IChatCompletionService> mockService = new();
        mockService.Setup(
            s => s.GetChatMessageContentsAsync(
                It.IsAny<ChatHistory>(),
                It.IsAny<PromptExecutionSettings>(),
                It.IsAny<Kernel>(),
                It.IsAny<CancellationToken>())).ReturnsAsync([new(AuthorRole.Assistant, "what?")]);

        var mockAIContextProvider = new Mock<AIContextProvider>();
        var aiContext = new AIContext
        {
            AIFunctions = [new TestAIFunction("TestFunction", "Test function description")]
        };
        mockAIContextProvider.Setup(p => p.ModelInvokingAsync(It.IsAny<ICollection<ChatMessage>>(), It.IsAny<CancellationToken>()))
                           .ReturnsAsync(aiContext);

        ChatCompletionAgent agent =
            new()
            {
                Instructions = "test instructions",
                Kernel = CreateKernel(mockService.Object),
                Arguments = []
                // UseImmutableKernel not set, should default to false
            };

        var thread = new ChatHistoryAgentThread();
        thread.AIContextProviders.Add(mockAIContextProvider.Object);

        // Act & Assert
        var exception = await Assert.ThrowsAsync<InvalidOperationException>(
            async () => await agent.InvokeAsync(Array.Empty<ChatMessageContent>() as ICollection<ChatMessageContent>, thread: thread).ToArrayAsync());

        Assert.NotNull(exception);
    }

    /// <summary>
    /// Verify that kernel remains immutable when UseImmutableKernel is true.
    /// </summary>
    [Fact]
    public async Task VerifyChatCompletionAgentKernelImmutabilityWhenUseImmutableKernelTrueAsync()
    {
        // Arrange
        Mock<IChatCompletionService> mockService = new();
        Kernel capturedKernel = null!;
        mockService.Setup(
            s => s.GetChatMessageContentsAsync(
                It.IsAny<ChatHistory>(),
                It.IsAny<PromptExecutionSettings>(),
                It.IsAny<Kernel>(),
                It.IsAny<CancellationToken>()))
            .Callback<ChatHistory, PromptExecutionSettings, Kernel, CancellationToken>((_, _, kernel, _) => capturedKernel = kernel)
            .ReturnsAsync([new(AuthorRole.Assistant, "what?")]);

        var originalKernel = CreateKernel(mockService.Object);
        var originalPluginCount = originalKernel.Plugins.Count;

        var mockAIContextProvider = new Mock<AIContextProvider>();
        var aiContext = new AIContext
        {
            AIFunctions = [new TestAIFunction("TestFunction", "Test function description")]
        };
        mockAIContextProvider.Setup(p => p.ModelInvokingAsync(It.IsAny<ICollection<ChatMessage>>(), It.IsAny<CancellationToken>()))
                           .ReturnsAsync(aiContext);

        ChatCompletionAgent agent =
            new()
            {
                Instructions = "test instructions",
                Kernel = originalKernel,
                Arguments = [],
                UseImmutableKernel = true
            };

        var thread = new ChatHistoryAgentThread();
        thread.AIContextProviders.Add(mockAIContextProvider.Object);

        // Act
        AgentResponseItem<ChatMessageContent>[] result = await agent.InvokeAsync(Array.Empty<ChatMessageContent>() as ICollection<ChatMessageContent>, thread: thread).ToArrayAsync();

        // Assert
        Assert.Single(result);

        // Verify original kernel was not modified
        Assert.Equal(originalPluginCount, originalKernel.Plugins.Count);

        // Verify a different kernel instance was used for the service call
        Assert.NotSame(originalKernel, capturedKernel);

        // Verify the captured kernel has the additional plugin from AIContext
        Assert.True(capturedKernel.Plugins.Count > originalPluginCount);
        Assert.Contains(capturedKernel.Plugins, p => p.Name == "Tools");
    }

    /// <summary>
    /// Verify that mutable kernel behavior works when UseImmutableKernel is false and no AIFunctions exist.
    /// </summary>
    [Fact]
    public async Task VerifyChatCompletionAgentMutableKernelWhenUseImmutableKernelFalseNoAIFunctionsAsync()
    {
        // Arrange
        Mock<IChatCompletionService> mockService = new();
        Kernel capturedKernel = null!;
        mockService.Setup(
            s => s.GetChatMessageContentsAsync(
                It.IsAny<ChatHistory>(),
                It.IsAny<PromptExecutionSettings>(),
                It.IsAny<Kernel>(),
                It.IsAny<CancellationToken>()))
            .Callback<ChatHistory, PromptExecutionSettings, Kernel, CancellationToken>((_, _, kernel, _) => capturedKernel = kernel)
            .ReturnsAsync([new(AuthorRole.Assistant, "what?")]);

        var originalKernel = CreateKernel(mockService.Object);

        var mockAIContextProvider = new Mock<AIContextProvider>();
        var aiContext = new AIContext
        {
            AIFunctions = [] // Empty AIFunctions list
        };
        mockAIContextProvider.Setup(p => p.ModelInvokingAsync(It.IsAny<ICollection<ChatMessage>>(), It.IsAny<CancellationToken>()))
                           .ReturnsAsync(aiContext);

        ChatCompletionAgent agent =
            new()
            {
                Instructions = "test instructions",
                Kernel = originalKernel,
                Arguments = [],
                UseImmutableKernel = false
            };

        var thread = new ChatHistoryAgentThread();
        thread.AIContextProviders.Add(mockAIContextProvider.Object);

        // Act
        AgentResponseItem<ChatMessageContent>[] result = await agent.InvokeAsync(Array.Empty<ChatMessageContent>() as ICollection<ChatMessageContent>, thread: thread).ToArrayAsync();

        // Assert
        Assert.Single(result);

        // Verify the same kernel instance was used (mutable behavior)
        Assert.Same(originalKernel, capturedKernel);
    }

    /// <summary>
    /// Verify that InvalidOperationException is thrown when UseImmutableKernel is false and AIFunctions exist (streaming).
    /// </summary>
    [Fact]
    public async Task VerifyChatCompletionAgentStreamingThrowsWhenUseImmutableKernelFalseWithAIFunctionsAsync()
    {
        // Arrange
        StreamingChatMessageContent[] returnContent =
            [
                new(AuthorRole.Assistant, "wh"),
                new(AuthorRole.Assistant, "at?"),
            ];

        Mock<IChatCompletionService> mockService = new();
        mockService.Setup(
            s => s.GetStreamingChatMessageContentsAsync(
                It.IsAny<ChatHistory>(),
                It.IsAny<PromptExecutionSettings>(),
                It.IsAny<Kernel>(),
                It.IsAny<CancellationToken>())).Returns(returnContent.ToAsyncEnumerable());

        var mockAIContextProvider = new Mock<AIContextProvider>();
        var aiContext = new AIContext
        {
            AIFunctions = [new TestAIFunction("TestFunction", "Test function description")]
        };
        mockAIContextProvider.Setup(p => p.ModelInvokingAsync(It.IsAny<ICollection<ChatMessage>>(), It.IsAny<CancellationToken>()))
                           .ReturnsAsync(aiContext);

        ChatCompletionAgent agent =
            new()
            {
                Instructions = "test instructions",
                Kernel = CreateKernel(mockService.Object),
                Arguments = [],
                UseImmutableKernel = false // Explicitly set to false
            };

        var thread = new ChatHistoryAgentThread();
        thread.AIContextProviders.Add(mockAIContextProvider.Object);

        // Act & Assert
        var exception = await Assert.ThrowsAsync<InvalidOperationException>(
            async () => await agent.InvokeStreamingAsync(Array.Empty<ChatMessageContent>() as ICollection<ChatMessageContent>, thread: thread).ToArrayAsync());

        Assert.NotNull(exception);
    }

    /// <summary>
    /// Verify that InvalidOperationException is thrown when UseImmutableKernel is default (false) and AIFunctions exist (streaming).
    /// </summary>
    [Fact]
    public async Task VerifyChatCompletionAgentStreamingThrowsWhenUseImmutableKernelDefaultWithAIFunctionsAsync()
    {
        // Arrange
        StreamingChatMessageContent[] returnContent =
            [
                new(AuthorRole.Assistant, "wh"),
                new(AuthorRole.Assistant, "at?"),
            ];

        Mock<IChatCompletionService> mockService = new();
        mockService.Setup(
            s => s.GetStreamingChatMessageContentsAsync(
                It.IsAny<ChatHistory>(),
                It.IsAny<PromptExecutionSettings>(),
                It.IsAny<Kernel>(),
                It.IsAny<CancellationToken>())).Returns(returnContent.ToAsyncEnumerable());

        var mockAIContextProvider = new Mock<AIContextProvider>();
        var aiContext = new AIContext
        {
            AIFunctions = [new TestAIFunction("TestFunction", "Test function description")]
        };
        mockAIContextProvider.Setup(p => p.ModelInvokingAsync(It.IsAny<ICollection<ChatMessage>>(), It.IsAny<CancellationToken>()))
                           .ReturnsAsync(aiContext);

        ChatCompletionAgent agent =
            new()
            {
                Instructions = "test instructions",
                Kernel = CreateKernel(mockService.Object),
                Arguments = []
                // UseImmutableKernel not set, should default to false
            };

        var thread = new ChatHistoryAgentThread();
        thread.AIContextProviders.Add(mockAIContextProvider.Object);

        // Act & Assert
        var exception = await Assert.ThrowsAsync<InvalidOperationException>(
            async () => await agent.InvokeStreamingAsync(Array.Empty<ChatMessageContent>() as ICollection<ChatMessageContent>, thread: thread).ToArrayAsync());

        Assert.NotNull(exception);
    }

    /// <summary>
    /// Verify that kernel remains immutable when UseImmutableKernel is true (streaming).
    /// </summary>
    [Fact]
    public async Task VerifyChatCompletionAgentStreamingKernelImmutabilityWhenUseImmutableKernelTrueAsync()
    {
        // Arrange
        StreamingChatMessageContent[] returnContent =
            [
                new(AuthorRole.Assistant, "wh"),
                new(AuthorRole.Assistant, "at?"),
            ];

        Mock<IChatCompletionService> mockService = new();
        Kernel capturedKernel = null!;
        mockService.Setup(
            s => s.GetStreamingChatMessageContentsAsync(
                It.IsAny<ChatHistory>(),
                It.IsAny<PromptExecutionSettings>(),
                It.IsAny<Kernel>(),
                It.IsAny<CancellationToken>()))
            .Callback<ChatHistory, PromptExecutionSettings, Kernel, CancellationToken>((_, _, kernel, _) => capturedKernel = kernel)
            .Returns(returnContent.ToAsyncEnumerable());

        var originalKernel = CreateKernel(mockService.Object);
        var originalPluginCount = originalKernel.Plugins.Count;

        var mockAIContextProvider = new Mock<AIContextProvider>();
        var aiContext = new AIContext
        {
            AIFunctions = [new TestAIFunction("TestFunction", "Test function description")]
        };
        mockAIContextProvider.Setup(p => p.ModelInvokingAsync(It.IsAny<ICollection<ChatMessage>>(), It.IsAny<CancellationToken>()))
                           .ReturnsAsync(aiContext);

        ChatCompletionAgent agent =
            new()
            {
                Instructions = "test instructions",
                Kernel = originalKernel,
                Arguments = [],
                UseImmutableKernel = true
            };

        var thread = new ChatHistoryAgentThread();
        thread.AIContextProviders.Add(mockAIContextProvider.Object);

        // Act
        AgentResponseItem<StreamingChatMessageContent>[] result = await agent.InvokeStreamingAsync(Array.Empty<ChatMessageContent>() as ICollection<ChatMessageContent>, thread: thread).ToArrayAsync();

        // Assert
        Assert.Equal(2, result.Length);

        // Verify original kernel was not modified
        Assert.Equal(originalPluginCount, originalKernel.Plugins.Count);

        // Verify a different kernel instance was used for the service call
        Assert.NotSame(originalKernel, capturedKernel);

        // Verify the captured kernel has the additional plugin from AIContext
        Assert.True(capturedKernel.Plugins.Count > originalPluginCount);
        Assert.Contains(capturedKernel.Plugins, p => p.Name == "Tools");
    }

    /// <summary>
    /// Verify that mutable kernel behavior works when UseImmutableKernel is false and no AIFunctions exist (streaming).
    /// </summary>
    [Fact]
    public async Task VerifyChatCompletionAgentStreamingMutableKernelWhenUseImmutableKernelFalseNoAIFunctionsAsync()
    {
        // Arrange
        StreamingChatMessageContent[] returnContent =
            [
                new(AuthorRole.Assistant, "wh"),
                new(AuthorRole.Assistant, "at?"),
            ];

        Mock<IChatCompletionService> mockService = new();
        Kernel capturedKernel = null!;
        mockService.Setup(
            s => s.GetStreamingChatMessageContentsAsync(
                It.IsAny<ChatHistory>(),
                It.IsAny<PromptExecutionSettings>(),
                It.IsAny<Kernel>(),
                It.IsAny<CancellationToken>()))
            .Callback<ChatHistory, PromptExecutionSettings, Kernel, CancellationToken>((_, _, kernel, _) => capturedKernel = kernel)
            .Returns(returnContent.ToAsyncEnumerable());

        var originalKernel = CreateKernel(mockService.Object);

        var mockAIContextProvider = new Mock<AIContextProvider>();
        var aiContext = new AIContext
        {
            AIFunctions = [] // Empty AIFunctions list
        };
        mockAIContextProvider.Setup(p => p.ModelInvokingAsync(It.IsAny<ICollection<ChatMessage>>(), It.IsAny<CancellationToken>()))
                           .ReturnsAsync(aiContext);

        ChatCompletionAgent agent =
            new()
            {
                Instructions = "test instructions",
                Kernel = originalKernel,
                Arguments = [],
                UseImmutableKernel = false
            };

        var thread = new ChatHistoryAgentThread();
        thread.AIContextProviders.Add(mockAIContextProvider.Object);

        // Act
        AgentResponseItem<StreamingChatMessageContent>[] result = await agent.InvokeStreamingAsync(Array.Empty<ChatMessageContent>() as ICollection<ChatMessageContent>, thread: thread).ToArrayAsync();

        // Assert
        Assert.Equal(2, result.Length);

        // Verify the same kernel instance was used (mutable behavior)
        Assert.Same(originalKernel, capturedKernel);
    }

    private static Kernel CreateKernel(IChatCompletionService chatCompletionService)
    {
        var builder = Kernel.CreateBuilder();
        builder.Services.AddSingleton<IChatCompletionService>(chatCompletionService);
        return builder.Build();
    }

    private static Kernel CreateKernel(IChatClient chatClient)
    {
        var builder = Kernel.CreateBuilder();
        builder.Services.AddSingleton<IChatClient>(chatClient);
        return builder.Build();
    }

    /// <summary>
    /// Gets the Kernel property from ChatOptions using reflection.
    /// </summary>
    /// <param name="options">The ChatOptions instance to extract Kernel from.</param>
    /// <returns>The Kernel instance if found; otherwise, null.</returns>
    private static Kernel? GetKernelFromChatOptions(ChatOptions options)
    {
        // Use reflection to try to get the Kernel property
        var kernelProperty = options.GetType().GetProperty("Kernel",
            System.Reflection.BindingFlags.Public |
            System.Reflection.BindingFlags.NonPublic |
            System.Reflection.BindingFlags.Instance);

        if (kernelProperty != null)
        {
            return kernelProperty.GetValue(options) as Kernel;
        }

        return null;
    }

    /// <summary>
    /// Helper class for testing AIFunction behavior.
    /// </summary>
    private sealed class TestAIFunction : AIFunction
    {
        public TestAIFunction(string name, string description = "")
        {
            this.Name = name;
            this.Description = description;
        }

        public override string Name { get; }

        public override string Description { get; }

        protected override ValueTask<object?> InvokeCoreAsync(AIFunctionArguments? arguments = null, CancellationToken cancellationToken = default)
        {
            return ValueTask.FromResult<object?>("Test result");
        }
    }
}


===== UnitTests\Core\ChatHistoryAgentThreadTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.ChatCompletion;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.Core;

/// <summary>
/// Contains tests for the <see cref="ChatHistoryAgentThread"/> class.
/// </summary>
public class ChatHistoryAgentThreadTests
{
    /// <summary>
    /// Tests that creating a thread generates a unique Id and doesn't change IsDeleted.
    /// </summary>
    [Fact]
    public async Task CreateShouldGenerateIdAsync()
    {
        // Arrange
        var thread = new ChatHistoryAgentThread();

        // Act
        await thread.CreateAsync();

        // Assert
        Assert.NotNull(thread.Id);
        Assert.False(thread.IsDeleted);
    }

    /// <summary>
    /// Tests that deleting a thread marks it as deleted.
    /// </summary>
    [Fact]
    public async Task DeleteShouldMarkThreadAsDeletedAsync()
    {
        // Arrange
        var thread = new ChatHistoryAgentThread();
        await thread.CreateAsync();

        // Act
        await thread.DeleteAsync();

        // Assert
        Assert.True(thread.IsDeleted);
    }

    /// <summary>
    /// Tests that adding a new message to the thread adds it to the message history.
    /// </summary>
    [Fact]
    public async Task OnNewMessageShouldAddMessageToHistoryAsync()
    {
        // Arrange
        var thread = new ChatHistoryAgentThread();
        var message = new ChatMessageContent(AuthorRole.User, "Hello");

        // Act
        await thread.OnNewMessageAsync(message);

        // Assert
        var messages = await thread.GetMessagesAsync().ToListAsync();
        Assert.Single(messages);
        Assert.Equal("Hello", messages[0].Content);
    }

    /// <summary>
    /// Tests that GetMessagesAsync returns all messages in the thread.
    /// </summary>
    [Fact]
    public async Task GetMessagesShouldReturnAllMessagesAsync()
    {
        // Arrange
        var thread = new ChatHistoryAgentThread();
        var message1 = new ChatMessageContent(AuthorRole.User, "Hello");
        var message2 = new ChatMessageContent(AuthorRole.Assistant, "Hi there");

        await thread.OnNewMessageAsync(message1);
        await thread.OnNewMessageAsync(message2);

        // Act
        var messages = await thread.GetMessagesAsync().ToListAsync();

        // Assert
        Assert.Equal(2, messages.Count);
        Assert.Equal("Hello", messages[0].Content);
        Assert.Equal("Hi there", messages[1].Content);
    }

    /// <summary>
    /// Tests that GetMessagesAsync throws an InvalidOperationException if the thread is deleted.
    /// </summary>
    [Fact]
    public async Task GetMessagesShouldThrowIfThreadIsDeletedAsync()
    {
        // Arrange
        var thread = new ChatHistoryAgentThread();
        await thread.CreateAsync();
        await thread.DeleteAsync();

        // Act & Assert
        await Assert.ThrowsAsync<InvalidOperationException>(async () => await thread.GetMessagesAsync().ToListAsync());
    }

    /// <summary>
    /// Tests that GetMessagesAsync creates the thread if it has not been created yet.
    /// </summary>
    [Fact]
    public async Task GetMessagesShouldCreateThreadIfNotCreatedAsync()
    {
        // Arrange
        var thread = new ChatHistoryAgentThread();

        // Act
        var messages = await thread.GetMessagesAsync().ToListAsync();

        // Assert
        Assert.NotNull(thread.Id);
        Assert.False(thread.IsDeleted);
        Assert.Empty(messages);
    }
}


===== UnitTests\Core\ChatHistoryChannelTests.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.ChatCompletion;
using Moq;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.Core;

/// <summary>
/// Unit testing of <see cref="ChatHistoryChannel"/>.
/// </summary>
public class ChatHistoryChannelTests
{
    /// <summary>
    /// Verify a <see cref="ChatHistoryChannel"/> throws if passed an agent that
    /// does not implement <see cref="ChatHistoryAgent"/>.
    /// </summary>
    [Fact]
    public async Task VerifyAgentIsChatHistoryAgentAsync()
    {
        // Arrange
        Mock<Agent> agent = new(); // Not a ChatHistoryAgent
        ChatHistoryChannel channel = new();

        // Act & Assert
        await Assert.ThrowsAsync<KernelException>(() => channel.InvokeAsync(agent.Object).ToArrayAsync().AsTask());
    }

    /// <summary>
    /// Verify a <see cref="ChatHistoryChannel"/> filters empty content on receive.
    /// </summary>
    [Fact]
    public async Task VerifyReceiveFiltersEmptyContentAsync()
    {
        // Arrange
        ChatHistoryChannel channel = new();

        // Act
        await channel.ReceiveAsync([new ChatMessageContent(AuthorRole.Assistant, string.Empty)]);

        // Assert
        Assert.Empty(await channel.GetHistoryAsync().ToArrayAsync());
    }

    /// <summary>
    /// Verify a <see cref="ChatHistoryChannel"/> filters file content on receive.
    /// </summary>
    /// <remarks>
    /// As long as content is not empty, extraneous file content is ok.
    /// </remarks>
    [Fact]
    public async Task VerifyReceiveFiltersFileContentAsync()
    {
        // Arrange
        ChatHistoryChannel channel = new();

        // Act
        await channel.ReceiveAsync([new ChatMessageContent(AuthorRole.Assistant, [new FileReferenceContent("fileId")])]);

        // Assert
        Assert.Empty(await channel.GetHistoryAsync().ToArrayAsync());

        // Act
        await channel.ReceiveAsync(
            [new ChatMessageContent(
                AuthorRole.Assistant,
                [
                    new TextContent("test"),
                    new FileReferenceContent("fileId")
                ])]);

        // Assert
        var history = await channel.GetHistoryAsync().ToArrayAsync();
        Assert.Single(history);
        Assert.Equal(2, history[0].Items.Count);
    }

    /// <summary>
    /// Verify a <see cref="ChatHistoryChannel"/> accepts function content on receive.
    /// </summary>
    [Fact]
    public async Task VerifyReceiveAcceptsFunctionContentAsync()
    {
        // Arrange
        ChatHistoryChannel channel = new();

        // Act
        await channel.ReceiveAsync([new ChatMessageContent(AuthorRole.Assistant, [new FunctionCallContent("test-func")])]);

        // Assert
        Assert.Single(await channel.GetHistoryAsync().ToArrayAsync());

        // Arrange
        channel = new();

        // Act
        await channel.ReceiveAsync([new ChatMessageContent(AuthorRole.Assistant, [new FunctionResultContent("test-func")])]);

        // Assert
        Assert.Single(await channel.GetHistoryAsync().ToArrayAsync());
    }

    /// <summary>
    /// Verify a <see cref="ChatHistoryChannel"/> accepts image content on receive.
    /// </summary>
    [Fact]
    public async Task VerifyReceiveAcceptsImageContentAsync()
    {
        // Arrange
        ChatHistoryChannel channel = new();

        // Act
        await channel.ReceiveAsync([new ChatMessageContent(AuthorRole.Assistant, [new ImageContent(new Uri("http://test.ms/test.jpg"))])]);

        // Assert
        Assert.Single(await channel.GetHistoryAsync().ToArrayAsync());
    }
}


===== UnitTests\Core\Definition\ChatCompletionAgentFactoryTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Threading.Tasks;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.Core.Definition;

/// <summary>
/// Unit tests for <see cref="ChatCompletionAgentFactory"/>.
/// </summary>
public class ChatCompletionAgentFactoryTests
{
    /// <summary>
    /// Verify can create an instance of <see cref="Agent"/> using <see cref="ChatCompletionAgentFactory"/>
    /// </summary>
    [Fact]
    public async Task VerifyCanCreateChatCompletionAgentAsync()
    {
        // Arrange
        AgentDefinition agentDefinition = new()
        {
            Type = ChatCompletionAgentFactory.ChatCompletionAgentType,
            Name = "ChatCompletionAgent",
            Description = "ChatCompletionAgent Description",
            Instructions = "ChatCompletionAgent Instructions",
            Model = new()
            {
                Id = "gpt-4o-mini"
            }
        };
        ChatCompletionAgentFactory factory = new();
        Kernel kernel = new();

        // Act
        var agent = await factory.CreateAsync(kernel, agentDefinition);

        // Assert
        Assert.NotNull(agent);
        Assert.Equal(agentDefinition.Name, agent.Name);
        Assert.Equal(agentDefinition.Description, agent.Description);
        Assert.Equal(agentDefinition.Instructions, agent.Instructions);
        Assert.Equal(kernel, agent.Kernel);
    }
}


===== UnitTests\Core\Extensions\AgentDefinitionExtensionsTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.Core.Extensions;

/// <summary>
/// Unit tests for <see cref="AgentDefinitionExtensions"/>.
/// </summary>
public class AgentDefinitionExtensionsTests
{
    /// <summary>
    /// Verify GetDefaultKernelArguments
    /// </summary>
    [Fact]
    public void VerifyGetDefaultKernelArguments()
    {
        // Arrange
        Kernel kernel = new();
        AgentDefinition agentDefinition = new()
        {
            Inputs = new Dictionary<string, AgentInput>
            {
                ["Input1"] = new() { Name = "Input1", Required = false, Default = "Default1" },
                ["Input2"] = new() { Name = "Input2", Required = true, Default = "Default2" }
            },
        };

        // Act
        var defaultArgs = agentDefinition.GetDefaultKernelArguments(kernel);

        // Assert
        Assert.NotNull(defaultArgs);
        Assert.Equal(2, defaultArgs.Count);
        Assert.Equal("Default1", defaultArgs["Input1"]);
        Assert.Equal("Default2", defaultArgs["Input2"]);
    }

    /// <summary>
    /// Verify GetFirstToolDefinition
    /// </summary>
    [Fact]
    public void VerifyGetFirstToolDefinition()
    {
        // Arrange
        AgentDefinition agentDefinition = new()
        {
            Tools =
            [
                new AgentToolDefinition { Type = "code_interpreter", Id = "Tool1" },
                new AgentToolDefinition { Type = "file_search", Id = "Tool2" },
            ],
        };

        // Act & Assert
        Assert.NotNull(agentDefinition.GetFirstToolDefinition("code_interpreter"));
        Assert.NotNull(agentDefinition.GetFirstToolDefinition("file_search"));
        Assert.Null(agentDefinition.GetFirstToolDefinition("openai"));
    }

    /// <summary>
    /// Verify HasToolType
    /// </summary>
    [Fact]
    public void VerifyIsEnableCodeInterpreter()
    {
        // Arrange
        AgentDefinition agentDefinition = new()
        {
            Tools =
            [
                new AgentToolDefinition { Type = "code_interpreter", Id = "Tool1" },
            ],
        };

        // Act & Assert
        Assert.True(agentDefinition.HasToolType("code_interpreter"));
    }

    /// <summary>
    /// Verify IsEnableFileSearch
    /// </summary>
    [Fact]
    public void VerifyIsEnableFileSearch()
    {
        // Arrange
        AgentDefinition agentDefinition = new()
        {
            Tools =
            [
                new AgentToolDefinition { Type = "file_search", Id = "Tool2" },
            ],
        };

        // Act & Assert
        Assert.True(agentDefinition.HasToolType("file_search"));
    }
}


===== UnitTests\Core\Factory\AggregatorAgentFactoryTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.Core.Factory;

/// <summary>
/// Tests for <see cref="AggregatorAgentFactory"/>.
/// </summary>
public class AggregatorAgentFactoryTests
{
    /// <summary>
    /// Verifies that the <see cref="AggregatorAgentFactory"/> can create different types of agents.
    /// </summary>
    [Fact]
    public async Task ItCreatesKernelAgentsAsync()
    {
        // Arrange
        var agentDefinition1 = new AgentDefinition() { Type = "my-type-1", Name = "my-name-1", Description = "my-description-1", Instructions = "my-instructions-1" };
        var agentDefinition2 = new AgentDefinition() { Type = "my-type-2", Name = "my-name-2", Description = "my-description-2", Instructions = "my-instructions-2" };
        var kernel = new Kernel();
        var target = new AggregatorAgentFactory(new MyAgentFactory1(), new MyAgentFactory2());

        // Act
        var result1 = await target.CreateAsync(kernel, agentDefinition1);
        var result2 = await target.CreateAsync(kernel, agentDefinition2);

        // Assert
        Assert.NotNull(result1);
        Assert.True(result1 is MyAgent1);
        Assert.NotNull(result2);
        Assert.True(result2 is MyAgent2);
    }

    /// <summary>
    /// Verifies that the <see cref="AggregatorAgentFactory"/> throws <see cref="KernelException"/> for an unknown agent type.
    /// </summary>
    [Fact]
    public async Task ItReturnsNullForUnknownAgentTypeAsync()
    {
        // Arrange
        var agentDefinition = new AgentDefinition() { Type = "my-type-unknown", Name = "my-name-1", Description = "my-description-1", Instructions = "my-instructions-1" };
        var kernel = new Kernel();
        var target = new AggregatorAgentFactory(new MyAgentFactory1(), new MyAgentFactory2());

        // Act & Assert
        await Assert.ThrowsAsync<NotSupportedException>(async () => await target.CreateAsync(kernel, agentDefinition));
    }

    #region private
    private sealed class MyAgentFactory1 : AgentFactory
    {
        public MyAgentFactory1() : base(["my-type-1"])
        {
        }

        public override async Task<Agent?> TryCreateAsync(Kernel kernel, AgentDefinition agentDefinition, AgentCreationOptions? agentCreationOptions = null, CancellationToken cancellationToken = default)
        {
            return agentDefinition.Type != "my-type-1"
                ? null
                : (Agent)await Task.FromResult(new MyAgent1()
                {
                    Name = agentDefinition.Name,
                    Description = agentDefinition.Description,
                    Instructions = agentDefinition.Instructions,
                    Kernel = kernel,
                });
        }
    }

    private sealed class MyAgentFactory2 : AgentFactory
    {
        public MyAgentFactory2() : base(["my-type-2"])
        {
        }

        public override async Task<Agent?> TryCreateAsync(Kernel kernel, AgentDefinition agentDefinition, AgentCreationOptions? agentCreationOptions = null, CancellationToken cancellationToken = default)
        {
            return agentDefinition.Type != "my-type-2"
                ? null
                : (Agent)await Task.FromResult(new MyAgent2()
                {
                    Name = agentDefinition.Name,
                    Description = agentDefinition.Description,
                    Instructions = agentDefinition.Instructions,
                    Kernel = kernel,
                });
        }
    }

    private sealed class MyAgent1 : Agent
    {
        public MyAgent1()
        {
        }

        public override IAsyncEnumerable<AgentResponseItem<ChatMessageContent>> InvokeAsync(ICollection<ChatMessageContent> messages, AgentThread? thread = null, AgentInvokeOptions? options = null, CancellationToken cancellationToken = default)
        {
            throw new NotImplementedException();
        }

        public override IAsyncEnumerable<AgentResponseItem<StreamingChatMessageContent>> InvokeStreamingAsync(ICollection<ChatMessageContent> messages, AgentThread? thread = null, AgentInvokeOptions? options = null, CancellationToken cancellationToken = default)
        {
            throw new NotImplementedException();
        }

        protected internal override Task<AgentChannel> CreateChannelAsync(CancellationToken cancellationToken)
        {
            throw new NotImplementedException();
        }

        protected internal override IEnumerable<string> GetChannelKeys()
        {
            throw new NotImplementedException();
        }

        protected internal override Task<AgentChannel> RestoreChannelAsync(string channelState, CancellationToken cancellationToken)
        {
            throw new NotImplementedException();
        }
    }

    private sealed class MyAgent2 : Agent
    {
        public MyAgent2()
        {
        }

        public override IAsyncEnumerable<AgentResponseItem<ChatMessageContent>> InvokeAsync(ICollection<ChatMessageContent> messages, AgentThread? thread = null, AgentInvokeOptions? options = null, CancellationToken cancellationToken = default)
        {
            throw new NotImplementedException();
        }

        public override IAsyncEnumerable<AgentResponseItem<StreamingChatMessageContent>> InvokeStreamingAsync(ICollection<ChatMessageContent> messages, AgentThread? thread = null, AgentInvokeOptions? options = null, CancellationToken cancellationToken = default)
        {
            throw new NotImplementedException();
        }

        protected internal override Task<AgentChannel> CreateChannelAsync(CancellationToken cancellationToken)
        {
            throw new NotImplementedException();
        }

        protected internal override IEnumerable<string> GetChannelKeys()
        {
            throw new NotImplementedException();
        }

        protected internal override Task<AgentChannel> RestoreChannelAsync(string channelState, CancellationToken cancellationToken)
        {
            throw new NotImplementedException();
        }
    }
    #endregion
}


===== UnitTests\Core\Functions\AgentKernelFunctionFactoryTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.ChatCompletion;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.Core.Functions;

/// <summary>
/// Unit testing of <see cref="AgentKernelFunctionFactory"/>.
/// </summary>
public class AgentKernelFunctionFactoryTests
{
    /// <summary>
    /// Verify calling AgentKernelFunctionFactory.CreateFromAgent.
    /// </summary>
    [Fact]
    public void VerifyCreateFromAgent()
    {
        // Arrange
        var agent = new MockAgent()
        {
            Name = "MyAgent",
            Description = "Description for MyAgent"
        };

        // Act
        var function = AgentKernelFunctionFactory.CreateFromAgent(agent);

        // Assert
        Assert.NotNull(function);
        Assert.Equal(agent.Name, function.Name);
        Assert.Equal(agent.Description, function.Description);
    }

    /// <summary>
    /// Verify calling AgentKernelFunctionFactory.CreateFromAgent with overrides.
    /// </summary>
    [Fact]
    public void VerifyCreateFromAgentWithOverrides()
    {
        // Arrange
        var agent = new MockAgent()
        {
            Name = "MyAgent",
            Description = "Description for MyAgent"
        };

        // Act
        var function = AgentKernelFunctionFactory.CreateFromAgent(
            agent,
            "MyAgentFunction",
            "Description for MyAgentFunction"
            );

        // Assert
        Assert.NotNull(function);
        Assert.Equal("MyAgentFunction", function.Name);
        Assert.Equal("Description for MyAgentFunction", function.Description);
    }

    /// <summary>
    /// Verify invoking function returned by AgentKernelFunctionFactory.CreateFromAgent.
    /// </summary>
    [Fact]
    public async Task VerifyInvokeAgentAsKernelFunctionAsync()
    {
        // Arrange
        var agent = new MockAgent()
        {
            Name = "MyAgent",
            Description = "Description for MyAgent"
        };
        var function = AgentKernelFunctionFactory.CreateFromAgent(agent);

        // Act
        var arguments = new KernelArguments
        {
            { "query", "Mock query" }
        };
        var result = await function.InvokeAsync(new(), arguments);

        // Assert
        Assert.NotNull(result);
        var items = result.GetValue<IEnumerable<ChatMessageContent>>();
        Assert.NotNull(items);
        Assert.NotEmpty(items);
        Assert.Equal("Response to: 'Mock query' with instructions: ''", items.First().ToString());
    }

    /// <summary>
    /// Verify invoking function returned by AgentKernelFunctionFactory.CreateFromAgent.
    /// </summary>
    [Fact]
    public async Task VerifyInvokeAgentAsKernelFunctionWithNoQueryAsync()
    {
        // Arrange
        var agent = new MockAgent()
        {
            Name = "MyAgent",
            Description = "Description for MyAgent"
        };
        var function = AgentKernelFunctionFactory.CreateFromAgent(agent);

        // Act
        var result = await function.InvokeAsync(new());

        // Assert
        Assert.NotNull(result);
        var items = result.GetValue<IEnumerable<ChatMessageContent>>();
        Assert.NotNull(items);
        Assert.NotEmpty(items);
        Assert.Equal("Response to: '' with instructions: ''", items.First().ToString());
    }

    /// <summary>
    /// Verify invoking function returned by AgentKernelFunctionFactory.CreateFromAgent.
    /// </summary>
    [Fact]
    public async Task VerifyInvokeAgentAsKernelFunctionWithInstructionsAsync()
    {
        // Arrange
        var agent = new MockAgent()
        {
            Name = "MyAgent",
            Description = "Description for MyAgent"
        };
        var function = AgentKernelFunctionFactory.CreateFromAgent(agent);

        // Act
        var arguments = new KernelArguments
        {
            { "query", "Mock query" },
            { "instructions", "Mock instructions" }
        };
        var result = await function.InvokeAsync(new(), arguments);

        // Assert
        Assert.NotNull(result);
        var items = result.GetValue<IEnumerable<ChatMessageContent>>();
        Assert.NotNull(items);
        Assert.NotEmpty(items);
        Assert.Equal("Response to: 'Mock query' with instructions: 'Mock instructions'", items.First().ToString());
    }

    /// <summary>
    /// Mock implementation of <see cref="Agent"/>.
    /// </summary>
    private sealed class MockAgent : Agent
    {
        public override async IAsyncEnumerable<AgentResponseItem<ChatMessageContent>> InvokeAsync(ICollection<ChatMessageContent> messages, AgentThread? thread = null, AgentInvokeOptions? options = null, [EnumeratorCancellation] CancellationToken cancellationToken = default)
        {
            var agentThread = thread ?? new MockAgentThread();
            foreach (var message in messages)
            {
                await Task.Delay(100, cancellationToken);
                yield return new AgentResponseItem<ChatMessageContent>(new ChatMessageContent(AuthorRole.Assistant, $"Response to: '{message.Content}' with instructions: '{options?.AdditionalInstructions}'"), agentThread);
            }
        }

        public override IAsyncEnumerable<AgentResponseItem<StreamingChatMessageContent>> InvokeStreamingAsync(ICollection<ChatMessageContent> messages, AgentThread? thread = null, AgentInvokeOptions? options = null, CancellationToken cancellationToken = default)
        {
            throw new NotImplementedException();
        }

        protected internal override Task<AgentChannel> CreateChannelAsync(CancellationToken cancellationToken)
        {
            throw new NotImplementedException();
        }

        protected internal override IEnumerable<string> GetChannelKeys()
        {
            throw new NotImplementedException();
        }

        protected internal override Task<AgentChannel> RestoreChannelAsync(string channelState, CancellationToken cancellationToken)
        {
            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// Mock implementation of <see cref="AgentThread"/>
    /// </summary>
    private sealed class MockAgentThread : AgentThread
    {
        protected override Task<string?> CreateInternalAsync(CancellationToken cancellationToken)
        {
            return Task.FromResult<string?>("mock_thread_id");
        }

        protected override Task DeleteInternalAsync(CancellationToken cancellationToken)
        {
            return Task.CompletedTask;
        }

        protected override Task OnNewMessageInternalAsync(ChatMessageContent newMessage, CancellationToken cancellationToken = default)
        {
            return Task.CompletedTask;
        }
    }
}


===== UnitTests\Core\Internal\ChatMessageForPromptTests.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Text.Json;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents.Internal;
using Microsoft.SemanticKernel.ChatCompletion;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.Core.Internal;

/// <summary>
/// Unit testing of <see cref="ChatMessageForPrompt"/>.
/// </summary>
public class ChatMessageForPromptTests
{
    /// <summary>
    /// Verify <see cref="ChatMessageForPrompt"/> formats history for prompt.
    /// </summary>
    [Fact]
    public void VerifyFormatHistoryAsync()
    {
        // Arrange & Act
        string history = ChatMessageForPrompt.Format([]);
        // Assert
        VerifyMessageCount<ChatMessageForTest>(history, 0);

        // Arrange & Act
        history = ChatMessageForPrompt.Format(CreatHistory());
        // Assert
        ChatMessageForTest[] messages = VerifyMessageCount<ChatMessageForTest>(history, 4);
        Assert.Equal("test", messages[1].Name);
        Assert.Equal(string.Empty, messages[2].Name);
        Assert.Equal("test", messages[3].Name);
    }

    /// <summary>
    /// Verify <see cref="ChatMessageForPrompt"/> formats history using name only.
    /// </summary>
    [Fact]
    public void VerifyFormatNamesAsync()
    {
        // Arrange & Act
        string history = ChatMessageForPrompt.Format([], useNameOnly: true);
        // Assert
        VerifyMessageCount<string>(history, 0);

        // Arrange & Act
        history = ChatMessageForPrompt.Format(CreatHistory(), useNameOnly: true);
        // Assert
        string[] names = VerifyMessageCount<string>(history, 4);
        Assert.Equal("test", names[1]);
        Assert.Equal(AuthorRole.Assistant.Label, names[2]);
        Assert.Equal("test", names[3]);
    }

    private static TResult[] VerifyMessageCount<TResult>(string history, int expectedLength)
    {
        TResult[]? messages = JsonSerializer.Deserialize<TResult[]>(history);
        Assert.NotNull(messages);
        Assert.Equal(expectedLength, messages.Length);
        return messages;
    }

    private static ChatHistory CreatHistory()
    {
        return
            [
                new ChatMessageContent(AuthorRole.User, "content1"),
                new ChatMessageContent(AuthorRole.Assistant, "content1") { AuthorName = "test" },
                new ChatMessageContent(AuthorRole.Assistant, "content1"),
                new ChatMessageContent(AuthorRole.Assistant, "content1") { AuthorName = "test" },
            ];
    }

    private sealed class ChatMessageForTest
    {
        public string Role { get; init; } = string.Empty;

        public string? Name { get; init; } = string.Empty;

        public string Content { get; init; } = string.Empty;
    }
}


===== UnitTests\Definition\AgentDefinitionModelTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using Microsoft.SemanticKernel.Agents;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.Definition;

/// <summary>
/// Unit testing of <see cref="AgentDefinition"/> and related model classes.
/// </summary>
public class AgentDefinitionModelTests
{
    /// <summary>
    /// Verify ModelDefinition.Api cannot be null or whitespace.
    /// </summary>
    [Fact]
    public void VerifyModelDefinitionApiNotNullOrWhiteSpace()
    {
        // Arrange
        var modelDefinition = new ModelDefinition();

        // Act & Assert
        Assert.Throws<ArgumentException>(() => modelDefinition.Api = "");
        Assert.Throws<ArgumentNullException>(() => modelDefinition.Api = null!);
    }
}


===== UnitTests\Extensions\AgentDefinitionExtensionsTests.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.ComponentModel;
using System.Linq;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.Extensions;

/// <summary>
/// Unit testing of <see cref="AgentDefinitionExtensions"/>.
/// </summary>
public class AgentDefinitionExtensionsTests
{
    /// <summary>
    /// Verify default instance of <see cref="KernelArguments"/> can be created.
    /// </summary>
    [Fact]
    public void VerifyGetDefaultKernelArguments()
    {
        // Arrange
        var agentDefinition = new AgentDefinition();
        var kernel = new Kernel();

        // Act
        var kernelArguments = agentDefinition.GetDefaultKernelArguments(kernel);

        // Assert
        Assert.NotNull(kernelArguments);
    }

    /// <summary>
    ///  Verify default instance of <see cref="KernelArguments"/> has function calling enabled.
    /// </summary>
    [Fact]
    public void VerifyGetDefaultKernelArgumentsEnablesFunctionCalling()
    {
        // Arrange
        var agentDefinition = new AgentDefinition
        {
            Tools = [new() { Type = "function", Id = "MyPlugin.Function1" }]
        };
        var kernel = new Kernel();
        var kernelPlugin = kernel.Plugins.AddFromType<MyPlugin>();

        // Act
        var kernelArguments = agentDefinition.GetDefaultKernelArguments(kernel);

        // Assert
        Assert.NotNull(kernelArguments);
        Assert.NotNull(kernelArguments.ExecutionSettings);
        Assert.Single(kernelArguments.ExecutionSettings);
        Assert.NotNull(kernelArguments.ExecutionSettings["default"].FunctionChoiceBehavior);
        var autoFunctionChoiceBehavior = kernelArguments.ExecutionSettings["default"].FunctionChoiceBehavior as AutoFunctionChoiceBehavior;
        Assert.NotNull(autoFunctionChoiceBehavior);
        Assert.NotNull(autoFunctionChoiceBehavior.Functions);
        Assert.Single(autoFunctionChoiceBehavior.Functions);
    }

    /// <summary>
    ///  Verify instance of <see cref="KernelArguments"/> cannot be created if function is not available.
    /// </summary>
    [Fact]
    public void VerifyGetDefaultKernelArgumentsThrowsForInvalidFunction()
    {
        // Arrange
        var agentDefinition = new AgentDefinition
        {
            Tools = [new() { Type = "function", Id = "MyPlugin.Function2" }]
        };
        var kernel = new Kernel();
        var kernelPlugin = kernel.Plugins.AddFromType<MyPlugin>();

        // Act & Assert
        Assert.Throws<KernelException>(() => agentDefinition.GetDefaultKernelArguments(kernel));
    }

    /// <summary>
    /// Verify GetPromptTemplate returns null if there is no template factory, template or instructions.
    /// </summary>
    [Fact]
    public void VerifyGetPromptTemplateReturnsNull()
    {
        // Arrange
        var agentDefinition = new AgentDefinition();
        var kernel = new Kernel();

        // Act & Assert
        Assert.Null(agentDefinition.GetPromptTemplate(kernel, null));
    }

    /// <summary>
    /// Verify GetPromptTemplate returns null if there is no template factory, template or instructions.
    /// </summary>
    [Fact]
    public void VerifyGetPromptTemplate()
    {
        // Arrange
        var agentDefinition = new AgentDefinition()
        {
            Instructions = "instructions",
            Template = new() { Format = "semantic-kernel" }
        };
        var kernel = new Kernel();
        var templateFactory = new KernelPromptTemplateFactory();

        // Act
        var promptTemplate = agentDefinition.GetPromptTemplate(kernel, templateFactory);

        // Assert
        Assert.NotNull(promptTemplate);
    }

    /// <summary>
    ///  Verify GetFirstToolDefinition returns the correct tool.
    /// </summary>
    [Fact]
    public void VerifyGetFirstToolDefinition()
    {
        // Arrange
        var agentDefinition = new AgentDefinition
        {
            Tools =
            [
                new() { Type = "function", Id = "MyPlugin.Function1" },
                new() { Type = "code_interpreter" }
            ]
        };
        var kernel = new Kernel();
        var kernelPlugin = kernel.Plugins.AddFromType<MyPlugin>();

        // Act
        var toolDefinition = agentDefinition.GetFirstToolDefinition("function");

        // Assert
        Assert.NotNull(toolDefinition);
        Assert.Equal("function", toolDefinition.Type);
    }

    /// <summary>
    ///  Verify GetToolDefinitions returns the correct tools.
    /// </summary>
    [Fact]
    public void VerifyGetToolDefinitions()
    {
        // Arrange
        var agentDefinition = new AgentDefinition
        {
            Tools =
            [
                new() { Type = "function", Id = "MyPlugin.Function1" },
                new() { Type = "function", Id = "MyPlugin.Function2" },
                new() { Type = "code_interpreter" }
            ]
        };
        var kernel = new Kernel();
        var kernelPlugin = kernel.Plugins.AddFromType<MyPlugin>();

        // Act
        var toolDefinitions = agentDefinition.GetToolDefinitions("function");

        // Assert
        Assert.NotNull(toolDefinitions);
        Assert.Equal(2, toolDefinitions.Count());
    }

    /// <summary>
    ///  Verify HasToolType returns the correct values.
    /// </summary>
    [Fact]
    public void VerifyHasToolType()
    {
        // Arrange
        var agentDefinition = new AgentDefinition
        {
            Tools =
            [
                new() { Type = "function", Id = "MyPlugin.Function1" },
                new() { Type = "code_interpreter" }
            ]
        };
        var kernel = new Kernel();
        var kernelPlugin = kernel.Plugins.AddFromType<MyPlugin>();

        // Act & Assert
        Assert.True(agentDefinition.HasToolType("function"));
        Assert.True(agentDefinition.HasToolType("code_interpreter"));
        Assert.False(agentDefinition.HasToolType("file_search"));
    }

    #region private
    private sealed class MyPlugin
    {
        [KernelFunction("Function1")]
        [Description("Description for function 1.")]
        public string Function1([Description("Description for parameter 1")] string param1) => $"Function1: {param1}";
    }
    #endregion
}


===== UnitTests\Extensions\AgentToolDefinitionExtensionsTests.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.Collections.Generic;
using Microsoft.SemanticKernel.Agents;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.Extensions;

/// <summary>
/// Unit testing of <see cref="AgentToolDefinitionExtensions"/>.
/// </summary>
public class AgentToolDefinitionExtensionsTests
{
    /// <summary>
    /// Verify GetOption.
    /// </summary>
    [Fact]
    public void VerifyGetOption()
    {
        // Arrange
        var agentToolDefinition = new AgentToolDefinition()
        {
            Type = "function",
            Id = "MyPlugin.Function1",
            Options = new Dictionary<string, object?>()
            {
                { "null", null },
                { "string", "string" },
                { "int", 1 },
                { "array", new string[] { "1", "2", "3" } },
            }
        };

        // Act & Assert
        Assert.Null(agentToolDefinition.GetOption<string>("null"));
        Assert.Equal("string", agentToolDefinition.GetOption<string>("string"));
        Assert.Equal(1, agentToolDefinition.GetOption<int>("int"));
        Assert.Equal(new string[] { "1", "2", "3" }, agentToolDefinition.GetOption<string[]>("array"));
        Assert.Throws<InvalidCastException>(() => agentToolDefinition.GetOption<string[]>("string"));
        Assert.Throws<ArgumentNullException>(() => agentToolDefinition.GetOption<string>(null!));
    }
}


===== UnitTests\Extensions\ChatHistoryExtensionsTests.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Linq;
using System.Threading.Tasks;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents.Extensions;
using Microsoft.SemanticKernel.ChatCompletion;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.Extensions;

/// <summary>
/// Unit testing of <see cref="Microsoft.SemanticKernel.Agents.Extensions.ChatHistoryExtensions"/>.
/// </summary>
public class ChatHistoryExtensionsTests
{
    /// <summary>
    /// Verify ability to reverse history in-place.
    /// </summary>
    [Fact]
    public void VerifyChatHistoryOrdering()
    {
        // Arrange
        ChatHistory history = [];
        history.AddUserMessage("Hi");
        history.AddAssistantMessage("Hi");

        // Act and Assert
        VerifyRole(AuthorRole.User, history.First());
        VerifyRole(AuthorRole.Assistant, history.Last());

        VerifyRole(AuthorRole.User, history.ToDescending().Last());
        VerifyRole(AuthorRole.Assistant, history.ToDescending().First());
    }

    /// <summary>
    /// Verify ability to asynchronously reverse history in-place.
    /// </summary>
    [Fact]
    public async Task VerifyChatHistoryOrderingAsync()
    {
        // Arrange
        ChatHistory history = [];
        history.AddUserMessage("Hi");
        history.AddAssistantMessage("Hi");

        // Act and Assert
        VerifyRole(AuthorRole.User, history.First());
        VerifyRole(AuthorRole.Assistant, history.Last());

        VerifyRole(AuthorRole.User, await history.ToDescendingAsync().LastOrDefaultAsync());
        VerifyRole(AuthorRole.Assistant, await history.ToDescendingAsync().FirstOrDefaultAsync());
    }

    private static void VerifyRole(AuthorRole expectedRole, ChatMessageContent? message)
    {
        Assert.Equal(expectedRole, message?.Role);
    }
}


===== UnitTests\Extensions\ResponseItemExtensionsTests.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.Collections.Generic;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents.OpenAI;
using Microsoft.SemanticKernel.ChatCompletion;
using OpenAI.Responses;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.OpenAI.Extensions;

/// <summary>
/// Unit testing of <see cref="Microsoft.SemanticKernel.Agents.OpenAI.OpenAIResponseExtensions"/>.
/// </summary>
public class ResponseItemExtensionsTests
{
    [Theory]
    [InlineData("CreateUserMessageItem", "user")]
    [InlineData("CreateAssistantMessageItem", "assistant")]
    [InlineData("CreateDeveloperMessageItem", "developer")]
    [InlineData("CreateSystemMessageItem", "system")]
    public void VerifyToChatMessageContentFromInputText(string creationMethod, string roleLabel)
    {
        // Arrange  
        string inputTextContent = "inputTextContent";
        MessageResponseItem responseItem = creationMethod switch
        {
            "CreateUserMessageItem" => ResponseItem.CreateUserMessageItem(inputTextContent),
            "CreateAssistantMessageItem" => ResponseItem.CreateAssistantMessageItem(inputTextContent),
            "CreateDeveloperMessageItem" => ResponseItem.CreateDeveloperMessageItem(inputTextContent),
            "CreateSystemMessageItem" => ResponseItem.CreateSystemMessageItem(inputTextContent),
            _ => throw new ArgumentException("Invalid creation method")
        };

        // Act  
        var messageContent = responseItem.ToChatMessageContent();

        // Assert
        Assert.NotNull(messageContent);
        Assert.Equal(new AuthorRole(roleLabel), messageContent.Role);
        Assert.Single(messageContent.Items);
        Assert.IsType<TextContent>(messageContent.Items[0]);
        Assert.Equal(inputTextContent, ((TextContent)messageContent.Items[0]).Text);
    }

    [Fact]
    public void VerifyToChatMessageContentFromInputImage()
    {
        // Arrange
        IEnumerable<ResponseContentPart> contentParts = [ResponseContentPart.CreateInputImagePart("imageFileId")];
        MessageResponseItem responseItem = ResponseItem.CreateUserMessageItem(contentParts);

        // Act
        var messageContent = responseItem.ToChatMessageContent();

        // Assert
        Assert.NotNull(messageContent);
        Assert.Equal(AuthorRole.User, messageContent.Role);
        Assert.Single(messageContent.Items);
        Assert.IsType<FileReferenceContent>(messageContent.Items[0]);
        Assert.Equal("imageFileId", ((FileReferenceContent)messageContent.Items[0]).FileId);
    }

    [Fact]
    public void VerifyToChatMessageContentFromInputFile()
    {
        // Arrange
        var fileBytes = new ReadOnlyMemory<byte>([1, 2, 3, 4, 5]);
        IEnumerable<ResponseContentPart> contentParts = [ResponseContentPart.CreateInputFilePart(BinaryData.FromBytes(fileBytes), "text/plain", "fileName")];
        MessageResponseItem responseItem = ResponseItem.CreateUserMessageItem(contentParts);

        // Act
        var messageContent = responseItem.ToChatMessageContent();

        // Assert
        Assert.NotNull(messageContent);
        Assert.Equal(AuthorRole.User, messageContent.Role);
        Assert.Single(messageContent.Items);
        Assert.IsType<BinaryContent>(messageContent.Items[0]);
        Assert.Equal(fileBytes.ToArray(), ((BinaryContent)messageContent.Items[0]).Data?.ToArray());
    }

    [Fact]
    public void VerifyToChatMessageContentFromRefusal()
    {
        // Arrange
        IEnumerable<ResponseContentPart> contentParts = [ResponseContentPart.CreateRefusalPart("refusal")];
        MessageResponseItem responseItem = ResponseItem.CreateUserMessageItem(contentParts);

        // Act
        var messageContent = responseItem.ToChatMessageContent();

        // Assert
        Assert.NotNull(messageContent);
        Assert.Equal(AuthorRole.User, messageContent.Role);
        Assert.Single(messageContent.Items);
        Assert.IsType<TextContent>(messageContent.Items[0]);
        Assert.Equal("refusal", ((TextContent)messageContent.Items[0]).Text);
    }

    [Fact]
    public void VerifyToChatMessageContentFromReasoning()
    {
        // Arrange
        IEnumerable<ReasoningSummaryPart> summaryParts = [ReasoningSummaryPart.CreateTextPart("Foo")];
        ReasoningResponseItem responseItem = ResponseItem.CreateReasoningItem(summaryParts);

        // Act
        var messageContent = responseItem.ToChatMessageContent();

        // Assert
        Assert.NotNull(messageContent);
        Assert.Single(messageContent.Items);
        var reasoningContent = messageContent.Items[0] as ReasoningContent;
        Assert.NotNull(reasoningContent);
        Assert.Equal("Foo", reasoningContent.Text);
    }
}


===== UnitTests\Internal\BroadcastQueueTests.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.Threading.Tasks;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents.Internal;
using Microsoft.SemanticKernel.ChatCompletion;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.Internal;

/// <summary>
/// Unit testing of <see cref="BroadcastQueue"/>.
/// </summary>
public class BroadcastQueueTests
{
    /// <summary>
    /// Verify the default configuration.
    /// </summary>
    [Fact]
    public void VerifyBroadcastQueueDefaultConfiguration()
    {
        // Arrange
        BroadcastQueue queue = new();

        // Assert
        Assert.True(queue.BlockDuration.TotalSeconds > 0);
    }

    /// <summary>
    /// Verify behavior of <see cref="BroadcastQueue"/> over the course of multiple interactions.
    /// </summary>
    [Fact]
    public async Task VerifyBroadcastQueueReceiveAsync()
    {
        // Arrange: Create queue and channel.
        BroadcastQueue queue =
            new()
            {
                BlockDuration = TimeSpan.FromSeconds(0.08),
            };
        MockChannel channel = new();
        ChannelReference reference = new(channel, "test");

        // Act: Verify initial state
        await VerifyReceivingStateAsync(receiveCount: 0, queue, channel, "test");

        // Assert
        Assert.Empty(channel.ReceivedMessages);

        // Act: Verify empty invocation with no channels.
        queue.Enqueue([], []);
        await VerifyReceivingStateAsync(receiveCount: 0, queue, channel, "test");

        // Assert
        Assert.Empty(channel.ReceivedMessages);

        // Act: Verify empty invocation of channel.
        queue.Enqueue([reference], []);
        await VerifyReceivingStateAsync(receiveCount: 1, queue, channel, "test");

        // Assert
        Assert.Empty(channel.ReceivedMessages);

        // Act: Verify expected invocation of channel.
        queue.Enqueue([reference], [new ChatMessageContent(AuthorRole.User, "hi")]);
        await VerifyReceivingStateAsync(receiveCount: 2, queue, channel, "test");

        // Assert
        Assert.NotEmpty(channel.ReceivedMessages);
    }

    /// <summary>
    /// Verify behavior of <see cref="BroadcastQueue"/> over the course of multiple interactions.
    /// </summary>
    [Fact]
    public async Task VerifyBroadcastQueueFailureAsync()
    {
        // Arrange: Create queue and channel.
        BroadcastQueue queue =
            new()
            {
                BlockDuration = TimeSpan.FromSeconds(0.08),
            };
        MockChannel channel = new() { MockException = new InvalidOperationException("Test") };
        ChannelReference reference = new(channel, "test");

        // Act: Verify expected invocation of channel.
        queue.Enqueue([reference], [new ChatMessageContent(AuthorRole.User, "hi")]);

        // Assert
        await Assert.ThrowsAsync<KernelException>(() => queue.EnsureSynchronizedAsync(reference));
        await Assert.ThrowsAsync<KernelException>(() => queue.EnsureSynchronizedAsync(reference));
        await Assert.ThrowsAsync<KernelException>(() => queue.EnsureSynchronizedAsync(reference));
    }

    /// <summary>
    /// Verify behavior of <see cref="BroadcastQueue"/> with queuing of multiple channels.
    /// </summary>
    [Fact]
    public async Task VerifyBroadcastQueueConcurrencyAsync()
    {
        // Arrange: Create queue and channel.
        BroadcastQueue queue =
            new()
            {
                BlockDuration = TimeSpan.FromSeconds(0.08),
            };
        MockChannel channel = new();
        ChannelReference reference = new(channel, "test");

        // Act: Enqueue multiple channels
        for (int count = 0; count < 10; ++count)
        {
            queue.Enqueue([new(channel, $"test{count}")], [new ChatMessageContent(AuthorRole.User, "hi")]);
        }

        // Drain all queues.
        for (int count = 0; count < 10; ++count)
        {
            await queue.EnsureSynchronizedAsync(new ChannelReference(channel, $"test{count}"));
        }

        // Assert
        Assert.NotEmpty(channel.ReceivedMessages);
        Assert.Equal(10, channel.ReceivedMessages.Count);
    }

    private static async Task VerifyReceivingStateAsync(int receiveCount, BroadcastQueue queue, MockChannel channel, string hash)
    {
        await queue.EnsureSynchronizedAsync(new ChannelReference(channel, hash));
        Assert.Equal(receiveCount, channel.ReceiveCount);
    }
}


===== UnitTests\Internal\KeyEncoderTests.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Linq;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.Agents.Internal;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.Internal;

/// <summary>
/// Unit testing of <see cref="KeyEncoder"/>.
/// </summary>
public class KeyEncoderTests
{
    /// <summary>
    /// Validate the production of unique and consistent hashes.
    /// </summary>
    [Fact]
    public void VerifyKeyEncoderUniqueness()
    {
        // Act
        this.VerifyHashEquivalancy([]);
        this.VerifyHashEquivalancy(nameof(KeyEncoderTests));
        this.VerifyHashEquivalancy(nameof(KeyEncoderTests), "http://localhost", "zoo");

        // Assert: Verify "well-known" value
        string localHash = KeyEncoder.GenerateHash([typeof(ChatHistoryChannel).FullName!]);
        Assert.Equal("Vdx37EnWT9BS+kkCkEgFCg9uHvHNw1+hXMA4sgNMKs4=", localHash);
    }

    private void VerifyHashEquivalancy(params string[] keys)
    {
        // Act
        string hash1 = KeyEncoder.GenerateHash(keys);
        string hash2 = KeyEncoder.GenerateHash(keys);
        string hash3 = KeyEncoder.GenerateHash(keys.Concat(["another"]));

        // Assert
        Assert.Equal(hash1, hash2);
        Assert.NotEqual(hash1, hash3);
    }
}


===== UnitTests\Magentic\MagenticManagerContextTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents.Magentic;
using Microsoft.SemanticKernel.ChatCompletion;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.Magentic;

public class MagenticManagerContextTests
{
    [Fact]
    public void Constructor_ShouldInitializeAllProperties()
    {
        // Arrange
        MagenticTeam mockTeam = [];
        List<ChatMessageContent> task = [new ChatMessageContent(AuthorRole.User, "Test task")];
        List<ChatMessageContent> history =
        [
            new ChatMessageContent(AuthorRole.User, "Test message 1"),
            new ChatMessageContent(AuthorRole.Assistant, "Test response 1")
        ];

        const int ResponseCount = 5;
        const int StallCount = 2;
        const int ResetCount = 1;

        // Act
        MagenticManagerContext context = new(mockTeam, task, history, ResponseCount, StallCount, ResetCount);

        // Assert
        Assert.Equal(mockTeam, context.Team);
        Assert.Equal(task, context.Task);
        Assert.Equal(history, context.History);
        Assert.Equal(ResponseCount, context.ResponseCount);
        Assert.Equal(StallCount, context.StallCount);
        Assert.Equal(ResetCount, context.ResetCount);
    }

    [Fact]
    public void ReadOnlyCollections_ShouldNotAllowModification()
    {
        // Arrange
        MagenticTeam mockTeam = [];
        List<ChatMessageContent> task = [new ChatMessageContent(AuthorRole.User, "Test task")];
        List<ChatMessageContent> history = [new ChatMessageContent(AuthorRole.User, "Test message")];

        // Act
        MagenticManagerContext context = new(mockTeam, task, history, 0, 0, 0);

        // Assert
        // Verify that the collections exposed as IReadOnlyList don't allow modifications
        Assert.Throws<NotSupportedException>(() => ((IList<ChatMessageContent>)context.History).Add(new ChatMessageContent(AuthorRole.User, "New history")));
        Assert.Throws<NotSupportedException>(() => ((IList<ChatMessageContent>)context.Task).Add(new ChatMessageContent(AuthorRole.User, "New task")));
    }
}


===== UnitTests\Magentic\MagenticOrchestrationTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.Agents.Magentic;
using Microsoft.SemanticKernel.Agents.Orchestration;
using Microsoft.SemanticKernel.Agents.Runtime.InProcess;
using Microsoft.SemanticKernel.ChatCompletion;
using Moq;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.Magentic;

/// <summary>
/// Tests for the <see cref="MagenticOrchestration"/> class.
/// </summary>
public class MagenticOrchestrationTests
{
    [Fact]
    public async Task MagenticOrchestrationWithSingleAgentAsync()
    {
        // Arrange
        await using InProcessRuntime runtime = new();
        MockAgent mockAgent1 = CreateMockAgent(2, "xyz");

        // Act: Create and execute the orchestration
        string response = await this.ExecuteOrchestrationAsync(runtime, "answer", mockAgent1);

        // Assert
        Assert.Equal("answer", response);
        Assert.Equal(1, mockAgent1.InvokeCount);
    }

    [Fact]
    public async Task MagenticOrchestrationWithMultipleAgentsAsync()
    {
        // Arrange
        await using InProcessRuntime runtime = new();

        MockAgent mockAgent1 = CreateMockAgent(1, "abc");
        MockAgent mockAgent2 = CreateMockAgent(2, "xyz");
        MockAgent mockAgent3 = CreateMockAgent(3, "lmn");

        // Act: Create and execute the orchestration
        string response = await this.ExecuteOrchestrationAsync(runtime, "answer", mockAgent1, mockAgent2, mockAgent3);

        // Assert
        Assert.Equal("answer", response);
        Assert.Equal(1, mockAgent1.InvokeCount);
        Assert.Equal(0, mockAgent2.InvokeCount);
        Assert.Equal(0, mockAgent3.InvokeCount);
    }

    [Fact]
    public async Task MagenticOrchestrationMaxInvocationCountReached_WithoutPartialResultAsync()
    {
        // Arrange
        await using InProcessRuntime runtime = new();

        MockAgent mockAgent1 = CreateMockAgent(1, "abc");
        MockAgent mockAgent2 = CreateMockAgent(2, "xyz");
        MockAgent mockAgent3 = CreateMockAgent(3, "lmn");

        string jsonStatus =
            $$"""
            {
                "Name": "{{mockAgent1.Name}}",
                "Instruction":"Proceed",
                "Reason":"TestReason",
                "IsTaskComplete": {
                  "Result": false,
                  "Reason": "Test"
                },
                "IsTaskProgressing": {
                  "Result": true,
                  "Reason": "Test"
                },
                "IsTaskInLoop": {
                  "Result": false,
                  "Reason": "Test"
                }
            }
            """;
        Mock<IChatCompletionService> chatServiceMock = CreateMockChatCompletionService(jsonStatus);

        FakePromptExecutionSettings settings = new();
        StandardMagenticManager manager = new(chatServiceMock.Object, settings)
        {
            MaximumInvocationCount = 1, // Fast failure for testing
        };

        MagenticOrchestration orchestration = new(manager, [mockAgent1, mockAgent2, mockAgent3]);

        // Act
        await runtime.StartAsync();

        const string InitialInput = "123";
        OrchestrationResult<string> result = await orchestration.InvokeAsync(InitialInput, runtime);
        string response = await result.GetValueAsync(TimeSpan.FromSeconds(20));

        // Assert
        Assert.NotNull(response);
        Assert.Contains("No partial result available.", response);
    }

    [Fact]
    public async Task MagenticOrchestrationMaxInvocationCountReached_WithPartialResultAsync()
    {
        // Arrange
        await using InProcessRuntime runtime = new();

        MockAgent mockAgent1 = CreateMockAgent(1, "abc");
        MockAgent mockAgent2 = CreateMockAgent(2, "xyz");
        MockAgent mockAgent3 = CreateMockAgent(3, "lmn");

        string jsonStatus =
            $$"""
            {
                "Name": "{{mockAgent1.Name}}",
                "Instruction":"Proceed",
                "Reason":"TestReason",
                "IsTaskComplete": {
                  "Result": false,
                  "Reason": "Test"
                },
                "IsTaskProgressing": {
                  "Result": true,
                  "Reason": "Test"
                },
                "IsTaskInLoop": {
                  "Result": false,
                  "Reason": "Test"
                }
            }
            """;
        Mock<IChatCompletionService> chatServiceMock = CreateMockChatCompletionService(jsonStatus);

        FakePromptExecutionSettings settings = new();
        StandardMagenticManager manager = new(chatServiceMock.Object, settings)
        {
            MaximumInvocationCount = 2, // Fast failure for testing but at least one invocation
        };

        MagenticOrchestration orchestration = new(manager, [mockAgent1, mockAgent2, mockAgent3]);

        // Act
        await runtime.StartAsync();

        const string InitialInput = "123";
        OrchestrationResult<string> result = await orchestration.InvokeAsync(InitialInput, runtime);
        string response = await result.GetValueAsync(TimeSpan.FromSeconds(20));

        // Assert
        Assert.NotNull(response);
        Assert.Equal("abc", response);
    }

    [Fact]
    public async Task MagenticOrchestrationMaxResetCountReached_WithoutPartialResultAsync()
    {
        // Arrange
        await using InProcessRuntime runtime = new();

        MockAgent mockAgent1 = CreateMockAgent(1, "abc");
        MockAgent mockAgent2 = CreateMockAgent(2, "xyz");
        MockAgent mockAgent3 = CreateMockAgent(3, "lmn");

        string jsonStatus =
            $$"""
            {
                "Name": "{{mockAgent1.Name}}",
                "Instruction":"Proceed",
                "Reason":"TestReason",
                "IsTaskComplete": {
                  "Result": false,
                  "Reason": "Test"
                },
                "IsTaskProgressing": {
                  "Result": false,
                  "Reason": "Test"
                },
                "IsTaskInLoop": {
                  "Result": true,
                  "Reason": "Test"
                }
            }
            """;
        Mock<IChatCompletionService> chatServiceMock = CreateMockChatCompletionService(jsonStatus);

        FakePromptExecutionSettings settings = new();
        StandardMagenticManager manager = new(chatServiceMock.Object, settings)
        {
            MaximumResetCount = 1, // Fast failure for testing
            MaximumStallCount = 0, // No stalls allowed
        };

        MagenticOrchestration orchestration = new(manager, [mockAgent1, mockAgent2, mockAgent3]);

        // Act
        await runtime.StartAsync();

        const string InitialInput = "123";
        OrchestrationResult<string> result = await orchestration.InvokeAsync(InitialInput, runtime);
        string response = await result.GetValueAsync(TimeSpan.FromSeconds(20));

        // Assert
        Assert.NotNull(response);
        Assert.Contains("No partial result available.", response);
    }

    [Fact]
    public async Task MagenticOrchestrationMaxResetCountReached_WithPartialResultAsync()
    {
        // Arrange
        await using InProcessRuntime runtime = new();

        MockAgent mockAgent1 = CreateMockAgent(1, "abc");
        MockAgent mockAgent2 = CreateMockAgent(2, "xyz");
        MockAgent mockAgent3 = CreateMockAgent(3, "lmn");

        string jsonStatus =
            $$"""
            {
                "Name": "{{mockAgent1.Name}}",
                "Instruction":"Proceed",
                "Reason":"TestReason",
                "IsTaskComplete": {
                  "Result": false,
                  "Reason": "Test"
                },
                "IsTaskProgressing": {
                  "Result": false,
                  "Reason": "Test"
                },
                "IsTaskInLoop": {
                  "Result": true,
                  "Reason": "Test"
                }
            }
            """;
        Mock<IChatCompletionService> chatServiceMock = CreateMockChatCompletionService(jsonStatus);

        FakePromptExecutionSettings settings = new();
        StandardMagenticManager manager = new(chatServiceMock.Object, settings)
        {
            MaximumResetCount = 1, // Fast failure for testing but at least one response
            MaximumStallCount = 2, // Allow some stalls for at least one response
        };

        MagenticOrchestration orchestration = new(manager, [mockAgent1, mockAgent2, mockAgent3]);

        // Act
        await runtime.StartAsync();

        const string InitialInput = "123";
        OrchestrationResult<string> result = await orchestration.InvokeAsync(InitialInput, runtime);
        string response = await result.GetValueAsync(TimeSpan.FromSeconds(20));

        // Assert
        Assert.NotNull(response);
        Assert.Contains("abc", response);
    }

    private async Task<string> ExecuteOrchestrationAsync(InProcessRuntime runtime, string answer, params Agent[] mockAgents)
    {
        // Act
        await runtime.StartAsync();

        Mock<MagenticManager> manager = this.CreateMockManager(answer);
        MagenticOrchestration orchestration = new(manager.Object, mockAgents);

        const string InitialInput = "123";
        OrchestrationResult<string> result = await orchestration.InvokeAsync(InitialInput, runtime);

        // Assert
        Assert.NotNull(result);

        // Act
        string response = await result.GetValueAsync(TimeSpan.FromSeconds(20));

        await runtime.RunUntilIdleAsync();

        return response;
    }

    private static MockAgent CreateMockAgent(int index, string response)
    {
        return new()
        {
            Name = $"MockAgent{index}",
            Description = $"test {index}",
            Response = [new(AuthorRole.Assistant, response)]
        };
    }

    private bool _isComplete = false;

    private Mock<MagenticManager> CreateMockManager(string answer)
    {
        Mock<MagenticManager> mockManager = new(MockBehavior.Strict);

        // Setup mock for PlanAsync method
        mockManager.Setup(m => m.PlanAsync(It.IsAny<MagenticManagerContext>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync((MagenticManagerContext context, CancellationToken _) => [new(AuthorRole.User, "test")]);

        // Setup mock for ReplanAsync method
        mockManager.Setup(m => m.ReplanAsync(It.IsAny<MagenticManagerContext>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync((MagenticManagerContext context, CancellationToken _) => [new(AuthorRole.User, "test")]);

        // Setup mock for EvaluateTaskProgressAsync method
        mockManager
            .Setup(m => m.EvaluateTaskProgressAsync(It.IsAny<MagenticManagerContext>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync((MagenticManagerContext context, CancellationToken _) => CreateLedger(false, context.Team.First().Key));

        // Setup mock for PrepareFinalAnswerAsync method
        mockManager.Setup(m => m.PrepareFinalAnswerAsync(It.IsAny<MagenticManagerContext>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync((MagenticManagerContext context, CancellationToken _) =>
                new ChatMessageContent(AuthorRole.Assistant, answer));

        return mockManager;

        MagenticProgressLedger CreateLedger(bool isTaskComplete, string name)
        {
            try
            {
                return
                    new(Name: name,
                        Instruction: "Test instruction",
                        Reason: "Test evaluation",
                        IsTaskComplete: new(this._isComplete, "test"),
                        IsTaskProgressing: new(true, "test"),
                        IsTaskInLoop: new(true, "test"));
            }
            finally
            {
                this._isComplete = true;
            }
        }
    }

    private static Mock<IChatCompletionService> CreateMockChatCompletionService(string response)
    {
        Mock<IChatCompletionService> chatServiceMock = new(MockBehavior.Strict);

        chatServiceMock.Setup(
            (service) => service.GetChatMessageContentsAsync(
                It.IsAny<ChatHistory>(),
                It.IsAny<PromptExecutionSettings>(),
                null,
                It.IsAny<CancellationToken>()))
            .ReturnsAsync([new ChatMessageContent(AuthorRole.Assistant, response)]);

        return chatServiceMock;
    }

    private sealed class FakePromptExecutionSettings : PromptExecutionSettings
    {
        public override PromptExecutionSettings Clone()
        {
            return this;
        }

        public object? ResponseFormat { get; set; }
    }
}


===== UnitTests\Magentic\StandardMagenticManagerTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents.Magentic;
using Microsoft.SemanticKernel.ChatCompletion;
using Moq;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.Magentic;

public class StandardMagenticManagerTests
{
    [Fact]
    public async Task PlanAsync_ReturnsLedgerAsync()
    {
        // Arrange
        Mock<IChatCompletionService> chatServiceMock = CreateMockChatCompletionService("TaskLedgerResponse");
        FakePromptExecutionSettings settings = new();
        MagenticTeam team = CreateMagenticTeam();
        MagenticManagerContext context = CreateMagenticContext(team, "Test Task", "History");
        StandardMagenticManager manager = new(chatServiceMock.Object, settings);

        // Act
        IList<ChatMessageContent> result = await manager.PlanAsync(context, CancellationToken.None);

        // Assert - ledger message should come from the LedgerTemplate.
        Assert.Single(result);
        ChatMessageContent ledgerMessage = result[0];
        Assert.Equal(AuthorRole.System, ledgerMessage.Role);
        Assert.Contains("TaskLedgerResponse", ledgerMessage.Content);
    }

    [Fact]
    public async Task ReplanAsync_ReturnsLedgerAsync()
    {
        // Arrange
        Mock<IChatCompletionService> chatServiceMock = CreateMockChatCompletionService("TaskLedgerResponse");
        FakePromptExecutionSettings settings = new();
        MagenticTeam team = CreateMagenticTeam();
        MagenticManagerContext context = CreateMagenticContext(team, "Test Task", "History");
        StandardMagenticManager manager = new(chatServiceMock.Object, settings);

        // Act
        IList<ChatMessageContent> result = await manager.ReplanAsync(context, CancellationToken.None);

        // Assert 
        Assert.Single(result);
        ChatMessageContent ledgerMessage = result[0];
        Assert.Equal(AuthorRole.System, ledgerMessage.Role);
        Assert.Contains("TaskLedgerResponse", ledgerMessage.Content);
    }

    [Fact]
    public async Task EvaluateTaskProgressAsync_ReturnsLedgerObjectAsync()
    {
        // Arrange
        string jsonStatus =
            """
            {
                "Name":"TestAgent",
                "Instruction":"Proceed",
                "Reason":"TestReason",
                "IsTaskComplete": {
                  "Result": false,
                  "Reason": "Test"
                },
                "IsTaskProgressing": {
                  "Result": true,
                  "Reason": "Test"
                },
                "IsTaskInLoop": {
                  "Result": false,
                  "Reason": "Test"
                }
            }            
            """;
        Mock<IChatCompletionService> chatServiceMock = CreateMockChatCompletionService(jsonStatus);

        FakePromptExecutionSettings settings = new();

        MagenticTeam team = CreateMagenticTeam();
        MagenticManagerContext context = CreateMagenticContext(team, "Test Task", "History");

        StandardMagenticManager manager = new(chatServiceMock.Object, settings);

        // Act
        MagenticProgressLedger result = await manager.EvaluateTaskProgressAsync(context, CancellationToken.None);

        // Assert
        Assert.Equal("TestAgent", result.Name);
        Assert.Equal("Proceed", result.Instruction);
        Assert.Equal("TestReason", result.Reason);
        Assert.False(result.IsTaskComplete);
        Assert.True(result.IsTaskProgressing);
        Assert.False(result.IsTaskInLoop);
    }

    [Fact]
    public async Task PrepareFinalAnswerAsync_ReturnsFinalAnswerAsync()
    {
        // Arrange
        Mock<IChatCompletionService> chatServiceMock = CreateMockChatCompletionService("FinalAnswerResponse");
        MagenticTeam team = CreateMagenticTeam();
        MagenticManagerContext context = CreateMagenticContext(team, "Test Task", "History");
        FakePromptExecutionSettings settings = new();
        StandardMagenticManager manager = new(chatServiceMock.Object, settings);

        // Act
        ChatMessageContent result = await manager.PrepareFinalAnswerAsync(context, CancellationToken.None);

        // Assert
        Assert.Equal(AuthorRole.Assistant, result.Role);
        Assert.Equal("FinalAnswerResponse", result.Content);
    }

    private static Mock<IChatCompletionService> CreateMockChatCompletionService(string response)
    {
        Mock<IChatCompletionService> chatServiceMock = new(MockBehavior.Strict);

        chatServiceMock.Setup(
            (service) => service.GetChatMessageContentsAsync(
                It.IsAny<ChatHistory>(),
                It.IsAny<PromptExecutionSettings>(),
                null,
                It.IsAny<CancellationToken>()))
            .ReturnsAsync([new ChatMessageContent(AuthorRole.Assistant, response)]);

        return chatServiceMock;
    }

    private static MagenticManagerContext CreateMagenticContext(MagenticTeam team, string inputTask, string history) =>
        new(team,
            [new ChatMessageContent(AuthorRole.User, inputTask)],
            [new ChatMessageContent(AuthorRole.User, history)],
            responseCount: 5,
            stallCount: 1,
            resetCount: 0);

    private static MagenticTeam CreateMagenticTeam() =>
        new()
        {
            { "Agent1", ("AgentType1", "Description1") },
            { "Agent2", ("AgentType2", "Description2") },
        };

    private sealed class FakePromptExecutionSettings : PromptExecutionSettings
    {
        public override PromptExecutionSettings Clone()
        {
            return this;
        }

        public object? ResponseFormat { get; set; }
    }
}


===== UnitTests\MockAgent.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.ChatCompletion;
using Moq;

namespace SemanticKernel.Agents.UnitTests;

/// <summary>
/// Mock definition of <see cref="Agent"/> with a <see cref="ChatHistoryAgent"/> contract.
/// </summary>
internal sealed class MockAgent : ChatHistoryAgent
{
    public int InvokeCount { get; private set; }

    public IReadOnlyList<ChatMessageContent> Response { get; set; } = [];

    public async override IAsyncEnumerable<AgentResponseItem<ChatMessageContent>> InvokeAsync(
        ICollection<ChatMessageContent> messages,
        AgentThread? thread = null,
        AgentInvokeOptions? options = null,
        [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        this.InvokeCount++;

        if (thread == null)
        {
            Mock<AgentThread> mockThread = new();
            thread = mockThread.Object;
        }

        foreach (ChatMessageContent response in this.Response)
        {
            AgentResponseItem<ChatMessageContent> responseItem = new(response, thread);
            if (options?.OnIntermediateMessage is not null)
            {
                await options.OnIntermediateMessage(responseItem);
                yield return responseItem;
            }
        }
    }

    protected internal override IAsyncEnumerable<ChatMessageContent> InvokeAsync(
        ChatHistory history,
        KernelArguments? arguments = null,
        Kernel? kernel = null,
        CancellationToken cancellationToken = default)
    {
        this.InvokeCount++;

        return this.Response.ToAsyncEnumerable();
    }

    /// <inheritdoc/>
    public async override IAsyncEnumerable<AgentResponseItem<StreamingChatMessageContent>> InvokeStreamingAsync(
        ICollection<ChatMessageContent> messages,
        AgentThread? thread = null,
        AgentInvokeOptions? options = null,
        [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        this.InvokeCount++;

        if (thread == null)
        {
            Mock<AgentThread> mockThread = new();
            thread = mockThread.Object;
        }

        foreach (ChatMessageContent response in this.Response)
        {
            if (options?.OnIntermediateMessage is not null)
            {
                await options.OnIntermediateMessage(new AgentResponseItem<ChatMessageContent>(response, thread));
                yield return new AgentResponseItem<StreamingChatMessageContent>(new StreamingChatMessageContent(response.Role, response.Content), thread);
            }
        }
    }

    protected internal override IAsyncEnumerable<StreamingChatMessageContent> InvokeStreamingAsync(
        ChatHistory history,
        KernelArguments? arguments = null,
        Kernel? kernel = null,
        CancellationToken cancellationToken = default)
    {
        this.InvokeCount++;
        return this.Response.Select(m => new StreamingChatMessageContent(m.Role, m.Content)).ToAsyncEnumerable();
    }

    protected internal override Task<AgentChannel> RestoreChannelAsync(string channelState, CancellationToken cancellationToken)
    {
        ChatHistory history =
            JsonSerializer.Deserialize<ChatHistory>(channelState) ??
            throw new KernelException("Unable to restore channel: invalid state.");
        return Task.FromResult<AgentChannel>(new ChatHistoryChannel(history));
    }

    // Expose protected method for testing
    public new Task<string?> RenderInstructionsAsync(Kernel kernel, KernelArguments? arguments, CancellationToken cancellationToken)
    {
        return base.RenderInstructionsAsync(kernel, arguments, cancellationToken);
    }
}


===== UnitTests\MockChannel.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents;

namespace SemanticKernel.Agents.UnitTests;

internal sealed class MockChannel : AgentChannel<MockAgent>
{
    public Exception? MockException { get; set; }

    public int InvokeCount { get; private set; }

    public int ReceiveCount { get; private set; }

    public TimeSpan ReceiveDuration { get; set; } = TimeSpan.FromSeconds(0.3);

    public List<ChatMessageContent> ReceivedMessages { get; } = [];

    protected internal override IAsyncEnumerable<ChatMessageContent> GetHistoryAsync(CancellationToken cancellationToken)
    {
        throw new NotImplementedException();
    }

    public IAsyncEnumerable<(bool IsVisible, ChatMessageContent Message)> InvokeAgentAsync(Agent agent, CancellationToken cancellationToken = default)
        => base.InvokeAsync(agent, cancellationToken);

#pragma warning disable CS1998 // Async method lacks 'await' operators and will run synchronously
    protected internal override async IAsyncEnumerable<(bool IsVisible, ChatMessageContent Message)> InvokeAsync(MockAgent agent, [EnumeratorCancellation] CancellationToken cancellationToken = default)
#pragma warning restore CS1998 // Async method lacks 'await' operators and will run synchronously
    {
        this.InvokeCount++;

        if (this.MockException is not null)
        {
            throw this.MockException;
        }

        yield break;
    }

    protected internal override IAsyncEnumerable<StreamingChatMessageContent> InvokeStreamingAsync(MockAgent agent, IList<ChatMessageContent> messages, CancellationToken cancellationToken = default)
    {
        throw new NotImplementedException();
    }

    protected internal override async Task ReceiveAsync(IEnumerable<ChatMessageContent> history, CancellationToken cancellationToken = default)
    {
        this.ReceivedMessages.AddRange(history);
        this.ReceiveCount++;

        await Task.Delay(this.ReceiveDuration, cancellationToken);

        if (this.MockException is not null)
        {
            throw this.MockException;
        }
    }

    protected internal override Task ResetAsync(CancellationToken cancellationToken = default)
    {
        throw new NotImplementedException();
    }

    protected internal override string Serialize()
    {
        throw new NotImplementedException();
    }
}


===== UnitTests\OpenAI\BaseOpenAIResponseClientTest.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.ClientModel;
using System.ClientModel.Primitives;
using System.Net.Http;
using OpenAI;
using OpenAI.Responses;

namespace SemanticKernel.Agents.UnitTests.OpenAI;

/// <summary>
/// Base tests which use <see cref="OpenAIResponseClient"/>
/// </summary>
public class BaseOpenAIResponseClientTest : IDisposable
{
    internal MultipleHttpMessageHandlerStub MessageHandlerStub { get; }
    internal HttpClient HttpClient { get; }
    internal OpenAIResponseClient Client { get; }

    internal BaseOpenAIResponseClientTest()
    {
        this.MessageHandlerStub = new MultipleHttpMessageHandlerStub();
        this.HttpClient = new HttpClient(this.MessageHandlerStub, disposeHandler: false);

        var clientOptions = new OpenAIClientOptions()
        {
            Transport = new HttpClientPipelineTransport(this.HttpClient)
        };
        this.Client = new OpenAIResponseClient("model", new ApiKeyCredential("apiKey"), clientOptions);
    }

    /// <inheritdoc />
    public void Dispose()
    {
        this.MessageHandlerStub.Dispose();
        this.HttpClient.Dispose();

        GC.SuppressFinalize(this);
    }
}


===== UnitTests\OpenAI\Definition\OpenAIAssistantAgentFactoryTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.ClientModel;
using System.Net;
using System.Net.Http;
using System.Threading.Tasks;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.Agents.OpenAI;
using OpenAI;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.OpenAI.Definition;

/// <summary>
/// Unit tests for <see cref="OpenAIAssistantAgentFactory"/>.
/// </summary>
public class OpenAIAssistantAgentFactoryTests : IDisposable
{
    private readonly HttpMessageHandlerStub _messageHandlerStub;
    private readonly HttpClient _httpClient;
    private readonly Kernel _kernel;

    /// <summary>
    /// Initializes a new instance of the <see cref="OpenAIAssistantAgentTests"/> class.
    /// </summary>
    public OpenAIAssistantAgentFactoryTests()
    {
        this._messageHandlerStub = new HttpMessageHandlerStub();
        this._httpClient = new HttpClient(this._messageHandlerStub, disposeHandler: false);

        OpenAIClient openAIClient = OpenAIAssistantAgent.CreateOpenAIClient(new ApiKeyCredential("fakekey"), httpClient: this._httpClient);

        var builder = Kernel.CreateBuilder();
        builder.Services.AddSingleton<OpenAIClient>(openAIClient);
        this._kernel = builder.Build();
    }

    /// <inheritdoc/>
    public void Dispose()
    {
        GC.SuppressFinalize(this);
        this._messageHandlerStub.Dispose();
        this._httpClient.Dispose();
    }

    /// <summary>
    /// Verify can create an instance of <see cref="Agent"/> using <see cref="OpenAIAssistantAgentFactory"/>
    /// </summary>
    [Fact]
    public async Task VerifyCanCreateOpenAIAssistantAsync()
    {
        // Arrange
        AgentDefinition agentDefinition = new()
        {
            Type = OpenAIAssistantAgentFactory.OpenAIAssistantAgentType,
            Name = "OpenAIAssistantAgent",
            Description = "OpenAIAssistantAgent Description",
            Instructions = "OpenAIAssistantAgent Instructions",
            Model = new()
            {
                Id = "gpt-4o-mini"
            },
            Tools = [
                new AgentToolDefinition()
                {
                    Id = "tool1",
                    Type = "code_interpreter",
                },
            ]
        };
        OpenAIAssistantAgentFactory factory = new();
        this.SetupResponse(HttpStatusCode.OK, OpenAIAssistantCreateResponse);

        // Act
        var agent = await factory.CreateAsync(this._kernel, agentDefinition);

        // Assert
        Assert.NotNull(agent);
        Assert.Equal("asst_z2BnUzSnnZ4QimeUCsVSdAug", agent.Id);
        Assert.Equal(agentDefinition.Name, agent.Name);
        Assert.Equal(agentDefinition.Description, agent.Description);
        Assert.Equal(agentDefinition.Instructions, agent.Instructions);
        Assert.Equal(this._kernel, agent.Kernel);
    }

    /// <summary>
    /// Verify can get an instance of <see cref="Agent"/> using <see cref="OpenAIAssistantAgentFactory"/>
    /// </summary>
    [Fact]
    public async Task VerifyCanGetOpenAIAssistantAsync()
    {
        // Arrange
        AgentDefinition agentDefinition = new()
        {
            Id = "asst_GQ8RUQKakmfsGPd2LdF6lJvD",
            Type = OpenAIAssistantAgentFactory.OpenAIAssistantAgentType,
        };
        OpenAIAssistantAgentFactory factory = new();
        this.SetupResponse(HttpStatusCode.OK, OpenAIAssistantGetResponse);

        // Act
        var agent = await factory.CreateAsync(this._kernel, agentDefinition);

        // Assert
        Assert.NotNull(agent);
        Assert.Equal("asst_GQ8RUQKakmfsGPd2LdF6lJvD", agent.Id);
        Assert.Equal("StoryAgent", agent.Name);
        Assert.Equal("Store Telling Agent", agent.Description);
        Assert.Equal("Tell a story suitable for children about the topic provided by the user.", agent.Instructions);
        Assert.Equal(this._kernel, agent.Kernel);
    }

    /// <summary>
    /// OpenAI Assistant create response.
    /// </summary>
    public const string OpenAIAssistantCreateResponse =
        """
        {
          "id": "asst_z2BnUzSnnZ4QimeUCsVSdAug",
          "object": "assistant",
          "created_at": 1740137107,
          "name": "OpenAIAssistantAgent",
          "description": "OpenAIAssistantAgent Description",
          "model": "gpt-4o",
          "instructions": "OpenAIAssistantAgent Instructions",
          "tools": [
            {
              "type": "code_interpreter"
            }
          ],
          "top_p": 1.0,
          "temperature": 1.0,
          "reasoning_effort": null,
          "tool_resources": {
            "code_interpreter": {
              "file_ids": []
            }
          },
          "metadata": {},
          "response_format": "auto"
        }
        """;

    /// <summary>
    /// OpenAI Assistant get response.
    /// </summary>
    public const string OpenAIAssistantGetResponse =
        """
        {
          "id": "asst_GQ8RUQKakmfsGPd2LdF6lJvD",
          "object": "assistant",
          "created_at": 1742985843,
          "name": "StoryAgent",
          "description": "Store Telling Agent",
          "model": "gpt-4o-mini",
          "instructions": "Tell a story suitable for children about the topic provided by the user.",
          "tools": [],
          "top_p": 1.0,
          "temperature": 1.0,
          "tool_resources": {},
          "metadata": {},
          "response_format": "auto"
        }
        """;

    #region private
    private void SetupResponse(HttpStatusCode statusCode, string response) =>
        this._messageHandlerStub.SetupResponses(statusCode, [response]);
    #endregion
}


===== UnitTests\OpenAI\Extensions\AgentDefinitionExtensionsTests.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Collections.Generic;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.Agents.OpenAI;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.OpenAI.Extensions;

/// <summary>
/// Unit tests for YamlAgentDefinitionExtensions
/// </summary>
public class AgentDefinitionExtensionsTests
{
    /// <summary>
    /// Verify CreateAssistantCreationOptions
    /// </summary>
    [Fact]
    public void VerifyCreateAssistantCreationOptions()
    {
        // Arrange
        AgentDefinition agentDefinition = new()
        {
            Type = OpenAIAssistantAgentFactory.OpenAIAssistantAgentType,
            Name = "OpenAIAssistantAgent",
            Description = "OpenAIAssistantAgent Description",
            Instructions = "OpenAIAssistantAgent Instructions",
            Model = new()
            {
                Id = "gpt-4o-mini"
            },
            Tools = [
                new AgentToolDefinition()
                {
                    Id = "tool1",
                    Type = "code_interpreter",
                },
            ]
        };

        // Act
        var creationOptions = agentDefinition.CreateAssistantCreationOptions();

        // Assert
        Assert.NotNull(creationOptions);
        Assert.Equal(agentDefinition.Name, creationOptions.Name);
        Assert.Equal(agentDefinition.Description, creationOptions.Description);
        Assert.Equal(agentDefinition.Instructions, creationOptions.Instructions);
        Assert.Single(creationOptions.Tools);
    }

    /// <summary>
    /// Verify GetCodeInterpreterFileIds
    /// </summary>
    [Fact]
    public void VerifyGetCodeInterpreterFileIds()
    {
        // Arrange
        var fileIds = new List<string>(["file1", "file2"]);
        var options = new Dictionary<string, object?>
        {
            { "file_ids", fileIds }
        };
        AgentDefinition agentDefinition = new()
        {
            Tools = [
                new AgentToolDefinition()
                {
                    Id = "tool1",
                    Type = "code_interpreter",
                    Options = options,
                },
            ]
        };

        // Act
        var interpreterFileIds = agentDefinition.GetCodeInterpreterFileIds();

        // Assert
        Assert.NotNull(interpreterFileIds);
        Assert.Equal(2, interpreterFileIds.Count);
    }

    /// <summary>
    /// Verify GetVectorStoreId
    /// </summary>
    [Fact]
    public void VerifyGetVectorStoreId()
    {
        // Arrange
        AgentDefinition agentDefinition = new()
        {
        };

        // Act
        var vectorId = agentDefinition.GetVectorStoreId();

        // Assert
        Assert.Null(vectorId);
    }

    /// <summary>
    /// Verify GetMetadata
    /// </summary>
    [Fact]
    public void VerifyGetMetadata()
    {
        // Arrange
        AgentDefinition agentDefinition = new()
        {
        };

        // Act
        var metadata = agentDefinition.GetMetadata();

        // Assert
        Assert.Null(metadata);
    }
}


===== UnitTests\OpenAI\Extensions\AssistantClientExtensionsTests.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.ClientModel;
using System.Collections.Generic;
using System.Net;
using System.Net.Http;
using System.Threading.Tasks;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents.OpenAI;
using Microsoft.SemanticKernel.ChatCompletion;
using OpenAI;
using OpenAI.Assistants;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.OpenAI.Extensions;

/// <summary>
/// Unit testing of <see cref="OpenAIAssistantAgent"/>.
/// </summary>
public sealed class AssistantClientExtensionsTests : IDisposable
{
    private const string ModelValue = "testmodel";

    private readonly HttpMessageHandlerStub _messageHandlerStub;
    private readonly HttpClient _httpClient;
    private readonly OpenAIClient _client;

    /// <summary>
    /// Verify the assistant creation with default values.
    /// </summary>
    [Fact]
    public async Task VerifyCreateAssistantAsync()
    {
        // Arrange
        this.SetupResponse(HttpStatusCode.OK, OpenAIAssistantResponseContent.AssistantDefinition(ModelValue));

        // Act
        Assistant definition = await this._client.GetAssistantClient().CreateAssistantAsync(modelId: ModelValue);

        // Assert
        Assert.NotNull(definition);
        Assert.Equal(ModelValue, definition.Model);
    }

    /// <summary>
    /// Verify the assistant creation with name, instructions, and description.
    /// </summary>
    [Fact]
    public async Task VerifyCreateAssistantWithIdentityAsync()
    {
        // Arrange
        const string NameValue = "test name";
        const string DescriptionValue = "test instructions";
        const string InstructionsValue = "test description";

        this.SetupResponse(
            HttpStatusCode.OK,
            OpenAIAssistantResponseContent.AssistantDefinition(
                ModelValue,
                name: NameValue,
                instructions: InstructionsValue,
                description: DescriptionValue));

        // Act
        Assistant definition = await this._client.GetAssistantClient().CreateAssistantAsync(
            modelId: ModelValue,
            name: NameValue,
            instructions: InstructionsValue,
            description: DescriptionValue);

        // Assert
        Assert.NotNull(definition);
        Assert.Equal(NameValue, definition.Name);
        Assert.Equal(DescriptionValue, definition.Description);
        Assert.Equal(InstructionsValue, definition.Instructions);
    }

    /// <summary>
    /// Verify the assistant creation with name, instructions, and description.
    /// </summary>
    [Fact]
    public async Task VerifyCreateAssistantWithTemplateAsync()
    {
        // Arrange
        const string NameValue = "test name";
        const string DescriptionValue = "test instructions";
        const string InstructionsValue = "test description";
        PromptTemplateConfig templateConfig =
            new(InstructionsValue)
            {
                Name = NameValue,
                Description = InstructionsValue,
            };
        this.SetupResponse(
            HttpStatusCode.OK,
            OpenAIAssistantResponseContent.AssistantDefinition(
                ModelValue,
                name: NameValue,
                instructions: InstructionsValue,
                description: DescriptionValue));

        // Act
        Assistant definition = await this._client.GetAssistantClient().CreateAssistantFromTemplateAsync(modelId: ModelValue, templateConfig);

        // Assert
        Assert.NotNull(definition);
        Assert.Equal(NameValue, definition.Name);
        Assert.Equal(DescriptionValue, definition.Description);
        Assert.Equal(InstructionsValue, definition.Instructions);
    }

    /// <summary>
    /// Verify the assistant creation with code-interpreter enabled.
    /// </summary>
    [Fact]
    public async Task VerifyCreateAssistantWithCodeInterpreterAsync()
    {
        // Arrange
        this.SetupResponse(
            HttpStatusCode.OK,
            OpenAIAssistantResponseContent.AssistantDefinition(ModelValue, enableCodeInterpreter: true));

        // Act
        Assistant definition = await this._client.GetAssistantClient().CreateAssistantAsync(
            modelId: ModelValue,
            enableCodeInterpreter: true);

        // Assert
        Assert.NotNull(definition);
        Assert.Single(definition.Tools);
        Assert.IsType<CodeInterpreterToolDefinition>(definition.Tools[0]);
    }

    /// <summary>
    /// Verify the assistant creation with code-interpreter files specified.
    /// </summary>
    [Fact]
    public async Task VerifyCreateAssistantWithCodeInterpreterFilesAsync()
    {
        // Arrange
        string[] fileIds = ["file1", "file2"];
        this.SetupResponse(
            HttpStatusCode.OK,
            OpenAIAssistantResponseContent.AssistantDefinition(ModelValue, codeInterpreterFileIds: fileIds));

        // Act
        Assistant definition = await this._client.GetAssistantClient().CreateAssistantAsync(
            modelId: ModelValue,
            codeInterpreterFileIds: fileIds);

        // Assert
        Assert.NotNull(definition);
        Assert.Single(definition.Tools);
        Assert.IsType<CodeInterpreterToolDefinition>(definition.Tools[0]);
        Assert.NotNull(definition.ToolResources.CodeInterpreter);
        Assert.Equal(2, definition.ToolResources.CodeInterpreter.FileIds.Count);
    }

    /// <summary>
    /// Verify the assistant creation with file-search enabled.
    /// </summary>
    [Fact]
    public async Task VerifyCreateAssistantWithFileSearchAsync()
    {
        // Arrange
        this.SetupResponse(
            HttpStatusCode.OK,
            OpenAIAssistantResponseContent.AssistantDefinition(ModelValue, enableFileSearch: true));

        // Act
        Assistant definition = await this._client.GetAssistantClient().CreateAssistantAsync(
            modelId: ModelValue,
            enableFileSearch: true);

        // Assert
        Assert.NotNull(definition);
        Assert.Single(definition.Tools);
        Assert.IsType<FileSearchToolDefinition>(definition.Tools[0]);
    }

    /// <summary>
    /// Verify the assistant creation with vector-store specified.
    /// </summary>
    [Fact]
    public async Task VerifyCreateAssistantWithVectorStoreAsync()
    {
        // Arrange
        const string VectorStoreValue = "test store";
        this.SetupResponse(
            HttpStatusCode.OK,
            OpenAIAssistantResponseContent.AssistantDefinition(ModelValue, vectorStoreId: VectorStoreValue));

        // Act
        Assistant definition = await this._client.GetAssistantClient().CreateAssistantAsync(
            modelId: ModelValue,
            vectorStoreId: VectorStoreValue);

        // Assert
        Assert.NotNull(definition);
        Assert.Single(definition.Tools);
        Assert.IsType<FileSearchToolDefinition>(definition.Tools[0]);
        Assert.NotNull(definition.ToolResources.FileSearch);
        Assert.Single(definition.ToolResources.FileSearch.VectorStoreIds);
    }

    /// <summary>
    /// Verify the invocation and response of <see cref="AssistantClient.CreateAssistantAsync(string, AssistantCreationOptions, System.Threading.CancellationToken)"/>
    /// for an agent with temperature defined.
    /// </summary>
    [Fact]
    public async Task VerifyCreateAssistantWithTemperatureAsync()
    {
        // Arrange
        const float TemperatureValue = 0.5F;
        this.SetupResponse(HttpStatusCode.OK, OpenAIAssistantResponseContent.AssistantDefinition("testmodel", temperature: TemperatureValue));

        // Act
        Assistant definition = await this._client.GetAssistantClient().CreateAssistantAsync(
            modelId: "testmodel",
            temperature: TemperatureValue);

        // Assert
        Assert.NotNull(definition);
        Assert.Equal(TemperatureValue, definition.Temperature);
    }

    /// <summary>
    /// Verify the invocation and response of <see cref="AssistantClient.CreateAssistantAsync(string, AssistantCreationOptions, System.Threading.CancellationToken)"/>
    /// for an agent with topP defined.
    /// </summary>
    [Fact]
    public async Task VerifyCreateAssistantWithTopPAsync()
    {
        // Arrange
        const float TopPValue = 2.0F;
        this.SetupResponse(HttpStatusCode.OK, OpenAIAssistantResponseContent.AssistantDefinition("testmodel", topP: TopPValue));

        // Act
        Assistant definition = await this._client.GetAssistantClient().CreateAssistantAsync(
            modelId: "testmodel",
            topP: TopPValue);

        // Assert
        Assert.NotNull(definition);
        Assert.Equal(TopPValue, definition.NucleusSamplingFactor);
    }

    /// <summary>
    /// Verify the invocation and response of <see cref="AssistantClient.CreateAssistantAsync(string, AssistantCreationOptions, System.Threading.CancellationToken)"/>
    /// for an agent with execution settings and meta-data.
    /// </summary>
    [Fact]
    public async Task VerifyCreateAssistantWithMetadataAsync()
    {
        // Arrange
        Dictionary<string, string> metadata =
            new()
            {
                { "a", "1" },
                { "b", "2" },
            };
        this.SetupResponse(HttpStatusCode.OK, OpenAIAssistantResponseContent.AssistantDefinition("testmodel", metadata: metadata));

        // Act
        Assistant definition = await this._client.GetAssistantClient().CreateAssistantAsync(
            modelId: "testmodel",
            metadata: metadata);

        // Assert
        Assert.NotNull(definition);
        Assert.NotEmpty(definition.Metadata);
    }

    /// <summary>
    /// Verify the deletion of assistant.
    /// </summary>
    [Fact]
    public async Task VerifyDeleteAssistantAsync()
    {
        // Arrange
        this.SetupResponse(HttpStatusCode.OK, OpenAIAssistantResponseContent.DeleteAgent);

        // Act
        AssistantDeletionResult result = await this._client.GetAssistantClient().DeleteAssistantAsync("testid");

        // Assert
        Assert.True(result.Deleted);
    }

    /// <summary>
    /// Verify the creating a thread.
    /// </summary>
    [Fact]
    public async Task VerifyCreateThreadAsync()
    {
        // Arrange
        this.SetupResponse(HttpStatusCode.OK, OpenAIAssistantResponseContent.CreateThread);

        // Act
        string threadId = await this._client.GetAssistantClient().CreateThreadAsync(messages: null);

        // Assert
        Assert.NotNull(threadId);
    }

    /// <summary>
    /// Verify the creating a thread with messages.
    /// </summary>
    [Fact]
    public async Task VerifyCreateThreadWithMessagesAsync()
    {
        // Arrange
        this.SetupResponse(HttpStatusCode.OK, OpenAIAssistantResponseContent.CreateThread);

        // Act
        string threadId = await this._client.GetAssistantClient().CreateThreadAsync(messages: [new ChatMessageContent(AuthorRole.User, "test")]);

        // Assert
        Assert.NotNull(threadId);
    }

    /// <summary>
    /// Verify the creating a thread with metadata.
    /// </summary>
    [Fact]
    public async Task VerifyCreateThreadWithMetadataAsync()
    {
        // Arrange
        this.SetupResponse(HttpStatusCode.OK, OpenAIAssistantResponseContent.CreateThread);
        Dictionary<string, string> metadata = new() { { "a", "1" }, { "b", "2" } };

        // Act
        string threadId = await this._client.GetAssistantClient().CreateThreadAsync(metadata: metadata);

        // Assert
        Assert.NotNull(threadId);
    }

    /// <inheritdoc/>
    public void Dispose()
    {
        this._messageHandlerStub.Dispose();
        this._httpClient.Dispose();
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="OpenAIAssistantAgentTests"/> class.
    /// </summary>
    public AssistantClientExtensionsTests()
    {
        this._messageHandlerStub = new HttpMessageHandlerStub();
        this._httpClient = new HttpClient(this._messageHandlerStub, disposeHandler: false);
        this._client = OpenAIAssistantAgent.CreateOpenAIClient(apiKey: new ApiKeyCredential("fakekey"), endpoint: null, this._httpClient);
    }

    private void SetupResponse(HttpStatusCode statusCode, string content) =>
        this._messageHandlerStub.SetupResponses(statusCode, content);
}


===== UnitTests\OpenAI\Extensions\AuthorRoleExtensionsTests.cs =====

// Copyright (c) Microsoft. All rights reserved.
using Microsoft.SemanticKernel.Agents.OpenAI;
using Microsoft.SemanticKernel.ChatCompletion;
using OpenAI.Assistants;
using Xunit;
using KernelExtensions = Microsoft.SemanticKernel.Agents.OpenAI;

namespace SemanticKernel.Agents.UnitTests.OpenAI.Extensions;

/// <summary>
/// Unit testing of <see cref="KernelExtensions"/>.
/// </summary>
public class AuthorRoleExtensionsTests
{
    /// <summary>
    /// Verify function lookup using KernelExtensions.
    /// </summary>
    [Fact]
    public void VerifyToMessageRole()
    {
        this.VerifyRoleConversion(AuthorRole.Assistant, MessageRole.Assistant);
        this.VerifyRoleConversion(AuthorRole.User, MessageRole.User);

        // Conversion isn't designed to, and won't, encounter these roles; however,
        // this is defined the behavior:
        this.VerifyRoleConversion(AuthorRole.System, MessageRole.Assistant);
        this.VerifyRoleConversion(AuthorRole.Tool, MessageRole.Assistant);
    }

    private void VerifyRoleConversion(AuthorRole inputRole, MessageRole expectedRole)
    {
        // Arrange
        MessageRole convertedRole = inputRole.ToMessageRole();

        // Assert
        Assert.Equal(expectedRole, convertedRole);
    }
}


===== UnitTests\OpenAI\Extensions\ChatContentMessageExtensionsTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Linq;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents.OpenAI;
using Microsoft.SemanticKernel.ChatCompletion;
using OpenAI.Responses;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.OpenAI.Extensions;

/// <summary>
/// Unit tests for ChatContentMessageExtensions
/// </summary>
public class ChatContentMessageExtensionsTests
{
    [Theory]
    [InlineData("User")]
    [InlineData("Assistant")]
    [InlineData("System")]
    public void VerifyToResponseItemWithUserChatMessageContent(string roleLabel)
    {
        // Arrange
        var role = new AuthorRole(roleLabel);
        var content = new ChatMessageContent(
                role,
                items: [
                    new TextContent("What is in this image?"),
                    new ImageContent(new Uri("https://upload.wikimedia.org/wikipedia/commons/thumb/d/dd/Gfp-wisconsin-madison-the-nature-boardwalk.jpg/2560px-Gfp-wisconsin-madison-the-nature-boardwalk.jpg")),
                    new BinaryContent(new ReadOnlyMemory<byte>([0x52, 0x49, 0x46, 0x46, 0x24, 0x08, 0x00, 0x00, 0x57, 0x41, 0x56, 0x45]), "audio/wav"),
                    new FileReferenceContent("file-abc123")
                ]
            );

        // Act
        var responseItem = content.ToResponseItem();

        // Assert
        Assert.NotNull(responseItem);
        Assert.IsType<MessageResponseItem>(responseItem, exactMatch: false);
        var messageResponseItem = responseItem as MessageResponseItem;
        Assert.NotNull(messageResponseItem);
        Assert.Equal(role.Label.ToUpperInvariant(), messageResponseItem.Role.ToString().ToUpperInvariant());
        Assert.Equal(4, messageResponseItem.Content.Count);

        // Validate TextContent conversion - should create InputText part
        var textContent = messageResponseItem.Content.FirstOrDefault(p => p.Kind == ResponseContentPartKind.InputText);
        Assert.NotNull(textContent);
        //Assert.IsType<>(textContent);
        Assert.Equal("What is in this image?", textContent.Text);

        // Validate ImageContent conversion - should create InputImage part
        var imageContent = messageResponseItem.Content.FirstOrDefault(p => p.Kind == ResponseContentPartKind.InputImage);
        Assert.NotNull(imageContent);

        // Validate BinaryContent conversion - should create InputFile part
        var binaryContent = messageResponseItem.Content.FirstOrDefault(p => p.Kind == ResponseContentPartKind.InputFile && p.InputFileBytes is not null);
        Assert.NotNull(binaryContent);
        Assert.Equal("audio/wav", binaryContent.InputFileBytesMediaType);

        // Validate FileReferenceContent conversion - should create InputImage part
        var fileContent = messageResponseItem.Content.FirstOrDefault(p => p.Kind == ResponseContentPartKind.InputFile && p.InputFileId is not null);
        Assert.NotNull(fileContent);
        Assert.Equal("file-abc123", fileContent.InputFileId);
    }
}


===== UnitTests\OpenAI\Extensions\KernelExtensionsTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using Microsoft.SemanticKernel.Agents;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.OpenAI.Extensions;

/// <summary>
/// Tests for KernelExtensions.
/// </summary>
public class KernelExtensionsTests
{
    /// <summary>
    /// Verify GetOpenAIClientProvider for AzureOpenAI
    /// </summary>
    [Fact]
    public void VerifyGetOpenAIClientProviderForAzureOpenAIWithApiKey()
    {
        // Arrange
        AgentDefinition agentDefinition = new()
        {
            Model = new()
            {
                Id = "gpt-4o-mini",
                Connection = new()
                {
                    ExtensionData = new Dictionary<string, object?>()
                    {
                        ["endpoint"] = "https://contosoo.openai.azure.com",
                        ["api_key"] = "api_key",
                    }
                }
            }
        };

        // Act

        // Assert
    }
}


===== UnitTests\OpenAI\Extensions\KernelFunctionExtensionsTests.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.ComponentModel;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents.OpenAI;
using OpenAI.Assistants;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.OpenAI.Extensions;

/// <summary>
/// Unit testing of <see cref="Microsoft.SemanticKernel.Agents.OpenAI.KernelFunctionExtensions"/>.
/// </summary>
public class KernelFunctionExtensionsTests
{
    /// <summary>
    /// Verify conversion from <see cref="KernelFunction"/> to <see cref="FunctionToolDefinition"/>.
    /// </summary>
    [Fact]
    public void VerifyKernelFunctionToFunctionTool()
    {
        // Arrange
        KernelPlugin plugin = KernelPluginFactory.CreateFromType<TestPlugin>();

        // Assert
        Assert.Equal(2, plugin.FunctionCount);

        // Arrange
        KernelFunction f1 = plugin[nameof(TestPlugin.TestFunction1)];
        KernelFunction f2 = plugin[nameof(TestPlugin.TestFunction2)];

        // Act
        FunctionToolDefinition definition1 = f1.ToToolDefinition("testplugin");

        // Assert
        Assert.StartsWith($"testplugin-{nameof(TestPlugin.TestFunction1)}", definition1.FunctionName, StringComparison.Ordinal);
        Assert.Equal("test description", definition1.Description);

        // Act
        FunctionToolDefinition definition2 = f2.ToToolDefinition("testplugin");

        // Assert
        Assert.StartsWith($"testplugin-{nameof(TestPlugin.TestFunction2)}", definition2.FunctionName, StringComparison.Ordinal);
        Assert.Equal("test description", definition2.Description);
    }

    /// <summary>
    /// Exists only for parsing.
    /// </summary>
#pragma warning disable CA1812 // Avoid uninstantiated internal classes
    private sealed class TestPlugin()
#pragma warning restore CA1812 // Avoid uninstantiated internal classes
    {
        [KernelFunction]
        [Description("test description")]
        public void TestFunction1() { }

        [KernelFunction]
        [Description("test description")]
#pragma warning disable IDE0060 // Unused parameter for mock kernel function
        public void TestFunction2(string p1, bool p2, int p3, string[] p4, ConsoleColor p5, OpenAIAssistantDefinition p6, DateTime p7) { }
#pragma warning restore IDE0060 // Unused parameter
    }
}


===== UnitTests\OpenAI\Extensions\OpenAIClientExtensionsTests.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.ClientModel;
using System.Collections.Generic;
using System.IO;
using System.Net;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;
using Microsoft.SemanticKernel.Agents.OpenAI;
using OpenAI;
using OpenAI.VectorStores;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.OpenAI.Extensions;

/// <summary>
/// Unit testing of <see cref="OpenAIAssistantAgent"/>.
/// </summary>
public sealed class OpenAIClientExtensionsTests : IDisposable
{
    private readonly HttpMessageHandlerStub _messageHandlerStub;
    private readonly HttpClient _httpClient;
    private readonly OpenAIClient _client;

    /// <summary>
    /// Verify the default creation of vector-store.
    /// </summary>
    [Fact]
    public async Task VerifyCreateDefaultVectorStoreAsync()
    {
        // Arrange
        string[] fileIds = ["file-1", "file-2"];
        this.SetupResponse(HttpStatusCode.OK, OpenAIAssistantResponseContent.CreateVectorStore);

        // Act
        string storeId = await this._client.CreateVectorStoreAsync(fileIds);

        // Assert
        Assert.NotNull(storeId);
    }

    /// <summary>
    /// Verify the custom creation of vector-store.
    /// </summary>
    [Fact]
    public async Task VerifyCreateVectorStoreAsync()
    {
        // Arrange
        string[] fileIds = ["file-1", "file-2"];
        Dictionary<string, string> metadata =
            new()
            {
                { "a", "1" },
                { "b", "2" },
            };
        this.SetupResponse(HttpStatusCode.OK, OpenAIAssistantResponseContent.CreateVectorStore);

        // Act
        string storeId = await this._client.CreateVectorStoreAsync(
            fileIds,
            storeName: "test-store",
            expirationPolicy: new VectorStoreExpirationPolicy(VectorStoreExpirationAnchor.LastActiveAt, 30),
            chunkingStrategy: FileChunkingStrategy.Auto,
            metadata: metadata);

        // Assert
        Assert.NotNull(storeId);
    }

    /// <summary>
    /// Verify the uploading an assistant file.
    /// </summary>
    [Fact]
    public async Task VerifyUploadFileAsync()
    {
        // Arrange
        this.SetupResponse(HttpStatusCode.OK, OpenAIAssistantResponseContent.UploadFile);

        // Act
        await using MemoryStream stream = new(Encoding.UTF8.GetBytes("test"));
        string fileId = await this._client.UploadAssistantFileAsync(stream, "text.txt");

        // Assert
        Assert.NotNull(fileId);
    }

    /// <summary>
    /// Verify the deleting a file.
    /// </summary>
    [Fact]
    public async Task VerifyDeleteFileAsync()
    {
        // Arrange
        this.SetupResponse(HttpStatusCode.OK, OpenAIAssistantResponseContent.DeleteFile);

        // Act
        bool isDeleted = await this._client.DeleteFileAsync("file-id");

        // Assert
        Assert.True(isDeleted);
    }

    /// <summary>
    /// Verify the deleting a vector-store.
    /// </summary>
    [Fact]
    public async Task VerifyDeleteVectorStoreAsync()
    {
        // Arrange
        this.SetupResponse(HttpStatusCode.OK, OpenAIAssistantResponseContent.DeleteVectorStore);

        // Act
        bool isDeleted = await this._client.DeleteVectorStoreAsync("store-id");

        // Assert
        Assert.True(isDeleted);
    }

    /// <inheritdoc/>
    public void Dispose()
    {
        this._messageHandlerStub.Dispose();
        this._httpClient.Dispose();
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="OpenAIAssistantAgentTests"/> class.
    /// </summary>
    public OpenAIClientExtensionsTests()
    {
        this._messageHandlerStub = new HttpMessageHandlerStub();
        this._httpClient = new HttpClient(this._messageHandlerStub, disposeHandler: false);
        this._client = OpenAIAssistantAgent.CreateOpenAIClient(apiKey: new ApiKeyCredential("fakekey"), endpoint: null, this._httpClient);
    }

    private void SetupResponse(HttpStatusCode statusCode, string content) =>
        this._messageHandlerStub.SetupResponses(statusCode, content);
}


===== UnitTests\OpenAI\Extensions\OpenAIResponseExtensionsTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents.OpenAI;
using Microsoft.SemanticKernel.ChatCompletion;
using OpenAI.Responses;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.OpenAI.Extensions;

/// <summary>
/// Unit testing of <see cref="Microsoft.SemanticKernel.Agents.OpenAI.OpenAIResponseExtensions"/>.
/// </summary>
public class OpenAIResponseExtensionsTests
{
    /// <summary>
    /// Verify conversion from <see cref="OpenAIResponse"/> to <see cref="ChatMessageContent"/>.
    /// </summary>
    [Fact]
    public void VerifyToChatMessageContentWithOpenAIResponse()
    {
        // Arrange
        OpenAIResponse mockResponse = this.CreateMockOpenAIResponse("gpt-4o-mini",
            [
                ResponseItem.CreateUserMessageItem("This is a user message."),
            ]);

        // Act
        ChatMessageContent chatMessageContent = mockResponse.ToChatMessageContent();

        // Assert
        Assert.NotNull(chatMessageContent);
        Assert.Equal(AuthorRole.User, chatMessageContent.Role);
        Assert.Equal("gpt-4o-mini", chatMessageContent.ModelId);
        Assert.Single(chatMessageContent.Items);
        Assert.Equal("This is a user message.", chatMessageContent.Items[0].ToString());
    }

    /// <summary>
    /// Verify conversion from <see cref="ResponseItem"/> to <see cref="ChatMessageContent"/>.
    /// </summary>
    [Fact]
    public void VerifyToChatMessageContentWithResponseItem()
    {
        // Arrange
        ResponseItem userMessage = ResponseItem.CreateUserMessageItem("This is a user message.");
        ResponseItem functionCall = ResponseItem.CreateFunctionCallItem("callId", "functionName", new BinaryData("{}"));

        // Act
        ChatMessageContent? userMessageContent = userMessage.ToChatMessageContent();
        ChatMessageContent? functionCallContent = functionCall.ToChatMessageContent();

        // Assert
        Assert.NotNull(userMessageContent);
        Assert.Equal(AuthorRole.User, userMessageContent.Role);
        Assert.Single(userMessageContent.Items);
        Assert.Equal("This is a user message.", userMessageContent.Items[0].ToString());
        Assert.NotNull(functionCallContent);
        Assert.Equal(AuthorRole.Assistant, functionCallContent.Role);
        Assert.Single(functionCallContent.Items);
        Assert.IsType<FunctionCallContent>(functionCallContent.Items[0]);
    }

    /// <summary>
    /// Verify conversion from <see cref="MessageResponseItem"/> to <see cref="ChatMessageContent"/>.
    /// </summary>
    [Fact]
    public void VerifyToChatMessageContentItemCollectionWithMessageResponseItem()
    {
        // Arrange
        ResponseItem responseItem = ResponseItem.CreateUserMessageItem("This is a user message.");

        // Act
        ChatMessageContentItemCollection collection = responseItem.ToChatMessageContentItemCollection();

        // Assert
        Assert.NotNull(collection);
        Assert.Single(collection);
        Assert.NotNull(collection[0]);
        Assert.IsType<TextContent>(collection[0]);
        Assert.Equal("This is a user message.", collection[0].ToString());
    }

    /// <summary>
    /// Verify conversion from <see cref="FunctionCallResponseItem"/> to <see cref="ChatMessageContent"/>.
    /// </summary>
    [Fact]
    public void VerifyToChatMessageContentItemCollectionWithFunctionCallResponseItem()
    {
        // Arrange
        FunctionCallResponseItem responseItem = FunctionCallResponseItem.CreateFunctionCallItem("callId", "functionName", new BinaryData("{}"));

        // Act
        ChatMessageContentItemCollection collection = responseItem.ToChatMessageContentItemCollection();

        // Assert
        Assert.NotNull(collection);
        Assert.Single(collection);
        Assert.NotNull(collection[0]);
        Assert.IsType<FunctionCallContent>(collection[0]);
    }

    /// <summary>
    /// Verify conversion from <see cref="FunctionCallResponseItem"/> to <see cref="StreamingFunctionCallUpdateContent"/>.
    /// </summary>
    [Fact]
    public void VerifyToStreamingFunctionCallUpdateContent()
    {
        // Arrange
        FunctionCallResponseItem responseItem = FunctionCallResponseItem.CreateFunctionCallItem("callId", "functionName", new BinaryData("{}"));

        // Act
        StreamingFunctionCallUpdateContent content = responseItem.ToStreamingFunctionCallUpdateContent("{}");

        // Assert
        Assert.NotNull(content);
        Assert.Equal("functionName", content.Name);
        Assert.Equal("callId", content.CallId);
        Assert.NotNull(content.Arguments);
    }

    /// <summary>
    /// Verify conversion from <see cref="MessageRole"/> to <see cref="AuthorRole"/>.
    /// </summary>
    [Fact]
    public void VerifyToAuthorRole()
    {
        // Act & Assert
        Assert.Equal(AuthorRole.Assistant, MessageRole.Assistant.ToAuthorRole());
        Assert.Equal(AuthorRole.User, MessageRole.User.ToAuthorRole());
        Assert.Equal(AuthorRole.Developer, MessageRole.Developer.ToAuthorRole());
        Assert.Equal(AuthorRole.System, MessageRole.System.ToAuthorRole());
    }

    /// <summary>
    /// Verify conversion from <see cref="FunctionCallResponseItem"/> to <see cref="FunctionCallContent"/>.
    /// </summary>
    [Fact]
    public void VerifyToFunctionCallContent()
    {
        // Arrange
        FunctionCallResponseItem responseItem = FunctionCallResponseItem.CreateFunctionCallItem("callId", "functionName", new BinaryData("{}"));

        // Act
        FunctionCallContent content = responseItem.ToFunctionCallContent();

        // Assert
        Assert.NotNull(content);
        Assert.Equal("functionName", content.FunctionName);
        Assert.Equal("callId", content.Id);
        Assert.NotNull(content.Arguments);
    }

    /// <summary>
    /// Verify that ReasoningResponseItem with SummaryParts generates ReasoningContent correctly.
    /// </summary>
    [Fact]
    public void VerifyToChatMessageContentWithReasoningResponseItem()
    {
        // Arrange
        var reasoningResponseItem = this.CreateReasoningResponseItem("Let me think about this step by step...");

        // Act
        ChatMessageContent? chatMessageContent = reasoningResponseItem.ToChatMessageContent();

        // Assert
        Assert.NotNull(chatMessageContent);
        Assert.Equal(AuthorRole.Assistant, chatMessageContent.Role);
        Assert.Single(chatMessageContent.Items);

        var reasoningContent = chatMessageContent.Items[0] as ReasoningContent;
        Assert.NotNull(reasoningContent);
        Assert.Equal("Let me think about this step by step...", reasoningContent.Text);
    }

    /// <summary>
    /// Verify that ReasoningResponseItem converts to correct ChatMessageContentItemCollection with ReasoningContent.
    /// </summary>
    [Fact]
    public void VerifyToChatMessageContentItemCollectionWithReasoningResponseItem()
    {
        // Arrange
        var reasoningResponseItem = this.CreateReasoningResponseItem("Analyzing the problem...");

        // Act
        ChatMessageContentItemCollection collection = reasoningResponseItem.ToChatMessageContentItemCollection();

        // Assert
        Assert.NotNull(collection);
        Assert.Single(collection);
        Assert.IsType<ReasoningContent>(collection[0]);

        var reasoningContent = collection[0] as ReasoningContent;
        Assert.Equal("Analyzing the problem...", reasoningContent?.Text);
    }

    /// <summary>
    /// Verify that OpenAIResponse with both ReasoningResponseItem and MessageResponseItem generates correct content types.
    /// </summary>
    [Fact]
    public void VerifyToChatMessageContentWithMixedResponseItems()
    {
        // Arrange
        var reasoningResponseItem = this.CreateReasoningResponseItem("Thinking about the answer...");
        var messageResponseItem = ResponseItem.CreateAssistantMessageItem("Here is my response.");

        OpenAIResponse mockResponse = this.CreateMockOpenAIResponse("gpt-4o-mini",
            [
                reasoningResponseItem,
                messageResponseItem
            ]);

        // Act
        ChatMessageContent chatMessageContent = mockResponse.ToChatMessageContent();

        // Assert
        Assert.NotNull(chatMessageContent);
        Assert.Equal(2, chatMessageContent.Items.Count);

        // First item should be ReasoningContent
        Assert.IsType<ReasoningContent>(chatMessageContent.Items[0]);
        var reasoningContent = chatMessageContent.Items[0] as ReasoningContent;
        Assert.Equal("Thinking about the answer...", reasoningContent?.Text);

        // Second item should be TextContent
        Assert.IsType<TextContent>(chatMessageContent.Items[1]);
        var textContent = chatMessageContent.Items[1] as TextContent;
        Assert.Equal("Here is my response.", textContent?.Text);
    }

    #region private
    private OpenAIResponse CreateMockOpenAIResponse(string model, IEnumerable<ResponseItem> outputItems) =>
        OpenAIResponsesModelFactory.OpenAIResponse(
            model: model,
            outputItems: outputItems);

    private OpenAIResponse CreateMockOpenAIResponse(string id, DateTimeOffset createdAt, ResponseError error, string instructions, string model, string previousResponseId, float temperature, IEnumerable<ResponseTool> tools, float topP, IDictionary<string, string> metadata, ResponseIncompleteStatusDetails incompleteStatusDetails, IEnumerable<ResponseItem> outputItems, bool parallelToolCallsEnabled, ResponseToolChoice toolChoice) =>
        OpenAIResponsesModelFactory.OpenAIResponse(
            id: id,
            createdAt: createdAt,
            error: error,
            instructions: instructions,
            model: model,
            previousResponseId: previousResponseId,
            temperature: temperature,
            tools: tools,
            topP: topP,
            metadata: metadata,
            incompleteStatusDetails: incompleteStatusDetails,
            outputItems: outputItems,
            parallelToolCallsEnabled: parallelToolCallsEnabled,
            toolChoice: toolChoice);

    private ReasoningResponseItem CreateReasoningResponseItem(string? reasoningText = null) =>
        OpenAIResponsesModelFactory.ReasoningResponseItem(summaryText: reasoningText);

    #endregion
}


===== UnitTests\OpenAI\Internal\AssistantMessageFactoryTests.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents.OpenAI.Internal;
using Microsoft.SemanticKernel.ChatCompletion;
using OpenAI.Assistants;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.OpenAI.Internal;

/// <summary>
/// Unit testing of <see cref="AssistantMessageFactory"/>.
/// </summary>
public class AssistantMessageFactoryTests
{
    /// <summary>
    /// Verify options creation.
    /// </summary>
    [Fact]
    public void VerifyAssistantMessageAdapterCreateOptionsDefault()
    {
        // Arrange (Setup message with null metadata)
        ChatMessageContent message = new(AuthorRole.User, "test");

        // Act: Create options
        MessageCreationOptions options = AssistantMessageFactory.CreateOptions(message);

        // Assert
        Assert.NotNull(options);
        Assert.Empty(options.Metadata);
    }

    /// <summary>
    /// Verify options creation.
    /// </summary>
    [Fact]
    public void VerifyAssistantMessageAdapterCreateOptionsWithMetadataEmpty()
    {
        // Arrange Setup message with empty metadata
        ChatMessageContent message =
            new(AuthorRole.User, "test")
            {
                Metadata = new Dictionary<string, object?>()
            };

        // Act: Create options
        MessageCreationOptions options = AssistantMessageFactory.CreateOptions(message);

        // Assert
        Assert.NotNull(options);
        Assert.Empty(options.Metadata);
    }

    /// <summary>
    /// Verify options creation.
    /// </summary>
    [Fact]
    public void VerifyAssistantMessageAdapterCreateOptionsWithMetadata()
    {
        // Arrange: Setup message with metadata
        ChatMessageContent message =
            new(AuthorRole.User, "test")
            {
                Metadata =
                    new Dictionary<string, object?>()
                    {
                        { "a", 1 },
                        { "b", "2" },
                    }
            };

        // Act: Create options
        MessageCreationOptions options = AssistantMessageFactory.CreateOptions(message);

        // Assert
        Assert.NotNull(options);
        Assert.NotEmpty(options.Metadata);
        Assert.Equal(2, options.Metadata.Count);
        Assert.Equal("1", options.Metadata["a"]);
        Assert.Equal("2", options.Metadata["b"]);
    }

    /// <summary>
    /// Verify options creation.
    /// </summary>
    [Fact]
    public void VerifyAssistantMessageAdapterCreateOptionsWithMetadataNull()
    {
        // Arrange: Setup message with null metadata value
        ChatMessageContent message =
            new(AuthorRole.User, "test")
            {
                Metadata =
                    new Dictionary<string, object?>()
                    {
                        { "a", null },
                        { "b", "2" },
                    }
            };

        // Act: Create options
        MessageCreationOptions options = AssistantMessageFactory.CreateOptions(message);

        // Assert
        Assert.NotNull(options);
        Assert.NotEmpty(options.Metadata);
        Assert.Equal(2, options.Metadata.Count);
        Assert.Equal(string.Empty, options.Metadata["a"]);
        Assert.Equal("2", options.Metadata["b"]);
    }

    /// <summary>
    /// Verify options creation.
    /// </summary>
    [Fact]
    public void VerifyAssistantMessageAdapterGetMessageContentsWithText()
    {
        // Arrange
        ChatMessageContent message = new(AuthorRole.User, items: [new TextContent("test")]);

        // Act
        MessageContent[] contents = AssistantMessageFactory.GetMessageContents(message).ToArray();

        // Assert
        Assert.NotNull(contents);
        Assert.Single(contents);
        Assert.NotNull(contents.Single().Text);
    }

    /// <summary>
    /// Verify options creation.
    /// </summary>
    [Fact]
    public void VerifyAssistantMessageAdapterGetMessageWithImageUrl()
    {
        // Arrange
        ChatMessageContent message = new(AuthorRole.User, items: [new ImageContent(new Uri("https://localhost/myimage.png"))]);

        // Act
        MessageContent[] contents = AssistantMessageFactory.GetMessageContents(message).ToArray();

        // Assert
        Assert.NotNull(contents);
        Assert.Single(contents);
        Assert.NotNull(contents.Single().ImageUri);
    }

    /// <summary>
    /// Verify options creation.
    /// </summary>
    [Fact]
    public void VerifyAssistantMessageAdapterGetMessageWithImageData()
    {
        // Arrange
        ChatMessageContent message = new(AuthorRole.User, items: [new ImageContent(new byte[] { 1, 2, 3 }, "image/png") { DataUri = "data:image/png;base64,MTIz" }]);

        // Act
        MessageContent[] contents = AssistantMessageFactory.GetMessageContents(message).ToArray();

        // Assert
        Assert.NotNull(contents);
        Assert.Single(contents);
        Assert.NotNull(contents.Single().ImageUri);
    }

    /// <summary>
    /// Verify options creation.
    /// </summary>
    [Fact]
    public void VerifyAssistantMessageAdapterGetMessageWithImageFile()
    {
        // Arrange
        ChatMessageContent message = new(AuthorRole.User, items: [new FileReferenceContent("file-id")]);

        // Act
        MessageContent[] contents = AssistantMessageFactory.GetMessageContents(message).ToArray();

        // Assert
        Assert.NotNull(contents);
        Assert.Single(contents);
        Assert.NotNull(contents.Single().ImageFileId);
    }

    /// <summary>
    /// Verify options creation.
    /// </summary>
    [Fact]
    public void VerifyAssistantMessageAdapterGetMessageWithAll()
    {
        // Arrange
        ChatMessageContent message =
            new(
                AuthorRole.User,
                items:
                [
                    new TextContent("test"),
                    new ImageContent(new Uri("https://localhost/myimage.png")),
                    new FileReferenceContent("file-id")
                ]);

        // Act
        MessageContent[] contents = AssistantMessageFactory.GetMessageContents(message).ToArray();

        // Assert
        Assert.NotNull(contents);
        Assert.Equal(3, contents.Length);
    }
}


===== UnitTests\OpenAI\Internal\AssistantRunOptionsFactoryTests.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents.OpenAI;
using Microsoft.SemanticKernel.Agents.OpenAI.Internal;
using Microsoft.SemanticKernel.ChatCompletion;
using OpenAI.Assistants;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.OpenAI.Internal;

/// <summary>
/// Unit testing of <see cref="AssistantRunOptionsFactory"/>.
/// </summary>
public class AssistantRunOptionsFactoryTests
{
    /// <summary>
    /// Verify run options generation with null <see cref="OpenAIAssistantInvocationOptions"/>.
    /// </summary>
    [Fact]
    public void AssistantRunOptionsFactoryExecutionOptionsNullTest()
    {
        // Arrange
        RunCreationOptions defaultOptions =
            new()
            {
                ModelOverride = "gpt-anything",
                Temperature = 0.5F,
                AdditionalInstructions = "test",
            };

        // Act
        RunCreationOptions options = AssistantRunOptionsFactory.GenerateOptions(defaultOptions, null, null, threadExtensionsContext: null);

        // Assert
        Assert.NotNull(options);
        Assert.Empty(options.AdditionalMessages);
        Assert.Null(options.InstructionsOverride);
        Assert.Null(options.NucleusSamplingFactor);
        Assert.Equal("test", options.AdditionalInstructions);
        Assert.Equal(0.5F, options.Temperature);
        Assert.Empty(options.Metadata);
    }

    /// <summary>
    /// Verify run options generation with equivalent <see cref="OpenAIAssistantInvocationOptions"/>.
    /// </summary>
    [Fact]
    public void AssistantRunOptionsFactoryExecutionOptionsEquivalentTest()
    {
        // Arrange
        RunCreationOptions defaultOptions =
            new()
            {
                ModelOverride = "gpt-anything",
                Temperature = 0.5F,
            };

        RunCreationOptions invocationOptions =
            new()
            {
                Temperature = 0.5F,
            };

        // Act
        RunCreationOptions options = AssistantRunOptionsFactory.GenerateOptions(defaultOptions, "test", invocationOptions, threadExtensionsContext: null);

        // Assert
        Assert.NotNull(options);
        Assert.Null(options.NucleusSamplingFactor);
        Assert.Equal("test", options.InstructionsOverride);
        Assert.Equal(0.5F, options.Temperature);
    }

    /// <summary>
    /// Verify run options generation with <see cref="OpenAIAssistantInvocationOptions"/> override.
    /// </summary>
    [Fact]
    public void AssistantRunOptionsFactoryExecutionOptionsOverrideTest()
    {
        // Arrange
        RunCreationOptions defaultOptions =
            new()
            {
                ModelOverride = "gpt-anything",
                Temperature = 0.5F,
                TruncationStrategy = RunTruncationStrategy.CreateLastMessagesStrategy(5),
            };

        RunCreationOptions invocationOptions =
            new()
            {
                ModelOverride = "gpt-anything",
                AdditionalInstructions = "test2",
                Temperature = 0.9F,
                TruncationStrategy = RunTruncationStrategy.CreateLastMessagesStrategy(8),
                ResponseFormat = AssistantResponseFormat.JsonObject,
            };

        // Act
        RunCreationOptions options = AssistantRunOptionsFactory.GenerateOptions(defaultOptions, null, invocationOptions, threadExtensionsContext: null);

        // Assert
        Assert.NotNull(options);
        Assert.Equal(0.9F, options.Temperature);
        Assert.Equal(8, options.TruncationStrategy.LastMessages);
        Assert.Equal("test2", options.AdditionalInstructions);
        Assert.Equal(AssistantResponseFormat.JsonObject, options.ResponseFormat);
        Assert.Null(options.NucleusSamplingFactor);
    }

    /// <summary>
    /// Verify run options generation with <see cref="OpenAIAssistantInvocationOptions"/> metadata.
    /// </summary>
    [Fact]
    public void AssistantRunOptionsFactoryExecutionOptionsMetadataTest()
    {
        // Arrange
        RunCreationOptions defaultOptions =
            new()
            {
                ModelOverride = "gpt-anything",
                Temperature = 0.5F,
                TruncationStrategy = RunTruncationStrategy.CreateLastMessagesStrategy(5),
            };

        RunCreationOptions invocationOptions =
            new()
            {
                Metadata =
                {
                    { "key1", "value" },
                    { "key2", null! },
                },
            };

        // Act
        RunCreationOptions options = AssistantRunOptionsFactory.GenerateOptions(defaultOptions, null, invocationOptions, threadExtensionsContext: null);

        // Assert
        Assert.Equal(2, options.Metadata.Count);
        Assert.Equal("value", options.Metadata["key1"]);
        Assert.Equal(string.Empty, options.Metadata["key2"]);
    }

    /// <summary>
    /// Verify run options generation with <see cref="OpenAIAssistantInvocationOptions"/> metadata.
    /// </summary>
    [Fact]
    public void AssistantRunOptionsFactoryExecutionOptionsMessagesTest()
    {
        // Arrange
        RunCreationOptions defaultOptions =
            new()
            {
                ModelOverride = "gpt-anything",
            };

        ChatMessageContent message = new(AuthorRole.User, "test message");
        RunCreationOptions invocationOptions =
            new()
            {
                AdditionalMessages = { message.ToThreadInitializationMessage() },
            };

        // Act
        RunCreationOptions options = AssistantRunOptionsFactory.GenerateOptions(defaultOptions, null, invocationOptions, threadExtensionsContext: null);

        // Assert
        Assert.Single(options.AdditionalMessages);
    }

    /// <summary>
    /// Verify run options generation with <see cref="OpenAIAssistantInvocationOptions"/> metadata.
    /// </summary>
    [Fact]
    public void AssistantRunOptionsFactoryExecutionOptionsMaxTokensTest()
    {
        // Arrange
        RunCreationOptions defaultOptions =
            new()
            {
                ModelOverride = "gpt-anything",
                Temperature = 0.5F,
                MaxOutputTokenCount = 4096,
                MaxInputTokenCount = 1024,
            };

        // Act
        RunCreationOptions options = AssistantRunOptionsFactory.GenerateOptions(defaultOptions, null, null, threadExtensionsContext: null);

        // Assert
        Assert.Equal(1024, options.MaxInputTokenCount);
        Assert.Equal(4096, options.MaxOutputTokenCount);
    }

    /// <summary>
    /// Verify run options generation with <see cref="OpenAIAssistantInvocationOptions"/> metadata.
    /// </summary>
    [Fact]
    public void AssistantRunOptionsFactoryAdditionalInstructionsTest()
    {
        // Arrange
        RunCreationOptions defaultOptions =
            new()
            {
                ModelOverride = "gpt-anything",
                Temperature = 0.5F,
                MaxOutputTokenCount = 4096,
                MaxInputTokenCount = 1024,
                AdditionalInstructions = "DefaultInstructions"
            };

        RunCreationOptions invocationOptions =
            new()
            {
                AdditionalInstructions = "OverrideInstructions",
            };

        // Act
        RunCreationOptions optionsWithOverride = AssistantRunOptionsFactory.GenerateOptions(defaultOptions, null, invocationOptions, threadExtensionsContext: "Context");
        RunCreationOptions optionsWithoutOverride = AssistantRunOptionsFactory.GenerateOptions(defaultOptions, null, null, threadExtensionsContext: "Context");

        // Assert
        Assert.Equal($"OverrideInstructions{Environment.NewLine}{Environment.NewLine}Context", optionsWithOverride.AdditionalInstructions);
        Assert.Equal($"DefaultInstructions{Environment.NewLine}{Environment.NewLine}Context", optionsWithoutOverride.AdditionalInstructions);
    }
}


===== UnitTests\OpenAI\Internal\ResponseCreationOptionsFactoryTests.cs =====

// Copyright (c) Microsoft. All rights reserved.
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.Agents.OpenAI;
using Microsoft.SemanticKernel.Agents.OpenAI.Internal;
using Moq;
using OpenAI.Responses;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.OpenAI.Internal;

/// <summary>
/// Unit testing of <see cref="ResponseCreationOptionsFactory"/>.
/// </summary>
public class ResponseCreationOptionsFactoryTests
{
    /// <summary>
    /// Verify response options creation with null invoke options.
    /// </summary>
    [Fact]
    public void CreateOptionsWithNullInvokeOptionsTest()
    {
        // Arrange
        var mockAgent = CreateMockAgent("Test Agent", "You are a helpful assistant.", storeEnabled: false);
        var mockThread = CreateMockAgentThread(null);

        // Act
        var options = ResponseCreationOptionsFactory.CreateOptions(mockAgent, mockThread.Object, null);

        // Assert
        Assert.NotNull(options);
        Assert.Equal("Test Agent", options.EndUserId);
        Assert.Equal("You are a helpful assistant.", options.Instructions);
        Assert.False(options.StoredOutputEnabled);
        Assert.Null(options.ReasoningOptions);
        Assert.Null(options.MaxOutputTokenCount);
        Assert.Null(options.TextOptions);
        Assert.Null(options.TruncationMode);
        Assert.Null(options.ParallelToolCallsEnabled);
        Assert.Null(options.ToolChoice);
        Assert.Empty(options.Tools);
        Assert.Null(options.PreviousResponseId);
    }

    /// <summary>
    /// Verify response options creation with store enabled and thread ID.
    /// </summary>
    [Fact]
    public void CreateOptionsWithStoreEnabledAndThreadIdTest()
    {
        // Arrange
        var mockAgent = CreateMockAgent("Test Agent", "You are a helpful assistant.", storeEnabled: true);
        var mockThread = CreateMockAgentThread("thread-123");

        // Act
        var options = ResponseCreationOptionsFactory.CreateOptions(mockAgent, mockThread.Object, null);

        // Assert
        Assert.NotNull(options);
        Assert.Equal("Test Agent", options.EndUserId);
        Assert.Equal("You are a helpful assistant.", options.Instructions);
        Assert.True(options.StoredOutputEnabled);
        Assert.Equal("thread-123", options.PreviousResponseId);
    }

    /// <summary>
    /// Verify response options creation with additional instructions from invoke options.
    /// </summary>
    [Fact]
    public void CreateOptionsWithAdditionalInstructionsTest()
    {
        // Arrange
        var mockAgent = CreateMockAgent("Test Agent", "You are a helpful assistant.", storeEnabled: false);
        var mockThread = CreateMockAgentThread(null);
        var invokeOptions = new AgentInvokeOptions
        {
            AdditionalInstructions = "Be more concise."
        };

        // Act
        var options = ResponseCreationOptionsFactory.CreateOptions(mockAgent, mockThread.Object, invokeOptions);

        // Assert
        Assert.NotNull(options);
        Assert.Equal("Test Agent", options.EndUserId);
        Assert.Equal("You are a helpful assistant.\nBe more concise.", options.Instructions);
        Assert.False(options.StoredOutputEnabled);
    }

    /// <summary>
    /// Verify response options creation with OpenAIResponseAgentInvokeOptions with full ResponseCreationOptions.
    /// </summary>
    [Fact]
    public void CreateOptionsWithResponseAgentInvokeOptionsTest()
    {
        // Arrange
        var mockAgent = CreateMockAgent("Test Agent", "You are a helpful assistant.", storeEnabled: false);
        var mockThread = CreateMockAgentThread(null);
        var responseCreationOptions = new ResponseCreationOptions
        {
            EndUserId = "custom-user",
            Instructions = "Custom instructions",
            StoredOutputEnabled = true,
            MaxOutputTokenCount = 1000,
            ParallelToolCallsEnabled = true,
            ToolChoice = ResponseToolChoice.CreateAutoChoice(),
            Temperature = 0.7f,
            TopP = 0.9f,
            PreviousResponseId = "previous-response-id",
        };
        responseCreationOptions.Tools.Add(ResponseTool.CreateWebSearchTool());

        var invokeOptions = new OpenAIResponseAgentInvokeOptions
        {
            AdditionalInstructions = "Additional instructions",
            ResponseCreationOptions = responseCreationOptions
        };

        // Act
        var options = ResponseCreationOptionsFactory.CreateOptions(mockAgent, mockThread.Object, invokeOptions);

        // Assert
        Assert.NotNull(options);
        Assert.Equal("custom-user", options.EndUserId);
        Assert.Equal("Custom instructions", options.Instructions);
        Assert.True(options.StoredOutputEnabled);
        Assert.Equal(1000, options.MaxOutputTokenCount);
        Assert.True(options.ParallelToolCallsEnabled);
        Assert.NotNull(options.ToolChoice);
        Assert.Single(options.Tools);
        Assert.Equal(0.7f, options.Temperature);
        Assert.Equal(0.9f, options.TopP);
        Assert.Equal("previous-response-id", options.PreviousResponseId);
    }

    /// <summary>
    /// Verify response options creation with ResponseCreationOptions having null values that fallback to agent defaults.
    /// </summary>
    [Fact]
    public void CreateOptionsWithResponseCreationOptionsNullFallbackTest()
    {
        // Arrange
        var mockAgent = CreateMockAgent("Test Agent", "You are a helpful assistant.", storeEnabled: true);
        var mockThread = CreateMockAgentThread(null);
        var responseCreationOptions = new ResponseCreationOptions
        {
            EndUserId = null, // Should fallback to agent display name
            Instructions = null, // Should fallback to agent instructions + additional
            StoredOutputEnabled = null // Should fallback to agent store enabled
        };

        var invokeOptions = new OpenAIResponseAgentInvokeOptions
        {
            AdditionalInstructions = "Be helpful",
            ResponseCreationOptions = responseCreationOptions
        };

        // Act
        var options = ResponseCreationOptionsFactory.CreateOptions(mockAgent, mockThread.Object, invokeOptions);

        // Assert
        Assert.NotNull(options);
        Assert.Equal("Test Agent", options.EndUserId);
        Assert.Equal("You are a helpful assistant.\nBe helpful", options.Instructions);
        Assert.True(options.StoredOutputEnabled);
    }

    /// <summary>
    /// Verify response options creation when agent has null instructions.
    /// </summary>
    [Fact]
    public void CreateOptionsWithNullAgentInstructionsTest()
    {
        // Arrange
        var mockAgent = CreateMockAgent("Test Agent", null, storeEnabled: false);
        var mockThread = CreateMockAgentThread(null);

        var invokeOptions = new AgentInvokeOptions
        {
            AdditionalInstructions = "Be helpful"
        };

        // Act
        var options = ResponseCreationOptionsFactory.CreateOptions(mockAgent, mockThread.Object, invokeOptions);

        // Assert
        Assert.NotNull(options);
        Assert.Equal("Be helpful", options.Instructions);
    }

    /// <summary>
    /// Verify response options creation when both agent instructions and additional instructions are null.
    /// </summary>
    [Fact]
    public void CreateOptionsWithAllNullInstructionsTest()
    {
        // Arrange
        var mockAgent = CreateMockAgent("Test Agent", null, storeEnabled: false);
        var mockThread = CreateMockAgentThread(null);

        // Act
        var options = ResponseCreationOptionsFactory.CreateOptions(mockAgent, mockThread.Object, null);

        // Assert
        Assert.NotNull(options);
        Assert.Equal("", options.Instructions);
    }

    /// <summary>
    /// Verify response options creation when agent store is disabled but thread ID exists.
    /// </summary>
    [Fact]
    public void CreateOptionsWithStoreDisabledButThreadIdExistsTest()
    {
        // Arrange
        var mockAgent = CreateMockAgent("Test Agent", "You are a helpful assistant.", storeEnabled: false);
        var mockThread = CreateMockAgentThread("thread-123");

        // Act
        var options = ResponseCreationOptionsFactory.CreateOptions(mockAgent, mockThread.Object, null);

        // Assert
        Assert.NotNull(options);
        Assert.False(options.StoredOutputEnabled);
        Assert.Null(options.PreviousResponseId); // Should not set previous response ID when store is disabled
    }

    /// <summary>
    /// Verify response options creation with empty agent name fallback to "UnnamedAgent".
    /// </summary>
    [Fact]
    public void CreateOptionsWithEmptyAgentNameTest()
    {
        // Arrange
        var mockAgent = CreateMockAgent("", "You are a helpful assistant.", storeEnabled: false);
        var mockThread = CreateMockAgentThread(null);

        // Act
        var options = ResponseCreationOptionsFactory.CreateOptions(mockAgent, mockThread.Object, null);

        // Assert
        Assert.NotNull(options);
        Assert.Equal("UnnamedAgent", options.EndUserId); // Empty name should fallback to "UnnamedAgent"
    }

    /// <summary>
    /// Verify response options creation with null agent name fallback to "UnnamedAgent".
    /// </summary>
    [Fact]
    public void CreateOptionsWithNullAgentNameTest()
    {
        // Arrange
        var mockAgent = CreateMockAgent(null, "You are a helpful assistant.", storeEnabled: false);
        var mockThread = CreateMockAgentThread(null);

        // Act
        var options = ResponseCreationOptionsFactory.CreateOptions(mockAgent, mockThread.Object, null);

        // Assert
        Assert.NotNull(options);
        Assert.Equal("UnnamedAgent", options.EndUserId); // Null name should fallback to "UnnamedAgent"
    }

    private static OpenAIResponseAgent CreateMockAgent(string? name, string? instructions, bool storeEnabled)
    {
        var mockClient = new Mock<OpenAIResponseClient>();
        var mockAgent = new OpenAIResponseAgent(mockClient.Object)
        {
            Name = name ?? "UnnamedAgent",
            Instructions = instructions ?? string.Empty,
            StoreEnabled = storeEnabled,
            Kernel = new Kernel() // Empty kernel for testing
        };

        return mockAgent;
    }

    private static Mock<AgentThread> CreateMockAgentThread(string? threadId)
    {
        var mockThread = new Mock<AgentThread>();
        mockThread.Setup(t => t.Id).Returns(threadId);
        return mockThread;
    }
}


===== UnitTests\OpenAI\OpenAIAssistantAgentExtensionsTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.ClientModel.Primitives;
using System.Text.Json;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.Agents.OpenAI;
using Moq;
using OpenAI.Assistants;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.OpenAI;

public sealed class OpenAIAssistantAgentExtensionsTests
{
    private static readonly Assistant s_assistantDefinition = ModelReaderWriter.Read<Assistant>(BinaryData.FromString(
    """
    {
        "id": "asst_abc123",
        "object": "assistant",
        "created_at": 1698984975,
        "name": "TestAssistant",
        "description": "A test assistant",
        "model": "gpt-4",
        "instructions": "Test instructions",
        "tools": [],
        "metadata": {}
    }
    """))!;

    [Fact]
    public void AsAIAgent_WithValidOpenAIAssistantAgent_ReturnsSemanticKernelAIAgent()
    {
        // Arrange
        var clientMock = new Mock<AssistantClient>();
        var assistantAgent = new OpenAIAssistantAgent(s_assistantDefinition, clientMock.Object);

        // Act
        var result = assistantAgent.AsAIAgent();

        // Assert
        Assert.NotNull(result);
        Assert.IsType<SemanticKernelAIAgent>(result);
    }

    [Fact]
    public void AsAIAgent_WithNullOpenAIAssistantAgent_ThrowsArgumentNullException()
    {
        // Arrange
        OpenAIAssistantAgent nullAgent = null!;

        // Act & Assert
        Assert.Throws<ArgumentNullException>(() => nullAgent.AsAIAgent());
    }

    [Fact]
    public void AsAIAgent_CreatesWorkingThreadFactory()
    {
        // Arrange
        var clientMock = new Mock<AssistantClient>();
        var assistantAgent = new OpenAIAssistantAgent(s_assistantDefinition, clientMock.Object);

        // Act
        var result = assistantAgent.AsAIAgent();
        var thread = result.GetNewThread();

        // Assert
        Assert.NotNull(thread);
        Assert.IsType<SemanticKernelAIAgentThread>(thread);
        var threadAdapter = (SemanticKernelAIAgentThread)thread;
        Assert.IsType<OpenAIAssistantAgentThread>(threadAdapter.InnerThread);
    }

    [Fact]
    public void AsAIAgent_ThreadDeserializationFactory_WithNullAgentId_CreatesNewThread()
    {
        // Arrange
        var clientMock = new Mock<AssistantClient>();
        var assistantAgent = new OpenAIAssistantAgent(s_assistantDefinition, clientMock.Object);
        var jsonElement = JsonSerializer.SerializeToElement((string?)null);

        // Act
        var result = assistantAgent.AsAIAgent();
        var thread = result.DeserializeThread(jsonElement);

        // Assert
        Assert.NotNull(thread);
        Assert.IsType<SemanticKernelAIAgentThread>(thread);
        var threadAdapter = (SemanticKernelAIAgentThread)thread;
        Assert.IsType<OpenAIAssistantAgentThread>(threadAdapter.InnerThread);
    }

    [Fact]
    public void AsAIAgent_ThreadDeserializationFactory_WithValidAgentId_CreatesThreadWithId()
    {
        // Arrange
        var clientMock = new Mock<AssistantClient>();
        var assistantAgent = new OpenAIAssistantAgent(s_assistantDefinition, clientMock.Object);
        var threadId = "test-thread-id";
        var jsonElement = JsonSerializer.SerializeToElement(threadId);

        // Act
        var result = assistantAgent.AsAIAgent();
        var thread = result.DeserializeThread(jsonElement);

        // Assert
        Assert.NotNull(thread);
        Assert.IsType<SemanticKernelAIAgentThread>(thread);
        var threadAdapter = (SemanticKernelAIAgentThread)thread;
        Assert.IsType<OpenAIAssistantAgentThread>(threadAdapter.InnerThread);
        Assert.Equal(threadId, threadAdapter.InnerThread.Id);
    }

    [Fact]
    public void AsAIAgent_ThreadSerializer_SerializesThreadId()
    {
        // Arrange
        var clientMock = new Mock<AssistantClient>();
        var assistantAgent = new OpenAIAssistantAgent(s_assistantDefinition, clientMock.Object);
        var expectedThreadId = "test-thread-id";
        var assistantThread = new OpenAIAssistantAgentThread(clientMock.Object, expectedThreadId);
        var jsonElement = JsonSerializer.SerializeToElement(expectedThreadId);

        var result = assistantAgent.AsAIAgent();
        var thread = result.DeserializeThread(jsonElement);

        // Act
        var serializedElement = thread.Serialize();

        // Assert
        Assert.Equal(JsonValueKind.String, serializedElement.ValueKind);
        Assert.Equal(expectedThreadId, serializedElement.GetString());
    }
}


===== UnitTests\OpenAI\OpenAIAssistantAgentInvokeOptionsTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.Agents.OpenAI;
using OpenAI.Assistants;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.OpenAI;

/// <summary>
/// Tests for <see cref="OpenAIAssistantAgentInvokeOptions"/>.
/// </summary>
public class OpenAIAssistantAgentInvokeOptionsTests
{
    /// <summary>
    /// Tests the constructor of <see cref="OpenAIAssistantAgentInvokeOptions"/> to ensure it correctly clones properties from the base class.
    /// </summary>
    [Fact]
    public void ConstructorShouldClonePropertiesCorrectly()
    {
        // Arrange
        var originalOptions = new OpenAIAssistantAgentInvokeOptions
        {
            RunCreationOptions = new RunCreationOptions(),
            AdditionalInstructions = "Test instructions"
        };

        // Act
        var clonedOptions = new OpenAIAssistantAgentInvokeOptions(originalOptions);

        // Assert
        Assert.NotNull(clonedOptions.RunCreationOptions);
        Assert.Equal(originalOptions.RunCreationOptions, clonedOptions.RunCreationOptions);
        Assert.Equal(originalOptions.AdditionalInstructions, clonedOptions.AdditionalInstructions);
    }

    /// <summary>
    /// Tests the constructor of <see cref="OpenAIAssistantAgentInvokeOptions"/> to ensure it correctly clones properties from an instance of <see cref="AgentInvokeOptions"/>.
    /// </summary>
    [Fact]
    public void ConstructorShouldCloneAgentInvokeOptionsPropertiesCorrectly()
    {
        // Arrange
        var originalOptions = new AgentInvokeOptions
        {
            AdditionalInstructions = "Test instructions"
        };

        // Act
        var clonedOptions = new OpenAIAssistantAgentInvokeOptions(originalOptions);

        // Assert
        Assert.Equal(originalOptions.AdditionalInstructions, clonedOptions.AdditionalInstructions);
    }
}


===== UnitTests\OpenAI\OpenAIAssistantAgentTests.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.ClientModel;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.AI;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.Agents.OpenAI;
using Microsoft.SemanticKernel.ChatCompletion;
using Moq;
using OpenAI.Assistants;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.OpenAI;

/// <summary>
/// Unit testing of <see cref="OpenAIAssistantAgent"/>.
/// </summary>
#pragma warning disable CS0419 // Ambiguous reference in cref attribute
public sealed class OpenAIAssistantAgentTests : IDisposable
{
    private readonly HttpMessageHandlerStub _messageHandlerStub;
    private readonly HttpClient _httpClient;
    private readonly Kernel _emptyKernel;

    /// <summary>
    /// Verify invocation via <see cref="AgentGroupChat"/>.
    /// </summary>
    [Fact]
    public async Task VerifyOpenAIAssistantAgentGroupChatAsync()
    {
        // Arrange
        OpenAIAssistantAgent agent = await this.CreateAgentAsync();

        this.SetupResponses(
            HttpStatusCode.OK,
            OpenAIAssistantResponseContent.CreateThread,
            OpenAIAssistantResponseContent.Run.CreateRun,
            OpenAIAssistantResponseContent.Run.CompletedRun,
            OpenAIAssistantResponseContent.Run.MessageSteps,
            OpenAIAssistantResponseContent.GetTextMessage());

        AgentGroupChat chat = new();

        // Act
        ChatMessageContent[] messages = await chat.InvokeAsync(agent).ToArrayAsync();

        // Assert
        Assert.Single(messages);
        Assert.Single(messages[0].Items);
        Assert.IsType<Microsoft.SemanticKernel.TextContent>(messages[0].Items[0]);

        // Arrange
        this.SetupResponse(HttpStatusCode.OK, OpenAIAssistantResponseContent.DeleteThread);

        // Act
        await chat.ResetAsync();

        // Assert
        Assert.Empty(this._messageHandlerStub.ResponseQueue);
    }

    /// <summary>
    /// Verify direct invocation of <see cref="OpenAIAssistantAgent"/> using <see cref="AgentThread"/>.
    /// </summary>
    [Fact]
    public async Task VerifyOpenAIAssistantAgentInvokeWithThreadAsync()
    {
        // Arrange
        OpenAIAssistantAgent agent = await this.CreateAgentAsync();

        this.SetupResponses(
            HttpStatusCode.OK,
            OpenAIAssistantResponseContent.CreateThread,
            // Create message response
            OpenAIAssistantResponseContent.GetTextMessage("Hi"),
            OpenAIAssistantResponseContent.Run.CreateRun,
            OpenAIAssistantResponseContent.Run.CompletedRun,
            OpenAIAssistantResponseContent.Run.MessageSteps,
            OpenAIAssistantResponseContent.GetTextMessage("Hello, how can I help you?"));

        // Act
        AgentResponseItem<ChatMessageContent>[] messages = await agent.InvokeAsync(new ChatMessageContent(AuthorRole.User, "Hi")).ToArrayAsync();

        // Assert
        Assert.Single(messages);
        Assert.Single(messages[0].Message.Items);
        Assert.IsType<Microsoft.SemanticKernel.TextContent>(messages[0].Message.Items[0]);
        Assert.Equal("Hello, how can I help you?", messages[0].Message.Content);
    }

    /// <summary>
    /// Verify direct invocation of <see cref="OpenAIAssistantAgent"/> using <see cref="AgentThread"/>.
    /// </summary>
    [Fact]
    public async Task VerifyOpenAIAssistantAgentInvokeMultipleMessagesWithThreadAsync()
    {
        // Arrange
        OpenAIAssistantAgent agent = await this.CreateAgentAsync();

        this.SetupResponses(
            HttpStatusCode.OK,
            OpenAIAssistantResponseContent.CreateThread,
            // Create message response
            OpenAIAssistantResponseContent.GetTextMessage("Hello"),
            // Create message response
            OpenAIAssistantResponseContent.GetTextMessage("Hi"),
            OpenAIAssistantResponseContent.Run.CreateRun,
            OpenAIAssistantResponseContent.Run.CompletedRun,
            OpenAIAssistantResponseContent.Run.MessageSteps,
            OpenAIAssistantResponseContent.GetTextMessage("How can I help you?"));

        // Act
        AgentResponseItem<ChatMessageContent>[] messages = await agent.InvokeAsync(
        [
            new ChatMessageContent(AuthorRole.Assistant, "Hello"),
            new ChatMessageContent(AuthorRole.User, "Hi")
        ]).ToArrayAsync();

        // Assert
        Assert.Single(messages);
        Assert.Single(messages[0].Message.Items);
        Assert.IsType<Microsoft.SemanticKernel.TextContent>(messages[0].Message.Items[0]);
        Assert.Equal("How can I help you?", messages[0].Message.Content);
    }

    /// <summary>
    /// Verify direct streaming invocation of <see cref="OpenAIAssistantAgent"/> using <see cref="AgentThread"/>.
    /// </summary>
    [Fact]
    public async Task VerifyOpenAIAssistantAgentInvokeStreamingWithThreadAsync()
    {
        // Arrange
        OpenAIAssistantAgent agent = await this.CreateAgentAsync();

        this.SetupResponses(
            HttpStatusCode.OK,
            OpenAIAssistantResponseContent.CreateThread,
            // Create message response
            OpenAIAssistantResponseContent.GetTextMessage("Hi"),
            OpenAIAssistantResponseContent.Streaming.Response(
            [
                OpenAIAssistantResponseContent.Streaming.CreateRun("created"),
                OpenAIAssistantResponseContent.Streaming.CreateRun("queued"),
                OpenAIAssistantResponseContent.Streaming.CreateRun("in_progress"),
                OpenAIAssistantResponseContent.Streaming.DeltaMessage("Hello, "),
                OpenAIAssistantResponseContent.Streaming.DeltaMessage("how can I "),
                OpenAIAssistantResponseContent.Streaming.DeltaMessage("help you?"),
                OpenAIAssistantResponseContent.Streaming.CreateRun("completed"),
                OpenAIAssistantResponseContent.Streaming.Done
            ]),
            OpenAIAssistantResponseContent.GetTextMessage("Hello, how can I help you?"));

        // Act
        Task OnIntermediateMessage(ChatMessageContent message)
        {
            // Assert intermediate messages
            Assert.NotNull(message);
            Assert.Equal("Hello, how can I help you?", message.Content);
            return Task.CompletedTask;
        }
        AgentResponseItem<StreamingChatMessageContent>[] messages = await agent.InvokeStreamingAsync(new ChatMessageContent(AuthorRole.User, "Hi"), options: new() { OnIntermediateMessage = OnIntermediateMessage }).ToArrayAsync();

        // Assert
        Assert.Equal(3, messages.Length);
        var combinedMessage = string.Concat(messages.Select(x => x.Message.Content));
        Assert.Equal("Hello, how can I help you?", combinedMessage);
    }

    /// <summary>
    /// Verify complex chat interaction across multiple states.
    /// </summary>
    [Fact]
    public async Task VerifyOpenAIAssistantAgentChatTextMessageWithAnnotationAsync()
    {
        // Arrange
        OpenAIAssistantAgent agent = await this.CreateAgentAsync();

        this.SetupResponses(
            HttpStatusCode.OK,
            OpenAIAssistantResponseContent.CreateThread,
            OpenAIAssistantResponseContent.Run.CreateRun,
            OpenAIAssistantResponseContent.Run.CompletedRun,
            OpenAIAssistantResponseContent.Run.MessageSteps,
            OpenAIAssistantResponseContent.GetTextMessageWithAnnotation);

        AgentGroupChat chat = new();

        // Act
        ChatMessageContent[] messages = await chat.InvokeAsync(agent).ToArrayAsync();

        // Assert
        Assert.Single(messages);
        Assert.Equal(2, messages[0].Items.Count);
        Assert.NotNull(messages[0].Items.SingleOrDefault(c => c is Microsoft.SemanticKernel.TextContent));
        Assert.NotNull(messages[0].Items.SingleOrDefault(c => c is AnnotationContent));
    }

    /// <summary>
    /// Verify complex chat interaction across multiple states.
    /// </summary>
    [Fact]
    public async Task VerifyOpenAIAssistantAgentChatImageMessageAsync()
    {
        // Arrange
        OpenAIAssistantAgent agent = await this.CreateAgentAsync();

        this.SetupResponses(
            HttpStatusCode.OK,
            OpenAIAssistantResponseContent.CreateThread,
            OpenAIAssistantResponseContent.Run.CreateRun,
            OpenAIAssistantResponseContent.Run.CompletedRun,
            OpenAIAssistantResponseContent.Run.MessageSteps,
            OpenAIAssistantResponseContent.GetImageMessage);

        AgentGroupChat chat = new();

        // Act
        ChatMessageContent[] messages = await chat.InvokeAsync(agent).ToArrayAsync();

        // Assert
        Assert.Single(messages);
        Assert.Single(messages[0].Items);
        Assert.IsType<FileReferenceContent>(messages[0].Items[0]);
    }

    /// <summary>
    /// Verify complex chat interaction across multiple states.
    /// </summary>
    [Fact]
    public async Task VerifyOpenAIAssistantAgentGetMessagesAsync()
    {
        // Arrange: Create agent
        OpenAIAssistantAgent agent = await this.CreateAgentAsync();

        // Initialize agent channel
        this.SetupResponses(
            HttpStatusCode.OK,
            OpenAIAssistantResponseContent.CreateThread,
            OpenAIAssistantResponseContent.Run.CreateRun,
            OpenAIAssistantResponseContent.Run.CompletedRun,
            OpenAIAssistantResponseContent.Run.MessageSteps,
            OpenAIAssistantResponseContent.GetTextMessage());

        AgentGroupChat chat = new();

        // Act
        ChatMessageContent[] messages = await chat.InvokeAsync(agent).ToArrayAsync();
        // Assert
        Assert.Single(messages);

        // Arrange: Setup messages
        this.SetupResponses(
            HttpStatusCode.OK,
            OpenAIAssistantResponseContent.ListMessagesPageMore,
            OpenAIAssistantResponseContent.ListMessagesPageMore,
            OpenAIAssistantResponseContent.ListMessagesPageFinal);

        // Act: Get messages
        messages = await chat.GetChatMessagesAsync(agent).ToArrayAsync();
        // Assert
        Assert.Equal(5, messages.Length);
    }

    /// <summary>
    /// Verify complex chat interaction across multiple states.
    /// </summary>
    [Fact]
    public async Task VerifyOpenAIAssistantAgentAddMessagesAsync()
    {
        // Arrange: Create agent
        OpenAIAssistantAgent agent = await this.CreateAgentAsync();

        // Initialize agent channel
        this.SetupResponses(
            HttpStatusCode.OK,
            OpenAIAssistantResponseContent.CreateThread,
            OpenAIAssistantResponseContent.Run.CreateRun,
            OpenAIAssistantResponseContent.Run.CompletedRun,
            OpenAIAssistantResponseContent.Run.MessageSteps,
            OpenAIAssistantResponseContent.GetTextMessage());
        AgentGroupChat chat = new();

        // Act
        ChatMessageContent[] messages = await chat.InvokeAsync(agent).ToArrayAsync();
        // Assert
        Assert.Single(messages);

        // Arrange
        chat.AddChatMessage(new ChatMessageContent(AuthorRole.User, "hi"));

        // Act
        messages = await chat.GetChatMessagesAsync().ToArrayAsync();
        // Assert
        Assert.Equal(2, messages.Length);
    }

    /// <summary>
    /// Verify ability to list agent definitions.
    /// </summary>
    [Fact]
    public async Task VerifyOpenAIAssistantAgentWithFunctionCallAsync()
    {
        // Arrange
        OpenAIAssistantAgent agent = await this.CreateAgentAsync();

        KernelPlugin plugin = KernelPluginFactory.CreateFromType<MyPlugin>();
        agent.Kernel.Plugins.Add(plugin);

        this.SetupResponses(
            HttpStatusCode.OK,
            OpenAIAssistantResponseContent.CreateThread,
            OpenAIAssistantResponseContent.Run.CreateRun,
            OpenAIAssistantResponseContent.Run.PendingRun,
            OpenAIAssistantResponseContent.Run.ToolSteps,
            OpenAIAssistantResponseContent.ToolResponse,
            OpenAIAssistantResponseContent.Run.CompletedRun,
            OpenAIAssistantResponseContent.Run.MessageSteps,
            OpenAIAssistantResponseContent.GetTextMessage());

        AgentGroupChat chat = new();

        // Act
        ChatMessageContent[] messages = await chat.InvokeAsync(agent).ToArrayAsync();

        // Assert
        Assert.Single(messages);
        Assert.Single(messages[0].Items);
        Assert.IsType<Microsoft.SemanticKernel.TextContent>(messages[0].Items[0]);
    }

    /// <summary>
    /// Verify that InvalidOperationException is thrown when UseImmutableKernel is false and AIFunctions exist.
    /// </summary>
    [Fact]
    public async Task VerifyOpenAIAssistantAgentThrowsWhenUseImmutableKernelFalseWithAIFunctionsAsync()
    {
        // Arrange
        OpenAIAssistantAgent agent = await this.CreateAgentAsync();
        agent.UseImmutableKernel = false; // Explicitly set to false

        // Initialize agent channel
        this.SetupResponses(
            HttpStatusCode.OK,
            OpenAIAssistantResponseContent.CreateThread,
            OpenAIAssistantResponseContent.Run.CreateRun,
            OpenAIAssistantResponseContent.Run.CompletedRun,
            OpenAIAssistantResponseContent.Run.MessageSteps,
            OpenAIAssistantResponseContent.GetTextMessage());

        var mockAIContextProvider = new Mock<AIContextProvider>();
        var aiContext = new AIContext
        {
            AIFunctions = [new TestAIFunction("TestFunction", "Test function description")]
        };
        mockAIContextProvider.Setup(p => p.ModelInvokingAsync(It.IsAny<ICollection<ChatMessage>>(), It.IsAny<CancellationToken>()))
                           .ReturnsAsync(aiContext);

        var thread = new OpenAIAssistantAgentThread(agent.Client);
        thread.AIContextProviders.Add(mockAIContextProvider.Object);

        this.SetupResponses(
            HttpStatusCode.OK,
            OpenAIAssistantResponseContent.CreateThread);

        // Act & Assert
        var exception = await Assert.ThrowsAsync<InvalidOperationException>(
            async () => await agent.InvokeAsync(new ChatMessageContent(AuthorRole.User, "Hi"), thread: thread).ToArrayAsync());

        Assert.NotNull(exception);
    }

    /// <summary>
    /// Verify that InvalidOperationException is thrown when UseImmutableKernel is default (false) and AIFunctions exist.
    /// </summary>
    [Fact]
    public async Task VerifyOpenAIAssistantAgentThrowsWhenUseImmutableKernelDefaultWithAIFunctionsAsync()
    {
        // Arrange
        OpenAIAssistantAgent agent = await this.CreateAgentAsync();
        // UseImmutableKernel not set, should default to false

        // Initialize agent channel
        this.SetupResponses(
            HttpStatusCode.OK,
            OpenAIAssistantResponseContent.CreateThread,
            OpenAIAssistantResponseContent.Run.CreateRun,
            OpenAIAssistantResponseContent.Run.CompletedRun,
            OpenAIAssistantResponseContent.Run.MessageSteps,
            OpenAIAssistantResponseContent.GetTextMessage());

        var mockAIContextProvider = new Mock<AIContextProvider>();
        var aiContext = new AIContext
        {
            AIFunctions = [new TestAIFunction("TestFunction", "Test function description")]
        };
        mockAIContextProvider.Setup(p => p.ModelInvokingAsync(It.IsAny<ICollection<ChatMessage>>(), It.IsAny<CancellationToken>()))
                           .ReturnsAsync(aiContext);

        var thread = new OpenAIAssistantAgentThread(agent.Client);
        thread.AIContextProviders.Add(mockAIContextProvider.Object);

        this.SetupResponses(
            HttpStatusCode.OK,
            OpenAIAssistantResponseContent.CreateThread);

        // Act & Assert
        var exception = await Assert.ThrowsAsync<InvalidOperationException>(
            async () => await agent.InvokeAsync(new ChatMessageContent(AuthorRole.User, "Hi"), thread: thread).ToArrayAsync());

        Assert.NotNull(exception);
    }

    /// <summary>
    /// Verify that kernel remains immutable when UseImmutableKernel is true.
    /// </summary>
    [Fact]
    public async Task VerifyOpenAIAssistantAgentKernelImmutabilityWhenUseImmutableKernelTrueAsync()
    {
        // Arrange
        OpenAIAssistantAgent agent = await this.CreateAgentAsync();
        agent.UseImmutableKernel = true;

        var originalKernel = agent.Kernel;
        var originalPluginCount = originalKernel.Plugins.Count;

        var mockAIContextProvider = new Mock<AIContextProvider>();
        var aiContext = new AIContext
        {
            AIFunctions = [new TestAIFunction("TestFunction", "Test function description")]
        };
        mockAIContextProvider.Setup(p => p.ModelInvokingAsync(It.IsAny<ICollection<ChatMessage>>(), It.IsAny<CancellationToken>()))
                           .ReturnsAsync(aiContext);

        var thread = new OpenAIAssistantAgentThread(agent.Client);
        thread.AIContextProviders.Add(mockAIContextProvider.Object);

        this.SetupResponses(
            HttpStatusCode.OK,
            OpenAIAssistantResponseContent.CreateThread,
            // Create message response
            OpenAIAssistantResponseContent.GetTextMessage("Hi"),
            OpenAIAssistantResponseContent.Run.CreateRun,
            OpenAIAssistantResponseContent.Run.CompletedRun,
            OpenAIAssistantResponseContent.Run.MessageSteps,
            OpenAIAssistantResponseContent.GetTextMessage("Hello, how can I help you?"));

        // Act
        AgentResponseItem<ChatMessageContent>[] result = await agent.InvokeAsync(new ChatMessageContent(AuthorRole.User, "Hi"), thread: thread).ToArrayAsync();

        // Assert
        Assert.Single(result);

        // Verify original kernel was not modified
        Assert.Equal(originalPluginCount, originalKernel.Plugins.Count);

        // The kernel should remain unchanged since UseImmutableKernel=true creates a clone
        Assert.Same(originalKernel, agent.Kernel);
    }

    /// <summary>
    /// Verify that mutable kernel behavior works when UseImmutableKernel is false and no AIFunctions exist.
    /// </summary>
    [Fact]
    public async Task VerifyOpenAIAssistantAgentMutableKernelWhenUseImmutableKernelFalseNoAIFunctionsAsync()
    {
        // Arrange
        OpenAIAssistantAgent agent = await this.CreateAgentAsync();
        agent.UseImmutableKernel = false;

        var originalKernel = agent.Kernel;
        var originalPluginCount = originalKernel.Plugins.Count;

        var mockAIContextProvider = new Mock<AIContextProvider>();
        var aiContext = new AIContext
        {
            AIFunctions = [] // Empty AIFunctions list
        };
        mockAIContextProvider.Setup(p => p.ModelInvokingAsync(It.IsAny<ICollection<ChatMessage>>(), It.IsAny<CancellationToken>()))
                           .ReturnsAsync(aiContext);

        var thread = new OpenAIAssistantAgentThread(agent.Client);
        thread.AIContextProviders.Add(mockAIContextProvider.Object);

        this.SetupResponses(
            HttpStatusCode.OK,
            OpenAIAssistantResponseContent.CreateThread,
            // Create message response
            OpenAIAssistantResponseContent.GetTextMessage("Hi"),
            OpenAIAssistantResponseContent.Run.CreateRun,
            OpenAIAssistantResponseContent.Run.CompletedRun,
            OpenAIAssistantResponseContent.Run.MessageSteps,
            OpenAIAssistantResponseContent.GetTextMessage("Hello, how can I help you?"));

        // Act
        AgentResponseItem<ChatMessageContent>[] result = await agent.InvokeAsync(new ChatMessageContent(AuthorRole.User, "Hi"), thread: thread).ToArrayAsync();

        // Assert
        Assert.Single(result);

        // Verify the same kernel instance is still being used (mutable behavior)
        Assert.Same(originalKernel, agent.Kernel);
    }

    /// <summary>
    /// Verify that InvalidOperationException is thrown when UseImmutableKernel is false and AIFunctions exist (streaming).
    /// </summary>
    [Fact]
    public async Task VerifyOpenAIAssistantAgentStreamingThrowsWhenUseImmutableKernelFalseWithAIFunctionsAsync()
    {
        // Arrange
        OpenAIAssistantAgent agent = await this.CreateAgentAsync();
        agent.UseImmutableKernel = false; // Explicitly set to false

        this.SetupResponses(
            HttpStatusCode.OK,
            OpenAIAssistantResponseContent.CreateThread,
            // Create message response
            OpenAIAssistantResponseContent.GetTextMessage("Hi"),
            OpenAIAssistantResponseContent.Streaming.Response(
            [
                OpenAIAssistantResponseContent.Streaming.CreateRun("created"),
                        OpenAIAssistantResponseContent.Streaming.CreateRun("queued"),
                        OpenAIAssistantResponseContent.Streaming.CreateRun("in_progress"),
                        OpenAIAssistantResponseContent.Streaming.DeltaMessage("Hello, "),
                        OpenAIAssistantResponseContent.Streaming.DeltaMessage("how can I "),
                        OpenAIAssistantResponseContent.Streaming.DeltaMessage("help you?"),
                        OpenAIAssistantResponseContent.Streaming.CreateRun("completed"),
                        OpenAIAssistantResponseContent.Streaming.Done
            ]),
            OpenAIAssistantResponseContent.GetTextMessage("Hello, how can I help you?"));

        var mockAIContextProvider = new Mock<AIContextProvider>();
        var aiContext = new AIContext
        {
            AIFunctions = [new TestAIFunction("TestFunction", "Test function description")]
        };
        mockAIContextProvider.Setup(p => p.ModelInvokingAsync(It.IsAny<ICollection<ChatMessage>>(), It.IsAny<CancellationToken>()))
                           .ReturnsAsync(aiContext);

        var thread = new OpenAIAssistantAgentThread(agent.Client);
        thread.AIContextProviders.Add(mockAIContextProvider.Object);

        this.SetupResponses(
            HttpStatusCode.OK,
            OpenAIAssistantResponseContent.CreateThread);

        // Act & Assert
        var exception = await Assert.ThrowsAsync<InvalidOperationException>(
            async () => await agent.InvokeStreamingAsync(new ChatMessageContent(AuthorRole.User, "Hi"), thread: thread).ToArrayAsync());

        Assert.NotNull(exception);
    }

    /// <summary>
    /// Verify that InvalidOperationException is thrown when UseImmutableKernel is default (false) and AIFunctions exist (streaming).
    /// </summary>
    [Fact]
    public async Task VerifyOpenAIAssistantAgentStreamingThrowsWhenUseImmutableKernelDefaultWithAIFunctionsAsync()
    {
        // Arrange
        OpenAIAssistantAgent agent = await this.CreateAgentAsync();
        // UseImmutableKernel not set, should default to false

        this.SetupResponses(
            HttpStatusCode.OK,
            OpenAIAssistantResponseContent.CreateThread,
            // Create message response
            OpenAIAssistantResponseContent.GetTextMessage("Hi"),
            OpenAIAssistantResponseContent.Streaming.Response(
            [
                OpenAIAssistantResponseContent.Streaming.CreateRun("created"),
                        OpenAIAssistantResponseContent.Streaming.CreateRun("queued"),
                        OpenAIAssistantResponseContent.Streaming.CreateRun("in_progress"),
                        OpenAIAssistantResponseContent.Streaming.DeltaMessage("Hello, "),
                        OpenAIAssistantResponseContent.Streaming.DeltaMessage("how can I "),
                        OpenAIAssistantResponseContent.Streaming.DeltaMessage("help you?"),
                        OpenAIAssistantResponseContent.Streaming.CreateRun("completed"),
                        OpenAIAssistantResponseContent.Streaming.Done
            ]),
            OpenAIAssistantResponseContent.GetTextMessage("Hello, how can I help you?"));

        var mockAIContextProvider = new Mock<AIContextProvider>();
        var aiContext = new AIContext
        {
            AIFunctions = [new TestAIFunction("TestFunction", "Test function description")]
        };
        mockAIContextProvider.Setup(p => p.ModelInvokingAsync(It.IsAny<ICollection<ChatMessage>>(), It.IsAny<CancellationToken>()))
                           .ReturnsAsync(aiContext);

        var thread = new OpenAIAssistantAgentThread(agent.Client);
        thread.AIContextProviders.Add(mockAIContextProvider.Object);

        this.SetupResponses(
            HttpStatusCode.OK,
            OpenAIAssistantResponseContent.CreateThread);

        // Act & Assert
        var exception = await Assert.ThrowsAsync<InvalidOperationException>(
            async () => await agent.InvokeStreamingAsync(new ChatMessageContent(AuthorRole.User, "Hi"), thread: thread).ToArrayAsync());

        Assert.NotNull(exception);
    }

    /// <summary>
    /// Verify that kernel remains immutable when UseImmutableKernel is true (streaming).
    /// </summary>
    [Fact]
    public async Task VerifyOpenAIAssistantAgentStreamingKernelImmutabilityWhenUseImmutableKernelTrueAsync()
    {
        // Arrange
        OpenAIAssistantAgent agent = await this.CreateAgentAsync();
        agent.UseImmutableKernel = true;

        var originalKernel = agent.Kernel;
        var originalPluginCount = originalKernel.Plugins.Count;

        var mockAIContextProvider = new Mock<AIContextProvider>();
        var aiContext = new AIContext
        {
            AIFunctions = [new TestAIFunction("TestFunction", "Test function description")]
        };
        mockAIContextProvider.Setup(p => p.ModelInvokingAsync(It.IsAny<ICollection<ChatMessage>>(), It.IsAny<CancellationToken>()))
                           .ReturnsAsync(aiContext);

        var thread = new OpenAIAssistantAgentThread(agent.Client);
        thread.AIContextProviders.Add(mockAIContextProvider.Object);

        this.SetupResponses(
            HttpStatusCode.OK,
            OpenAIAssistantResponseContent.CreateThread,
            // Create message response
            OpenAIAssistantResponseContent.GetTextMessage("Hi"),
            OpenAIAssistantResponseContent.Streaming.Response(
            [
                OpenAIAssistantResponseContent.Streaming.CreateRun("created"),
                OpenAIAssistantResponseContent.Streaming.CreateRun("queued"),
                OpenAIAssistantResponseContent.Streaming.CreateRun("in_progress"),
                OpenAIAssistantResponseContent.Streaming.DeltaMessage("Hello, "),
                OpenAIAssistantResponseContent.Streaming.DeltaMessage("how can I "),
                OpenAIAssistantResponseContent.Streaming.DeltaMessage("help you?"),
                OpenAIAssistantResponseContent.Streaming.CreateRun("completed"),
                OpenAIAssistantResponseContent.Streaming.Done
            ]),
            OpenAIAssistantResponseContent.GetTextMessage("Hello, how can I help you?"));

        // Act
        AgentResponseItem<StreamingChatMessageContent>[] result = await agent.InvokeStreamingAsync(new ChatMessageContent(AuthorRole.User, "Hi"), thread: thread).ToArrayAsync();

        // Assert
        Assert.True(result.Length > 0);

        // Verify original kernel was not modified
        Assert.Equal(originalPluginCount, originalKernel.Plugins.Count);

        // The kernel should remain unchanged since UseImmutableKernel=true creates a clone
        Assert.Same(originalKernel, agent.Kernel);
    }

    /// <summary>
    /// Verify that mutable kernel behavior works when UseImmutableKernel is false and no AIFunctions exist (streaming).
    /// </summary>
    [Fact]
    public async Task VerifyOpenAIAssistantAgentStreamingMutableKernelWhenUseImmutableKernelFalseNoAIFunctionsAsync()
    {
        // Arrange
        OpenAIAssistantAgent agent = await this.CreateAgentAsync();
        agent.UseImmutableKernel = false;

        var originalKernel = agent.Kernel;
        var originalPluginCount = originalKernel.Plugins.Count;

        var mockAIContextProvider = new Mock<AIContextProvider>();
        var aiContext = new AIContext
        {
            AIFunctions = [] // Empty AIFunctions list
        };
        mockAIContextProvider.Setup(p => p.ModelInvokingAsync(It.IsAny<ICollection<ChatMessage>>(), It.IsAny<CancellationToken>()))
                           .ReturnsAsync(aiContext);

        var thread = new OpenAIAssistantAgentThread(agent.Client);
        thread.AIContextProviders.Add(mockAIContextProvider.Object);

        this.SetupResponses(
            HttpStatusCode.OK,
            OpenAIAssistantResponseContent.CreateThread,
            // Create message response
            OpenAIAssistantResponseContent.GetTextMessage("Hi"),
            OpenAIAssistantResponseContent.Streaming.Response(
            [
                OpenAIAssistantResponseContent.Streaming.CreateRun("created"),
                OpenAIAssistantResponseContent.Streaming.CreateRun("queued"),
                OpenAIAssistantResponseContent.Streaming.CreateRun("in_progress"),
                OpenAIAssistantResponseContent.Streaming.DeltaMessage("Hello, "),
                OpenAIAssistantResponseContent.Streaming.DeltaMessage("how can I "),
                OpenAIAssistantResponseContent.Streaming.DeltaMessage("help you?"),
                OpenAIAssistantResponseContent.Streaming.CreateRun("completed"),
                OpenAIAssistantResponseContent.Streaming.Done
            ]),
            OpenAIAssistantResponseContent.GetTextMessage("Hello, how can I help you?"));

        // Act
        AgentResponseItem<StreamingChatMessageContent>[] result = await agent.InvokeStreamingAsync(new ChatMessageContent(AuthorRole.User, "Hi"), thread: thread).ToArrayAsync();

        // Assert
        Assert.True(result.Length > 0);

        // Verify the same kernel instance is still being used (mutable behavior)
        Assert.Same(originalKernel, agent.Kernel);
    }

    /// <inheritdoc/>
    public void Dispose()
    {
        this._messageHandlerStub.Dispose();
        this._httpClient.Dispose();
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="OpenAIAssistantAgentTests"/> class.
    /// </summary>
    public OpenAIAssistantAgentTests()
    {
        this._messageHandlerStub = new HttpMessageHandlerStub();
        this._httpClient = new HttpClient(this._messageHandlerStub, disposeHandler: false);
        this._emptyKernel = new Kernel();
    }

    private static void ValidateAgentDefinition(OpenAIAssistantAgent agent, OpenAIAssistantDefinition expectedConfig)
    {
        ValidateAgent(agent, expectedConfig.Name, expectedConfig.Instructions, expectedConfig.Description, expectedConfig);
    }

    private static void ValidateAgentDefinition(OpenAIAssistantAgent agent, OpenAIAssistantCapabilities expectedConfig, PromptTemplateConfig templateConfig)
    {
        ValidateAgent(agent, templateConfig.Name, templateConfig.Template, templateConfig.Description, expectedConfig);
    }

    private static void ValidateAgent(
        OpenAIAssistantAgent agent,
        string? expectedName,
        string? expectedInstructions,
        string? expectedDescription,
        OpenAIAssistantCapabilities expectedConfig)
    {
        // Verify fundamental state
        Assert.NotNull(agent);
        Assert.NotNull(agent.Id);
        Assert.NotNull(agent.Definition);
        Assert.Equal(expectedConfig.ModelId, agent.Definition.Model);

        // Verify core properties
        Assert.Equal(expectedInstructions ?? string.Empty, agent.Instructions);
        Assert.Equal(expectedName ?? string.Empty, agent.Name);
        Assert.Equal(expectedDescription ?? string.Empty, agent.Description);

        // Verify options
        Assert.Equal(expectedConfig.Temperature, agent.Definition.Temperature);
        Assert.Equal(expectedConfig.TopP, agent.Definition.NucleusSamplingFactor);

        // Verify tool definitions
        int expectedToolCount = 0;

        bool hasCodeInterpreter = false;
        if (expectedConfig.EnableCodeInterpreter)
        {
            hasCodeInterpreter = true;
            ++expectedToolCount;
        }

        Assert.Equal(hasCodeInterpreter, agent.Definition.Tools.OfType<CodeInterpreterToolDefinition>().Any());

        bool hasFileSearch = false;
        if (expectedConfig.EnableFileSearch)
        {
            hasFileSearch = true;
            ++expectedToolCount;
        }

        Assert.Equal(hasFileSearch, agent.Definition.Tools.OfType<FileSearchToolDefinition>().Any());

        Assert.Equal(expectedToolCount, agent.Definition.Tools.Count);

        // Verify metadata
        Assert.NotNull(agent.Definition.Metadata);
        if (expectedConfig.ExecutionOptions == null)
        {
            Assert.Equal(expectedConfig.Metadata ?? new Dictionary<string, string>(), agent.Definition.Metadata);
        }
        else // Additional metadata present when execution options are defined
        {
            Assert.Equal((expectedConfig.Metadata?.Count ?? 0) + 1, agent.Definition.Metadata.Count);

            if (expectedConfig.Metadata != null)
            {
                foreach (var (key, value) in expectedConfig.Metadata)
                {
                    string? targetValue = agent.Definition.Metadata[key];
                    Assert.NotNull(targetValue);
                    Assert.Equal(value, targetValue);
                }
            }
        }

        // Verify detail definition
        Assert.Equal(expectedConfig.VectorStoreId, agent.Definition.ToolResources.FileSearch?.VectorStoreIds.SingleOrDefault());
        Assert.Equal(expectedConfig.CodeInterpreterFileIds, agent.Definition.ToolResources.CodeInterpreter?.FileIds);
    }

    private async Task<OpenAIAssistantAgent> CreateAgentAsync()
    {
        OpenAIAssistantDefinition definition = new("testmodel");

        this.SetupResponse(HttpStatusCode.OK, definition);

        var clientProvider = this.CreateTestClient();
        var assistantClient = clientProvider.Client.GetAssistantClient();
        var assistantCreationOptions = new AssistantCreationOptions();
        var model = await assistantClient.CreateAssistantAsync("testmodel", assistantCreationOptions);

        return new OpenAIAssistantAgent(model, assistantClient)
        {
            Kernel = this._emptyKernel
        };
    }

    private OpenAIClientProvider CreateTestClient(bool targetAzure = false)
        => targetAzure ?
            OpenAIClientProvider.ForAzureOpenAI(apiKey: new ApiKeyCredential("fakekey"), endpoint: new Uri("https://localhost"), this._httpClient) :
            OpenAIClientProvider.ForOpenAI(apiKey: new ApiKeyCredential("fakekey"), endpoint: null, this._httpClient);

    private void SetupResponse(HttpStatusCode statusCode, string content) =>
        this._messageHandlerStub.SetupResponses(statusCode, content);

    private void SetupResponse(HttpStatusCode statusCode, OpenAIAssistantDefinition definition) =>
        this._messageHandlerStub.SetupResponses(statusCode, OpenAIAssistantResponseContent.AssistantDefinition(definition));

    private void SetupResponse(HttpStatusCode statusCode, OpenAIAssistantCapabilities capabilities, PromptTemplateConfig templateConfig) =>
        this._messageHandlerStub.SetupResponses(statusCode, OpenAIAssistantResponseContent.AssistantDefinition(capabilities, templateConfig));

    private void SetupResponses(HttpStatusCode statusCode, params string[] content) =>
        this._messageHandlerStub.SetupResponses(statusCode, content);

    private sealed class MyPlugin
    {
        [KernelFunction]
        public void MyFunction(int index)
        { }
    }

    /// <summary>
    /// Helper class for testing AIFunction behavior.
    /// </summary>
    private sealed class TestAIFunction : AIFunction
    {
        public TestAIFunction(string name, string description = "")
        {
            this.Name = name;
            this.Description = description;
        }

        public override string Name { get; }

        public override string Description { get; }

        protected override ValueTask<object?> InvokeCoreAsync(AIFunctionArguments? arguments = null, CancellationToken cancellationToken = default)
        {
            return ValueTask.FromResult<object?>("Test result");
        }
    }
}
#pragma warning restore CS0419 // Ambiguous reference in cref attribute



===== UnitTests\OpenAI\OpenAIAssistantAgentThreadTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.ClientModel;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Threading.Tasks;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents.OpenAI;
using Microsoft.SemanticKernel.ChatCompletion;
using Moq;
using OpenAI;
using OpenAI.Assistants;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.OpenAI;

/// <summary>
/// Tests for the <see cref="OpenAIAssistantAgentThread"/> class.
/// </summary>
public class OpenAIAssistantAgentThreadTests : IDisposable
{
    private readonly HttpMessageHandlerStub _messageHandlerStub;
    private readonly HttpClient _httpClient;

    /// <summary>
    /// Initializes a new instance of the <see cref="OpenAIAssistantAgentThreadTests"/> class.
    /// </summary>
    public OpenAIAssistantAgentThreadTests()
    {
        this._messageHandlerStub = new HttpMessageHandlerStub();
        this._httpClient = new HttpClient(this._messageHandlerStub, disposeHandler: false);
    }

    /// <summary>
    /// Tests that the constructor verifies parameters and throws <see cref="ArgumentNullException"/> when necessary.
    /// </summary>
    [Fact]
    public void ConstructorShouldVerifyParams()
    {
        // Arrange
        var mockClient = new Mock<AssistantClient>();

        // Act & Assert
        Assert.Throws<ArgumentNullException>(() => new OpenAIAssistantAgentThread(null!));
        Assert.Throws<ArgumentNullException>(() => new OpenAIAssistantAgentThread(null!, "threadId"));
        Assert.Throws<ArgumentNullException>(() => new OpenAIAssistantAgentThread(mockClient.Object, id: null!));

        var thread = new OpenAIAssistantAgentThread(mockClient.Object);
        Assert.NotNull(thread);
    }

    /// <summary>
    /// Tests that the constructor for resuming a thread uses the provided parameters.
    /// </summary>
    [Fact]
    public void ConstructorForResumingThreadShouldUseParams()
    {
        // Arrange
        var mockClient = new Mock<AssistantClient>();

        // Act
        var threadWithId = new OpenAIAssistantAgentThread(mockClient.Object, "threadId");

        // Assert
        Assert.NotNull(threadWithId);
        Assert.Equal("threadId", threadWithId.Id);
    }

    /// <summary>
    /// Tests that the CreateAsync method invokes the client and sets the thread ID.
    /// </summary>
    [Fact]
    public async Task CreateShouldInvokeClientAsync()
    {
        // Arrange
        this._messageHandlerStub.SetupResponses(HttpStatusCode.OK, OpenAIAssistantResponseContent.CreateThread);

        var client = this.CreateTestClient();

        var thread = new OpenAIAssistantAgentThread(client.GetAssistantClient());

        // Act
        await thread.CreateAsync();

        // Assert
        Assert.Equal("thread_abc123", thread.Id);
        Assert.Empty(this._messageHandlerStub.ResponseQueue);
    }

    /// <summary>
    /// Tests that the CreateAsync method invokes the client and sets the thread ID.
    /// </summary>
    [Fact]
    public async Task CreateWithOptionsShouldInvokeClientAsync()
    {
        // Arrange
        this._messageHandlerStub.SetupResponses(HttpStatusCode.OK, OpenAIAssistantResponseContent.CreateThread);

        var client = this.CreateTestClient();

        var thread = new OpenAIAssistantAgentThread(client.GetAssistantClient(), new ThreadCreationOptions());

        // Act
        await thread.CreateAsync();

        // Assert
        Assert.Equal("thread_abc123", thread.Id);
        Assert.Empty(this._messageHandlerStub.ResponseQueue);
    }

    /// <summary>
    /// Tests that the CreateAsync method invokes the client and sets the thread ID.
    /// </summary>
    [Fact]
    public async Task CreateWithParamsShouldInvokeClientAsync()
    {
        // Arrange
        this._messageHandlerStub.SetupResponses(HttpStatusCode.OK, OpenAIAssistantResponseContent.CreateThread);

        var client = this.CreateTestClient();

        var thread = new OpenAIAssistantAgentThread(client.GetAssistantClient(), [new ChatMessageContent(AuthorRole.User, "Hello")]);

        // Act
        await thread.CreateAsync();

        // Assert
        Assert.Equal("thread_abc123", thread.Id);
        Assert.Empty(this._messageHandlerStub.ResponseQueue);
    }

    /// <summary>
    /// Tests that the DeleteAsync method invokes the client.
    /// </summary>
    [Fact]
    public async Task DeleteShouldInvokeClientAsync()
    {
        // Arrange
        this._messageHandlerStub.SetupResponses(HttpStatusCode.OK, OpenAIAssistantResponseContent.CreateThread);
        this._messageHandlerStub.SetupResponses(HttpStatusCode.OK, OpenAIAssistantResponseContent.DeleteThread);

        var client = this.CreateTestClient();

        var thread = new OpenAIAssistantAgentThread(client.GetAssistantClient());
        await thread.CreateAsync();

        // Act
        await thread.DeleteAsync();

        // Assert
        Assert.Empty(this._messageHandlerStub.ResponseQueue);
    }

    /// <summary>
    /// Tests that the GetMessagesAsync method invokes the client.
    /// </summary>
    [Fact]
    public async Task GetMessagesShouldInvokeClientAsync()
    {
        // Arrange
        this._messageHandlerStub.SetupResponses(HttpStatusCode.OK, OpenAIAssistantResponseContent.ListMessagesPageFinal);
        var client = this.CreateTestClient();
        var thread = new OpenAIAssistantAgentThread(client.GetAssistantClient(), "thread_abc123");

        // Act
        var messages = await thread.GetMessagesAsync().ToListAsync();

        // Assert
        Assert.NotNull(messages);
        Assert.Single(messages);
        Assert.Equal("How does AI work? Explain it in simple terms.", messages[0].Content);
        Assert.Empty(this._messageHandlerStub.ResponseQueue);
    }

    /// <summary>
    /// Tests that the GetMessagesAsync method creates a thread if it does not exist yet.
    /// </summary>
    [Fact]
    public async Task GetMessagesShouldCreateThreadAsync()
    {
        // Arrange
        this._messageHandlerStub.SetupResponses(HttpStatusCode.OK, OpenAIAssistantResponseContent.CreateThread);
        this._messageHandlerStub.SetupResponses(HttpStatusCode.OK, OpenAIAssistantResponseContent.ListMessagesPageFinal);
        var client = this.CreateTestClient();
        var thread = new OpenAIAssistantAgentThread(client.GetAssistantClient());

        // Act
        var messages = await thread.GetMessagesAsync().ToListAsync();

        // Assert
        Assert.NotNull(messages);
        Assert.Single(messages);
        Assert.Equal("How does AI work? Explain it in simple terms.", messages[0].Content);
        Assert.Empty(this._messageHandlerStub.ResponseQueue);
    }

    /// <summary>
    /// Tests that the GetMessagesAsync method throws for a deleted thread.
    /// </summary>
    [Fact]
    public async Task GetMessagesShouldThrowForDeletedThreadAsync()
    {
        // Arrange
        this._messageHandlerStub.SetupResponses(HttpStatusCode.OK, OpenAIAssistantResponseContent.CreateThread);
        this._messageHandlerStub.SetupResponses(HttpStatusCode.OK, OpenAIAssistantResponseContent.DeleteThread);

        var client = this.CreateTestClient();

        var thread = new OpenAIAssistantAgentThread(client.GetAssistantClient());
        await thread.CreateAsync();
        await thread.DeleteAsync();

        // Act
        await Assert.ThrowsAsync<InvalidOperationException>(async () => await thread.GetMessagesAsync().ToListAsync());
    }

    /// <inheritdoc/>
    public void Dispose()
    {
        this._messageHandlerStub.Dispose();
        this._httpClient.Dispose();

        GC.SuppressFinalize(this);
    }

    private OpenAIClient CreateTestClient()
        => OpenAIAssistantAgent.CreateOpenAIClient(apiKey: new ApiKeyCredential("fakekey"), endpoint: null, this._httpClient);
}


===== UnitTests\OpenAI\OpenAIAssistantDefinitionTests.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Collections.Generic;
using System.Text.Json;
using Microsoft.SemanticKernel.Agents.OpenAI;
using SemanticKernel.Agents.UnitTests.Test;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.OpenAI;

/// <summary>
/// Unit testing of <see cref="OpenAIAssistantDefinition"/>.
/// </summary>
public class OpenAIAssistantDefinitionTests
{
    /// <summary>
    /// Verify initial state.
    /// </summary>
    [Fact]
    public void VerifyOpenAIAssistantDefinitionInitialState()
    {
        // Arrange
        OpenAIAssistantDefinition definition = new("testmodel");

        // Assert
        Assert.Equal(string.Empty, definition.Id);
        Assert.Equal("testmodel", definition.ModelId);
        Assert.Null(definition.Name);
        Assert.Null(definition.Instructions);
        Assert.Null(definition.Description);
        Assert.Null(definition.Metadata);
        Assert.Null(definition.ExecutionOptions);
        Assert.Null(definition.Temperature);
        Assert.Null(definition.TopP);
        Assert.False(definition.EnableFileSearch);
        Assert.Null(definition.VectorStoreId);
        Assert.Null(definition.CodeInterpreterFileIds);
        Assert.False(definition.EnableCodeInterpreter);
        Assert.False(definition.EnableJsonResponse);

        // Act and Assert
        ValidateSerialization(definition);
    }

    /// <summary>
    /// Verify initialization.
    /// </summary>
    [Fact]
    public void VerifyOpenAIAssistantDefinitionAssignment()
    {
        // Arrange
        OpenAIAssistantDefinition definition =
            new("testmodel")
            {
                Id = "testid",
                Name = "testname",
                Instructions = "testinstructions",
                Description = "testdescription",
                EnableFileSearch = true,
                VectorStoreId = "#vs",
                Metadata = new Dictionary<string, string>() { { "a", "1" } },
                Temperature = 2,
                TopP = 0,
                ExecutionOptions =
                    new()
                    {
                        AdditionalInstructions = "test instructions",
                        MaxCompletionTokens = 1000,
                        MaxPromptTokens = 1000,
                        ParallelToolCallsEnabled = false,
                        TruncationMessageCount = 12,
                    },
                CodeInterpreterFileIds = ["file1"],
                EnableCodeInterpreter = true,
                EnableJsonResponse = true,
            };

        // Assert
        Assert.Equal("testid", definition.Id);
        Assert.Equal("testname", definition.Name);
        Assert.Equal("testmodel", definition.ModelId);
        Assert.Equal("testinstructions", definition.Instructions);
        Assert.Equal("testdescription", definition.Description);
        Assert.True(definition.EnableFileSearch);
        Assert.Equal("#vs", definition.VectorStoreId);
        Assert.Equal(2, definition.Temperature);
        Assert.Equal(0, definition.TopP);
        Assert.NotNull(definition.ExecutionOptions);
        Assert.Equal("test instructions", definition.ExecutionOptions.AdditionalInstructions);
        Assert.Equal(1000, definition.ExecutionOptions.MaxCompletionTokens);
        Assert.Equal(1000, definition.ExecutionOptions.MaxPromptTokens);
        Assert.Equal(12, definition.ExecutionOptions.TruncationMessageCount);
        Assert.False(definition.ExecutionOptions.ParallelToolCallsEnabled);
        Assert.Single(definition.Metadata);
        Assert.Single(definition.CodeInterpreterFileIds);
        Assert.True(definition.EnableCodeInterpreter);
        Assert.True(definition.EnableJsonResponse);

        // Act and Assert
        ValidateSerialization(definition);
    }

    /// <summary>
    /// Verify TemplateFactoryFormat.
    /// </summary>
    [Fact]
    public void VerifyOpenAIAssistantDefinitionTemplateFactoryFormat()
    {
        // Arrange
        OpenAIAssistantDefinition definition = new("testmodel");

        // Assert
        Assert.Null(definition.TemplateFactoryFormat);

        // Act
        definition = new("testmodel")
        {
            Metadata = new Dictionary<string, string>() { { OpenAIAssistantAgent.TemplateMetadataKey, "testformat" } }
        };

        // Assert
        Assert.Equal("testformat", definition.TemplateFactoryFormat);
    }

    private static void ValidateSerialization(OpenAIAssistantDefinition source)
    {
        string json = JsonSerializer.Serialize(source);

        OpenAIAssistantDefinition? target = JsonSerializer.Deserialize<OpenAIAssistantDefinition>(json);

        Assert.NotNull(target);
        Assert.Equal(source.Id, target.Id);
        Assert.Equal(source.Name, target.Name);
        Assert.Equal(source.ModelId, target.ModelId);
        Assert.Equal(source.Instructions, target.Instructions);
        Assert.Equal(source.Description, target.Description);
        Assert.Equal(source.EnableFileSearch, target.EnableFileSearch);
        Assert.Equal(source.VectorStoreId, target.VectorStoreId);
        Assert.Equal(source.Temperature, target.Temperature);
        Assert.Equal(source.TopP, target.TopP);
        Assert.Equal(source.EnableFileSearch, target.EnableFileSearch);
        Assert.Equal(source.VectorStoreId, target.VectorStoreId);
        Assert.Equal(source.EnableCodeInterpreter, target.EnableCodeInterpreter);
        Assert.Equal(source.ExecutionOptions?.MaxCompletionTokens, target.ExecutionOptions?.MaxCompletionTokens);
        Assert.Equal(source.ExecutionOptions?.MaxPromptTokens, target.ExecutionOptions?.MaxPromptTokens);
        Assert.Equal(source.ExecutionOptions?.TruncationMessageCount, target.ExecutionOptions?.TruncationMessageCount);
        Assert.Equal(source.ExecutionOptions?.ParallelToolCallsEnabled, target.ExecutionOptions?.ParallelToolCallsEnabled);
        AssertCollection.Equal(source.CodeInterpreterFileIds, target.CodeInterpreterFileIds);
        AssertCollection.Equal(source.Metadata, target.Metadata);
    }
}


===== UnitTests\OpenAI\OpenAIAssistantInvocationOptionsTests.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Collections.Generic;
using System.Text.Json;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents.OpenAI;
using Microsoft.SemanticKernel.ChatCompletion;
using SemanticKernel.Agents.UnitTests.Test;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.OpenAI;

/// <summary>
/// Unit testing of <see cref="OpenAIAssistantInvocationOptions"/>.
/// </summary>
public class OpenAIAssistantInvocationOptionsTests
{
    /// <summary>
    /// Verify initial state.
    /// </summary>
    [Fact]
    public void OpenAIAssistantInvocationOptionsInitialState()
    {
        // Arrange
        OpenAIAssistantInvocationOptions options = new();

        // Assert
        Assert.Null(options.ModelName);
        Assert.Null(options.AdditionalInstructions);
        Assert.Null(options.AdditionalMessages);
        Assert.Null(options.Metadata);
        Assert.Null(options.Temperature);
        Assert.Null(options.TopP);
        Assert.Null(options.ParallelToolCallsEnabled);
        Assert.Null(options.MaxCompletionTokens);
        Assert.Null(options.MaxPromptTokens);
        Assert.Null(options.TruncationMessageCount);
        Assert.Null(options.EnableJsonResponse);
        Assert.False(options.EnableCodeInterpreter);
        Assert.False(options.EnableFileSearch);

        // Act and Assert
        ValidateSerialization(options);
    }

    /// <summary>
    /// Verify initialization.
    /// </summary>
    [Fact]
    public void OpenAIAssistantInvocationOptionsAssignment()
    {
        // Arrange
        OpenAIAssistantInvocationOptions options =
            new()
            {
                ModelName = "testmodel",
                AdditionalInstructions = "test instructions",
                AdditionalMessages = [
                    new ChatMessageContent(AuthorRole.User, "test message")
                ],
                Metadata = new Dictionary<string, string>() { { "a", "1" } },
                MaxCompletionTokens = 1000,
                MaxPromptTokens = 1000,
                ParallelToolCallsEnabled = false,
                TruncationMessageCount = 12,
                Temperature = 2,
                TopP = 0,
                EnableCodeInterpreter = true,
                EnableJsonResponse = true,
                EnableFileSearch = true,
            };

        // Assert
        Assert.Equal("testmodel", options.ModelName);
        Assert.Equal("test instructions", options.AdditionalInstructions);
        Assert.Single(options.AdditionalMessages);
        Assert.Equal(2, options.Temperature);
        Assert.Equal(0, options.TopP);
        Assert.Equal(1000, options.MaxCompletionTokens);
        Assert.Equal(1000, options.MaxPromptTokens);
        Assert.Equal(12, options.TruncationMessageCount);
        Assert.False(options.ParallelToolCallsEnabled);
        Assert.Single(options.Metadata);
        Assert.True(options.EnableCodeInterpreter);
        Assert.True(options.EnableJsonResponse);
        Assert.True(options.EnableFileSearch);

        // Act and Assert
        ValidateSerialization(options);
    }

    private static void ValidateSerialization(OpenAIAssistantInvocationOptions source)
    {
        // Act
        string json = JsonSerializer.Serialize(source);

        OpenAIAssistantInvocationOptions? target = JsonSerializer.Deserialize<OpenAIAssistantInvocationOptions>(json);

        // Assert
        Assert.NotNull(target);
        Assert.Equal(source.AdditionalInstructions, target.AdditionalInstructions);
        Assert.Equivalent(source.AdditionalMessages, target.AdditionalMessages);
        Assert.Equal(source.ModelName, target.ModelName);
        Assert.Equal(source.Temperature, target.Temperature);
        Assert.Equal(source.TopP, target.TopP);
        Assert.Equal(source.MaxCompletionTokens, target.MaxCompletionTokens);
        Assert.Equal(source.MaxPromptTokens, target.MaxPromptTokens);
        Assert.Equal(source.TruncationMessageCount, target.TruncationMessageCount);
        Assert.Equal(source.EnableCodeInterpreter, target.EnableCodeInterpreter);
        Assert.Equal(source.EnableJsonResponse, target.EnableJsonResponse);
        Assert.Equal(source.EnableFileSearch, target.EnableFileSearch);
        AssertCollection.Equal(source.Metadata, target.Metadata);
    }
}


===== UnitTests\OpenAI\OpenAIAssistantResponseContent.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Text;
using System.Text.Json;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents.OpenAI;
using OpenAI.Assistants;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.OpenAI;

/// <summary>
/// Mock response payloads for <see cref="OpenAIAssistantAgent"/>.
/// </summary>
internal static class OpenAIAssistantResponseContent
{
    /// <summary>
    /// Setup the response content for the <see cref="HttpMessageHandlerStub"/>.
    /// </summary>
    public static void SetupResponse(this HttpMessageHandlerStub messageHandlerStub, HttpStatusCode statusCode, string content)
    {
        messageHandlerStub.ResponseToReturn =
            new HttpResponseMessage(statusCode)
            {
                Content = new StringContent(content)
            };
    }

    /// <summary>
    /// Setup the response content for the <see cref="HttpMessageHandlerStub"/>.
    /// </summary>
    public static void SetupResponses(this HttpMessageHandlerStub messageHandlerStub, HttpStatusCode statusCode, params string[] content)
    {
        foreach (var item in content)
        {
#pragma warning disable CA2000 // Dispose objects before losing scope
            messageHandlerStub.ResponseQueue.Enqueue(
                new(statusCode)
                {
                    Content = new StreamContent(new MemoryStream(Encoding.UTF8.GetBytes(item)))
                });
#pragma warning restore CA2000 // Dispose objects before losing scope
        }
    }

    private const string AssistantId = "asst_abc123";
    private const string ThreadId = "thread_abc123";
    private const string RunId = "run_abc123";
    private const string MessageId = "msg_abc123";
    private const string StepId = "step_abc123";

    #region Assistant

    /// <summary>
    /// The response for creating or querying an assistant definition.
    /// </summary>
    public static string AssistantDefinition(OpenAIAssistantCapabilities capabilities, PromptTemplateConfig templateConfig) =>
        AssistantDefinition(templateConfig.Name, templateConfig.Template, templateConfig.Description, capabilities);

    /// <summary>
    /// The response for creating or querying an assistant definition.
    /// </summary>
    public static string AssistantDefinition(OpenAIAssistantDefinition definition) =>
        AssistantDefinition(definition.Name, definition.Instructions, definition.Description, definition);

    /// <summary>
    /// The response for creating or querying an assistant definition.
    /// </summary>
    public static string AssistantDefinition(
        string? name,
        string? instructions,
        string? description,
        OpenAIAssistantCapabilities capabilities)
    {
        StringBuilder builder = new();
        builder.AppendLine("{");
        builder.AppendLine(@$"  ""id"": ""{AssistantId}"",");
        builder.AppendLine(@"  ""object"": ""assistant"",");
        builder.AppendLine(@"  ""created_at"": 1698984975,");
        builder.AppendLine(@$"  ""name"": ""{name}"",");
        builder.AppendLine(@$"  ""description"": ""{description}"",");
        builder.AppendLine(@$"  ""instructions"": ""{instructions}"",");
        builder.AppendLine(@$"  ""model"": ""{capabilities.ModelId}"",");

        bool hasCodeInterpreter = capabilities.EnableCodeInterpreter;
        bool hasCodeInterpreterFiles = (capabilities.CodeInterpreterFileIds?.Count ?? 0) > 0;
        bool hasFileSearch = capabilities.EnableFileSearch;
        if (!hasCodeInterpreter && !hasFileSearch)
        {
            builder.AppendLine(@"  ""tools"": [],");
        }
        else
        {
            builder.AppendLine(@"  ""tools"": [");

            if (hasCodeInterpreter)
            {
                builder.Append(@$"  {{ ""type"": ""code_interpreter"" }}{(hasFileSearch ? "," : string.Empty)}");
            }

            if (hasFileSearch)
            {
                builder.AppendLine(@"  { ""type"": ""file_search"" }");
            }

            builder.AppendLine("    ],");
        }

        if (!hasCodeInterpreterFiles && !hasFileSearch)
        {
            builder.AppendLine(@"  ""tool_resources"": {},");
        }
        else
        {
            builder.AppendLine(@"  ""tool_resources"": {");

            if (hasCodeInterpreterFiles)
            {
                string fileIds = string.Join(",", capabilities.CodeInterpreterFileIds!.Select(fileId => "\"" + fileId + "\""));
                builder.AppendLine(@$"  ""code_interpreter"": {{ ""file_ids"": [{fileIds}] }}{(hasFileSearch ? "," : string.Empty)}");
            }

            if (hasFileSearch && capabilities.VectorStoreId != null)
            {
                builder.AppendLine(@$"  ""file_search"": {{ ""vector_store_ids"": [""{capabilities.VectorStoreId}""] }}");
            }

            builder.AppendLine("    },");
        }

        if (capabilities.Temperature.HasValue)
        {
            builder.AppendLine(@$"  ""temperature"": {capabilities.Temperature},");
        }

        if (capabilities.TopP.HasValue)
        {
            builder.AppendLine(@$"  ""top_p"": {capabilities.TopP},");
        }

        bool hasExecutionOptions = capabilities.ExecutionOptions != null;
        int metadataCount = (capabilities.Metadata?.Count ?? 0);
        if (metadataCount == 0 && !hasExecutionOptions)
        {
            builder.AppendLine(@"  ""metadata"": {}");
        }
        else
        {
            int index = 0;
            builder.AppendLine(@"  ""metadata"": {");

            if (hasExecutionOptions)
            {
                string serializedExecutionOptions = JsonSerializer.Serialize(capabilities.ExecutionOptions);
                builder.AppendLine(@$"    ""{OpenAIAssistantAgent.OptionsMetadataKey}"": ""{JsonEncodedText.Encode(serializedExecutionOptions)}""{(metadataCount > 0 ? "," : string.Empty)}");
            }

            if (metadataCount > 0)
            {
                foreach (var (key, value) in capabilities.Metadata!)
                {
                    builder.AppendLine(@$"    ""{key}"": ""{value}""{(index < metadataCount - 1 ? "," : string.Empty)}");
                    ++index;
                }
            }

            builder.AppendLine("  }");
        }

        builder.AppendLine("}");

        return builder.ToString();
    }

    /// <summary>
    /// The response for creating or querying an assistant definition.
    /// </summary>
    public static string AssistantDefinition(
        string modelId,
        string? name = null,
        string? description = null,
        string? instructions = null,
        bool enableCodeInterpreter = false,
        IReadOnlyList<string>? codeInterpreterFileIds = null,
        bool enableFileSearch = false,
        string? vectorStoreId = null,
        float? temperature = null,
        float? topP = null,
        AssistantResponseFormat? responseFormat = null,
        IReadOnlyDictionary<string, string>? metadata = null)
    {
        StringBuilder builder = new();
        builder.AppendLine("{");
        builder.AppendLine(@$"  ""id"": ""{AssistantId}"",");
        builder.AppendLine(@"  ""object"": ""assistant"",");
        builder.AppendLine(@"  ""created_at"": 1698984975,");
        builder.AppendLine(@$"  ""name"": ""{name}"",");
        builder.AppendLine(@$"  ""description"": ""{description}"",");
        builder.AppendLine(@$"  ""instructions"": ""{instructions}"",");
        builder.AppendLine(@$"  ""model"": ""{modelId}"",");

        bool hasCodeInterpreterFiles = (codeInterpreterFileIds?.Count ?? 0) > 0;
        bool hasCodeInterpreter = enableCodeInterpreter || hasCodeInterpreterFiles;
        bool hasFileSearch = enableFileSearch || vectorStoreId != null;
        if (!hasCodeInterpreter && !hasFileSearch)
        {
            builder.AppendLine(@"  ""tools"": [],");
        }
        else
        {
            builder.AppendLine(@"  ""tools"": [");

            if (hasCodeInterpreter)
            {
                builder.Append(@$"  {{ ""type"": ""code_interpreter"" }}{(hasFileSearch ? "," : string.Empty)}");
            }

            if (hasFileSearch)
            {
                builder.AppendLine(@"  { ""type"": ""file_search"" }");
            }

            builder.AppendLine("    ],");
        }

        if (!hasCodeInterpreterFiles && !hasFileSearch)
        {
            builder.AppendLine(@"  ""tool_resources"": {},");
        }
        else
        {
            builder.AppendLine(@"  ""tool_resources"": {");

            if (hasCodeInterpreterFiles)
            {
                string fileIds = string.Join(",", codeInterpreterFileIds!.Select(fileId => "\"" + fileId + "\""));
                builder.AppendLine(@$"  ""code_interpreter"": {{ ""file_ids"": [{fileIds}] }}{(hasFileSearch ? "," : string.Empty)}");
            }

            if (hasFileSearch && vectorStoreId != null)
            {
                builder.AppendLine(@$"  ""file_search"": {{ ""vector_store_ids"": [""{vectorStoreId}""] }}");
            }

            builder.AppendLine("    },");
        }

        if (temperature.HasValue)
        {
            builder.AppendLine(@$"  ""temperature"": {temperature},");
        }

        if (topP.HasValue)
        {
            builder.AppendLine(@$"  ""top_p"": {topP},");
        }
        int metadataCount = (metadata?.Count ?? 0);
        if (metadataCount == 0)
        {
            builder.AppendLine(@"  ""metadata"": {}");
        }
        else
        {
            int index = 0;
            builder.AppendLine(@"  ""metadata"": {");

            if (metadataCount > 0)
            {
                foreach (var (key, value) in metadata!)
                {
                    builder.AppendLine(@$"    ""{key}"": ""{value}""{(index < metadataCount - 1 ? "," : string.Empty)}");
                    ++index;
                }
            }

            builder.AppendLine("  }");
        }

        builder.AppendLine("}");

        return builder.ToString();
    }

    public const string DeleteAgent =
        $$$"""
        {
            "id": "{{{AssistantId}}}",
            "object": "assistant.deleted",
            "deleted": true
        }
        """;

    public const string CreateThread =
        $$$"""
        {
            "id": "{{{ThreadId}}}",
            "object": "thread",
            "created_at": 1699012949,
            "metadata": {}
        }
        """;

    public const string DeleteThread =
        $$$"""
        {
            "id": "{{{ThreadId}}}",
            "object": "thread.deleted",
            "deleted": true
        }
        """;

    public const string ToolResponse = "{ }";

    public const string GetImageMessage =
        $$$"""
        {
            "id": "{{{MessageId}}}",
            "object": "thread.message",
            "created_at": 1699017614,
            "thread_id": "{{{ThreadId}}}",
            "role": "user",
            "content": [
            {
                "type": "image_file",
                "image_file": {
                "file_id": "file_123"
                }
            }
            ],
            "assistant_id": "{{{AssistantId}}}",
            "run_id": "{{{RunId}}}"
        }
        """;

    public static string GetTextMessage(string text = "test") =>
        $$$"""
        {
            "id": "{{{MessageId}}}",
            "object": "thread.message",
            "created_at": 1699017614,
            "thread_id": "{{{ThreadId}}}",
            "role": "user",
            "content": [
            {
                "type": "text",
                "text": {
                "value": "{{{text}}}",
                "annotations": []
                }
            }
            ],
            "assistant_id": "{{{AssistantId}}}",
            "run_id": "{{{RunId}}}"
        }
        """;

    public const string GetTextMessageWithAnnotation =
        $$$"""
        {
            "id": "{{{MessageId}}}",
            "object": "thread.message",
            "created_at": 1699017614,
            "thread_id": "{{{ThreadId}}}",
            "role": "user",
            "content": [
            {
                "type": "text",
                "text": {
                "value": "How does AI work? Explain it in simple terms.**f1",
                "annotations": [
                    {
                        "type": "file_citation",
                        "text": "**f1",
                        "file_citation": {
                            "file_id": "file_123",
                            "quote": "does"
                        },
                        "start_index": 3,
                        "end_index": 6
                    }
                ]
                }
            }
            ],
            "assistant_id": "{{{AssistantId}}}",
            "run_id": "{{{RunId}}}"
        }
        """;

    public const string ListAgentsPageMore =
        $$$"""
        {
            "object": "list",
            "data": [
            {
                "id": "{{{AssistantId}}}",
                "object": "assistant",
                "created_at": 1698982736,
                "name": "Coding Tutor",
                "description": null,
                "model": "gpt-4-turbo",
                "instructions": "You are a helpful assistant designed to make me better at coding!",
                "tools": [],
                "metadata": {}
            },
            {
                "id": "asst_abc456",
                "object": "assistant",
                "created_at": 1698982718,
                "name": "My Assistant",
                "description": null,
                "model": "gpt-4-turbo",
                "instructions": "You are a helpful assistant designed to make me better at coding!",
                "tools": [],
                "metadata": {}
            },
            {
                "id": "asst_abc789",
                "object": "assistant",
                "created_at": 1698982643,
                "name": null,
                "description": null,
                "model": "gpt-4-turbo",
                "instructions": null,
                "tools": [],
                "metadata": {}
            }
            ],
            "first_id": "{{{AssistantId}}}",
            "last_id": "asst_abc789",
            "has_more": true
        }
        """;

    public const string ListAgentsPageFinal =
        """
        {
            "object": "list",
            "data": [
            {
                "id": "asst_abc789",
                "object": "assistant",
                "created_at": 1698982736,
                "name": "Coding Tutor",
                "description": null,
                "model": "gpt-4-turbo",
                "instructions": "You are a helpful assistant designed to make me better at coding!",
                "tools": [],
                "metadata": {}
            }           
            ],
            "first_id": "asst_abc789",
            "last_id": "asst_abc789",
            "has_more": false
        }
        """;

    public const string ListMessagesPageMore =
        $$$"""
        {
            "object": "list",
            "data": [
            {
                "id": "{{{MessageId}}}",
                "object": "thread.message",
                "created_at": 1699016383,
                "thread_id": "{{{ThreadId}}}",
                "role": "user",
                "content": [
                {
                    "type": "text",
                    "text": {
                    "value": "How does AI work? Explain it in simple terms.",
                    "annotations": []
                    }
                }
                ],
                "file_ids": [],
                "assistant_id": null,
                "run_id": null,
                "metadata": {}
            },
            {
                "id": "msg_abc456",
                "object": "thread.message",
                "created_at": 1699016383,
                "thread_id": "{{{ThreadId}}}",
                "role": "user",
                "content": [
                {
                    "type": "text",
                    "text": {
                    "value": "Hello, what is AI?",
                    "annotations": []
                    }
                }
                ],
                "file_ids": [
                "file-abc123"
                ],
                "assistant_id": null,
                "run_id": null,
                "metadata": {}
            }
            ],
            "first_id": "{{{MessageId}}}",
            "last_id": "msg_abc456",
            "has_more": true
        }
        """;

    public const string ListMessagesPageFinal =
        $$$"""
        {
            "object": "list",
            "data": [
            {
                "id": "msg_abc789",
                "object": "thread.message",
                "created_at": 1699016383,
                "thread_id": "{{{ThreadId}}}",
                "role": "user",
                "content": [
                {
                    "type": "text",
                    "text": {
                    "value": "How does AI work? Explain it in simple terms.",
                    "annotations": []
                    }
                }
                ],
                "file_ids": [],
                "assistant_id": null,
                "run_id": null,
                "metadata": {}
            }
            ],
            "first_id": "msg_abc789",
            "last_id": "msg_abc789",
            "has_more": false
        }
        """;

    public static string UploadFile =
        """
        {
          "id": "file-abc123",
          "object": "file",
          "bytes": 120000,
          "created_at": 1677610602,
          "filename": "test.txt",
          "purpose": "assistants"
        }
        """;

    public static string DeleteFile =
        """
        {
          "id": "file-abc123",
          "object": "file",
          "deleted": true
        }
        """;

    public static string CreateVectorStore =
        """
        {
          "id": "vs_abc123",
          "object": "vector_store",
          "created_at": 1699061776,
          "name": "test store",
          "bytes": 139920,
          "file_counts": {
            "in_progress": 0,
            "completed": 3,
            "failed": 0,
            "cancelled": 0,
            "total": 3
          }
        }      
        """;

    public static string DeleteVectorStore =
        """
        {
          "id": "vs-abc123",
          "object": "vector_store.deleted",
          "deleted": true
        }
        """;

    #endregion

    /// <summary>
    /// Response payloads for a "regular" assistant run.
    /// </summary>
    public static class Run
    {
        public const string CreateRun =
            $$$"""
            {
              "id": "{{{RunId}}}",
              "object": "thread.run",
              "created_at": 1699063290,
              "assistant_id": "{{{AssistantId}}}",
              "thread_id": "{{{ThreadId}}}",
              "status": "queued",
              "started_at": 1699063290,
              "expires_at": null,
              "cancelled_at": null,
              "failed_at": null,
              "completed_at": 1699063291,
              "last_error": null,
              "model": "gpt-4-turbo",
              "instructions": null,
              "tools": [],
              "file_ids": [],
              "metadata": {},
              "usage": null,
              "temperature": 1
            }
            """;

        public const string PendingRun =
            $$$"""
            {
              "id": "{{{RunId}}}",
              "object": "thread.run",
              "created_at": 1699063290,
              "assistant_id": "{{{AssistantId}}}",
              "thread_id": "{{{ThreadId}}}",
              "status": "requires_action",
              "started_at": 1699063290,
              "expires_at": null,
              "cancelled_at": null,
              "failed_at": null,
              "completed_at": 1699063291,
              "last_error": null,
              "model": "gpt-4-turbo",
              "instructions": null,
              "tools": [],
              "file_ids": [],
              "metadata": {},
              "usage": null,
              "temperature": 1
            }
            """;

        public const string CompletedRun =
            $$$"""
            {
              "id": "{{{RunId}}}",
              "object": "thread.run",
              "created_at": 1699063290,
              "assistant_id": "{{{AssistantId}}}",
              "thread_id": "{{{ThreadId}}}",
              "status": "completed",
              "started_at": 1699063290,
              "expires_at": null,
              "cancelled_at": null,
              "failed_at": null,
              "completed_at": 1699063291,
              "last_error": null,
              "model": "gpt-4-turbo",
              "instructions": null,
              "tools": [],
              "file_ids": [],
              "metadata": {},
              "usage": null,
              "temperature": 1
            }
            """;

        public const string MessageSteps =
            $$$"""
            {
              "object": "list",
              "data": [
                {
                  "id": "{{{StepId}}}",
                  "object": "thread.run.step",
                  "created_at": 1699063291,
                  "run_id": "{{{RunId}}}",
                  "assistant_id": "{{{AssistantId}}}",
                  "thread_id": "{{{ThreadId}}}",
                  "type": "message_creation",
                  "status": "completed",
                  "cancelled_at": null,
                  "completed_at": 1699063291,
                  "expired_at": null,
                  "failed_at": null,
                  "last_error": null,
                  "step_details": {
                    "type": "message_creation",
                    "message_creation": {
                      "message_id": "{{{MessageId}}}"
                    }
                  },
                  "usage": {
                    "prompt_tokens": 123,
                    "completion_tokens": 456,
                    "total_tokens": 579
                  }
                }
              ],
              "first_id": "{{{StepId}}}",
              "last_id": "step_abc456",
              "has_more": false
            }
            """;

        public const string ToolSteps =
            $$$"""
            {
              "object": "list",
              "data": [
                {
                  "id": "step_abc987",
                  "object": "thread.run.step",
                  "created_at": 1699063291,
                  "run_id": "{{{RunId}}}",
                  "assistant_id": "{{{AssistantId}}}",
                  "thread_id": "{{{ThreadId}}}",
                  "type": "tool_calls",
                  "status": "in_progress",
                  "cancelled_at": null,
                  "completed_at": 1699063291,
                  "expired_at": null,
                  "failed_at": null,
                  "last_error": null,
                  "step_details": {
                    "type": "tool_calls",
                    "tool_calls": [
                     {
                        "id": "tool_1",
                        "type": "function",
                        "function": {
                            "name": "MyPlugin-MyFunction",
                            "arguments": "{ \"index\": 3 }",
                            "output": "test"
                        }
                     }
                    ]
                  },
                  "usage": {
                    "prompt_tokens": 123,
                    "completion_tokens": 456,
                    "total_tokens": 579
                  }
                }
              ],
              "first_id": "{{{StepId}}}",
              "last_id": "step_abc456",
              "has_more": false
            }
            """;
    }

    /// <summary>
    /// Response payloads for a streaming assistant run.
    /// </summary>
    public static class Streaming
    {
        public static string Response(params string[] eventPayloads)
        {
            StringBuilder builder = new();

            foreach (string payload in eventPayloads)
            {
                builder.Append(payload);
                builder.AppendLine();
                builder.AppendLine();
            }

            return builder.ToString();
        }

        public const string Done =
            """
            event: thread.done
            data: [DONE]
            """;

        public static string CreateRun(string eventType)
        {
            int? createdAt = null;
            int? startedAt = null;
            int? completedAt = null;
            int? expiresAt = null;
            string? status = null;

            switch (eventType)
            {
                case "created":
                    status = "created";
                    createdAt = 1725978974;
                    break;
                case "queued":
                    status = "queued";
                    createdAt = 1725978974;
                    break;
                case "in_progress":
                    status = "in_progress";
                    createdAt = 1725978974;
                    startedAt = 1725978975;
                    expiresAt = 1725979576;
                    break;
                case "completed":
                    status = "completed";
                    createdAt = 1725978974;
                    startedAt = 1725978975;
                    expiresAt = 1725979576;
                    completedAt = 1725978976;
                    break;
            }

            Assert.NotNull(status);

            return
                CreateEvent(
                    $"thread.run.{eventType}",
                    $$$"""
                    {
                      "id": "{{{RunId}}}",
                      "object": "thread.run",
                      "assistant_id": "{{{AssistantId}}}",
                      "thread_id": "{{{ThreadId}}}",
                      "status": "{{{status}}}",
                      "created_at": {{{ParseTimestamp(createdAt)}}},
                      "started_at": {{{ParseTimestamp(startedAt)}}},
                      "expires_at": {{{ParseTimestamp(expiresAt)}}},
                      "completed_at": {{{ParseTimestamp(completedAt)}}},
                      "required_action": null,
                      "model": "gpt-4o-mini",
                      "instructions": "test",
                      "tools": [],
                      "metadata": {},
                      "temperature": 1.0,
                      "top_p": 1.0,
                      "truncation_strategy": { "type": "auto" },
                      "incomplete_details": null,
                      "usage": null,
                      "response_format": "auto",
                      "tool_choice": "auto",
                      "parallel_tool_calls": true
                    }
                    """);
        }

        public static string DeltaMessage(string text) =>
                CreateEvent(
                    "thread.message.delta",
                    $$$"""
                    {
                      "id": "{{{MessageId}}}",
                      "object": "thread.message.delta",
                      "delta": {
                        "content": [
                          {
                            "index": 0,
                            "type": "text",
                            "text": { "value": "{{{text}}}", "annotations": [] }
                          }
                        ]
                      }
                    }
                    """);

        private static string ParseTimestamp(int? timestamp)
        {
            if (timestamp.HasValue)
            {
                return timestamp.Value.ToString();
            }

            return "0";
        }

        private static string CreateEvent(string eventType, string data) =>
            $"""
            event: {eventType}
            data: {data.Replace("\n", string.Empty).Replace("\r", string.Empty)}
            """;
    }
}


===== UnitTests\OpenAI\OpenAIClientProviderTests.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.ClientModel;
using System.Net.Http;
using Azure.Core;
using Microsoft.SemanticKernel.Agents.OpenAI;
using Moq;
using OpenAI;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.OpenAI;

/// <summary>
/// Unit testing of <see cref="OpenAIClientProvider"/>.
/// </summary>
public class OpenAIClientProviderTests
{
    /// <summary>
    /// Verify that provisioning of client for Azure OpenAI.
    /// </summary>
    [Fact]
    public void VerifyOpenAIClientProviderTargetAzureByKey()
    {
        // Act
        OpenAIClientProvider provider = OpenAIClientProvider.ForAzureOpenAI(new ApiKeyCredential("key"), new Uri("https://localhost"));

        // Assert
        Assert.NotNull(provider.Client);
    }

    /// <summary>
    /// Verify that provisioning of client for Azure OpenAI.
    /// </summary>
    [Fact]
    public void VerifyOpenAIClientProviderTargetAzureByCredential()
    {
        // Arrange
        Mock<TokenCredential> mockCredential = new();

        // Act
        OpenAIClientProvider provider = OpenAIClientProvider.ForAzureOpenAI(mockCredential.Object, new Uri("https://localhost"));

        // Assert
        Assert.NotNull(provider.Client);
    }

    /// <summary>
    /// Verify that provisioning of client for OpenAI.
    /// </summary>
    [Theory]
    [InlineData(null)]
    [InlineData("http://myproxy:9819")]
    public void VerifyOpenAIClientProviderTargetOpenAINoKey(string? endpoint)
    {
        // Act
        OpenAIClientProvider provider = OpenAIClientProvider.ForOpenAI(endpoint != null ? new Uri(endpoint) : null);

        // Assert
        Assert.NotNull(provider.Client);
    }

    /// <summary>
    /// Verify that provisioning of client for OpenAI.
    /// </summary>
    [Theory]
    [InlineData("key", null)]
    [InlineData("key", "http://myproxy:9819")]
    public void VerifyOpenAIClientProviderTargetOpenAIByKey(string key, string? endpoint)
    {
        // Act
        OpenAIClientProvider provider = OpenAIClientProvider.ForOpenAI(new ApiKeyCredential(key), endpoint != null ? new Uri(endpoint) : null);

        // Assert
        Assert.NotNull(provider.Client);
    }

    /// <summary>
    /// Verify that the factory can create a client with http proxy.
    /// </summary>
    [Fact]
    public void VerifyOpenAIClientProviderWithHttpClient()
    {
        // Arrange
        using HttpClient httpClient = new() { BaseAddress = new Uri("http://myproxy:9819") };

        // Act
        OpenAIClientProvider provider = OpenAIClientProvider.ForOpenAI(httpClient: httpClient);

        // Assert
        Assert.NotNull(provider.Client);

        // Arrange
        using HttpClient httpClientWithHeaders = new() { BaseAddress = new Uri("http://myproxy:9819") };
        httpClientWithHeaders.DefaultRequestHeaders.Add("X-Test", "Test");

        // Act
        OpenAIClientProvider providerWithHeaders = OpenAIClientProvider.ForOpenAI(httpClient: httpClientWithHeaders);

        // Assert
        Assert.NotNull(providerWithHeaders.Client);

        Assert.NotEqual(provider.ConfigurationKeys.Count, providerWithHeaders.ConfigurationKeys.Count);
    }

    /// <summary>
    /// Verify that the factory can create a client with http proxy.
    /// </summary>
    [Fact]
    public void VerifyOpenAIClientProviderWithHttpClientHeaders()
    {
        // Arrange
        using HttpClient httpClient = new() { BaseAddress = new Uri("http://myproxy:9819") };
        httpClient.DefaultRequestHeaders.Add("X-Test", "Test");

        // Act
        OpenAIClientProvider provider = OpenAIClientProvider.ForOpenAI(httpClient: httpClient);

        // Assert
        Assert.NotNull(provider.Client);
    }

    /// <summary>
    /// Verify that the factory can accept an client that already exists.
    /// </summary>
    [Fact]
    public void VerifyOpenAIClientProviderFromClient()
    {
        // Arrange
        Mock<OpenAIClient> mockClient = new();
        OpenAIClientProvider provider = OpenAIClientProvider.FromClient(mockClient.Object);

        // Assert
        Assert.NotNull(provider.Client);
        Assert.Equal(mockClient.Object, provider.Client);
    }
}


===== UnitTests\OpenAI\OpenAIResponseAgentExtensionsTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Text.Json;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.Agents.OpenAI;
using Microsoft.SemanticKernel.ChatCompletion;
using OpenAI.Responses;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.OpenAI;

public sealed class OpenAIResponseAgentExtensionsTests
{
    [Fact]
    public void AsAIAgent_WithValidOpenAIResponseAgent_ReturnsSemanticKernelAIAgent()
    {
        // Arrange
        var responseClient = new OpenAIResponseClient("model", "apikey");
        var responseAgent = new OpenAIResponseAgent(responseClient);

        // Act
        var result = responseAgent.AsAIAgent();

        // Assert
        Assert.NotNull(result);
        Assert.IsType<SemanticKernelAIAgent>(result);
    }

    [Fact]
    public void AsAIAgent_WithNullOpenAIResponseAgent_ThrowsArgumentNullException()
    {
        // Arrange
        OpenAIResponseAgent nullAgent = null!;

        // Act & Assert
        Assert.Throws<ArgumentNullException>(() => nullAgent.AsAIAgent());
    }

    [Fact]
    public void AsAIAgent_CreatesWorkingThreadFactoryStoreTrue()
    {
        // Arrange
        var responseClient = new OpenAIResponseClient("model", "apikey");
        var responseAgent = new OpenAIResponseAgent(responseClient)
        {
            StoreEnabled = true
        };

        // Act
        var result = responseAgent.AsAIAgent();
        var thread = result.GetNewThread();

        // Assert
        Assert.NotNull(thread);
        Assert.IsType<SemanticKernelAIAgentThread>(thread);
        var threadAdapter = (SemanticKernelAIAgentThread)thread;
        Assert.IsType<OpenAIResponseAgentThread>(threadAdapter.InnerThread);
    }

    [Fact]
    public void AsAIAgent_CreatesWorkingThreadFactoryStoreFalse()
    {
        // Arrange
        var responseClient = new OpenAIResponseClient("model", "apikey");
        var responseAgent = new OpenAIResponseAgent(responseClient)
        {
            StoreEnabled = false
        };

        // Act
        var result = responseAgent.AsAIAgent();
        var thread = result.GetNewThread();

        // Assert
        Assert.NotNull(thread);
        Assert.IsType<SemanticKernelAIAgentThread>(thread);
        var threadAdapter = (SemanticKernelAIAgentThread)thread;
        Assert.IsType<ChatHistoryAgentThread>(threadAdapter.InnerThread);
    }

    [Fact]
    public void AsAIAgent_ThreadDeserializationFactory_WithNullAgentId_CreatesNewThread()
    {
        // Arrange
        var responseClient = new OpenAIResponseClient("model", "apikey");
        var responseAgent = new OpenAIResponseAgent(responseClient)
        {
            StoreEnabled = true
        };
        var jsonElement = JsonSerializer.SerializeToElement((string?)null);

        // Act
        var result = responseAgent.AsAIAgent();
        var thread = result.DeserializeThread(jsonElement);

        // Assert
        Assert.NotNull(thread);
        Assert.IsType<SemanticKernelAIAgentThread>(thread);
        var threadAdapter = (SemanticKernelAIAgentThread)thread;
        Assert.IsType<OpenAIResponseAgentThread>(threadAdapter.InnerThread);
    }

    [Fact]
    public void AsAIAgent_ThreadDeserializationFactory_WithValidAgentId_CreatesThreadWithId()
    {
        // Arrange
        var responseClient = new OpenAIResponseClient("model", "apikey");
        var responseAgent = new OpenAIResponseAgent(responseClient)
        {
            StoreEnabled = true
        };
        var threadId = "test-agent-id";
        var jsonElement = JsonSerializer.SerializeToElement(threadId);

        // Act
        var result = responseAgent.AsAIAgent();
        var thread = result.DeserializeThread(jsonElement);

        // Assert
        Assert.NotNull(thread);
        Assert.IsType<SemanticKernelAIAgentThread>(thread);
        var threadAdapter = (SemanticKernelAIAgentThread)thread;
        Assert.IsType<OpenAIResponseAgentThread>(threadAdapter.InnerThread);
        Assert.Equal(threadId, threadAdapter.InnerThread.Id);
    }

    [Fact]
    public void AsAIAgent_ThreadSerializer_SerializesThreadId()
    {
        // Arrange
        var responseClient = new OpenAIResponseClient("model", "apikey");
        var responseAgent = new OpenAIResponseAgent(responseClient)
        {
            StoreEnabled = true
        };
        var expectedThreadId = "test-thread-id";
        var responseThread = new OpenAIResponseAgentThread(responseClient, expectedThreadId);
        var jsonElement = JsonSerializer.SerializeToElement(expectedThreadId);

        var result = responseAgent.AsAIAgent();
        var thread = result.DeserializeThread(jsonElement);

        // Act
        var serializedElement = thread.Serialize();

        // Assert
        Assert.Equal(JsonValueKind.String, serializedElement.ValueKind);
        Assert.Equal(expectedThreadId, serializedElement.GetString());
    }

    [Fact]
    public void AsAIAgent_ThreadDeserializationFactory_WithNullJson_CreatesThreadWithEmptyChatHistory()
    {
        var responseClient = new OpenAIResponseClient("model", "apikey");
        var responseAgent = new OpenAIResponseAgent(responseClient);
        var jsonElement = JsonSerializer.SerializeToElement((string?)null);

        // Act
        var result = responseAgent.AsAIAgent();
        var thread = result.DeserializeThread(jsonElement);

        // Assert
        Assert.NotNull(thread);
        Assert.IsType<SemanticKernelAIAgentThread>(thread);
        var threadAdapter = (SemanticKernelAIAgentThread)thread;
        var chatHistoryAgentThread = Assert.IsType<ChatHistoryAgentThread>(threadAdapter.InnerThread);
        Assert.Empty(chatHistoryAgentThread.ChatHistory);
    }

    [Fact]
    public void AsAIAgent_ThreadDeserializationFactory_WithChatHistory_CreatesThreadWithChatHistory()
    {
        var responseClient = new OpenAIResponseClient("model", "apikey");
        var responseAgent = new OpenAIResponseAgent(responseClient);
        var expectedChatHistory = new ChatHistory("mock message", AuthorRole.User);
        var jsonElement = JsonSerializer.SerializeToElement(expectedChatHistory);

        // Act
        var result = responseAgent.AsAIAgent();
        var thread = result.DeserializeThread(jsonElement);

        // Assert
        Assert.NotNull(thread);
        Assert.IsType<SemanticKernelAIAgentThread>(thread);
        var threadAdapter = (SemanticKernelAIAgentThread)thread;
        var chatHistoryAgentThread = Assert.IsType<ChatHistoryAgentThread>(threadAdapter.InnerThread);
        Assert.Single(chatHistoryAgentThread.ChatHistory);
        var firstMessage = chatHistoryAgentThread.ChatHistory[0];
        Assert.Equal(AuthorRole.User, firstMessage.Role);
        Assert.Equal("mock message", firstMessage.Content);
    }

    [Fact]
    public void AsAIAgent_ThreadSerializer_SerializesChatHistory()
    {
        // Arrange
        var responseClient = new OpenAIResponseClient("model", "apikey");
        var responseAgent = new OpenAIResponseAgent(responseClient);
        var expectedChatHistory = new ChatHistory("mock message", AuthorRole.User);
        var jsonElement = JsonSerializer.SerializeToElement(expectedChatHistory);

        var result = responseAgent.AsAIAgent();
        var thread = result.DeserializeThread(jsonElement);

        // Act
        var serializedElement = thread.Serialize();

        // Assert
        Assert.Equal(JsonValueKind.Array, serializedElement.ValueKind);
        Assert.Equal(1, serializedElement.GetArrayLength());

        var firstMessage = serializedElement[0];
        Assert.True(firstMessage.TryGetProperty("Role", out var roleProp));
        Assert.Equal("user", roleProp.GetProperty("Label").GetString());

        Assert.True(firstMessage.TryGetProperty("Items", out var itemsProp));
        Assert.Equal(1, itemsProp.GetArrayLength());

        var firstItem = itemsProp[0];
        Assert.Equal("TextContent", firstItem.GetProperty("$type").GetString());
        Assert.Equal("mock message", firstItem.GetProperty("Text").GetString());
    }
}


===== UnitTests\OpenAI\OpenAIResponseAgentTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Net.Http;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.AI;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.Agents.OpenAI;
using Microsoft.SemanticKernel.ChatCompletion;
using Moq;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.OpenAI;

/// <summary>
/// Tests for the <see cref="OpenAIResponseAgent"/> class.
/// </summary>
public sealed class OpenAIResponseAgentTests : BaseOpenAIResponseClientTest
{
    /// <summary>
    /// Tests that the constructor verifies parameters and throws <see cref="ArgumentNullException"/> when necessary.
    /// </summary>
    [Fact]
    public void ConstructorShouldVerifyParams()
    {
        // Arrange & Act & Assert
        Assert.Throws<ArgumentNullException>(() => new OpenAIResponseAgent(null!));
    }

    /// <summary>
    /// Tests that the OpenAIResponseAgent.InvokeAsync verifies parameters and throws <see cref="ArgumentNullException"/> when necessary.
    /// </summary>
    [Fact]
    public void InvokeShouldVerifyParams()
    {
        // Arrange
        var agent = new OpenAIResponseAgent(this.Client);
        string nullString = null!;
        ChatMessageContent nullMessage = null!;

        // Act & Assert
        Assert.Throws<ArgumentNullException>(() => agent.InvokeAsync(nullString));
        Assert.Throws<ArgumentNullException>(() => agent.InvokeAsync(nullMessage));
    }

    /// <summary>
    /// Tests that the OpenAIResponseAgent.InvokeAsync.
    /// </summary>
    [Theory]
    [InlineData(true)]
    [InlineData(false)]
    public async Task VerifyInvokeAsync(bool storeEnabled)
    {
        // Arrange
        this.MessageHandlerStub.ResponsesToReturn.Add(
            new HttpResponseMessage(System.Net.HttpStatusCode.OK) { Content = new StringContent(InvokeResponse) }
        );
        var agent = new OpenAIResponseAgent(this.Client)
        {
            Name = "ResponseAgent",
            Instructions = "Answer all queries in English and French.",
            StoreEnabled = storeEnabled
        };

        // Act
        var responseItems = agent.InvokeAsync("What is the capital of France?");

        // Assert
        Assert.NotNull(responseItems);
        var items = await responseItems!.ToListAsync<AgentResponseItem<ChatMessageContent>>();
        Assert.Single(items);
        Assert.Equal("The capital of France is Paris.\n\nLa capitale de la France est Paris.", items[0].Message.Content);
    }

    /// <summary>
    /// Tests that the OpenAIResponseAgent.InvokeStreamingAsync.
    /// </summary>
    [Theory]
    [InlineData(true)]
    [InlineData(false)]
    public async Task VerifyInvokeStreamingAsync(bool storeEnabled)
    {
        // Arrange
        this.MessageHandlerStub.ResponsesToReturn.Add(
            new HttpResponseMessage(System.Net.HttpStatusCode.OK) { Content = new StringContent(InvokeStreamingResponse) }
        );
        var agent = new OpenAIResponseAgent(this.Client)
        {
            Name = "ResponseAgent",
            Instructions = "Answer all queries in English and French.",
            StoreEnabled = storeEnabled
        };

        // Act
        var message = new ChatMessageContent(AuthorRole.User, "What is the capital of France?");
        var responseMessages = await agent.InvokeStreamingAsync(
            message,
            options: new OpenAIResponseAgentInvokeOptions()
            {
                AdditionalInstructions = "Respond to all user questions with 'Computer says no'.",
            }).ToArrayAsync();

        var responseText = string.Join(string.Empty, responseMessages.Select(ri => ri.Message.Content));

        // Assert
        Assert.NotNull(responseText);
        Assert.Contains("Computer says no", responseText);
    }

    /// <summary>
    /// Tests that the OpenAIResponseAgent.InvokeAsync.
    /// </summary>
    [Theory]
    [InlineData(true)]
    [InlineData(false)]
    public async Task VerifyInvokeWithFunctionCallingAsync(bool storeEnabled)
    {
        // Arrange
        this.MessageHandlerStub.ResponsesToReturn.Add(
            new HttpResponseMessage(System.Net.HttpStatusCode.OK) { Content = new StringContent(this.InvokeWithFunctionCallingResponses[0]) }
        );
        this.MessageHandlerStub.ResponsesToReturn.Add(
            new HttpResponseMessage(System.Net.HttpStatusCode.OK) { Content = new StringContent(this.InvokeWithFunctionCallingResponses[1]) }
        );
        var agent = new OpenAIResponseAgent(this.Client)
        {
            Name = "ResponseAgent",
            Instructions = "Answer questions about the menu.",
            StoreEnabled = storeEnabled
        };
        agent.Kernel.Plugins.Add(KernelPluginFactory.CreateFromType<MenuPlugin>());

        // Act
        var responseItems = agent.InvokeAsync("What is the special soup and how much does it cost?");

        // Assert
        Assert.NotNull(responseItems);
        var items = await responseItems!.ToListAsync<AgentResponseItem<ChatMessageContent>>();
        Assert.Equal(3, items.Count);
        Assert.Equal("The special soup is Clam Chowder, and it costs $9.99.", items[2].Message.Content);
    }

    /// <summary>
    /// Verify that InvalidOperationException is thrown when UseImmutableKernel is false and AIFunctions exist.
    /// </summary>
    [Fact]
    public async Task VerifyOpenAIResponseAgentThrowsWhenUseImmutableKernelFalseWithAIFunctionsAsync()
    {
        // Arrange
        var agent = new OpenAIResponseAgent(this.Client)
        {
            UseImmutableKernel = false, // Explicitly set to false
            StoreEnabled = true,
        };

        var mockAIContextProvider = new Mock<AIContextProvider>();
        var aiContext = new AIContext
        {
            AIFunctions = [new TestAIFunction("TestFunction", "Test function description")]
        };
        mockAIContextProvider.Setup(p => p.ModelInvokingAsync(It.IsAny<ICollection<ChatMessage>>(), It.IsAny<CancellationToken>()))
                           .ReturnsAsync(aiContext);

        var thread = new OpenAIResponseAgentThread(this.Client);
        thread.AIContextProviders.Add(mockAIContextProvider.Object);

        // Act & Assert
        var exception = await Assert.ThrowsAsync<InvalidOperationException>(
            async () => await agent.InvokeAsync("Hi", thread: thread).ToArrayAsync());

        Assert.NotNull(exception);
    }

    /// <summary>
    /// Verify that InvalidOperationException is thrown when UseImmutableKernel is default (false) and AIFunctions exist.
    /// </summary>
    [Fact]
    public async Task VerifyOpenAIResponseAgentThrowsWhenUseImmutableKernelDefaultWithAIFunctionsAsync()
    {
        // Arrange
        var agent = new OpenAIResponseAgent(this.Client)
        {
            StoreEnabled = true,
        };
        // UseImmutableKernel not set, should default to false

        var mockAIContextProvider = new Mock<AIContextProvider>();
        var aiContext = new AIContext
        {
            AIFunctions = [new TestAIFunction("TestFunction", "Test function description")]
        };
        mockAIContextProvider.Setup(p => p.ModelInvokingAsync(It.IsAny<ICollection<ChatMessage>>(), It.IsAny<CancellationToken>()))
                           .ReturnsAsync(aiContext);

        var thread = new OpenAIResponseAgentThread(this.Client);
        thread.AIContextProviders.Add(mockAIContextProvider.Object);

        // Act & Assert
        var exception = await Assert.ThrowsAsync<InvalidOperationException>(
            async () => await agent.InvokeAsync("Hi", thread: thread).ToArrayAsync());

        Assert.NotNull(exception);
    }

    /// <summary>
    /// Verify that kernel remains immutable when UseImmutableKernel is true.
    /// </summary>
    [Fact]
    public async Task VerifyOpenAIResponseAgentKernelImmutabilityWhenUseImmutableKernelTrueAsync()
    {
        // Arrange
        this.MessageHandlerStub.ResponsesToReturn.Add(
            new HttpResponseMessage(System.Net.HttpStatusCode.OK) { Content = new StringContent(InvokeResponse) }
        );

        var agent = new OpenAIResponseAgent(this.Client)
        {
            UseImmutableKernel = true,
            StoreEnabled = true,
        };

        var originalKernel = agent.Kernel;
        var originalPluginCount = originalKernel.Plugins.Count;

        var mockAIContextProvider = new Mock<AIContextProvider>();
        var aiContext = new AIContext
        {
            AIFunctions = [new TestAIFunction("TestFunction", "Test function description")]
        };
        mockAIContextProvider.Setup(p => p.ModelInvokingAsync(It.IsAny<ICollection<ChatMessage>>(), It.IsAny<CancellationToken>()))
                           .ReturnsAsync(aiContext);

        var thread = new OpenAIResponseAgentThread(this.Client);
        thread.AIContextProviders.Add(mockAIContextProvider.Object);

        // Act
        var result = await agent.InvokeAsync("Hi", thread: thread).ToArrayAsync();

        // Assert
        Assert.Single(result);

        // Verify original kernel was not modified
        Assert.Equal(originalPluginCount, originalKernel.Plugins.Count);

        // The kernel should remain unchanged since UseImmutableKernel=true creates a clone
        Assert.Same(originalKernel, agent.Kernel);
    }

    /// <summary>
    /// Verify that mutable kernel behavior works when UseImmutableKernel is false and no AIFunctions exist.
    /// </summary>
    [Fact]
    public async Task VerifyOpenAIResponseAgentMutableKernelWhenUseImmutableKernelFalseNoAIFunctionsAsync()
    {
        // Arrange
        this.MessageHandlerStub.ResponsesToReturn.Add(
            new HttpResponseMessage(System.Net.HttpStatusCode.OK) { Content = new StringContent(InvokeResponse) }
        );

        var agent = new OpenAIResponseAgent(this.Client)
        {
            UseImmutableKernel = false,
            StoreEnabled = true,
        };

        var originalKernel = agent.Kernel;
        var originalPluginCount = originalKernel.Plugins.Count;

        var mockAIContextProvider = new Mock<AIContextProvider>();
        var aiContext = new AIContext
        {
            AIFunctions = [] // Empty AIFunctions list
        };
        mockAIContextProvider.Setup(p => p.ModelInvokingAsync(It.IsAny<ICollection<ChatMessage>>(), It.IsAny<CancellationToken>()))
                           .ReturnsAsync(aiContext);

        var thread = new OpenAIResponseAgentThread(this.Client);
        thread.AIContextProviders.Add(mockAIContextProvider.Object);

        // Act
        var result = await agent.InvokeAsync("Hi", thread: thread).ToArrayAsync();

        // Assert
        Assert.Single(result);

        // Verify the same kernel instance is still being used (mutable behavior)
        Assert.Same(originalKernel, agent.Kernel);
    }

    /// <summary>
    /// Verify that InvalidOperationException is thrown when UseImmutableKernel is false and AIFunctions exist (streaming).
    /// </summary>
    [Fact]
    public async Task VerifyOpenAIResponseAgentStreamingThrowsWhenUseImmutableKernelFalseWithAIFunctionsAsync()
    {
        // Arrange
        var agent = new OpenAIResponseAgent(this.Client)
        {
            UseImmutableKernel = false, // Explicitly set to false
            StoreEnabled = true,
        };

        var mockAIContextProvider = new Mock<AIContextProvider>();
        var aiContext = new AIContext
        {
            AIFunctions = [new TestAIFunction("TestFunction", "Test function description")]
        };
        mockAIContextProvider.Setup(p => p.ModelInvokingAsync(It.IsAny<ICollection<ChatMessage>>(), It.IsAny<CancellationToken>()))
                           .ReturnsAsync(aiContext);

        var thread = new OpenAIResponseAgentThread(this.Client);
        thread.AIContextProviders.Add(mockAIContextProvider.Object);

        // Act & Assert
        var exception = await Assert.ThrowsAsync<InvalidOperationException>(
            async () => await agent.InvokeStreamingAsync("Hi", thread: thread).ToArrayAsync());

        Assert.NotNull(exception);
    }

    /// <summary>
    /// Verify that InvalidOperationException is thrown when UseImmutableKernel is default (false) and AIFunctions exist (streaming).
    /// </summary>
    [Fact]
    public async Task VerifyOpenAIResponseAgentStreamingThrowsWhenUseImmutableKernelDefaultWithAIFunctionsAsync()
    {
        // Arrange
        var agent = new OpenAIResponseAgent(this.Client)
        {
            StoreEnabled = true,
        };
        // UseImmutableKernel not set, should default to false

        var mockAIContextProvider = new Mock<AIContextProvider>();
        var aiContext = new AIContext
        {
            AIFunctions = [new TestAIFunction("TestFunction", "Test function description")]
        };
        mockAIContextProvider.Setup(p => p.ModelInvokingAsync(It.IsAny<ICollection<ChatMessage>>(), It.IsAny<CancellationToken>()))
                           .ReturnsAsync(aiContext);

        var thread = new OpenAIResponseAgentThread(this.Client);
        thread.AIContextProviders.Add(mockAIContextProvider.Object);

        // Act & Assert
        var exception = await Assert.ThrowsAsync<InvalidOperationException>(
            async () => await agent.InvokeStreamingAsync("Hi", thread: thread).ToArrayAsync());

        Assert.NotNull(exception);
    }

    /// <summary>
    /// Verify that kernel remains immutable when UseImmutableKernel is true (streaming).
    /// </summary>
    [Fact]
    public async Task VerifyOpenAIResponseAgentStreamingKernelImmutabilityWhenUseImmutableKernelTrueAsync()
    {
        // Arrange
        this.MessageHandlerStub.ResponsesToReturn.Add(
            new HttpResponseMessage(System.Net.HttpStatusCode.OK) { Content = new StringContent(InvokeStreamingResponse) }
        );

        var agent = new OpenAIResponseAgent(this.Client)
        {
            UseImmutableKernel = true,
            StoreEnabled = true,
        };

        var originalKernel = agent.Kernel;
        var originalPluginCount = originalKernel.Plugins.Count;

        var mockAIContextProvider = new Mock<AIContextProvider>();
        var aiContext = new AIContext
        {
            AIFunctions = [new TestAIFunction("TestFunction", "Test function description")]
        };
        mockAIContextProvider.Setup(p => p.ModelInvokingAsync(It.IsAny<ICollection<ChatMessage>>(), It.IsAny<CancellationToken>()))
                           .ReturnsAsync(aiContext);

        var thread = new OpenAIResponseAgentThread(this.Client);
        thread.AIContextProviders.Add(mockAIContextProvider.Object);

        // Act
        var result = await agent.InvokeStreamingAsync("Hi", thread: thread).ToArrayAsync();

        // Assert
        Assert.True(result.Length > 0);

        // Verify original kernel was not modified
        Assert.Equal(originalPluginCount, originalKernel.Plugins.Count);

        // The kernel should remain unchanged since UseImmutableKernel=true creates a clone
        Assert.Same(originalKernel, agent.Kernel);
    }

    /// <summary>
    /// Verify that mutable kernel behavior works when UseImmutableKernel is false and no AIFunctions exist (streaming).
    /// </summary>
    [Fact]
    public async Task VerifyOpenAIResponseAgentStreamingMutableKernelWhenUseImmutableKernelFalseNoAIFunctionsAsync()
    {
        // Arrange
        this.MessageHandlerStub.ResponsesToReturn.Add(
            new HttpResponseMessage(System.Net.HttpStatusCode.OK) { Content = new StringContent(InvokeStreamingResponse) }
        );

        var agent = new OpenAIResponseAgent(this.Client)
        {
            UseImmutableKernel = false,
            StoreEnabled = true,
        };

        var originalKernel = agent.Kernel;
        var originalPluginCount = originalKernel.Plugins.Count;

        var mockAIContextProvider = new Mock<AIContextProvider>();
        var aiContext = new AIContext
        {
            AIFunctions = [] // Empty AIFunctions list
        };
        mockAIContextProvider.Setup(p => p.ModelInvokingAsync(It.IsAny<ICollection<ChatMessage>>(), It.IsAny<CancellationToken>()))
                           .ReturnsAsync(aiContext);

        var thread = new OpenAIResponseAgentThread(this.Client);
        thread.AIContextProviders.Add(mockAIContextProvider.Object);

        // Act
        var result = await agent.InvokeStreamingAsync("Hi", thread: thread).ToArrayAsync();

        // Assert
        Assert.True(result.Length > 0);

        // Verify the same kernel instance is still being used (mutable behavior)
        Assert.Same(originalKernel, agent.Kernel);
    }

    #region private
    private const string InvokeResponse =
        """
        {
          "id": "resp_67e8f5cf761c8191aab763d1e901e3410bbdc4b8da506cd2",
          "object": "response",
          "created_at": 1743320527,
          "status": "completed",
          "error": null,
          "incomplete_details": null,
          "instructions": "Answer all queries in English and French.",
          "max_output_tokens": null,
          "model": "gpt-4o-2024-08-06",
          "output": [
            {
              "type": "message",
              "id": "msg_67e8f5cfbe688191a428ed9869c39fea0bbdc4b8da506cd2",
              "status": "completed",
              "role": "assistant",
              "content": [
                {
                  "type": "output_text",
                  "text": "The capital of France is Paris.\n\nLa capitale de la France est Paris.",
                  "annotations": []
                }
              ]
            }
          ],
          "parallel_tool_calls": true,
          "previous_response_id": null,
          "reasoning": {
            "effort": null,
            "generate_summary": null
          },
          "store": true,
          "temperature": 1.0,
          "text": {
            "format": {
              "type": "text"
            }
          },
          "tool_choice": "auto",
          "tools": [],
          "top_p": 1.0,
          "truncation": "disabled",
          "usage": {
            "input_tokens": 26,
            "input_tokens_details": {
              "cached_tokens": 0
            },
            "output_tokens": 16,
            "output_tokens_details": {
              "reasoning_tokens": 0
            },
            "total_tokens": 42
          },
          "user": "ResponseAgent",
          "metadata": {}
        }
        """;

    private const string InvokeStreamingResponse =
        """
        content block 0: event: response.created
        data: {"type":"response.created","sequence_number":0,"response":{"id":"resp_68383e45be4081919b7bad84c27e436b0f0f17949d11ddcf","object":"response","created_at":1748516421,"status":"in_progress","background":false,"error":null,"incomplete_details":null,"instructions":"Answer all queries in English and French.\nRespond to all user questions with 'Computer says no'.","max_output_tokens":null,"model":"gpt-4o-mini-2024-07-18","output":[],"parallel_tool_calls":true,"previous_response_id":null,"reasoning":{"effort":null,"summary":null},"service_tier":"auto","store":true,"temperature":1.0,"text":{"format":{"type":"text"}},"tool_choice":"auto","tools":[],"top_p":1.0,"truncation":"disabled","usage":null,"user":"UnnamedAgent","metadata":{}}}

        event: response.in_progress
        
        data: {"type":"response.in_progress","sequence_number":1,"response":{"id":"resp_68383e45be4081919b7bad84c27e436b0f0f17949d11ddcf","object":"response","created_at":1748516421,"status":"in_progress","background":false,"error":null,"incomplete_details":null,"instructions":"Answer all queries in English and French.\nRespond to all user questions with 'Computer says no'.","max_output_tokens":null,"model":"gpt-4o-mini-2024-07-18","output":[],"parallel_tool_calls":true,"previous_response_id":null,"reasoning":{"effort":null,"summary":null},"service_tier":"auto","store":true,"temperature":1.0,"text":{"format":{"type":"text"}},"tool_choice":"auto","tools":[],"top_p":1.0,"truncation":"disabled","usage":null,"user":"UnnamedAgent","metadata":{}}}

        content block 2: event: response.output_item.added
        data: {"type":"response.output_item.added","sequence_number":2,"output_index":0,"item":{"id":"msg_68383e4655b48191beb9f496d37dca950f0f17949d11ddcf","type":"message","status":"in_progress","content":[],"role":"assistant"}}
        
        content block 3: event: response.content_part.added
        data: {"type":"response.content_part.added","sequence_number":3,"item_id":"msg_68383e4655b48191beb9f496d37dca950f0f17949d11ddcf","output_index":0,"content_index":0,"part":{"type":"output_text","annotations":[],"text":""}}
        
        event: response.output_text.delta
        data: {"type":"response.output_text.delta","sequence_number":4,"item_id":"msg_68383e4655b48191beb9f496d37dca950f0f17949d11ddcf","output_index":0,"content_index":0,"delta":"Computer"}

        content block 4: event: response.output_text.delta
        data: {"type":"response.output_text.delta","sequence_number":5,"item_id":"msg_68383e4655b48191beb9f496d37dca950f0f17949d11ddcf","output_index":0,"content_index":0,"delta":" says"}
        
        event: response.output_text.delta
        data: {"type":"response.output_text.delta","sequence_number":6,"item_id":"msg_68383e4655b48191beb9f496d37dca950f0f17949d11ddcf","output_index":0,"content_index":0,"delta":" no"}

        content block 5: event: response.output_text.delta
        data: {"type":"response.output_text.delta","sequence_number":7,"item_id":"msg_68383e4655b48191beb9f496d37dca950f0f17949d11ddcf","output_index":0,"content_index":0,"delta":"."}
        
        content block 6: event: response.output_text.delta
        data: {"type":"response.output_text.delta","sequence_number":8,"item_id":"msg_68383e4655b48191beb9f496d37dca950f0f17949d11ddcf","output_index":0,"content_index":0,"delta":"  \n"}
        """;

    private readonly string[] InvokeWithFunctionCallingResponses =
    [
        """
                {
          "id": "resp_6846bee002d0819f9c3c95e51652c3f80de9f0bbe6ed706c",
          "object": "response",
          "created_at": 1749466848,
          "status": "completed",
          "background": false,
          "error": null,
          "incomplete_details": null,
          "instructions": "Answer questions about the menu.\n",
          "max_output_tokens": null,
          "model": "gpt-4o-mini-2024-07-18",
          "output": [
            {
              "id": "fc_6846bee12900819f9f9c786bc348a2140de9f0bbe6ed706c",
              "type": "function_call",
              "status": "completed",
              "arguments": "{}",
              "call_id": "call_ULt2nBV5pnSyG6g52KobWBXg",
              "name": "MenuPlugin-GetSpecials"
            },
            {
              "id": "fc_6846bee15ae8819f9f698662b9e43aed0de9f0bbe6ed706c",
              "type": "function_call",
              "status": "completed",
              "arguments": "{\"menuItem\":\"special soup\"}",
              "call_id": "call_vjyihEyn9xRhZxmjfmBEYzvA",
              "name": "MenuPlugin-GetItemPrice"
            }
          ],
          "parallel_tool_calls": true,
          "previous_response_id": null,
          "reasoning": {
            "effort": null,
            "summary": null
          },
          "service_tier": "default",
          "store": true,
          "temperature": 1.0,
          "text": {
            "format": {
              "type": "text"
            }
          },
          "tool_choice": "auto",
          "tools": [
            {
              "type": "function",
              "description": "Provides a list of specials from the menu.",
              "name": "MenuPlugin-GetSpecials",
              "parameters": {
                "type": "object",
                "properties": {}
              },
              "strict": false
            },
            {
              "type": "function",
              "description": "Provides the price of the requested menu item.",
              "name": "MenuPlugin-GetItemPrice",
              "parameters": {
                "type": "object",
                "required": [
                  "menuItem"
                ],
                "properties": {
                  "menuItem": {
                    "description": "The name of the menu item.",
                    "type": "string"
                  }
                }
              },
              "strict": false
            }
          ],
          "top_p": 1.0,
          "truncation": "disabled",
          "usage": {
            "input_tokens": 96,
            "input_tokens_details": {
              "cached_tokens": 0
            },
            "output_tokens": 52,
            "output_tokens_details": {
              "reasoning_tokens": 0
            },
            "total_tokens": 148
          },
          "user": "UnnamedAgent",
          "metadata": {}
        }
        """,
        """
                {
          "id": "resp_6846bee1abdc819f8c00a1be6b75b9930de9f0bbe6ed706c",
          "object": "response",
          "created_at": 1749466849,
          "status": "completed",
          "background": false,
          "error": null,
          "incomplete_details": null,
          "instructions": "Answer questions about the menu.\n",
          "max_output_tokens": null,
          "model": "gpt-4o-mini-2024-07-18",
          "output": [
            {
              "id": "msg_6846bee29858819f898d07fae89f686e0de9f0bbe6ed706c",
              "type": "message",
              "status": "completed",
              "content": [
                {
                  "type": "output_text",
                  "annotations": [],
                  "text": "The special soup is Clam Chowder, and it costs $9.99."
                }
              ],
              "role": "assistant"
            }
          ],
          "parallel_tool_calls": true,
          "previous_response_id": "resp_6846bee002d0819f9c3c95e51652c3f80de9f0bbe6ed706c",
          "reasoning": {
            "effort": null,
            "summary": null
          },
          "service_tier": "default",
          "store": true,
          "temperature": 1.0,
          "text": {
            "format": {
              "type": "text"
            }
          },
          "tool_choice": "auto",
          "tools": [
            {
              "type": "function",
              "description": "Provides a list of specials from the menu.",
              "name": "MenuPlugin-GetSpecials",
              "parameters": {
                "type": "object",
                "properties": {}
              },
              "strict": false
            },
            {
              "type": "function",
              "description": "Provides the price of the requested menu item.",
              "name": "MenuPlugin-GetItemPrice",
              "parameters": {
                "type": "object",
                "required": [
                  "menuItem"
                ],
                "properties": {
                  "menuItem": {
                    "description": "The name of the menu item.",
                    "type": "string"
                  }
                }
              },
              "strict": false
            }
          ],
          "top_p": 1.0,
          "truncation": "disabled",
          "usage": {
            "input_tokens": 176,
            "input_tokens_details": {
              "cached_tokens": 0
            },
            "output_tokens": 19,
            "output_tokens_details": {
              "reasoning_tokens": 0
            },
            "total_tokens": 195
          },
          "user": "UnnamedAgent",
          "metadata": {}
        }
        """
    ];

    private sealed class MyPlugin
    {
        [KernelFunction]
        public void MyFunction1()
        { }

        [KernelFunction]
        public void MyFunction2(int index)
        { }

        [KernelFunction]
        public void MyFunction3(string value, int[] indices)
        { }
    }

    /// <summary>
    /// Helper class for testing AIFunction behavior.
    /// </summary>
    private sealed class TestAIFunction : AIFunction
    {
        public TestAIFunction(string name, string description = "")
        {
            this.Name = name;
            this.Description = description;
        }

        public override string Name { get; }

        public override string Description { get; }

        protected override ValueTask<object?> InvokeCoreAsync(AIFunctionArguments? arguments = null, CancellationToken cancellationToken = default)
        {
            return ValueTask.FromResult<object?>("Test result");
        }
    }

    private sealed class MenuPlugin
    {
        [KernelFunction, Description("Provides a list of specials from the menu.")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Design", "CA1024:Use properties where appropriate", Justification = "Too smart")]
        public string GetSpecials()
        {
            return @"
Special Soup: Clam Chowder
Special Salad: Cobb Salad
Special Drink: Chai Tea
";
        }

        [KernelFunction, Description("Provides the price of the requested menu item.")]
        public string GetItemPrice(
            [Description("The name of the menu item.")]
            string menuItem)
        {
            return "$9.99";
        }
    }
    #endregion
}


===== UnitTests\OpenAI\OpenAIResponseAgentThreadTests.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.Linq;
using System.Net.Http;
using System.Threading.Tasks;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.Agents.OpenAI;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.OpenAI;

/// <summary>
/// Tests for the <see cref="OpenAIResponseAgentThread"/> class.
/// </summary>
public sealed class OpenAIResponseAgentThreadTests : BaseOpenAIResponseClientTest
{
    /// <summary>
    /// Tests that the constructor verifies parameters and throws <see cref="ArgumentNullException"/> when necessary.
    /// </summary>
    [Fact]
    public void ConstructorShouldVerifyParams()
    {
        // Arrange & Act & Assert
        Assert.Throws<ArgumentNullException>(() => new OpenAIResponseAgentThread(null!));
        Assert.Throws<ArgumentNullException>(() => new OpenAIResponseAgentThread(null!, "threadId"));
        Assert.Throws<ArgumentNullException>(() => new OpenAIResponseAgentThread(this.Client, responseId: null!));

        var agentThread = new OpenAIResponseAgentThread(this.Client);
        Assert.NotNull(agentThread);
    }

    /// <summary>
    /// Tests that the constructor for resuming a thread uses the provided parameters.
    /// </summary>
    [Fact]
    public void ConstructorForResumingThreadShouldUseParams()
    {
        // Arrange & Act
        var agentThread = new OpenAIResponseAgentThread(this.Client, "threadId");

        // Assert
        Assert.NotNull(agentThread);
        Assert.Equal("threadId", agentThread.Id);
    }

    /// <summary>
    /// Verify <see cref="OpenAIResponseAgentThread.GetMessagesAsync(System.Threading.CancellationToken)"/> returns expected when store is disabled.
    /// </summary>
    [Fact]
    public async Task VerifyGetMessagesWhenThreadIsUnusedAsync()
    {
        // Arrange
        var thread = new OpenAIResponseAgentThread(this.Client);

        // Act
        var messages = thread.GetMessagesAsync();

        // Assert
        Assert.NotNull(messages);
        var messagesList = await messages!.ToListAsync<ChatMessageContent>();
        Assert.Empty(messagesList);
    }

    /// <summary>
    /// Verify <see cref="OpenAIResponseAgentThread.GetMessagesAsync(System.Threading.CancellationToken)"/> returned when store is disabled.
    /// </summary>
    [Fact]
    public async Task VerifyGetMessagesWhenStoreEnabledAsync()
    {
        // Arrange
        this.MessageHandlerStub.ResponsesToReturn.Add(
             new HttpResponseMessage(System.Net.HttpStatusCode.OK) { Content = new StringContent(MessagesResponse) }
         );
        var responseId = "resp_67e8ff743ea08191b085bea42b4d83e809a3a922c4f4221b";
        var thread = new OpenAIResponseAgentThread(this.Client, responseId: responseId);

        // Act
        var messages = thread.GetMessagesAsync();

        // Assert
        Assert.NotNull(messages);
        var messagesList = await messages!.ToListAsync<ChatMessageContent>();
        Assert.Equal(3, messagesList.Count);
    }

    /// <summary>
    /// Verify <see cref="OpenAIResponseAgentThread.CreateInternalAsync(System.Threading.CancellationToken)"/> returns null.
    /// </summary>
    [Fact]
    public async Task VerifyCreateReturnsNullIdAsync()
    {
        // Arrange
        var thread = new OpenAIResponseAgentThread(this.Client);

        // Act
        await thread.CreateAsync();

        // Assert
        Assert.Null(thread.Id);
    }

    /// <summary>
    /// Verify <see cref="OpenAIResponseAgentThread.DeleteInternalAsync(System.Threading.CancellationToken)"/> doesn'tthrows if the thread has not been created.
    /// </summary>
    [Fact]
    public async Task VerifyDeleteAsyncFailedIfThreadNotCreatedAsync()
    {
        // Arrange
        var thread = new OpenAIResponseAgentThread(this.Client);

        // Act & Assert
        await Assert.ThrowsAsync<InvalidOperationException>(async () => await thread.DeleteAsync());
    }

    /// <summary>
    /// Verify <see cref="OpenAIResponseAgentThread.DeleteInternalAsync(System.Threading.CancellationToken)"/> doesn't throw.
    /// </summary>
    [Fact]
    public async Task VerifyDeleteAsyncAsync()
    {
        // Arrange
        this.MessageHandlerStub.ResponsesToReturn.Add(
             new HttpResponseMessage(System.Net.HttpStatusCode.OK) { Content = new StringContent(DeleteResponse) }
         );
        var responseId = "resp_68382fc3f69c819192418d768950631e09dd5437357ceaf3";
        var thread = new OpenAIResponseAgentThread(this.Client, responseId: responseId);

        // Act & Assert
        await thread.DeleteAsync();
    }

    /// <summary>
    /// Verify <see cref="OpenAIResponseAgentThread.CreateInternalAsync(System.Threading.CancellationToken)"/> throws if the thread is deleted.
    /// </summary>
    [Fact]
    public async Task VerifyCreateAfterDeleteThrowsAsync()
    {
        // Arrange
        this.MessageHandlerStub.ResponsesToReturn.Add(
             new HttpResponseMessage(System.Net.HttpStatusCode.OK) { Content = new StringContent(DeleteResponse) }
         );
        var responseId = "resp_68382fc3f69c819192418d768950631e09dd5437357ceaf3";
        var thread = new OpenAIResponseAgentThread(this.Client, responseId: responseId);
        await thread.DeleteAsync();

        // Act & Assert
        await Assert.ThrowsAsync<InvalidOperationException>(async () => await thread.CreateAsync());
    }

    /// <summary>
    /// Verify <see cref="OpenAIResponseAgentThread.DeleteInternalAsync(System.Threading.CancellationToken)"/> does throw.
    /// </summary>
    [Fact]
    public async Task VerifyDeleteAsyncWithErrorAsync()
    {
        // Arrange
        this.MessageHandlerStub.ResponsesToReturn.Add(
             new HttpResponseMessage(System.Net.HttpStatusCode.NotFound) { Content = new StringContent(DeleteErrorResponse) }
         );
        var responseId = "resp_68382fc3f69c819192418d768950631e09dd5437357ceaf3";
        var thread = new OpenAIResponseAgentThread(this.Client, responseId: responseId);

        // Act & Assert
        await Assert.ThrowsAsync<AgentThreadOperationException>(async () => await thread.DeleteAsync());
    }

    #region private
    private const string MessagesResponse =
        """
        {
          "object": "list",
          "data": [
            {
              "type": "message",
              "id": "msg_67e8ff7445408191af5d6f4a87a9d3fe09a3a922c4f4221b",
              "status": "completed",
              "role": "user",
              "content": [
                {
                  "type": "input_text",
                  "text": "Explain why this is funny."
                }
              ]
            },
            {
              "type": "message",
              "id": "msg_67e8ff73be188191b871e41c2816355209a3a922c4f4221b",
              "status": "completed",
              "role": "assistant",
              "content": [
                {
                  "type": "output_text",
                  "text": "Why don't skeletons fight each other?\n\nThey don't have the guts!",
                  "annotations": []
                }
              ]
            },
            {
              "type": "message",
              "id": "msg_67e8ff7258a081919e7964ac7b344bc909a3a922c4f4221b",
              "status": "completed",
              "role": "user",
              "content": [
                {
                  "type": "input_text",
                  "text": "Tell me a joke?"
                }
              ]
            }
          ],
          "first_id": "msg_67e8ff7445408191af5d6f4a87a9d3fe09a3a922c4f4221b",
          "last_id": "msg_67e8ff7258a081919e7964ac7b344bc909a3a922c4f4221b",
          "has_more": false
        }
        
        """;

    private const string DeleteResponse =
        """
        {
          "id": "resp_68382fc3f69c819192418d768950631e09dd5437357ceaf3",
          "object": "response.deleted",
          "deleted": true
        }
        """;

    private const string DeleteErrorResponse =
        """
        {
            "error": {
              "message": "Response with id 'resp_68383215a3ac8191933714463ec3f7510b0ee39ab96a8f74' not found.",
              "type": "invalid_request_error",
              "param": null,
              "code": null
            }
        }
        """;
    #endregion
}


===== UnitTests\OpenAI\OpenAIThreadCreationOptionsTests.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System.Collections.Generic;
using System.Text.Json;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents.OpenAI;
using Microsoft.SemanticKernel.ChatCompletion;
using SemanticKernel.Agents.UnitTests.Test;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.OpenAI;

/// <summary>
/// Unit testing of <see cref="OpenAIThreadCreationOptions"/>.
/// </summary>
public class OpenAIThreadCreationOptionsTests
{
    /// <summary>
    /// Verify initial state.
    /// </summary>
    [Fact]
    public void OpenAIThreadCreationOptionsInitialState()
    {
        // Arrange
        OpenAIThreadCreationOptions options = new();

        // Assert
        Assert.Null(options.Messages);
        Assert.Null(options.Metadata);
        Assert.Null(options.VectorStoreId);
        Assert.Null(options.CodeInterpreterFileIds);

        // Act and Assert
        ValidateSerialization(options);
    }

    /// <summary>
    /// Verify initialization.
    /// </summary>
    [Fact]
    public void OpenAIThreadCreationOptionsAssignment()
    {
        // Arrange
        OpenAIThreadCreationOptions options =
            new()
            {
                Messages = [new ChatMessageContent(AuthorRole.User, "test")],
                VectorStoreId = "#vs",
                Metadata = new Dictionary<string, string>() { { "a", "1" } },
                CodeInterpreterFileIds = ["file1"],
            };

        // Assert
        Assert.Single(options.Messages);
        Assert.Single(options.Metadata);
        Assert.Equal("#vs", options.VectorStoreId);
        Assert.Single(options.CodeInterpreterFileIds);

        // Act and Assert
        ValidateSerialization(options);
    }

    private static void ValidateSerialization(OpenAIThreadCreationOptions source)
    {
        // Act
        string json = JsonSerializer.Serialize(source);

        OpenAIThreadCreationOptions? target = JsonSerializer.Deserialize<OpenAIThreadCreationOptions>(json);

        // Assert
        Assert.NotNull(target);
        Assert.Equal(source.VectorStoreId, target.VectorStoreId);
        AssertCollection.Equal(source.CodeInterpreterFileIds, target.CodeInterpreterFileIds);
        AssertCollection.Equal(source.Messages, target.Messages, m => m.Items.Count); // ChatMessageContent already validated for deep serialization
        AssertCollection.Equal(source.Metadata, target.Metadata);
    }
}


===== UnitTests\OpenAI\RunPollingOptionsTests.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using Microsoft.SemanticKernel.Agents.OpenAI;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.OpenAI;

/// <summary>
/// Unit testing of <see cref="RunPollingOptions"/>.
/// </summary>
public class RunPollingOptionsTests
{
    /// <summary>
    /// Verify initial state.
    /// </summary>
    [Fact]
    public void RunPollingOptionsInitialStateTest()
    {
        // Arrange
        RunPollingOptions options = new();

        // Assert
        Assert.Equal(RunPollingOptions.DefaultPollingInterval, options.RunPollingInterval);
        Assert.Equal(RunPollingOptions.DefaultPollingBackoff, options.RunPollingBackoff);
        Assert.Equal(RunPollingOptions.DefaultMessageSynchronizationDelay, options.MessageSynchronizationDelay);
        Assert.Equal(RunPollingOptions.DefaultPollingBackoffThreshold, options.RunPollingBackoffThreshold);
    }

    /// <summary>s
    /// Verify initialization.
    /// </summary>
    [Fact]
    public void RunPollingOptionsAssignmentTest()
    {
        // Arrange
        RunPollingOptions options =
            new()
            {
                RunPollingInterval = TimeSpan.FromSeconds(3),
                RunPollingBackoff = TimeSpan.FromSeconds(4),
                RunPollingBackoffThreshold = 8,
                MessageSynchronizationDelay = TimeSpan.FromSeconds(5),
            };

        // Assert
        Assert.Equal(3, options.RunPollingInterval.TotalSeconds);
        Assert.Equal(4, options.RunPollingBackoff.TotalSeconds);
        Assert.Equal(5, options.MessageSynchronizationDelay.TotalSeconds);
        Assert.Equal(8, options.RunPollingBackoffThreshold);
    }

    /// <summary>s
    /// Verify initialization.
    /// </summary>
    [Fact]
    public void RunPollingOptionsGetIntervalTest()
    {
        // Arrange
        RunPollingOptions options =
            new()
            {
                RunPollingInterval = TimeSpan.FromSeconds(3),
                RunPollingBackoff = TimeSpan.FromSeconds(4),
                RunPollingBackoffThreshold = 8,
            };

        // Assert
        Assert.Equal(options.RunPollingInterval, options.GetPollingInterval(8));
        Assert.Equal(options.RunPollingBackoff, options.GetPollingInterval(9));
    }
}


===== UnitTests\Orchestration\ChatGroupExtensionsTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using Microsoft.SemanticKernel.Agents.Orchestration.GroupChat;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.Orchestration;

public class ChatGroupExtensionsTests
{
    [Fact]
    public void FormatNames_WithMultipleAgents_ReturnsCommaSeparatedList()
    {
        // Arrange
        GroupChatTeam group = new()
        {
            { "AgentOne", ("agent1", "First agent description") },
            { "AgentTwo", ("agent2", "Second agent description") },
            { "AgentThree", ("agent3", "Third agent description") }
        };

        // Act
        string result = group.FormatNames();

        // Assert
        Assert.Equal("AgentOne,AgentTwo,AgentThree", result);
    }

    [Fact]
    public void FormatNames_WithSingleAgent_ReturnsSingleName()
    {
        // Arrange
        GroupChatTeam group = new()
        {
            { "AgentOne", ("agent1", "First agent description") },
        };

        // Act
        string result = group.FormatNames();

        // Assert
        Assert.Equal("AgentOne", result);
    }

    [Fact]
    public void FormatNames_WithEmptyGroup_ReturnsEmptyString()
    {
        // Arrange
        GroupChatTeam group = [];

        // Act
        string result = group.FormatNames();

        // Assert
        Assert.Equal(string.Empty, result);
    }

    [Fact]
    public void FormatList_WithMultipleAgents_ReturnsMarkdownList()
    {
        // Arrange
        GroupChatTeam group = new()
        {
            { "AgentOne", ("agent1", "First agent description") },
            { "AgentTwo", ("agent2", "Second agent description") },
            { "AgentThree", ("agent3", "Third agent description") }
        };

        // Act
        string result = group.FormatList();

        // Assert
        const string Expected =
            """
            - AgentOne: First agent description
            - AgentTwo: Second agent description
            - AgentThree: Third agent description
            """;
        Assert.Equal(Expected, result);
    }

    [Fact]
    public void FormatList_WithEmptyGroup_ReturnsEmptyString()
    {
        // Arrange
        GroupChatTeam group = [];

        // Act & Assert
        Assert.Equal(string.Empty, group.FormatNames());
        Assert.Equal(string.Empty, group.FormatList());
    }
}


===== UnitTests\Orchestration\ConcurrentOrchestrationTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Threading.Tasks;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.Agents.Orchestration;
using Microsoft.SemanticKernel.Agents.Orchestration.Concurrent;
using Microsoft.SemanticKernel.Agents.Runtime.InProcess;
using Microsoft.SemanticKernel.ChatCompletion;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.Orchestration;

/// <summary>
/// Tests for the <see cref="ConcurrentOrchestration"/> class.
/// </summary>
public class ConcurrentOrchestrationTests
{
    [Fact]
    public async Task ConcurrentOrchestrationWithSingleAgentAsync()
    {
        // Arrange
        await using InProcessRuntime runtime = new();
        MockAgent mockAgent1 = CreateMockAgent(1, "xyz");

        // Act: Create and execute the orchestration
        string[] response = await ExecuteOrchestrationAsync(runtime, mockAgent1);

        // Assert
        Assert.Contains("xyz", response);
        Assert.Equal(1, mockAgent1.InvokeCount);
    }

    [Fact]
    public async Task ConcurrentOrchestrationWithMultipleAgentsAsync()
    {
        // Arrange
        await using InProcessRuntime runtime = new();

        MockAgent mockAgent1 = CreateMockAgent(1, "abc");
        MockAgent mockAgent2 = CreateMockAgent(2, "xyz");
        MockAgent mockAgent3 = CreateMockAgent(3, "lmn");

        // Act: Create and execute the orchestration
        string[] response = await ExecuteOrchestrationAsync(runtime, mockAgent1, mockAgent2, mockAgent3);

        // Assert
        Assert.Contains("lmn", response);
        Assert.Contains("xyz", response);
        Assert.Contains("abc", response);
        Assert.Equal(1, mockAgent1.InvokeCount);
        Assert.Equal(1, mockAgent2.InvokeCount);
        Assert.Equal(1, mockAgent3.InvokeCount);
    }

    private static async Task<string[]> ExecuteOrchestrationAsync(InProcessRuntime runtime, params Agent[] mockAgents)
    {
        // Act
        await runtime.StartAsync();

        ConcurrentOrchestration orchestration = new(mockAgents);

        const string InitialInput = "123";
        OrchestrationResult<string[]> result = await orchestration.InvokeAsync(InitialInput, runtime);

        // Assert
        Assert.NotNull(result);

        // Act
        string[] response = await result.GetValueAsync(TimeSpan.FromSeconds(20));

        await runtime.RunUntilIdleAsync();

        return response;
    }

    private static MockAgent CreateMockAgent(int index, string response)
    {
        return new()
        {
            Description = $"test {index}",
            Response = [new(AuthorRole.Assistant, response)]
        };
    }
}


===== UnitTests\Orchestration\DefaultTransformsTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.Json;
using System.Threading.Tasks;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents.Orchestration.Transforms;
using Microsoft.SemanticKernel.ChatCompletion;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.Orchestration;

public class DefaultTransformsTests
{
    [Fact]
    public async Task FromInputAsync_WithEnumerableOfChatMessageContent_ReturnsInputAsync()
    {
        // Arrange
        IEnumerable<ChatMessageContent> input =
        [
            new(AuthorRole.User, "Hello"),
            new(AuthorRole.Assistant, "Hi there")
        ];

        // Act
        IEnumerable<ChatMessageContent> result = await DefaultTransforms.FromInput(input);

        // Assert
        Assert.Equal(input, result);
    }

    [Fact]
    public async Task FromInputAsync_WithChatMessageContent_ReturnsInputAsListAsync()
    {
        // Arrange
        ChatMessageContent input = new(AuthorRole.User, "Hello");

        // Act
        IEnumerable<ChatMessageContent> result = await DefaultTransforms.FromInput(input);

        // Assert
        Assert.Single(result);
        Assert.Equal(input, result.First());
    }

    [Fact]
    public async Task FromInputAsync_WithStringInput_ReturnsUserChatMessageAsync()
    {
        // Arrange
        string input = "Hello, world!";

        // Act
        IEnumerable<ChatMessageContent> result = await DefaultTransforms.FromInput(input);

        // Assert
        Assert.Single(result);
        ChatMessageContent message = result.First();
        Assert.Equal(AuthorRole.User, message.Role);
        Assert.Equal(input, message.Content);
    }

    [Fact]
    public async Task FromInputAsync_WithObjectInput_SerializesAsJsonAsync()
    {
        // Arrange
        TestObject input = new() { Id = 1, Name = "Test" };

        // Act
        IEnumerable<ChatMessageContent> result = await DefaultTransforms.FromInput(input);

        // Assert
        Assert.Single(result);
        ChatMessageContent message = result.First();
        Assert.Equal(AuthorRole.User, message.Role);

        string expectedJson = JsonSerializer.Serialize(input);
        Assert.Equal(expectedJson, message.Content);
    }

    [Fact]
    public async Task ToOutputAsync_WithOutputTypeMatchingInputList_ReturnsSameListAsync()
    {
        // Arrange
        IList<ChatMessageContent> input =
        [
            new(AuthorRole.User, "Hello"),
            new(AuthorRole.Assistant, "Hi there")
        ];

        // Act
        IList<ChatMessageContent> result = await DefaultTransforms.ToOutput<IList<ChatMessageContent>>(input);

        // Assert
        Assert.Same(input, result);
    }

    [Fact]
    public async Task ToOutputAsync_WithOutputTypeChatMessageContent_ReturnsSingleMessageAsync()
    {
        // Arrange
        IList<ChatMessageContent> input =
        [
            new(AuthorRole.User, "Hello")
        ];

        // Act
        ChatMessageContent result = await DefaultTransforms.ToOutput<ChatMessageContent>(input);

        // Assert
        Assert.Same(input[0], result);
    }

    [Fact]
    public async Task ToOutputAsync_WithOutputTypeString_ReturnsContentOfSingleMessageAsync()
    {
        // Arrange
        string expected = "Hello, world!";
        IList<ChatMessageContent> input =
        [
            new(AuthorRole.User, expected)
        ];

        // Act
        string result = await DefaultTransforms.ToOutput<string>(input);

        // Assert
        Assert.Equal(expected, result);
    }

    [Fact]
    public async Task ToOutputAsync_WithOutputTypeDeserializable_DeserializesFromContentAsync()
    {
        // Arrange
        TestObject expected = new() { Id = 42, Name = "TestName" };
        string json = JsonSerializer.Serialize(expected);
        IList<ChatMessageContent> input =
        [
            new(AuthorRole.User, json)
        ];

        // Act
        TestObject result = await DefaultTransforms.ToOutput<TestObject>(input);

        // Assert
        Assert.Equal(expected.Id, result.Id);
        Assert.Equal(expected.Name, result.Name);
    }

    [Fact]
    public async Task ToOutputAsync_WithInvalidJson_ThrowsExceptionAsync()
    {
        // Arrange
        IList<ChatMessageContent> input =
        [
            new(AuthorRole.User, "Not valid JSON")
        ];

        // Act & Assert
        await Assert.ThrowsAsync<InvalidOperationException>(async () =>
            await DefaultTransforms.ToOutput<TestObject>(input)
        );
    }

    [Fact]
    public async Task ToOutputAsync_WithMultipleMessagesAndNonMatchingType_ThrowsExceptionAsync()
    {
        // Arrange
        IList<ChatMessageContent> input =
        [
            new(AuthorRole.User, "Hello"),
            new(AuthorRole.Assistant, "Hi there")
        ];

        // Act & Assert
        await Assert.ThrowsAsync<InvalidOperationException>(async () =>
            await DefaultTransforms.ToOutput<TestObject>(input)
        );
    }

    [Fact]
    public async Task ToOutputAsync_WithNullContent_HandlesGracefullyAsync()
    {
        // Arrange
        IList<ChatMessageContent> input =
        [
            new(AuthorRole.User, (string?)null)
        ];

        // Act
        string result = await DefaultTransforms.ToOutput<string>(input);

        // Assert
        Assert.Equal(string.Empty, result);
    }

    private sealed class TestObject
    {
        public int Id { get; set; }
        public string? Name { get; set; }
    }
}


===== UnitTests\Orchestration\GroupChatOrchestrationTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Threading.Tasks;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.Agents.Orchestration;
using Microsoft.SemanticKernel.Agents.Orchestration.GroupChat;
using Microsoft.SemanticKernel.Agents.Runtime.InProcess;
using Microsoft.SemanticKernel.ChatCompletion;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.Orchestration;

/// <summary>
/// Tests for the <see cref="GroupChatOrchestration"/> class.
/// </summary>
public class GroupChatOrchestrationTests
{
    [Fact]
    public async Task GroupChatOrchestrationWithSingleAgentAsync()
    {
        // Arrange
        await using InProcessRuntime runtime = new();
        MockAgent mockAgent1 = CreateMockAgent(2, "xyz");

        // Act: Create and execute the orchestration
        string response = await ExecuteOrchestrationAsync(runtime, mockAgent1);

        // Assert
        Assert.Equal("xyz", response);
        Assert.Equal(1, mockAgent1.InvokeCount);
    }

    [Fact]
    public async Task GroupChatOrchestrationWithMultipleAgentsAsync()
    {
        // Arrange
        await using InProcessRuntime runtime = new();

        MockAgent mockAgent1 = CreateMockAgent(1, "abc");
        MockAgent mockAgent2 = CreateMockAgent(2, "xyz");
        MockAgent mockAgent3 = CreateMockAgent(3, "lmn");

        // Act: Create and execute the orchestration
        string response = await ExecuteOrchestrationAsync(runtime, mockAgent1, mockAgent2, mockAgent3);

        // Assert
        Assert.Equal("lmn", response);
        Assert.Equal(1, mockAgent1.InvokeCount);
        Assert.Equal(1, mockAgent2.InvokeCount);
        Assert.Equal(1, mockAgent3.InvokeCount);
    }

    private static async Task<string> ExecuteOrchestrationAsync(InProcessRuntime runtime, params Agent[] mockAgents)
    {
        // Act
        await runtime.StartAsync();

        GroupChatOrchestration orchestration = new(new RoundRobinGroupChatManager() { MaximumInvocationCount = mockAgents.Length }, mockAgents);

        const string InitialInput = "123";
        OrchestrationResult<string> result = await orchestration.InvokeAsync(InitialInput, runtime);

        // Assert
        Assert.NotNull(result);

        // Act
        string response = await result.GetValueAsync(TimeSpan.FromSeconds(20));

        await runtime.RunUntilIdleAsync();

        return response;
    }

    private static MockAgent CreateMockAgent(int index, string response)
    {
        return new()
        {
            Description = $"test {index}",
            Response = [new(AuthorRole.Assistant, response)]
        };
    }
}


===== UnitTests\Orchestration\HandoffOrchestrationTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Net.Http;
using System.Threading.Tasks;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.Agents.Orchestration;
using Microsoft.SemanticKernel.Agents.Orchestration.Handoff;
using Microsoft.SemanticKernel.Agents.Runtime.InProcess;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.Orchestration;

/// <summary>
/// Tests for the <see cref="HandoffOrchestration"/> class.
/// </summary>
public class HandoffOrchestrationTests : IDisposable
{
    private readonly List<IDisposable> _disposables;

    /// <summary>
    /// Initializes a new instance of the <see cref="HandoffOrchestrationTests"/> class.
    /// </summary>
    public HandoffOrchestrationTests()
    {
        this._disposables = [];
    }

    /// <inheritdoc/>
    public void Dispose()
    {
        foreach (IDisposable disposable in this._disposables)
        {
            disposable.Dispose();
        }
        GC.SuppressFinalize(this);
    }

    [Fact]
    public async Task HandoffOrchestrationWithSingleAgentAsync()
    {
        // Arrange
        ChatCompletionAgent mockAgent1 =
            this.CreateMockAgent(
                "Agent1",
                "Test Agent",
                Responses.Message("Final response"));

        // Act: Create and execute the orchestration
        string response = await ExecuteOrchestrationAsync(OrchestrationHandoffs.StartWith(mockAgent1), mockAgent1);

        // Assert
        Assert.Equal("Final response", response);
    }

    [Fact]
    public async Task HandoffOrchestrationWithMultipleAgentsAsync()
    {
        // Arrange
        ChatCompletionAgent mockAgent1 =
            this.CreateMockAgent(
                "Agent1",
                "Test Agent",
                Responses.Handoff("Agent2"));
        ChatCompletionAgent mockAgent2 =
            this.CreateMockAgent(
                "Agent2",
                "Test Agent",
                Responses.Result("Final response"));
        ChatCompletionAgent mockAgent3 =
            this.CreateMockAgent(
                "Agent3",
                "Test Agent",
                Responses.Message("Wrong response"));

        // Act: Create and execute the orchestration
        string response = await ExecuteOrchestrationAsync(
            OrchestrationHandoffs
                .StartWith(mockAgent1)
                .Add(mockAgent1, mockAgent2, mockAgent3),
            mockAgent1,
            mockAgent2,
            mockAgent3);

        // Assert
        Assert.Equal("Final response", response);
    }

    private static async Task<string> ExecuteOrchestrationAsync(OrchestrationHandoffs handoffs, params Agent[] mockAgents)
    {
        // Arrange
        await using InProcessRuntime runtime = new();
        await runtime.StartAsync();

        HandoffOrchestration orchestration = new(handoffs, mockAgents);

        // Act
        const string InitialInput = "123";
        OrchestrationResult<string> result = await orchestration.InvokeAsync(InitialInput, runtime);

        // Assert
        Assert.NotNull(result);

        // Act
        string response = await result.GetValueAsync(TimeSpan.FromSeconds(10));
        await runtime.RunUntilIdleAsync();

        return response;
    }

    private ChatCompletionAgent CreateMockAgent(string name, string description, string response)
    {
        HttpMessageHandlerStub messageHandlerStub =
            new()
            {
                ResponseToReturn = new HttpResponseMessage
                {
                    StatusCode = System.Net.HttpStatusCode.OK,
                    Content = new StringContent(response),
                },
            };
        HttpClient httpClient = new(messageHandlerStub, disposeHandler: false);

        this._disposables.Add(messageHandlerStub);
        this._disposables.Add(httpClient);

        IKernelBuilder builder = Kernel.CreateBuilder();
        builder.AddOpenAIChatCompletion("gpt-test", "mykey", orgId: null, serviceId: null, httpClient);
        Kernel kernel = builder.Build();

        ChatCompletionAgent mockAgent1 =
            new()
            {
                Name = name,
                Description = description,
                Kernel = kernel,
            };

        return mockAgent1;
    }

    private static class Responses
    {
        public static string Message(string content) =>
            $$$"""            
            {
              "id": "chat-123",
              "object": "chat.completion",
              "created": 1699482945,
              "model": "gpt-4.1",
              "choices": [
                {
                  "index": 0,
                  "message": {
                    "role": "assistant",
                    "content": "{{{content}}}",
                    "tool_calls":[]
                  }
                }
              ],
              "usage": {
                "prompt_tokens": 52,
                "completion_tokens": 1,
                "total_tokens": 53
              }
            }      
            """;

        public static string Handoff(string agentName) =>
            $$$"""            
            {
              "id": "chat-123",
              "object": "chat.completion",
              "created": 1699482945,
              "model": "gpt-4.1",
              "choices": [
                {
                  "index": 0,
                  "message": {
                    "role": "assistant",
                    "content": null,
                    "tool_calls":[{
                        "id": "1",
                        "type": "function",
                        "function": {
                          "name": "{{{HandoffInvocationFilter.HandoffPlugin}}}-transfer_to_{{{agentName}}}",
                          "arguments": "{}"
                        }
                      }
                    ]
                  }
                }
              ],
              "usage": {
                "prompt_tokens": 52,
                "completion_tokens": 1,
                "total_tokens": 53
              }
            }      
            """;

        public static string Result(string summary) =>
            $$$"""            
            {
              "id": "chat-123",
              "object": "chat.completion",
              "created": 1699482945,
              "model": "gpt-4.1",
              "choices": [
                {
                  "index": 0,
                  "message": {
                    "role": "assistant",
                    "content": null,
                    "tool_calls":[{
                        "id": "1",
                        "type": "function",
                        "function": {
                          "name": "{{{HandoffInvocationFilter.HandoffPlugin}}}-end_task_with_summary",
                          "arguments": "{ \"summary\": \"{{{summary}}}\" }"
                        }
                      }
                    ]
                  }
                }
              ]
            }      
            """;
    }
}


===== UnitTests\Orchestration\HandoffsTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.Agents.Orchestration.Handoff;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.Orchestration;

public class HandoffsTests
{
    [Fact]
    public void EmptyConstructors_CreateEmptyCollections()
    {
        AgentHandoffs agentHandoffs = [];
        Assert.Empty(agentHandoffs);

        OrchestrationHandoffs orchestrationHandoffs = new("first");
        Assert.Empty(orchestrationHandoffs);
        Assert.Equal("first", orchestrationHandoffs.FirstAgentName);
    }

    [Fact]
    public void DictionaryConstructors_InvalidFirstAgent()
    {
        Assert.Throws<ArgumentNullException>(() => new OrchestrationHandoffs((string)null!));
        Assert.Throws<ArgumentException>(() => new OrchestrationHandoffs(string.Empty));
        Assert.Throws<ArgumentException>(() => new OrchestrationHandoffs(" "));
    }

    [Fact]
    public void Add_WithAgentObjects_CreatesHandoffRelationships()
    {
        // Arrange
        OrchestrationHandoffs handoffs = new("source");

        Agent sourceAgent = CreateAgent("source", "Source Agent");
        Agent targetAgent1 = CreateAgent("target1", "Target Agent 1");
        Agent targetAgent2 = CreateAgent("target2", "Target Agent 2");

        // Act
        handoffs.Add(sourceAgent, targetAgent1, targetAgent2);

        // Assert
        Assert.Single(handoffs);
        Assert.Equal("source", handoffs.FirstAgentName);
        Assert.True(handoffs.ContainsKey("source"));

        AgentHandoffs sourceHandoffs = handoffs["source"];
        Assert.Equal(2, sourceHandoffs.Count);
        Assert.Equal("Target Agent 1", sourceHandoffs["target1"]);
        Assert.Equal("Target Agent 2", sourceHandoffs["target2"]);
    }

    [Fact]
    public void Add_WithAgentAndCustomDescription_UsesCustomDescription()
    {
        // Arrange
        OrchestrationHandoffs handoffs = new("source");

        Agent sourceAgent = CreateAgent("source", "Source Agent");
        Agent targetAgent = CreateAgent("target", "Target Agent");
        string customDescription = "Custom handoff description";

        // Act
        handoffs.Add(sourceAgent, targetAgent, customDescription);

        // Assert
        Assert.Single(handoffs);
        Assert.Equal("source", handoffs.FirstAgentName);
        AgentHandoffs sourceHandoffs = handoffs["source"];
        Assert.Single(sourceHandoffs);
        Assert.Equal(customDescription, sourceHandoffs["target"]);
    }

    [Fact]
    public void Add_WithAgentAndTargetName_AddsHandoffWithDescription()
    {
        // Arrange
        OrchestrationHandoffs handoffs = new("source");

        Agent sourceAgent = CreateAgent("source", "Source Agent");
        string targetName = "targetName";
        string description = "Target description";

        // Act
        handoffs.Add(sourceAgent, targetName, description);

        // Assert
        Assert.Single(handoffs);
        Assert.Equal("source", handoffs.FirstAgentName);
        AgentHandoffs sourceHandoffs = handoffs["source"];
        Assert.Single(sourceHandoffs);
        Assert.Equal(description, sourceHandoffs[targetName]);
    }

    [Fact]
    public void Add_WithSourceNameAndTargetName_AddsHandoffWithDescription()
    {
        // Arrange
        OrchestrationHandoffs handoffs = new("sourceName");

        string sourceName = "sourceName";
        string targetName = "targetName";
        string description = "Target description";

        // Act
        handoffs.Add(sourceName, targetName, description);

        // Assert
        Assert.Single(handoffs);
        Assert.Equal("sourceName", handoffs.FirstAgentName);
        AgentHandoffs sourceHandoffs = handoffs[sourceName];
        Assert.Single(sourceHandoffs);
        Assert.Equal(description, sourceHandoffs[targetName]);
    }

    [Fact]
    public void Add_WithMultipleSourcesAndTargets_CreatesCorrectStructure()
    {
        // Arrange
        OrchestrationHandoffs handoffs = new("source1");

        Agent source1 = CreateAgent("source1", "Source Agent 1");
        Agent source2 = CreateAgent("source2", "Source Agent 2");

        Agent target1 = CreateAgent("target1", "Target Agent 1");
        Agent target2 = CreateAgent("target2", "Target Agent 2");
        Agent target3 = CreateAgent("target3", "Target Agent 3");

        // Act
        handoffs.Add(source1, target1, target2);
        handoffs.Add(source2, target2, target3);
        handoffs.Add(source1, target3, "Custom description");

        // Assert
        Assert.Equal(2, handoffs.Count);
        Assert.Equal("source1", handoffs.FirstAgentName);

        // Check source1's targets
        AgentHandoffs source1Handoffs = handoffs["source1"];
        Assert.Equal(3, source1Handoffs.Count);
        Assert.Equal("Target Agent 1", source1Handoffs["target1"]);
        Assert.Equal("Target Agent 2", source1Handoffs["target2"]);
        Assert.Equal("Custom description", source1Handoffs["target3"]);

        // Check source2's targets
        AgentHandoffs source2Handoffs = handoffs["source2"];
        Assert.Equal(2, source2Handoffs.Count);
        Assert.Equal("Target Agent 2", source2Handoffs["target2"]);
        Assert.Equal("Target Agent 3", source2Handoffs["target3"]);
    }

    [Fact]
    public void StaticAdd_CreatesNewOrchestrationHandoffs()
    {
        // Arrange
        Agent source = CreateAgent("source", "Source Agent");
        Agent target1 = CreateAgent("target1", "Target Agent 1");
        Agent target2 = CreateAgent("target2", "Target Agent 2");

        // Act
        OrchestrationHandoffs handoffs =
            OrchestrationHandoffs
                .StartWith(source)
                .Add(source, target1, target2);

        // Assert
        Assert.NotNull(handoffs);
        Assert.Equal(source.Id, handoffs.FirstAgentName);
        Assert.Single(handoffs);
        Assert.True(handoffs.ContainsKey("source"));

        AgentHandoffs sourceHandoffs = handoffs["source"];
        Assert.Equal(2, sourceHandoffs.Count);
        Assert.Equal("Target Agent 1", sourceHandoffs["target1"]);
        Assert.Equal("Target Agent 2", sourceHandoffs["target2"]);
    }

    [Fact]
    public void Add_WithAgentsWithNoNameUsesId()
    {
        // Arrange
        OrchestrationHandoffs handoffs = new("source-id");

        Agent sourceAgent = CreateAgent(id: "source-id", name: null);
        Agent targetAgent = CreateAgent(id: "target-id", name: null, description: "Target Description");

        // Act
        handoffs.Add(sourceAgent, targetAgent);

        // Assert
        Assert.Single(handoffs);
        Assert.Equal("source-id", handoffs.FirstAgentName);
        Assert.True(handoffs.ContainsKey("source-id"));

        AgentHandoffs sourceHandoffs = handoffs["source-id"];
        Assert.Single(sourceHandoffs);
        Assert.Equal("Target Description", sourceHandoffs["target-id"]);
    }

    [Fact]
    public void Add_WithTargetWithNoDescription_UsesEmptyString()
    {
        // Arrange
        OrchestrationHandoffs handoffs = new("source");

        Agent sourceAgent = CreateAgent("source", "Source Agent");
        Agent targetAgent = CreateAgent("target", null);

        // Act
        handoffs.Add(sourceAgent, targetAgent);

        // Assert
        Assert.Single(handoffs);
        Assert.Equal("source", handoffs.FirstAgentName);
        AgentHandoffs sourceHandoffs = handoffs["source"];
        Assert.Single(sourceHandoffs);
        Assert.Equal(string.Empty, sourceHandoffs["target"]);
    }

    private static ChatCompletionAgent CreateAgent(string id, string? description = null, string? name = null)
    {
        ChatCompletionAgent mockAgent =
            new()
            {
                Id = id,
                Description = description,
                Name = name,
            };

        return mockAgent;
    }
}


===== UnitTests\Orchestration\OrchestrationResultTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.SemanticKernel.Agents.Orchestration;
using Microsoft.SemanticKernel.Agents.Runtime;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.Orchestration;

public class OrchestrationResultTests
{
    [Fact]
    public void Constructor_InitializesPropertiesCorrectly()
    {
        // Arrange
        Exception? captureException = null;
        OrchestrationContext context = new("TestOrchestration", new TopicId("testTopic"), null, null, exception => captureException = exception, NullLoggerFactory.Instance, CancellationToken.None);
        TaskCompletionSource<string> tcs = new();

        // Act
        using CancellationTokenSource cancelSource = new();
        using OrchestrationResult<string> result = new(context, tcs, cancelSource, NullLogger.Instance);

        // Assert
        Assert.Null(captureException);
        Assert.Equal("TestOrchestration", result.Orchestration);
        Assert.Equal(new TopicId("testTopic"), result.Topic);
    }

    [Fact]
    public async Task GetValueAsync_ReturnsCompletedValue_WhenTaskIsCompletedAsync()
    {
        // Arrange
        Exception? captureException = null;
        OrchestrationContext context = new("TestOrchestration", new TopicId("testTopic"), null, null, exception => captureException = exception, NullLoggerFactory.Instance, CancellationToken.None);
        TaskCompletionSource<string> tcs = new();
        using CancellationTokenSource cancelSource = new();
        using OrchestrationResult<string> result = new(context, tcs, cancelSource, NullLogger.Instance);
        string expectedValue = "Result value";

        // Act
        tcs.SetResult(expectedValue);
        string actualValue = await result.GetValueAsync();

        // Assert
        Assert.Null(captureException);
        Assert.Equal(expectedValue, actualValue);
    }

    [Fact]
    public async Task GetValueAsync_WithTimeout_ReturnsCompletedValue_WhenTaskCompletesWithinTimeoutAsync()
    {
        // Arrange
        Exception? captureException = null;
        OrchestrationContext context = new("TestOrchestration", new TopicId("testTopic"), null, null, exception => captureException = exception, NullLoggerFactory.Instance, CancellationToken.None);
        TaskCompletionSource<string> tcs = new();
        using CancellationTokenSource cancelSource = new();
        using OrchestrationResult<string> result = new(context, tcs, cancelSource, NullLogger.Instance);
        string expectedValue = "Result value";
        TimeSpan timeout = TimeSpan.FromSeconds(1);

        // Act
        tcs.SetResult(expectedValue);
        string actualValue = await result.GetValueAsync(timeout);

        // Assert
        Assert.Null(captureException);
        Assert.Equal(expectedValue, actualValue);
    }

    [Fact]
    public async Task GetValueAsync_WithTimeout_ThrowsTimeoutException_WhenTaskDoesNotCompleteWithinTimeoutAsync()
    {
        // Arrange
        Exception? captureException = null;
        OrchestrationContext context = new("TestOrchestration", new TopicId("testTopic"), null, null, exception => captureException = exception, NullLoggerFactory.Instance, CancellationToken.None);
        TaskCompletionSource<string> tcs = new();
        using CancellationTokenSource cancelSource = new();
        using OrchestrationResult<string> result = new(context, tcs, cancelSource, NullLogger.Instance);
        TimeSpan timeout = TimeSpan.FromMilliseconds(50);

        // Act & Assert
        TimeoutException exception = await Assert.ThrowsAsync<TimeoutException>(() => result.GetValueAsync(timeout).AsTask());
        Assert.Null(captureException);
    }

    [Fact]
    public async Task GetValueAsync_ReturnsCompletedValue_WhenCompletionIsDelayedAsync()
    {
        // Arrange
        Exception? captureException = null;
        OrchestrationContext context = new("TestOrchestration", new TopicId("testTopic"), null, null, exception => captureException = exception, NullLoggerFactory.Instance, CancellationToken.None);
        TaskCompletionSource<int> tcs = new();
        using CancellationTokenSource cancelSource = new();
        using OrchestrationResult<int> result = new(context, tcs, cancelSource, NullLogger.Instance);
        int expectedValue = 42;

        // Act
        // Simulate delayed completion in a separate task
        Task delayTask = Task.Run(async () =>
        {
            await Task.Delay(100);
            tcs.SetResult(expectedValue);
        });

        int actualValue = await result.GetValueAsync();

        // Assert
        Assert.Null(captureException);
        Assert.Equal(expectedValue, actualValue);
    }
}


===== UnitTests\Orchestration\SequentialOrchestrationTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Threading.Tasks;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.Agents.Orchestration;
using Microsoft.SemanticKernel.Agents.Orchestration.Sequential;
using Microsoft.SemanticKernel.Agents.Runtime.InProcess;
using Microsoft.SemanticKernel.ChatCompletion;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.Orchestration;

/// <summary>
/// Tests for the <see cref="SequentialOrchestration"/> class.
/// </summary>
public class SequentialOrchestrationTests
{
    [Fact]
    public async Task SequentialOrchestrationWithSingleAgentAsync()
    {
        // Arrange
        await using InProcessRuntime runtime = new();
        MockAgent mockAgent1 = CreateMockAgent(2, "xyz");

        // Act: Create and execute the orchestration
        string response = await ExecuteOrchestrationAsync(runtime, mockAgent1);

        // Assert
        Assert.Equal("xyz", response);
        Assert.Equal(1, mockAgent1.InvokeCount);
    }

    [Fact]
    public async Task SequentialOrchestrationWithMultipleAgentsAsync()
    {
        // Arrange
        await using InProcessRuntime runtime = new();

        MockAgent mockAgent1 = CreateMockAgent(1, "abc");
        MockAgent mockAgent2 = CreateMockAgent(2, "xyz");
        MockAgent mockAgent3 = CreateMockAgent(3, "lmn");

        // Act: Create and execute the orchestration
        string response = await ExecuteOrchestrationAsync(runtime, mockAgent1, mockAgent2, mockAgent3);

        // Assert
        Assert.Equal("lmn", response);
        Assert.Equal(1, mockAgent1.InvokeCount);
        Assert.Equal(1, mockAgent2.InvokeCount);
        Assert.Equal(1, mockAgent3.InvokeCount);
    }

    private static async Task<string> ExecuteOrchestrationAsync(InProcessRuntime runtime, params Agent[] mockAgents)
    {
        // Act
        await runtime.StartAsync();

        SequentialOrchestration orchestration = new(mockAgents);

        const string InitialInput = "123";
        OrchestrationResult<string> result = await orchestration.InvokeAsync(InitialInput, runtime);

        // Assert
        Assert.NotNull(result);

        // Act
        string response = await result.GetValueAsync(TimeSpan.FromSeconds(20));

        await runtime.RunUntilIdleAsync();

        return response;
    }

    private static MockAgent CreateMockAgent(int index, string response)
    {
        return new()
        {
            Description = $"test {index}",
            Response = [new(AuthorRole.Assistant, response)]
        };
    }
}


===== UnitTests\Test\AssertCollection.cs =====

// Copyright (c) Microsoft. All rights reserved.
using System;
using System.Collections.Generic;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.Test;

internal static class AssertCollection
{
    public static void Equal<T>(IReadOnlyList<T>? source, IReadOnlyList<T>? target, Func<T, object?>? adapter = null)
    {
        if (source == null)
        {
            Assert.Null(target);
            return;
        }

        Assert.NotNull(target);
        Assert.Equal(source.Count, target.Count);

        adapter ??= (x) => x;

        for (int i = 0; i < source.Count; i++)
        {
            Assert.Equal(adapter(source[i]), adapter(target[i]));
        }
    }

    public static void Equal<TKey, TValue>(IReadOnlyDictionary<TKey, TValue>? source, IReadOnlyDictionary<TKey, TValue>? target)
    {
        if (source == null)
        {
            Assert.Null(target);
            return;
        }

        Assert.NotNull(target);
        Assert.Equal(source.Count, target.Count);

        foreach ((TKey key, TValue value) in source)
        {
            Assert.True(target.TryGetValue(key, out TValue? targetValue));
            Assert.Equal(value, targetValue);
        }
    }
}


===== UnitTests\Test\FakeTokenCredential.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;

namespace SemanticKernel.Agents.UnitTests;

internal sealed class FakeTokenCredential : TokenCredential
{
    /// <inheritdoc/>
    public override AccessToken GetToken(TokenRequestContext requestContext, CancellationToken cancellationToken)
    {
        return new AccessToken("fakeToken", DateTimeOffset.Now.AddHours(1));
    }

    /// <inheritdoc/>
    public override ValueTask<AccessToken> GetTokenAsync(TokenRequestContext requestContext, CancellationToken cancellationToken)
    {
        return new ValueTask<AccessToken>(new AccessToken("fakeToken", DateTimeOffset.Now.AddHours(1)));
    }
}


===== UnitTests\Yaml\AgentDefinitionYamlTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using Microsoft.Extensions.Configuration;
using Microsoft.SemanticKernel.Agents;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.Yaml;

/// <summary>
/// Unit tests for <see cref="AgentDefinitionYaml"/>.
/// </summary>
public class AgentDefinitionYamlTests
{
    /// <summary>
    /// Verify can create an instance of <see cref="AgentDefinition"/> from YAML text.
    /// </summary>
    [Fact]
    public void VerifyAgentDefinitionFromYaml()
    {
        // Arrange
        var text =
            """
            id: agent_12345
            version: 1.0.0
            type: chat_completion_agent
            name: My Agent
            description: Description of My Agent
            instructions: Instructions for how My Agent works
            metadata:
                authors:
                    - Bob
                    - Ted
                    - Alice
                tags:
                    - red
                    - green
                    - blue
                created: 2025-02-21
            model:
                id: ${AzureAI:ChatModelId}
                options:
                    temperature: 0.4
                    function_choice_behavior:
                        type: auto
                connection:
                    type: azureai
            inputs:
                input1:
                    description: input1 description
                    required: true
                    default: input1 default
                    sample: input1 sample
                input2:
                    description: input2 description
                    required: false
                    default: input2 default
                    sample: input2 sample
            outputs:
                output1:
                    description: output1 description
            template:
                format: liquid
                parser: semantic-kernel
            tools:
                - id: tool1
                  type: code_interpreter
                  description: Code interpreter tool
                - id: tool2
                  type: file_search
                  description: File search tool
            """;

        // Act
        var agentDefinition = AgentDefinitionYaml.FromYaml(text);

        // Assert
        Assert.NotNull(agentDefinition);
    }

    /// <summary>
    /// Verify can create an instance of <see cref="AgentDefinition"/> from YAML text.
    /// </summary>
    [Fact]
    public void VerifyAgentDefinitionMetadataPropertiesFromYaml()
    {
        // Arrange
        var text =
            """
            version: 1.0.0
            type: chat_completion_agent
            name: My Agent
            description: Description of My Agent
            instructions: Instructions for how My Agent works
            metadata:
                authors:
                    - Bob
                    - Ted
                    - Alice
                tags:
                    - red
                    - green
                    - blue
                created: 2025-02-21
            """;

        // Act
        var agentDefinition = AgentDefinitionYaml.FromYaml(text);

        // Assert
        Assert.NotNull(agentDefinition);
        Assert.Equal("1.0.0", agentDefinition.Version);
        Assert.Equal("chat_completion_agent", agentDefinition.Type);
        Assert.Equal("My Agent", agentDefinition.Name);
        Assert.Equal("Description of My Agent", agentDefinition.Description);
        Assert.Equal("Instructions for how My Agent works", agentDefinition.Instructions);
        Assert.NotNull(agentDefinition.Metadata);
        Assert.Equal(3, agentDefinition.Metadata.Authors?.Count);
        Assert.Equal(3, agentDefinition.Metadata.Tags?.Count);
        Assert.Equal("2025-02-21", agentDefinition.Metadata.ExtensionData["created"]);
    }

    /// <summary>
    /// Verify can create an instance of <see cref="AgentDefinition"/> from YAML text
    /// and values are resolved successfully from an <see cref="IConfiguration"/> instance.
    /// </summary>
    [Fact]
    public void VerifyAgentDefinitionWithConfigurationFromYaml()
    {
        // Arrange
        var text =
            """
            version: 1.0.0
            type: chat_completion_agent
            name: ${OpenAI:AgentName}
            description: Description of My Agent
            instructions: Instructions for how My Agent works
            model:
                id: ${BedrockAgent:ChatModelId}
                connection:
                    connection_string: ${AzureAI.ConnectionString}
                    agent_resource_role_arn: ${BedrockAgent.AgentResourceRoleArn}
            tools:
              - type: file_search
                description: Grounding with available files.
                options:
                  vector_store_ids:
                    - ${OpenAI:VectorStoreId1}
                    - ${OpenAI:VectorStoreId2}
              - type: knowledge_base
                description: You will find information here.
                options:
                  knowledge_base_id: ${BedrockAgent.KnowledgeBaseId}
              - type: bing_grounding
                options:
                  tool_connections:
                    - ${AzureAI.BingConnectionId}
            """;

        var configData = new Dictionary<string, string?>
        {
            {"OpenAI:AgentName", "My Agent"},
            {"OpenAI:VectorStoreId1", "VECTOR-STORE-ID-1"},
            {"OpenAI:VectorStoreId2", "VECTOR-STORE-ID-2"},
            {"AzureAI.ConnectionString", "CONNECTION-STRING"},
            {"AzureAI.BingConnectionId", "BING-CONNECTION-ID"},
            {"BedrockAgent:ChatModelId", "CHAT-MODEL-ID"},
            {"BedrockAgent.AgentResourceRoleArn", "AGENT-RESOURCE-ROLE-ARN"},
            {"BedrockAgent.KnowledgeBaseId", "KNOWLEDGE-BASE-ID"},
        };
        var configuration = new ConfigurationBuilder().AddInMemoryCollection(configData).Build();

        // Act
        var agentDefinition = AgentDefinitionYaml.FromYaml(text, configuration);

        // Assert
        Assert.NotNull(agentDefinition);
        Assert.Equal("1.0.0", agentDefinition.Version);
        Assert.Equal("chat_completion_agent", agentDefinition.Type);
        Assert.Equal("My Agent", agentDefinition.Name);
        Assert.Equal("Description of My Agent", agentDefinition.Description);
        Assert.Equal("Instructions for how My Agent works", agentDefinition.Instructions);

        Assert.NotNull(agentDefinition.Model);
        Assert.Equal("CHAT-MODEL-ID", agentDefinition.Model.Id);
        Assert.NotNull(agentDefinition.Model.Connection);
        Assert.NotNull(agentDefinition.Model.Connection.ExtensionData);
        Assert.Equal("CONNECTION-STRING", agentDefinition.Model.Connection.ExtensionData["connection_string"]);
        Assert.Equal("AGENT-RESOURCE-ROLE-ARN", agentDefinition.Model.Connection.ExtensionData["agent_resource_role_arn"]);

        Assert.NotNull(agentDefinition.Tools);

        var fileSearch = agentDefinition.GetFirstToolDefinition("file_search");
        Assert.NotNull(fileSearch);
        Assert.NotNull(fileSearch.Options);
        Assert.NotNull(fileSearch.Options!["vector_store_ids"]);
        var vectorStoreIds = fileSearch.Options!["vector_store_ids"] as List<object>;
        Assert.NotNull(vectorStoreIds);
        Assert.Equal("VECTOR-STORE-ID-1", vectorStoreIds[0]);
        Assert.Equal("VECTOR-STORE-ID-2", vectorStoreIds[1]);

        var knowledgeBase = agentDefinition.GetFirstToolDefinition("knowledge_base");
        Assert.NotNull(knowledgeBase);
        Assert.NotNull(knowledgeBase.Options);
        var knowledgeBaseId = knowledgeBase.Options!["knowledge_base_id"] as string;
        Assert.Equal("KNOWLEDGE-BASE-ID", knowledgeBaseId);

        var bingGrounding = agentDefinition.GetFirstToolDefinition("bing_grounding");
        Assert.NotNull(bingGrounding);
        Assert.NotNull(bingGrounding.Options);
        Assert.NotNull(bingGrounding.Options!["tool_connections"]);
        var toolConnections = bingGrounding.Options!["tool_connections"] as List<object>;
        Assert.NotNull(toolConnections);
        Assert.Equal("BING-CONNECTION-ID", toolConnections[0]);
    }
}


===== UnitTests\Yaml\AgentYamlTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Net;
using System.Net.Http;
using System.Threading.Tasks;
using Azure.AI.Agents.Persistent;
using Azure.AI.Projects;
using Azure.Core.Pipeline;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.Agents.AzureAI;
using Microsoft.SemanticKernel.Agents.OpenAI;
using OpenAI;
using SemanticKernel.Agents.UnitTests.AzureAI.Definition;
using SemanticKernel.Agents.UnitTests.OpenAI;
using SemanticKernel.Agents.UnitTests.OpenAI.Definition;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.Yaml;

/// <summary>
/// Unit tests for <see cref="YamlAgentFactoryExtensions"/>.
/// </summary>
public class AgentYamlTests : IDisposable
{
    private readonly HttpMessageHandlerStub _messageHandlerStub;
    private readonly HttpClient _httpClient;
    private readonly Kernel _kernel;

    /// <summary>
    /// Initializes a new instance of the <see cref="OpenAIAssistantAgentTests"/> class.
    /// </summary>
    public AgentYamlTests()
    {
        this._messageHandlerStub = new HttpMessageHandlerStub();
        this._httpClient = new HttpClient(this._messageHandlerStub, disposeHandler: false);

        var builder = Kernel.CreateBuilder();

        // Add OpenAI client
        OpenAIClient openAIClient = OpenAIAssistantAgent.CreateOpenAIClient(new System.ClientModel.ApiKeyCredential("fakekey"), httpClient: this._httpClient);
        builder.Services.AddSingleton(openAIClient);

        // Add Azure AI agents client
        var client = new PersistentAgentsClient(
            "https://endpoint",
            new FakeTokenCredential(),
            new PersistentAgentsAdministrationClientOptions
            {
                Transport = new HttpClientTransport(this._httpClient)
            });
        builder.Services.AddSingleton(client);
        var projectClient = new AIProjectClient(
            new Uri("https://test"),
            new FakeTokenCredential());
        builder.Services.AddSingleton(projectClient);

        this._kernel = builder.Build();
    }

    /// <inheritdoc/>
    public void Dispose()
    {
        GC.SuppressFinalize(this);
        this._messageHandlerStub.Dispose();
        this._httpClient.Dispose();
    }

    /// <summary>
    /// Verify can create an instance of <see cref="AgentDefinition"/> from YAML text.
    /// </summary>
    [Fact]
    public void VerifyAgentDefinitionFromYaml()
    {
        // Arrange
        var text =
            """
            version: 1.0.0
            type: chat_completion_agent
            name: ChatCompletionAgent
            description: ChatCompletionAgent Description
            instructions: ChatCompletionAgent Instructions
            metadata:
                author: Microsoft
                created: 2025-02-21
            model:
                id: gpt-4o-mini
                options:
                    temperature: 0.4
                    function_choice_behavior:
                        type: auto
                connection:
                    type: azureai
            inputs:
                input1:
                    description: input1 description
                    required: true
                    default: input1 default
                    sample: input1 sample
                input2:
                    description: input2 description
                    required: false
                    default: input2 default
                    sample: input2 sample
            outputs:
                output1:
                    description: output1 description
            template:
                format: liquid
                parser: semantic-kernel
            tools:
                - id: tool1
                  type: code_interpreter
                - id: tool2
                  type: file_search
            """;

        // Act
        var agentDefinition = AgentDefinitionYaml.FromYaml(text);

        // Assert
        Assert.NotNull(agentDefinition);
    }

    /// <summary>
    /// Verify can create an instance of <see cref="Microsoft.SemanticKernel.Agents.Agent"/> using <see cref="ChatCompletionAgentFactory"/>
    /// </summary>
    [Fact]
    public async Task VerifyCanCreateChatCompletionAgentAsync()
    {
        // Arrange
        var text =
            """
            type: chat_completion_agent
            name: ChatCompletionAgent
            description: ChatCompletionAgent Description
            instructions: ChatCompletionAgent Instructions
            model:
              id: gpt-4o-mini
              options:
                temperature: 0.4
                function_choice_behavior:
                  type: auto
            """;
        ChatCompletionAgentFactory factory = new();

        // Act
        var agent = await factory.CreateAgentFromYamlAsync(text, new() { Kernel = this._kernel });

        // Assert
        Assert.NotNull(agent);
        Assert.True(agent is ChatCompletionAgent);
        Assert.Equal("ChatCompletionAgent", agent.Name);
        Assert.Equal("ChatCompletionAgent Description", agent.Description);
        Assert.Equal("ChatCompletionAgent Instructions", agent.Instructions);
        Assert.Equal(this._kernel, agent.Kernel);
    }

    /// <summary>
    /// Verify can create an instance of <see cref="Microsoft.SemanticKernel.Agents.Agent"/> using <see cref="OpenAIAssistantAgentFactory"/>
    /// </summary>
    [Fact]
    public async Task VerifyCanCreateOpenAIAssistantAsync()
    {
        // Arrange
        var text =
            """
            type: openai_assistant
            name: OpenAIAssistantAgent
            description: OpenAIAssistantAgent Description
            instructions: OpenAIAssistantAgent Instructions
            model:
              id: gpt-4o-mini
            tools:
                - id: tool1
                  type: code_interpreter
            """;
        OpenAIAssistantAgentFactory factory = new();
        this.SetupResponse(HttpStatusCode.OK, OpenAIAssistantAgentFactoryTests.OpenAIAssistantCreateResponse);

        // Act
        var agent = await factory.CreateAgentFromYamlAsync(text, new() { Kernel = this._kernel });

        // Assert
        Assert.NotNull(agent);
        Assert.True(agent is OpenAIAssistantAgent);
        Assert.Equal("OpenAIAssistantAgent", agent.Name);
        Assert.Equal("OpenAIAssistantAgent Description", agent.Description);
        Assert.Equal("OpenAIAssistantAgent Instructions", agent.Instructions);
        Assert.Equal(this._kernel, agent.Kernel);
    }

    /// <summary>
    /// Verify can create an instance of <see cref="Microsoft.SemanticKernel.Agents.Agent"/> using <see cref="AzureAIAgentFactory"/>
    /// </summary>
    [Fact]
    public async Task VerifyCanCreateAzureAIAgentAsync()
    {
        // Arrange
        var text =
            """
            type: foundry_agent
            name: AzureAIAgent
            description: AzureAIAgent Description
            instructions: AzureAIAgent Instructions
            model:
              id: gpt-4o-mini
            tools:
                - id: tool1
                  type: code_interpreter
            """;
        AzureAIAgentFactory factory = new();
        this.SetupResponse(HttpStatusCode.OK, AzureAIAgentFactoryTests.AzureAIAgentCreateResponse);

        // Act
        var agent = await factory.CreateAgentFromYamlAsync(text, new() { Kernel = this._kernel });

        // Assert
        Assert.NotNull(agent);
        Assert.True(agent is AzureAIAgent);
        Assert.Equal("AzureAIAgent", agent.Name);
        Assert.Equal("AzureAIAgent Description", agent.Description);
        Assert.Equal("AzureAIAgent Instructions", agent.Instructions);
        Assert.Equal(this._kernel, agent.Kernel);
    }

    #region private
    private void SetupResponse(HttpStatusCode statusCode, string response) =>
#pragma warning disable CA2000 // Dispose objects before losing scope
        this._messageHandlerStub.ResponseQueue.Enqueue(new(statusCode)
        {
            Content = new StringContent(response)
        });
    #endregion
}


===== UnitTests\Yaml\AzureAIKernelAgentYamlTests.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.ComponentModel;
using System.Net;
using System.Net.Http;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;
using Azure.AI.Agents.Persistent;
using Azure.AI.Projects;
using Azure.Core.Pipeline;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.Agents.AzureAI;
using SemanticKernel.Agents.UnitTests.AzureAI.Definition;
using Xunit;

namespace SemanticKernel.Agents.UnitTests.Yaml;

/// <summary>
/// Unit tests for <see cref="YamlAgentFactoryExtensions"/> with <see cref="AzureAIAgentFactory"/>.
/// </summary>
public class AzureAIKernelAgentYamlTests : IDisposable
{
    private readonly HttpMessageHandlerStub _agentClientHandlerStub;
    private readonly HttpClient _agentHttpClient;
    private readonly HttpMessageHandlerStub _projectClientHandlerStub;
    private readonly HttpClient _projectHttpClient;
    private readonly Kernel _kernel;

    /// <summary>
    /// Initializes a new instance of the <see cref="AzureAIKernelAgentYamlTests"/> class.
    /// </summary>
    public AzureAIKernelAgentYamlTests()
    {
        this._agentClientHandlerStub = new HttpMessageHandlerStub();
        this._agentHttpClient = new HttpClient(this._agentClientHandlerStub, disposeHandler: false);

        this._projectClientHandlerStub = new HttpMessageHandlerStub();
        this._projectHttpClient = new HttpClient(this._projectClientHandlerStub, disposeHandler: false);

        var builder = Kernel.CreateBuilder();

        // Add Azure AI agents client
        var client = new PersistentAgentsClient(
            "https://test",
            new FakeTokenCredential(),
            new PersistentAgentsAdministrationClientOptions
            {
                Transport = new HttpClientTransport(this._agentHttpClient)
            });
        builder.Services.AddSingleton(client);
        var projectClient = new AIProjectClient(
            new Uri("https://test"),
            new FakeTokenCredential(),
            new AIProjectClientOptions
            {
                Transport = new HttpClientTransport(this._projectHttpClient)
            });
        builder.Services.AddSingleton(projectClient);

        this._kernel = builder.Build();
        this._kernel.Plugins.Add(KernelPluginFactory.CreateFromType<WeatherPlugin>());
    }

    /// <inheritdoc/>
    public void Dispose()
    {
        GC.SuppressFinalize(this);
        this._agentClientHandlerStub.Dispose();
        this._agentHttpClient.Dispose();
        this._projectClientHandlerStub.Dispose();
        this._projectHttpClient.Dispose();
    }

    /// <summary>
    /// Verify the request includes a tool of the specified when creating an Azure AI agent.
    /// </summary>
    [Theory]
    [InlineData("code_interpreter")]
    [InlineData("azure_ai_search")]
    public async Task VerifyRequestIncludesToolAsync(string type)
    {
        // Arrange
        var text =
            $"""
            type: foundry_agent
            name: FoundryAgent
            description: AzureAIAgent Description
            instructions: AzureAIAgent Instructions
            model:
              id: gpt-4o-mini
            tools:
                - type: {type}
            """;
        AzureAIAgentFactory factory = new();
        this.SetupResponse(HttpStatusCode.OK, AzureAIAgentFactoryTests.AzureAIAgentCreateResponse);

        // Act
        var agent = await factory.CreateAgentFromYamlAsync(text, new() { Kernel = this._kernel });

        // Assert
        Assert.NotNull(agent);
        var requestContent = Encoding.UTF8.GetString(this._agentClientHandlerStub.RequestContent!);
        Assert.NotNull(requestContent);
        var requestJson = JsonSerializer.Deserialize<JsonElement>(requestContent);
        Assert.Equal(1, requestJson.GetProperty("tools").GetArrayLength());
        Assert.Equal(type, requestJson.GetProperty("tools")[0].GetProperty("type").GetString());
    }

    /// <summary>
    /// Verify the request includes an Azure Function tool when creating an Azure AI agent.
    /// </summary>
    [Fact]
    public async Task VerifyRequestIncludesAzureFunctionAsync()
    {
        // Arrange
        const string Text =
            """
            type: foundry_agent
            name: FoundryAgent
            description: AzureAIAgent Description
            instructions: AzureAIAgent Instructions
            model:
              id: gpt-4o-mini
            tools:
                - type: azure_function
                  id: function1
                  description: function1 description
                  options:
                      input_binding:
                          storage_service_endpoint: https://storage_service_endpoint
                          queue_name: queue_name
                      output_binding:
                          storage_service_endpoint: https://storage_service_endpoint
                          queue_name: queue_name
                      parameters:
                          - name: param1
                            type: string
                            description: param1 description
                          - name: param2
                            type: string
                            description: param2 description
            """;
        AzureAIAgentFactory factory = new();
        this.SetupResponse(HttpStatusCode.OK, AzureAIAgentFactoryTests.AzureAIAgentCreateResponse);

        // Act
        var agent = await factory.CreateAgentFromYamlAsync(Text, new() { Kernel = this._kernel });

        // Assert
        Assert.NotNull(agent);
        var requestContent = Encoding.UTF8.GetString(this._agentClientHandlerStub.RequestContent!);
        Assert.NotNull(requestContent);
        var requestJson = JsonSerializer.Deserialize<JsonElement>(requestContent);
        Assert.Equal(1, requestJson.GetProperty("tools").GetArrayLength());
        Assert.Equal("azure_function", requestJson.GetProperty("tools")[0].GetProperty("type").GetString());
    }

    /// <summary>
    /// Verify the request includes a Function when creating an Azure AI agent.
    /// </summary>
    [Fact]
    public async Task VerifyRequestIncludesFunctionAsync()
    {
        // Arrange
        const string Text =
            """
            type: foundry_agent
            name: FoundryAgent
            description: AzureAIAgent Description
            instructions: AzureAIAgent Instructions
            model:
              id: gpt-4o-mini
            tools:
                - type: function
                  id: WeatherPlugin.Current
                  description: Provides real-time weather information.
                  options:
                      parameters:
                          - name: location
                            type: string
                            description: The location to get the weather for.
            """;
        AzureAIAgentFactory factory = new();
        this.SetupResponse(HttpStatusCode.OK, AzureAIAgentFactoryTests.AzureAIAgentCreateResponse);

        // Act
        var agent = await factory.CreateAgentFromYamlAsync(Text, new() { Kernel = this._kernel });

        // Assert
        Assert.NotNull(agent);
        var requestContent = Encoding.UTF8.GetString(this._agentClientHandlerStub.RequestContent!);
        Assert.NotNull(requestContent);
        var requestJson = JsonSerializer.Deserialize<JsonElement>(requestContent);
        Assert.Equal(1, requestJson.GetProperty("tools").GetArrayLength());
        Assert.Equal("function", requestJson.GetProperty("tools")[0].GetProperty("type").GetString());
    }

    /// <summary>
    /// Verify the request includes a Bing Grounding tool when creating an Azure AI agent.
    /// </summary>
    [Fact]
    public async Task VerifyRequestIncludesBingGroundingAsync()
    {
        // Arrange
        const string Text =
            """
            type: foundry_agent
            name: FoundryAgent
            description: AzureAIAgent Description
            instructions: AzureAIAgent Instructions
            model:
              id: gpt-4o-mini
            tools:
                - type: bing_grounding
                  options:
                    tool_connections:
                      - test_connection
            """;
        AzureAIAgentFactory factory = new();
        this.SetupResponse(HttpStatusCode.OK, AzureAIAgentFactoryTests.AzureAIAgentCreateResponse);
        this._projectClientHandlerStub.ResponseToReturn =
            new HttpResponseMessage(HttpStatusCode.OK)
            {
                Content = new StringContent(AzureAIAgentFactoryTests.ProjectBingGroundingConnectionResponse)
            };

        // Act
        var agent = await factory.CreateAgentFromYamlAsync(Text, new() { Kernel = this._kernel });

        // Assert
        Assert.NotNull(agent);
        var requestContent = Encoding.UTF8.GetString(this._agentClientHandlerStub.RequestContent!);
        Assert.NotNull(requestContent);
        var requestJson = JsonSerializer.Deserialize<JsonElement>(requestContent);
        Assert.Equal(1, requestJson.GetProperty("tools").GetArrayLength());
        Assert.Equal("bing_grounding", requestJson.GetProperty("tools")[0].GetProperty("type").GetString());
    }

    /// <summary>
    /// Verify the request includes a Open API tool when creating an Azure AI agent.
    /// </summary>
    [Fact]
    public async Task VerifyRequestIncludesOpenAPIAsync()
    {
        // Arrange
        const string Text =
            """
            type: foundry_agent
            name: FoundryAgent
            description: AzureAIAgent Description
            instructions: AzureAIAgent Instructions
            model:
              id: gpt-4o-mini
            tools:
                - type: openapi
                  id: function1
                  description: function1 description
                  options:
                    specification: {"openapi":"3.1.0","info":{"title":"Get Weather Data","description":"Retrieves current weather data for a location based on wttr.in.","version":"v1.0.0"},"servers":[{"url":"https://wttr.in"}],"auth":[],"paths":{"/{location}":{"get":{"description":"Get weather information for a specific location","operationId":"GetCurrentWeather","parameters":[{"name":"location","in":"path","description":"City or location to retrieve the weather for","required":true,"schema":{"type":"string"}},{"name":"format","in":"query","description":"Always use j1 value for this parameter","required":true,"schema":{"type":"string","default":"j1"}}],"responses":{"200":{"description":"Successful response","content":{"text/plain":{"schema":{"type":"string"}}}},"404":{"description":"Location not found"}},"deprecated":false}}},"components":{"schemes":{}}}
                - type: openapi
                  id: function2
                  description: function2 description
                  options:
                      specification: {"openapi":"3.1.0","info":{"title":"Get Weather Data","description":"Retrieves current weather data for a location based on wttr.in.","version":"v1.0.0"},"servers":[{"url":"https://wttr.in"}],"auth":[],"paths":{"/{location}":{"get":{"description":"Get weather information for a specific location","operationId":"GetCurrentWeather","parameters":[{"name":"location","in":"path","description":"City or location to retrieve the weather for","required":true,"schema":{"type":"string"}},{"name":"format","in":"query","description":"Always use j1 value for this parameter","required":true,"schema":{"type":"string","default":"j1"}}],"responses":{"200":{"description":"Successful response","content":{"text/plain":{"schema":{"type":"string"}}}},"404":{"description":"Location not found"}},"deprecated":false}}},"components":{"schemes":{}}}
                      authentication:
                          connection_id: connection_id
                - type: openapi
                  id: function3
                  description: function3 description
                  options:
                      specification: {"openapi":"3.1.0","info":{"title":"Get Weather Data","description":"Retrieves current weather data for a location based on wttr.in.","version":"v1.0.0"},"servers":[{"url":"https://wttr.in"}],"auth":[],"paths":{"/{location}":{"get":{"description":"Get weather information for a specific location","operationId":"GetCurrentWeather","parameters":[{"name":"location","in":"path","description":"City or location to retrieve the weather for","required":true,"schema":{"type":"string"}},{"name":"format","in":"query","description":"Always use j1 value for this parameter","required":true,"schema":{"type":"string","default":"j1"}}],"responses":{"200":{"description":"Successful response","content":{"text/plain":{"schema":{"type":"string"}}}},"404":{"description":"Location not found"}},"deprecated":false}}},"components":{"schemes":{}}}
                      authentication:
                          audience: audience
            """;
        AzureAIAgentFactory factory = new();
        this.SetupResponse(HttpStatusCode.OK, AzureAIAgentFactoryTests.AzureAIAgentCreateResponse);

        // Act
        var agent = await factory.CreateAgentFromYamlAsync(Text, new() { Kernel = this._kernel });

        // Assert
        Assert.NotNull(agent);
        var requestContent = Encoding.UTF8.GetString(this._agentClientHandlerStub.RequestContent!);
        Assert.NotNull(requestContent);
        var requestJson = JsonSerializer.Deserialize<JsonElement>(requestContent);
        Assert.Equal(3, requestJson.GetProperty("tools").GetArrayLength());
        Assert.Equal("openapi", requestJson.GetProperty("tools")[0].GetProperty("type").GetString());
        Assert.Equal("openapi", requestJson.GetProperty("tools")[1].GetProperty("type").GetString());
        Assert.Equal("openapi", requestJson.GetProperty("tools")[2].GetProperty("type").GetString());
    }

    /// <summary>
    /// Verify the request includes a code interpreter tool and associated resource when creating an Azure AI agent.
    /// </summary>
    [Fact]
    public async Task VerifyRequestIncludesCodeInterpreterWithResourceAsync()
    {
        // Arrange
        const string Text =
            """
            type: foundry_agent
            name: FoundryAgent
            description: AzureAIAgent Description
            instructions: AzureAIAgent Instructions
            model:
              id: gpt-4o-mini
            tools:
                - type: code_interpreter
                  options:
                      file_ids:
                          - file_id_1
                          - file_id_2
                      data_sources:
                          - asset_identifier: data_source_1
                            asset_type: uri_asset
                          - asset_identifier: data_source_2
                            asset_type: id_asset
            """;
        AzureAIAgentFactory factory = new();
        this.SetupResponse(HttpStatusCode.OK, AzureAIAgentFactoryTests.AzureAIAgentCreateResponse);

        // Act
        var agent = await factory.CreateAgentFromYamlAsync(Text, new() { Kernel = this._kernel });

        // Assert
        Assert.NotNull(agent);
        var requestContent = Encoding.UTF8.GetString(this._agentClientHandlerStub.RequestContent!);
        Assert.NotNull(requestContent);
        var requestJson = JsonSerializer.Deserialize<JsonElement>(requestContent);
        Assert.Equal(1, requestJson.GetProperty("tools").GetArrayLength());
        Assert.Equal("code_interpreter", requestJson.GetProperty("tools")[0].GetProperty("type").GetString());
        var toolResources = requestJson.GetProperty("tool_resources");
        toolResources.TryGetProperty("code_interpreter", out var codeInterpreter);
        Assert.Equal(2, codeInterpreter.GetProperty("file_ids").GetArrayLength());
        Assert.Equal(2, codeInterpreter.GetProperty("data_sources").GetArrayLength());
    }

    /// <summary>
    /// Verify the request includes a code interpreter tool and associated resource when creating an Azure AI agent.
    /// </summary>
    [Fact]
    public async Task VerifyRequestIncludesAzureAISearchWithResourceAsync()
    {
        // Arrange
        const string Text =
            """
            type: foundry_agent
            name: FoundryAgent
            description: AzureAIAgent Description
            instructions: AzureAIAgent Instructions
            model:
              id: gpt-4o-mini
            tools:
                - type: azure_ai_search
                  options:
                      index_connection_id: id_1
                      index_name: name_1
                      top_k: 6
                      filter: "field1 = 'value1' and field2 = 'value2'"
                      query_type: "semantic"
            """;
        AzureAIAgentFactory factory = new();
        this.SetupResponse(HttpStatusCode.OK, AzureAIAgentFactoryTests.AzureAIAgentCreateResponse);

        // Act
        var agent = await factory.CreateAgentFromYamlAsync(Text, new() { Kernel = this._kernel });

        // Assert
        Assert.NotNull(agent);
        var requestContent = Encoding.UTF8.GetString(this._agentClientHandlerStub.RequestContent!);
        Assert.NotNull(requestContent);
        var requestJson = JsonSerializer.Deserialize<JsonElement>(requestContent);
        Assert.Equal(1, requestJson.GetProperty("tools").GetArrayLength());
        Assert.Equal("azure_ai_search", requestJson.GetProperty("tools")[0].GetProperty("type").GetString());
        var toolResources = requestJson.GetProperty("tool_resources");
        toolResources.TryGetProperty("azure_ai_search", out var azureAiSearch);
        Assert.Equal(1, azureAiSearch.GetProperty("indexes").GetArrayLength());
        Assert.Equal("id_1", azureAiSearch.GetProperty("indexes")[0].GetProperty("index_connection_id").GetString());
        Assert.Equal("name_1", azureAiSearch.GetProperty("indexes")[0].GetProperty("index_name").GetString());
        Assert.Equal(6, azureAiSearch.GetProperty("indexes")[0].GetProperty("top_k").GetInt32());
        Assert.Equal("field1 = 'value1' and field2 = 'value2'", azureAiSearch.GetProperty("indexes")[0].GetProperty("filter").GetString());
        Assert.Equal("semantic", azureAiSearch.GetProperty("indexes")[0].GetProperty("query_type").GetString());
    }

    #region private
    private void SetupResponse(HttpStatusCode statusCode, string response) =>
        this._agentClientHandlerStub.ResponseToReturn =
            new HttpResponseMessage(statusCode)
            {
                Content = new StringContent(response)
            };

    private sealed class WeatherPlugin
    {
        [KernelFunction, Description("Provides real-time weather information.")]
        public string Current([Description("The location to get the weather for.")] string location)
        {
            return $"The current weather in {location} is 72 degrees.";
        }

        [KernelFunction, Description("Forecast weather information.")]
        public string Forecast([Description("The location to get the weather for.")] string location)
        {
            return $"The forecast for {location} is 75 degrees tomorrow.";
        }
    }
    #endregion
}


===== Yaml\AgentDefinitionYaml.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Diagnostics.CodeAnalysis;
using Microsoft.Extensions.Configuration;
using YamlDotNet.Serialization;
using YamlDotNet.Serialization.NamingConventions;

namespace Microsoft.SemanticKernel.Agents;

/// <summary>
/// Helper methods for creating <see cref="AgentDefinition"/> from YAML.
/// </summary>
[Experimental("SKEXP0110")]
public static class AgentDefinitionYaml
{
    /// <summary>
    /// Convert the given YAML text to a <see cref="AgentDefinition"/> model.
    /// </summary>
    /// <remarks>
    /// The <see cref="AgentDefinition"/> will be normalized by calling
    /// <see cref="AgentDefinitionYaml.Normalize(AgentDefinition, IConfiguration?)"/> before being returned.
    /// </remarks>
    /// <param name="text">YAML representation of the <see cref="AgentDefinition"/> to use to create the prompt function.</param>
    /// <param name="configuration">Optional instance of <see cref="IConfiguration"/> which can provide configuration settings.</param>
    public static AgentDefinition FromYaml(string text, IConfiguration? configuration = null)
    {
        var deserializer = new DeserializerBuilder()
            .WithNamingConvention(UnderscoredNamingConvention.Instance)
            .WithTypeConverter(new ModelConfigurationTypeConverter())
            .WithTypeConverter(new AgentMetadataTypeConverter())
            .Build();

        var agentDefinition = deserializer.Deserialize<AgentDefinition>(text);
        return Normalize(agentDefinition, configuration);
    }

    /// <summary>
    /// Normalizing the <see cref="AgentDefinition"/> makes the following changes:
    /// <ul>
    ///     <li>
    ///     Update the input names to match dictionary keys in this <see cref="AgentInput"/> instance.
    ///     </li>
    ///     <li>
    ///     All string properties that are delimited with "${" and "}" will be resolved as variables from the provided <see cref="IConfiguration"/>.
    ///     </li>
    /// </ul>
    /// </summary>
    /// <param name="agentDefinition">AgentDefinition instance to update.</param>
    /// <param name="configuration">Optional instance of <see cref="IConfiguration"/> which can provide configuration settings.</param>
    public static AgentDefinition Normalize(AgentDefinition agentDefinition, IConfiguration? configuration)
    {
        Verify.NotNull(agentDefinition);

        if (agentDefinition?.Inputs is not null)
        {
            foreach (var keyValuePair in agentDefinition.Inputs)
            {
                keyValuePair.Value.Name = keyValuePair.Key;
            }
        }

        if (agentDefinition?.Outputs is not null)
        {
            foreach (var keyValuePair in agentDefinition.Outputs)
            {
                keyValuePair.Value.Name = keyValuePair.Key;
            }
        }

        if (configuration is not null)
        {
            agentDefinition!.Normalize(configuration);
        }

        return agentDefinition!;
    }
}


===== Yaml\AgentMetadataTypeConverter.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using YamlDotNet.Core;
using YamlDotNet.Core.Events;
using YamlDotNet.Serialization;
using YamlDotNet.Serialization.NamingConventions;

namespace Microsoft.SemanticKernel.Agents;

/// <summary>
/// Type converter custom deserialization for <see cref="AgentMetadata"/> from YAML.
/// </summary>
/// <remarks>
/// Required to correctly deserialize the <see cref="AgentDefinition.Metadata"/> from YAML.
/// </remarks>
internal sealed class AgentMetadataTypeConverter : IYamlTypeConverter
{
    /// <inheritdoc/>
    public bool Accepts(Type type)
    {
        return type == typeof(AgentMetadata);
    }

    /// <inheritdoc/>
    public object? ReadYaml(IParser parser, Type type, ObjectDeserializer rootDeserializer)
    {
        s_deserializer ??= new DeserializerBuilder()
            .WithNamingConvention(UnderscoredNamingConvention.Instance)
            .IgnoreUnmatchedProperties() // Required to ignore the 'type' property used as type discrimination. Otherwise, the "Property 'type' not found on type '{type.FullName}'" exception is thrown.
            .Build();

        parser.MoveNext(); // Move to the first property  

        var agentMetadata = new AgentMetadata();
        while (parser.Current is not MappingEnd)
        {
            var propertyName = parser.Consume<Scalar>().Value;
            switch (propertyName)
            {
                case "authors":
                    agentMetadata.Authors = s_deserializer.Deserialize<List<string>>(parser);
                    break;
                case "tags":
                    agentMetadata.Tags = s_deserializer.Deserialize<List<string>>(parser);
                    break;
                default:
                    (agentMetadata.ExtensionData ??= new Dictionary<string, object?>()).Add(propertyName, s_deserializer.Deserialize<object>(parser));
                    break;
            }
        }
        parser.MoveNext(); // Move past the MappingEnd event  
        return agentMetadata;
    }

    /// <inheritdoc/>
    public void WriteYaml(IEmitter emitter, object? value, Type type, ObjectSerializer serializer)
    {
        throw new NotImplementedException();
    }

    /// <summary>
    /// The YamlDotNet deserializer instance.
    /// </summary>
    private static IDeserializer? s_deserializer;
}


===== Yaml\Extensions\YamlAgentDefinitionExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;
using Microsoft.Extensions.Configuration;

namespace Microsoft.SemanticKernel.Agents;

/// <summary>
/// Provides extension methods for <see cref="AgentDefinition"/>.
/// </summary>
internal static class YamlAgentDefinitionExtensions
{
    /// <summary>
    /// Processes the properties of the specified <see cref="AgentDefinition" />, including nested objects and collections.
    /// </summary>
    /// <param name="agentDefinition">Instance of <see cref="AgentDefinition"/> to normalize.</param>
    /// <param name="configuration">Instance of <see cref="IConfiguration"/> which provides the configuration values.</param>
    public static void Normalize(this AgentDefinition agentDefinition, IConfiguration configuration)
    {
        Verify.NotNull(agentDefinition);

        NormalizeObject(agentDefinition, configuration);
    }

    #region private
    private static void NormalizeObject(object? obj, IConfiguration configuration)
    {
        if (obj is null)
        {
            return;
        }

        if (obj is IList<object> objList)
        {
            for (int i = 0; i < objList.Count; i++)
            {
                if (objList[i] is string listValueString)
                {
                    if (RequiresNormalization(listValueString))
                    {
                        objList[i] = GetNormalizedValue(listValueString, configuration);
                    }
                }
                else
                {
                    NormalizeObject(objList[i], configuration);
                }
            }
        }
        else if (obj is IEnumerable enumerableValue)
        {
            foreach (var enumerableItem in enumerableValue)
            {
                NormalizeObject(enumerableItem, configuration);
            }
        }
        else
        {
            Type type = obj.GetType();
            foreach (PropertyInfo property in type.GetProperties())
            {
                if (!property.CanRead || !property.CanWrite)
                {
                    continue;
                }

                var value = property.GetValue(obj);
                if (value is null)
                {
                    continue;
                }

                if (value is string stringValue)
                {
                    if (RequiresNormalization(stringValue))
                    {
                        NormalizeString(obj, property, stringValue!, configuration);
                    }
                }
                else if (value is IDictionary<string, object> dictionaryValue)
                {
                    foreach (var entryKey in dictionaryValue.Keys)
                    {
                        var entryValue = dictionaryValue[entryKey];
                        if (entryValue is string entryStringValue)
                        {
                            if (RequiresNormalization(entryStringValue))
                            {
                                var normalizedValue = GetNormalizedValue(entryStringValue, configuration);
                                dictionaryValue[entryKey] = normalizedValue;
                            }
                        }
                        else
                        {
                            NormalizeObject(entryValue, configuration);
                        }
                    }
                }
                else
                {
                    NormalizeObject(value, configuration);
                }
            }
        }
    }

    private static bool RequiresNormalization(string? value)
    {
        return !string.IsNullOrEmpty(value) && value.StartsWith("${", StringComparison.InvariantCulture) && value.EndsWith("}", StringComparison.InvariantCulture);
    }

    private static void NormalizeString(object instance, PropertyInfo property, string input, IConfiguration configuration)
    {
        property.SetValue(instance, GetNormalizedValue(input, configuration));
    }

    private static string GetNormalizedValue(string input, IConfiguration configuration)
    {
        string key = input.Substring(2, input.Length - 3);
        return configuration[key] ?? input;
    }
    #endregion
}


===== Yaml\Extensions\YamlAgentFactoryExtensions.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Configuration;

namespace Microsoft.SemanticKernel.Agents;

/// <summary>
/// Extension methods for <see cref="AgentFactory"/> to create agents from YAML.
/// </summary>
public static class YamlAgentFactoryExtensions
{
    /// <summary>
    /// Create a <see cref="Agent"/> from the given YAML text.
    /// </summary>
    /// <param name="kernelAgentFactory">Kernel agent factory which will be used to create the agent.</param>
    /// <param name="text">Text string containing the YAML representation of a kernel agent.</param>
    /// <param name="options">Optional <see cref="AgentCreationOptions"/> instance.</param>
    /// <param name="configuration">Optional <see cref="IConfiguration"/> instance.</param>
    /// <param name="cancellationToken">Optional cancellation token</param>
    public static async Task<Agent?> CreateAgentFromYamlAsync(this AgentFactory kernelAgentFactory, string text, AgentCreationOptions? options = null, IConfiguration? configuration = null, CancellationToken cancellationToken = default)
    {
        var agentDefinition = AgentDefinitionYaml.FromYaml(text, configuration);
        agentDefinition.Type ??= (kernelAgentFactory.Types.Count > 0 ? kernelAgentFactory.Types[0] : null);

        return await kernelAgentFactory.CreateAsync(
            options?.Kernel ?? new Kernel(),
            agentDefinition,
            options,
            cancellationToken).ConfigureAwait(false);
    }
}


===== Yaml\ModelConfigurationTypeConverter.cs =====

// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using YamlDotNet.Core;
using YamlDotNet.Core.Events;
using YamlDotNet.Serialization;
using YamlDotNet.Serialization.NamingConventions;

namespace Microsoft.SemanticKernel.Agents;

/// <summary>
/// Type converter with custom deserialization for <see cref="ModelConnection"/> from YAML.
/// </summary>
///  <remarks>
/// Required to correctly deserialize the <see cref="ModelConnection.ExtensionData"/> from YAML.
/// </remarks>
internal sealed class ModelConfigurationTypeConverter : IYamlTypeConverter
{
    /// <inheritdoc/>
    public bool Accepts(Type type)
    {
        return type == typeof(ModelConnection);
    }

    /// <inheritdoc/>
    public object? ReadYaml(IParser parser, Type type, ObjectDeserializer rootDeserializer)
    {
        s_deserializer ??= new DeserializerBuilder()
            .WithNamingConvention(UnderscoredNamingConvention.Instance)
            .IgnoreUnmatchedProperties() // Required to ignore the 'type' property used as type discrimination. Otherwise, the "Property 'type' not found on type '{type.FullName}'" exception is thrown.
            .Build();

        parser.MoveNext(); // Move to the first property  

        var modelConfiguration = new ModelConnection();
        while (parser.Current is not MappingEnd)
        {
            var propertyName = parser.Consume<Scalar>().Value;
            switch (propertyName)
            {
                case "type":
                    modelConfiguration.Type = s_deserializer.Deserialize<string>(parser);
                    break;
                case "service_id":
                    modelConfiguration.ServiceId = s_deserializer.Deserialize<string>(parser);
                    break;
                default:
                    (modelConfiguration.ExtensionData ??= new Dictionary<string, object?>()).Add(propertyName, s_deserializer.Deserialize<object>(parser));
                    break;
            }
        }
        parser.MoveNext(); // Move past the MappingEnd event  
        return modelConfiguration;
    }

    /// <inheritdoc/>
    public void WriteYaml(IEmitter emitter, object? value, Type type, ObjectSerializer serializer)
    {
        throw new NotImplementedException();
    }

    /// <summary>
    /// The YamlDotNet deserializer instance.
    /// </summary>
    private static IDeserializer? s_deserializer;
}


